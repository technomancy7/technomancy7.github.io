{
    "classes": {
        "AdminVoteWindow.uc": {
            "body": "class AdminVoteWindow expands MenuUIWindow;\n\nenum EMessageBoxModes\n{\n\tMB_YesNo,\n\tMB_OK,\n};\n\nenum EMessageBoxResults\n{\n\tMR_Yes,\n\tMR_No,\n\tMR_OK\n};\n\nvar Color colTextMessage;\nvar bool bForced;\nvar DXL Caller;\nvar MenuUIActionButtonWindow btnYes;\nvar MenuUIActionButtonWindow btnNo;\nvar MenuUIHeaderWindow winText;\nvar int  mbMode;\nvar bool bDeferredKeyPress;\nvar bool bKeyPressed;\nvar Window winNotify;\nvar int textBorderX;\nvar int textBorderY;\nvar int numButtons;\nvar localized string btnLabelYes;\nvar localized string btnLabelNo;\n\nevent InitWindow()\n{\n\tSuper.InitWindow();\n\t// Don't show if match has ended\n\tif (( DeusExMPGame(Player.DXGame) != None ) && DeusExMPGame(Player.DXGame).bClientNewMap )\n\t\treturn;\n\t// Force the title bar to be a certain width;\n\twinTitle.minTitleWidth = 250;\n\n\tCreateTextWindow();\n\tSetTitle(\"MapVote\");\n\tSetMode(0);\n\tSetNotifyWindow(Self);\n}\n\nfunction CreateTextWindow()\n{\n\twinText = CreateMenuHeader(21, 13, \"\", winClient);\n\twinText.SetTextAlignments(HALIGN_Center, VALIGN_Center);\n\twinText.SetFont(Font'FontMenuHeaders_DS');\n\twinText.SetWindowAlignments(HALIGN_Full, VALIGN_Full, textBorderX, textBorderY);\n}\n\nfunction SetMessageText( String msgText )\n{\n\twinText.SetText(msgText);\n\n\tAskParentForReconfigure();\n}\n\nfunction SetDeferredKeyPress(bool bNewDeferredKeyPress)\n{\n\tbDeferredKeyPress = bNewDeferredKeyPress;\n}\n\nfunction SetMode( int newMode )\n{\n\tmbMode = newMode;\n\n\tswitch( mbMode )\n\t{\n\t\tcase 0:\t\t\t// MB_YesNo:\n\t\t\tbtnNo  = winButtonBar.AddButton(btnLabelNo, HALIGN_Right);\n\t\t\tbtnYes = winButtonBar.AddButton(btnLabelYes, HALIGN_Right);\n\t\t\tnumButtons = 2;\n\t\t\tSetFocusWindow(btnYes);\n\t\t\tbreak;\n\t}\n\n\tif (winShadow != None)\n\t\tMenuUIMessageBoxShadowWindow(winShadow).SetButtonCount(numButtons);\n}\n\nfunction int GetNumButtons()\n{\n\treturn numButtons;\n}\n\nfunction SetNotifyWindow( Window newWinNotify )\n{\n\twinNotify = newWinNotify;\n}\n\nfunction bool ButtonActivated( Window buttonPressed )\n{\n\tlocal bool bHandled;\n\n\tbHandled = True;\n\n\tSuper.ButtonActivated(buttonPressed);\n\n\tswitch( buttonPressed )\n\t{\n\t\tcase btnYes:\n\t\t\tif ((bDeferredKeyPress) && (IsKeyDown(IK_Enter) || IsKeyDown(IK_Space) || IsKeyDown(IK_Y)))\n\t\t\t\tbKeyPressed = True;\n\t\t\telse\n\t\t\t\tPostResult(1);  // MR_Yes;\n\n\t\t\tbHandled = True;\n\t\t\tbreak;\n\n\t\tcase btnNo:\n\t\t\tPostResult(0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbHandled = False;\n\t\t\tbreak;\n\t}\n\n\treturn bHandled;\n}\n\nevent bool MouseButtonReleased(float pointX, float pointY, EInputKey button, int numClicks)\n{\n\treturn True;\n}\n\nevent bool VirtualKeyPressed(EInputKey key, bool bRepeat)\n{\n\tlocal bool bHandled;\n\n\tswitch( key )\n\t{\n\n        case IK_Escape:\n\t\t\tif ( mbMode == 0  /*MB_YesNo*/ )\n\t\t\t{\n\t\t\t\tPostResult(0);\n\t\t\t\tbHandled = True;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IK_Enter:\n\t\t\tif ( mbMode == 0  /*MB_YesNo*/ )\n\t\t\t{\n\t\t\t\tPostResult(1);\n\t\t\t\tbHandled = True;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IK_Y:\n\t\t\tif ( mbMode == 0  /*MB_YesNo*/ )\n\t\t\t{\n\t\t\t\tPostResult(1);\n\t\t\t\tbHandled = True;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IK_N:\n\t\t\tif ( mbMode == 0  /*MB_YesNo*/ )\n\t\t\t{\n\t\t\t\tPostResult(0);\n\t\t\t\tbHandled = True;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treturn bHandled;\n}\n\nevent bool RawKeyPressed(EInputKey key, EInputState iState, bool bRepeat)\n{\n\tif (((key == IK_Enter) || (key == IK_Space) || (key == IK_Y)) &&\n\t   ((iState == IST_Release) && (bKeyPressed)))\n\t{\n\t\tPostResult(0);\n\t\treturn True;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nfunction PostResult( int buttonNumber )\n{\n\tif(ButtonNumber==0)\n\t{\n        Caller.ClientAdminVote(False);\n    }\n    else if(ButtonNumber==1)\n\t{\n        Caller.ClientAdminVote(True);\n    }\n    root.PopWindow();\n\troot.ClearWindowStack();\n}\n\ndefaultproperties\n{\n    textBorderX=20\n    textBorderY=14\n    btnLabelYes=\"|&Yes\"\n    btnLabelNo=\"|&No\"\n    ClientWidth=280\n    ClientHeight=85\n    clientTextures(0)=Texture'DeusExUI.UserInterface.MenuMessageBoxBackground_1'\n    clientTextures(1)=Texture'DeusExUI.UserInterface.MenuMessageBoxBackground_2'\n    textureRows=1\n    textureCols=2\n    bActionButtonBarActive=True\n    bUsesHelpWindow=False\n    winShadowClass=Class'DeusEx.MenuUIMessageBoxShadowWindow'\n}\n",
            "name": "AdminVoteWindow.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "textBorderX=20",
                    "textBorderY=14",
                    "btnLabelYes=\"|&Yes\"",
                    "btnLabelNo=\"|&No\"",
                    "ClientWidth=280",
                    "ClientHeight=85",
                    "clientTextures(0)=Texture'DeusExUI.UserInterface.MenuMessageBoxBackground_1'",
                    "clientTextures(1)=Texture'DeusExUI.UserInterface.MenuMessageBoxBackground_2'",
                    "textureRows=1",
                    "textureCols=2",
                    "bActionButtonBarActive=True",
                    "bUsesHelpWindow=False",
                    "winShadowClass=Class'DeusEx.MenuUIMessageBoxShadowWindow'"
                ],
                "exec": [],
                "extends": "MenuUIWindow",
                "functions": {
                    "ButtonActivated": {
                        "body": "{\n\n\tbHandled = True;\n\n\tSuper.ButtonActivated(buttonPressed);\n\n\tswitch( buttonPressed )\n\t{\n\t\tcase btnYes:\n\t\t\tif ((bDeferredKeyPress) && (IsKeyDown(IK_Enter) || IsKeyDown(IK_Space) || IsKeyDown(IK_Y)))\n\t\t\t\tbKeyPressed = True;\n\t\t\telse\n\t\t\t\tPostResult(1);  // MR_Yes;\n\n\t\t\tbHandled = True;\n\t\t\tbreak;\n\n\t\tcase btnNo:\n\t\t\tPostResult(0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbHandled = False;\n\t\t\tbreak;\n\t}\n\n\treturn bHandled;\n}",
                        "locals": [
                            "local bool bHandled;"
                        ],
                        "modifiers": [],
                        "name": "ButtonActivated",
                        "native": false,
                        "param": [
                            [
                                "Window",
                                "buttonPressed"
                            ]
                        ],
                        "return": "bool"
                    },
                    "CreateTextWindow": {
                        "body": "{\n\twinText = CreateMenuHeader(21, 13, \"\", winClient);\n\twinText.SetTextAlignments(HALIGN_Center, VALIGN_Center);\n\twinText.SetFont(Font'FontMenuHeaders_DS');\n\twinText.SetWindowAlignments(HALIGN_Full, VALIGN_Full, textBorderX, textBorderY);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CreateTextWindow",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GetNumButtons": {
                        "body": "{\n\treturn numButtons;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetNumButtons",
                        "native": false,
                        "param": [],
                        "return": "int"
                    },
                    "InitWindow": {
                        "body": "{\n\tSuper.InitWindow();\n\t// Don't show if match has ended\n\tif (( DeusExMPGame(Player.DXGame) != None ) && DeusExMPGame(Player.DXGame).bClientNewMap )\n\t\treturn;\n\t// Force the title bar to be a certain width;\n\twinTitle.minTitleWidth = 250;\n\n\tCreateTextWindow();\n\tSetTitle(\"MapVote\");\n\tSetMode(0);\n\tSetNotifyWindow(Self);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "InitWindow",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "MouseButtonReleased": {
                        "body": "{\n\treturn True;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "MouseButtonReleased",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "pointX"
                            ],
                            [
                                "float",
                                "pointY"
                            ],
                            [
                                "EInputKey",
                                "button"
                            ],
                            [
                                "int",
                                "numClicks"
                            ]
                        ],
                        "return": "bool"
                    },
                    "PostResult": {
                        "body": "{\n\tif(ButtonNumber==0)\n\t{\n        Caller.ClientAdminVote(False);\n    }\n    else if(ButtonNumber==1)\n\t{\n        Caller.ClientAdminVote(True);\n    }\n    root.PopWindow();\n\troot.ClearWindowStack();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostResult",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "buttonNumber"
                            ]
                        ],
                        "return": ""
                    },
                    "RawKeyPressed": {
                        "body": "{\n\tif (((key == IK_Enter) || (key == IK_Space) || (key == IK_Y)) &&\n\t   ((iState == IST_Release) && (bKeyPressed)))\n\t{\n\t\tPostResult(0);\n\t\treturn True;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "RawKeyPressed",
                        "native": false,
                        "param": [
                            [
                                "EInputKey",
                                "key"
                            ],
                            [
                                "EInputState",
                                "iState"
                            ],
                            [
                                "bool",
                                "bRepeat"
                            ]
                        ],
                        "return": "bool"
                    },
                    "SetDeferredKeyPress": {
                        "body": "{\n\tbDeferredKeyPress = bNewDeferredKeyPress;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetDeferredKeyPress",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "bNewDeferredKeyPress"
                            ]
                        ],
                        "return": ""
                    },
                    "SetMessageText": {
                        "body": "{\n\twinText.SetText(msgText);\n\n\tAskParentForReconfigure();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetMessageText",
                        "native": false,
                        "param": [
                            [
                                "String",
                                "msgText"
                            ]
                        ],
                        "return": ""
                    },
                    "SetMode": {
                        "body": "{\n\tmbMode = newMode;\n\n\tswitch( mbMode )\n\t{\n\t\tcase 0:\t\t\t// MB_YesNo:\n\t\t\tbtnNo  = winButtonBar.AddButton(btnLabelNo, HALIGN_Right);\n\t\t\tbtnYes = winButtonBar.AddButton(btnLabelYes, HALIGN_Right);\n\t\t\tnumButtons = 2;\n\t\t\tSetFocusWindow(btnYes);\n\t\t\tbreak;\n\t}\n\n\tif (winShadow != None)\n\t\tMenuUIMessageBoxShadowWindow(winShadow).SetButtonCount(numButtons);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetMode",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "newMode"
                            ]
                        ],
                        "return": ""
                    },
                    "SetNotifyWindow": {
                        "body": "{\n\twinNotify = newWinNotify;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetNotifyWindow",
                        "native": false,
                        "param": [
                            [
                                "Window",
                                "newWinNotify"
                            ]
                        ],
                        "return": ""
                    },
                    "VirtualKeyPressed": {
                        "body": "{\n\n\tswitch( key )\n\t{\n\n        case IK_Escape:\n\t\t\tif ( mbMode == 0  /*MB_YesNo*/ )\n\t\t\t{\n\t\t\t\tPostResult(0);\n\t\t\t\tbHandled = True;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IK_Enter:\n\t\t\tif ( mbMode == 0  /*MB_YesNo*/ )\n\t\t\t{\n\t\t\t\tPostResult(1);\n\t\t\t\tbHandled = True;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IK_Y:\n\t\t\tif ( mbMode == 0  /*MB_YesNo*/ )\n\t\t\t{\n\t\t\t\tPostResult(1);\n\t\t\t\tbHandled = True;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IK_N:\n\t\t\tif ( mbMode == 0  /*MB_YesNo*/ )\n\t\t\t{\n\t\t\t\tPostResult(0);\n\t\t\t\tbHandled = True;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\treturn bHandled;\n}",
                        "locals": [
                            "local bool bHandled;"
                        ],
                        "modifiers": [],
                        "name": "VirtualKeyPressed",
                        "native": false,
                        "param": [
                            [
                                "EInputKey",
                                "key"
                            ],
                            [
                                "bool",
                                "bRepeat"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 218,
                "replication": "",
                "states": [],
                "variables": [
                    "var Color colTextMessage;",
                    "var bool bForced;",
                    "var DXL Caller;",
                    "var MenuUIActionButtonWindow btnYes;",
                    "var MenuUIActionButtonWindow btnNo;",
                    "var MenuUIHeaderWindow winText;",
                    "var int  mbMode;",
                    "var bool bDeferredKeyPress;",
                    "var bool bKeyPressed;",
                    "var Window winNotify;",
                    "var int textBorderX;",
                    "var int textBorderY;",
                    "var int numButtons;",
                    "var localized string btnLabelYes;",
                    "var localized string btnLabelNo;"
                ]
            }
        },
        "AugFlight.uc": {
            "body": "//=============================================================================\n//  \n//=============================================================================\nclass AugFlight extends Augmentation;\n\nvar float mpAugValue;\nvar float mpEnergyDrain;\n\nstate Active\n{\nBegin:\nLoop:\n\tSleep(1.0);\n\n\tPlayer.DoJump();\n\tPlayer.SetPhysics(PHYS_Flying);\n\t//Player.bFlightAug=True;\n\tGoto('Loop');\n}\n\nfunction Deactivate()\n{\n\tPlayer.SetPhysics(PHYS_Falling);\n\t//Player.bFlightAug=False;\n\tSuper.Deactivate();\n}\n\nsimulated function PreBeginPlay()\n{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n\t}\n}\n\ndefaultproperties\n{\n\tmpAugValue=10.000000\n\tmpEnergyDrain=100.000000\n\tEnergyRate=120.000000\n\tIcon=Texture'DeusExUI.UserInterface.AugIconDrone'\n\tsmallIcon=Texture'DeusExUI.UserInterface.AugIconDrone_Small'\n\tAugmentationName=\"Flight\"\n\tDescription=\"\"\n\tMPInfo=\"When active, you fly.\"\n\tLevelValues(0)=5.000000\n\tLevelValues(1)=15.000000\n\tLevelValues(2)=25.000000\n\tLevelValues(3)=40.000000\n\tAugmentationLocation=LOC_Torso\n\tMPConflictSlot=2\n}\n\n",
            "name": "AugFlight.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "mpAugValue=10.000000",
                    "mpEnergyDrain=100.000000",
                    "EnergyRate=120.000000",
                    "Icon=Texture'DeusExUI.UserInterface.AugIconDrone'",
                    "smallIcon=Texture'DeusExUI.UserInterface.AugIconDrone_Small'",
                    "AugmentationName=\"Flight\"",
                    "Description=\"\"",
                    "MPInfo=\"When active, you fly.\"",
                    "LevelValues(0)=5.000000",
                    "LevelValues(1)=15.000000",
                    "LevelValues(2)=25.000000",
                    "LevelValues(3)=40.000000",
                    "AugmentationLocation=LOC_Torso",
                    "MPConflictSlot=2"
                ],
                "exec": [],
                "extends": "Augmentation",
                "functions": {
                    "Deactivate": {
                        "body": "{\n\tPlayer.SetPhysics(PHYS_Falling);\n\t//Player.bFlightAug=False;\n\tSuper.Deactivate();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Deactivate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 58,
                "replication": "",
                "states": [],
                "variables": [
                    "var float mpAugValue;",
                    "var float mpEnergyDrain;"
                ]
            }
        },
        "AugHealing2.uc": {
            "body": "//=============================================================================\n// AugHealing.\n//=============================================================================\nclass AugHealing2 extends AugHealing;\n\nvar float mpAugValue;\nvar float mpEnergyDrain;\n\nstate Active\n{\nBegin:\n\tif(Player.Energy < 5)\n\t\tDeactivate();\nLoop:\n\tSleep(1.0);\n\n\tif (Player.Health < 100 && Player.Health > 0)\n\t{\n\t\tLoopSound=Sound'DeusExSounds.Augmentation.AugLoop';\n\t\tPlayer.Energy -= 5;\n\t\tif((TCPRI(player.PlayerReplicationInfo) != None) && (Juggernaut(Player.Level.Game) != None) && TCPRI(Player.PlayerReplicationInfo).bJuggernaut)\n\t\t\tPlayer.HealPlayer(5, False);\n\t\telse\n\t\t\tPlayer.HealPlayer(15, False);\n\t\t\t\n\t\tPlayer.ClientFlash(0.5, vect(0, 0, 500));\n\t}\n\telse LoopSound=none;\n\tGoto('Loop');\n}\n\nsimulated function PreBeginPlay()\n{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n\t}\n}\n\ndefaultproperties\n{\n\tmpAugValue=0\n\tmpEnergyDrain=0\n\tEnergyRate=0\n\tIcon=Texture'DeusExUI.UserInterface.AugIconHealing'\n\tsmallIcon=Texture'DeusExUI.UserInterface.AugIconHealing_Small'\n\tAugmentationName=\"Nano Regeneration\"\n\tDescription=\"Programmable polymerase automatically directs construction of proteins in injured cells, restoring an agent to full health over time.|n|nTECH ONE: Healing occurs at a normal rate.|n|nTECH TWO: Healing occurs at a slightly faster rate.|n|nTECH THREE: Healing occurs at a moderately faster rate.|n|nTECH FOUR: Healing occurs at a significantly faster rate.\"\n\tMPInfo=\"When active, you heal, but at a rate insufficient for healing in combat.  Energy Drain: High\"\n\tLevelValues(0)=0\n\tLevelValues(1)=0\n\tLevelValues(2)=0\n\tLevelValues(3)=0\n\tLoopSound=None\n\tAugmentationLocation=LOC_Torso\n\tMPConflictSlot=2\n}\n\n",
            "name": "AugHealing2.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "mpAugValue=0",
                    "mpEnergyDrain=0",
                    "EnergyRate=0",
                    "Icon=Texture'DeusExUI.UserInterface.AugIconHealing'",
                    "smallIcon=Texture'DeusExUI.UserInterface.AugIconHealing_Small'",
                    "AugmentationName=\"Nano Regeneration\"",
                    "Description=\"Programmable polymerase automatically directs construction of proteins in injured cells, restoring an agent to full health over time.|n|nTECH ONE: Healing occurs at a normal rate.|n|nTECH TWO: Healing occurs at a slightly faster rate.|n|nTECH THREE: Healing occurs at a moderately faster rate.|n|nTECH FOUR: Healing occurs at a significantly faster rate.\"",
                    "MPInfo=\"When active, you heal, but at a rate insufficient for healing in combat.  Energy Drain: High\"",
                    "LevelValues(0)=0",
                    "LevelValues(1)=0",
                    "LevelValues(2)=0",
                    "LevelValues(3)=0",
                    "LoopSound=None",
                    "AugmentationLocation=LOC_Torso",
                    "MPConflictSlot=2"
                ],
                "exec": [],
                "extends": "AugHealing",
                "functions": {
                    "PreBeginPlay": {
                        "body": "{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 63,
                "replication": "",
                "states": [],
                "variables": [
                    "var float mpAugValue;",
                    "var float mpEnergyDrain;"
                ]
            }
        },
        "AugIcarus.uc": {
            "body": "//=============================================================================\n//  CONCEPT: When Velocity.Z > 600/700\n//=============================================================================\nclass AugIcarus extends Augmentation;\n\nvar float mpAugValue;\nvar float mpEnergyDrain;\nvar bool bReverse;\nvar bool bTrig;\n\nstate Active\n{\nBegin:\n\tif(Player.Energy <= 1)\n\t\tDeactivate();\nLoop:\n\tSleep(0.1); //Was 1.0, now 0.1\n\tif(Player.Energy > 1)\n\t{\n\t\tIcarus();\n\t}\n\tGoto('Loop');\n}\n\nfunction Icarus()\n{\t\n\tif(Player.Velocity.Z < -600 && !bReverse)\n\t{\n\t\tbTrig=True;\n\t\tbReverse=True;\n\t\tPlayer.ClientMessage(\"|P3Icarus landing system activated...\");\n\t}\n\t\n\tif(bTrig)\n\t{\n\t\tPlayer.Energy -= 1;\n\t\tif(bReverse)\n\t\t\tPlayer.Velocity.Z += 100;\n\t\t\n\t\tif(Player.Velocity.Z > 0)\n\t\t{\n\t\t\tbTrig=False;\n\t\t\tbReverse=False;\n\t\t\tPlayer.ClientMessage(\"|P3Icarus landing system de-activated...\");\n\t\t}\n\t}\n}\n\nfunction Deactivate()\n{\n\t\n\tSuper.Deactivate();\n}\n\nsimulated function PreBeginPlay()\n{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n\t}\n}\n\ndefaultproperties\n{\n\tmpAugValue=0\n\tmpEnergyDrain=0\n\tEnergyRate=0\n\tIcon=Texture'DeusExUI.UserInterface.AugIconDrone'\n\tsmallIcon=Texture'DeusExUI.UserInterface.AugIconDrone_Small'\n\tAugmentationName=\"Icarus Landing System\"\n\tDescription=\"\"\n\tMPInfo=\"When active, you emit dangerous energy while falling at high velocity.\"\n\tLevelValues(0)=0\n\tLevelValues(1)=0\n\tLevelValues(2)=0\n\tLevelValues(3)=0\n\tLoopSound=None\n\tAugmentationLocation=4\n\tMPConflictSlot=3\n}\n\n",
            "name": "AugIcarus.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "mpAugValue=0",
                    "mpEnergyDrain=0",
                    "EnergyRate=0",
                    "Icon=Texture'DeusExUI.UserInterface.AugIconDrone'",
                    "smallIcon=Texture'DeusExUI.UserInterface.AugIconDrone_Small'",
                    "AugmentationName=\"Icarus Landing System\"",
                    "Description=\"\"",
                    "MPInfo=\"When active, you emit dangerous energy while falling at high velocity.\"",
                    "LevelValues(0)=0",
                    "LevelValues(1)=0",
                    "LevelValues(2)=0",
                    "LevelValues(3)=0",
                    "LoopSound=None",
                    "AugmentationLocation=4",
                    "MPConflictSlot=3"
                ],
                "exec": [],
                "extends": "Augmentation",
                "functions": {
                    "Deactivate": {
                        "body": "{\n\t\n\tSuper.Deactivate();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Deactivate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Icarus": {
                        "body": "{\t\n\tif(Player.Velocity.Z < -600 && !bReverse)\n\t{\n\t\tbTrig=True;\n\t\tbReverse=True;\n\t\tPlayer.ClientMessage(\"|P3Icarus landing system activated...\");\n\t}\n\t\n\tif(bTrig)\n\t{\n\t\tPlayer.Energy -= 1;\n\t\tif(bReverse)\n\t\t\tPlayer.Velocity.Z += 100;\n\t\t\n\t\tif(Player.Velocity.Z > 0)\n\t\t{\n\t\t\tbTrig=False;\n\t\t\tbReverse=False;\n\t\t\tPlayer.ClientMessage(\"|P3Icarus landing system de-activated...\");\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Icarus",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 86,
                "replication": "",
                "states": [],
                "variables": [
                    "var float mpAugValue;",
                    "var float mpEnergyDrain;",
                    "var bool bReverse;",
                    "var bool bTrig;"
                ]
            }
        },
        "AugMagnet.uc": {
            "body": "//=============================================================================\n//Magnetize\n//=============================================================================\nclass AugMagnet extends Augmentation;\n\nvar int BioDrainODX;\nvar actor Magnet;\n\nfunction SpawnExplosion(vector Loc)\n{\nlocal ShockRing s1, s2, s3;\n\n    s1 = spawn(class'ShockRing',,,Loc,rot(16384,0,0));\n\ts1.Lifespan = 2.5;\n    s2 = spawn(class'ShockRing',,,Loc,rot(0,16384,0));\n\ts2.Lifespan = 2.5;\n    s3 = spawn(class'ShockRing',,,Loc,rot(0,0,16384));\n\tS3.Lifespan = 2.5;\n}\n\nfunction Skullshot()\n{\n\tlocal Actor hitActor;\n\tlocal vector loc, line, HitLocation, hitNormal;\n\tlocal ScriptedPawn     hitPawn;\n\tlocal PlayerPawn       hitPlayer;\n\tlocal DeusExMover      hitMover;\n\tlocal DeusExDecoration hitDecoration;\n\tlocal int              damage;\n\tlocal vector v2;\n\t\n\tv2 = Player.location;\n\tv2.z += 20;\n\t\n\tloc = Player.Location;\n\tloc.Z += Player.BaseEyeHeight;\n\tline = Vector(Player.ViewRotation) * 4000;\n\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\tif (hitActor != None)\n\t{\n\t\thitMover = DeusExMover(hitActor);\n\t\thitPawn = ScriptedPawn(hitActor);\n\t\thitDecoration = DeusExDecoration(hitActor);\n\t\thitPlayer = PlayerPawn(hitActor);\n\t\tif (hitMover != None)\n\t\t{\n\t\t\tMagnet = hitMover;\n\t\t}\n\t\telse if (hitPawn != None)\n\t\t{\n\t\t\tMagnet = hitPawn;\n\t\t}\n\t\telse if (hitDecoration != None)\n\t\t{\n\t\t\tMagnet = hitDecoration;\n\t\t}\n\t\telse if (hitPlayer != None)\n\t\t{\n\t\t\tMagnet = hitPlayer;\n\t\t}\n\t}\n\t\n\tif(Magnet == None)\n\t{\n\t\tloc = Player.Location;\n\t\tloc.Z -= 32;\n\t\t\n\t\tSpawnExplosion(Loc);\n\t\tSpawnExplosion(HitLocation);\n\t\tPlayer.DoJump();\n\t\tPlayer.Velocity = (normal(Loc - HitLocation) * -1450);\n\t\tPlayer.SetPhysics(Phys_Falling);\n\t\tDeactivate();\n\t}\n\telse\n\t\tSpawnExplosion(Magnet.Location);\n}\n\nfunction Pull()\n{\n\tlocal vector loc;\n\tloc = Player.Location;\n\tloc.Z -= 32;\n\t\n\tPlayer.DoJump();\n\tPlayer.Velocity = (normal(Loc - Magnet.Location) * -750);\n\tPlayer.SetPhysics(Phys_Falling);\n}\n\nstate Active\n{\nBegin:\n\tSkullshot();\n\t\nLoop:\n\tSleep(0.1);\n\tPull();\n\tif(Magnet != None)\n\t\tGoto('Loop');\n\telse\n\t\tDeactivate();\n}\n\nfunction Deactivate()\n{\n\tMagnet = None;\n\tSuper.Deactivate();\n}\n\ndefaultproperties\n{\n\tBioDrainODX=10\n\t//mpAugValue=0.000000\n\t//mpEnergyDrain=0.000000\n\tEnergyRate=0.000000\n\tIcon=Texture'DeusExUI.UserInterface.AugIconEMP'\n\tsmallIcon=Texture'DeusExUI.UserInterface.AugIconEMP_Small'\n\tAugmentationName=\"Magnetize\"\n\tDescription=\"\"\n\tMPInfo=\"When active, it.. magnets. idk\"\n\tLevelValues(0)=5.000000\n\tLevelValues(1)=15.000000\n\tLevelValues(2)=25.000000\n\tLevelValues(3)=40.000000\n    AugmentationLocation=5\n    MPConflictSlot=9\n\tDeActivateSound=none\n}\n\n",
            "name": "AugMagnet.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "BioDrainODX=10",
                    "//mpAugValue=0.000000",
                    "//mpEnergyDrain=0.000000",
                    "EnergyRate=0.000000",
                    "Icon=Texture'DeusExUI.UserInterface.AugIconEMP'",
                    "smallIcon=Texture'DeusExUI.UserInterface.AugIconEMP_Small'",
                    "AugmentationName=\"Magnetize\"",
                    "Description=\"\"",
                    "MPInfo=\"When active, it.. magnets. idk\"",
                    "LevelValues(0)=5.000000",
                    "LevelValues(1)=15.000000",
                    "LevelValues(2)=25.000000",
                    "LevelValues(3)=40.000000",
                    "AugmentationLocation=5",
                    "MPConflictSlot=9",
                    "DeActivateSound=none"
                ],
                "exec": [],
                "extends": "Augmentation",
                "functions": {
                    "Deactivate": {
                        "body": "{\n\tMagnet = None;\n\tSuper.Deactivate();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Deactivate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Pull": {
                        "body": "{\n\tloc = Player.Location;\n\tloc.Z -= 32;\n\t\n\tPlayer.DoJump();\n\tPlayer.Velocity = (normal(Loc - Magnet.Location) * -750);\n\tPlayer.SetPhysics(Phys_Falling);\n}",
                        "locals": [
                            "local vector loc;"
                        ],
                        "modifiers": [],
                        "name": "Pull",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Skullshot": {
                        "body": "{\n\t\n\tv2 = Player.location;\n\tv2.z += 20;\n\t\n\tloc = Player.Location;\n\tloc.Z += Player.BaseEyeHeight;\n\tline = Vector(Player.ViewRotation) * 4000;\n\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\tif (hitActor != None)\n\t{\n\t\thitMover = DeusExMover(hitActor);\n\t\thitPawn = ScriptedPawn(hitActor);\n\t\thitDecoration = DeusExDecoration(hitActor);\n\t\thitPlayer = PlayerPawn(hitActor);\n\t\tif (hitMover != None)\n\t\t{\n\t\t\tMagnet = hitMover;\n\t\t}\n\t\telse if (hitPawn != None)\n\t\t{\n\t\t\tMagnet = hitPawn;\n\t\t}\n\t\telse if (hitDecoration != None)\n\t\t{\n\t\t\tMagnet = hitDecoration;\n\t\t}\n\t\telse if (hitPlayer != None)\n\t\t{\n\t\t\tMagnet = hitPlayer;\n\t\t}\n\t}\n\t\n\tif(Magnet == None)\n\t{\n\t\tloc = Player.Location;\n\t\tloc.Z -= 32;\n\t\t\n\t\tSpawnExplosion(Loc);\n\t\tSpawnExplosion(HitLocation);\n\t\tPlayer.DoJump();\n\t\tPlayer.Velocity = (normal(Loc - HitLocation) * -1450);\n\t\tPlayer.SetPhysics(Phys_Falling);\n\t\tDeactivate();\n\t}\n\telse\n\t\tSpawnExplosion(Magnet.Location);\n}",
                        "locals": [
                            "local Actor hitActor;",
                            "local vector loc, line, HitLocation, hitNormal;",
                            "local ScriptedPawn     hitPawn;",
                            "local PlayerPawn       hitPlayer;",
                            "local DeusExMover      hitMover;",
                            "local DeusExDecoration hitDecoration;",
                            "local int              damage;",
                            "local vector v2;"
                        ],
                        "modifiers": [],
                        "name": "Skullshot",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpawnExplosion": {
                        "body": "{\n\n    s1 = spawn(class'ShockRing',,,Loc,rot(16384,0,0));\n\ts1.Lifespan = 2.5;\n    s2 = spawn(class'ShockRing',,,Loc,rot(0,16384,0));\n\ts2.Lifespan = 2.5;\n    s3 = spawn(class'ShockRing',,,Loc,rot(0,0,16384));\n\tS3.Lifespan = 2.5;\n}",
                        "locals": [
                            "local ShockRing s1, s2, s3;"
                        ],
                        "modifiers": [],
                        "name": "SpawnExplosion",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "Loc"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 130,
                "replication": "",
                "states": [],
                "variables": [
                    "var int BioDrainODX;",
                    "var actor Magnet;"
                ]
            }
        },
        "AugMediAura.uc": {
            "body": "//=============================================================================\n// Medical Aurra\n//=============================================================================\nclass AugMediAura extends Augmentation;\n\n#exec TEXTURE IMPORT NAME=\"AugIconHealingAura_Small\" FILE=\"Textures\\AugIconHealingAura_Small.pcx\" GROUP=Icons FLAGS=2\n#exec TEXTURE IMPORT NAME=\"AugIconHealingAura\" FILE=\"Textures\\AugIconHealingAura.pcx\" GROUP=Icons FLAGS=2\n\nvar float mpAugValue;\nvar float mpEnergyDrain;\n\nstate Active\n{\nBegin:\n\tif(Player.Energy < 3)\n\t\tDeactivate();\n\t\t\nLoop:\n\tSleep(1.0);\n    \n\tif(Player.Energy > 3)\n\t{\n\t\tHealPlayers();\n\t}\n\n\tGoto('Loop');\n}\n\nfunction HealPlayers()\n{\n    local Actor a;\n    local TCPlayer target, targetList[3];\n    local int count, i, healamount, totalamount, edrain;\n\n    count = 0;\n\n    if(TCTeam(Player.DXGame) != None) // Healing teammates in deathmatch is useless.\n    {\n        foreach RadiusActors(class'Actor', a, 256, Player.Location)\n        {\n            if(a.IsA('TCPlayer')) // TODO: Only heal teammates\n            {\n                target = TCPlayer(a);\n                if(target.PlayerReplicationInfo != None && target != TCPlayer(Player) && !target.PlayerReplicationInfo.bIsSpectator && target.Health > 0 && target.Health < 100 && (target.lastTeamHeal+1 <= Level.TimeSeconds) && (target.PlayerReplicationInfo.Team == player.PlayerReplicationInfo.Team))\n                {\n                    targetList[count] = target;\n                    count++;\n                    edrain = 3 * count;\n                    if(count == 3) // We heal a maximum of 3 players\n                        break;\n                }\n            }\n        }\n        \n        if(count > 0)\n        {\n\t\t\tLoopSound=Sound'DeusExSounds.Augmentation.AugLoop';\n            healamount = Min(30, (45/count));\n            totalamount = healamount*count;\n            for(i = 0; i < count; i++)\n            {\n                if(targetList[i] != None)\n                {\n\t\t\t\t\tPlayer.Energy -= edrain;\n                    targetList[i].HealPlayer(healamount, False);\n                    targetList[i].ClientFlash(0.5, vect(0, 0, 500));\n                    targetList[i].lastTeamHeal = Level.TimeSeconds;\n                }\n            }\n            if(totalamount > 0)\n            {\n                Player.ClientMessage(\"Healed\"@count@\"nearby player(s) for\"@totalamount$\"HP\");\n            }\n        }\n        else LoopSound=None;\n    }\n    else if(TCDeathmatch(Player.DXGame) != None)\n    {\n\t\tforeach RadiusActors(class'Actor', a, 256, Player.Location)\n        {\n            if(a.IsA('TCPlayer')) // TODO: Only heal teammates\n            {\n                target = TCPlayer(a);\n                if(target.PlayerReplicationInfo != None && target != TCPlayer(Player) && !target.PlayerReplicationInfo.bIsSpectator && target.Health > 0 && target.Health < 100 && (target.lastTeamHeal+1 <= Level.TimeSeconds) && AreAlliesBasic(target, TCPlayer(Player)))\n                {\n                    targetList[count] = target;\n                    count++;\n                    edrain = 3 * count;\n                    if(count == 3) // We heal a maximum of 3 players\n                        break;\n                }\n            }\n        }\n        \n        if(count > 0)\n        {\n\t\t\tLoopSound=Sound'DeusExSounds.Augmentation.AugLoop';\n            healamount = Min(30, (45/count));\n            totalamount = healamount*count;\n            for(i = 0; i < count; i++)\n            {\n                if(targetList[i] != None)\n                {\n\t\t\t\t\tPlayer.Energy -= edrain;\n                    targetList[i].HealPlayer(healamount, False);\n                    targetList[i].ClientFlash(0.5, vect(0, 0, 500));\n                    targetList[i].lastTeamHeal = Level.TimeSeconds;\n                }\n            }\n            if(totalamount > 0)\n            {\n                Player.ClientMessage(\"Healed\"@count@\"nearby player(s) for\"@totalamount$\"HP\");\n            }\n        }\n        else LoopSound=none;\n\t}\n}\n\nfunction bool AreAlliesBasic(TCPlayer one, tcplayer two)\n{\n\tif(TCPRI(One.PlayerReplicationInfo).TeamNamePRI == \"\" || TCPRI(Two.PlayerReplicationInfo).TeamNamePRI == \"\")\n\t\treturn false;\n\t\n\tif(TCPRI(One.PlayerReplicationInfo).TeamNamePRI == TCPRI(Two.PlayerReplicationInfo).TeamNamePRI)\n\t\treturn true;\n}\n\nfunction float GetEnergyRate()\n{\n\treturn energyRate * LevelValues[CurrentLevel];\n}\n\nsimulated function PreBeginPlay()\n{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n        AugmentationLocation = LOC_Torso;\n\t}\n}\n\ndefaultproperties\n{\n    mpAugValue=0\n    mpEnergyDrain=0\n    EnergyRate=0\n    Icon=Texture'AugIconHealingAura'\n    smallIcon=Texture'AugIconHealingAura_Small'\n    AugmentationName=\"Medic Aura\"\n    Description=\"Radar-absorbent resin augments epithelial proteins; microprojection units distort agent's visual signature. Provides highly effective concealment from automated detection systems -- bots, cameras, turrets.|n|nTECH ONE: Power drain is normal.|n|nTECH TWO: Power drain is reduced slightly.|n|nTECH THREE: Power drain is reduced moderately.|n|nTECH FOUR: Power drain is reduced significantly.\"\n    MPInfo=\"Heals your allies close-by.\"\n    LevelValues(0)=0\n    LevelValues(1)=0\n    LevelValues(2)=0\n    LevelValues(3)=0\n    LoopSound=None\n\tAugmentationLocation=LOC_Torso\n\tMPConflictSlot=2\n}\n",
            "name": "AugMediAura.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "mpAugValue=0",
                    "mpEnergyDrain=0",
                    "EnergyRate=0",
                    "Icon=Texture'AugIconHealingAura'",
                    "smallIcon=Texture'AugIconHealingAura_Small'",
                    "AugmentationName=\"Medic Aura\"",
                    "Description=\"Radar-absorbent resin augments epithelial proteins; microprojection units distort agent's visual signature. Provides highly effective concealment from automated detection systems -- bots, cameras, turrets.|n|nTECH ONE: Power drain is normal.|n|nTECH TWO: Power drain is reduced slightly.|n|nTECH THREE: Power drain is reduced moderately.|n|nTECH FOUR: Power drain is reduced significantly.\"",
                    "MPInfo=\"Heals your allies close-by.\"",
                    "LevelValues(0)=0",
                    "LevelValues(1)=0",
                    "LevelValues(2)=0",
                    "LevelValues(3)=0",
                    "LoopSound=None",
                    "AugmentationLocation=LOC_Torso",
                    "MPConflictSlot=2"
                ],
                "exec": [
                    "#exec TEXTURE IMPORT NAME=\"AugIconHealingAura_Small\" FILE=\"Textures\\AugIconHealingAura_Small.pcx\" GROUP=Icons FLAGS=2",
                    "#exec TEXTURE IMPORT NAME=\"AugIconHealingAura\" FILE=\"Textures\\AugIconHealingAura.pcx\" GROUP=Icons FLAGS=2"
                ],
                "extends": "Augmentation",
                "functions": {
                    "AreAlliesBasic": {
                        "body": "{\n\tif(TCPRI(One.PlayerReplicationInfo).TeamNamePRI == \"\" || TCPRI(Two.PlayerReplicationInfo).TeamNamePRI == \"\")\n\t\treturn false;\n\t\n\tif(TCPRI(One.PlayerReplicationInfo).TeamNamePRI == TCPRI(Two.PlayerReplicationInfo).TeamNamePRI)\n\t\treturn true;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AreAlliesBasic",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "one"
                            ],
                            [
                                "tcplayer",
                                "two"
                            ]
                        ],
                        "return": "bool"
                    },
                    "GetEnergyRate": {
                        "body": "{\n\treturn energyRate * LevelValues[CurrentLevel];\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetEnergyRate",
                        "native": false,
                        "param": [],
                        "return": "float"
                    },
                    "HealPlayers": {
                        "body": "{\n\n    count = 0;\n\n    if(TCTeam(Player.DXGame) != None) // Healing teammates in deathmatch is useless.\n    {\n        foreach RadiusActors(class'Actor', a, 256, Player.Location)\n        {\n            if(a.IsA('TCPlayer')) // TODO: Only heal teammates\n            {\n                target = TCPlayer(a);\n                if(target.PlayerReplicationInfo != None && target != TCPlayer(Player) && !target.PlayerReplicationInfo.bIsSpectator && target.Health > 0 && target.Health < 100 && (target.lastTeamHeal+1 <= Level.TimeSeconds) && (target.PlayerReplicationInfo.Team == player.PlayerReplicationInfo.Team))\n                {\n                    targetList[count] = target;\n                    count++;\n                    edrain = 3 * count;\n                    if(count == 3) // We heal a maximum of 3 players\n                        break;\n                }\n            }\n        }\n        \n        if(count > 0)\n        {\n\t\t\tLoopSound=Sound'DeusExSounds.Augmentation.AugLoop';\n            healamount = Min(30, (45/count));\n            totalamount = healamount*count;\n            for(i = 0; i < count; i++)\n            {\n                if(targetList[i] != None)\n                {\n\t\t\t\t\tPlayer.Energy -= edrain;\n                    targetList[i].HealPlayer(healamount, False);\n                    targetList[i].ClientFlash(0.5, vect(0, 0, 500));\n                    targetList[i].lastTeamHeal = Level.TimeSeconds;\n                }\n            }\n            if(totalamount > 0)\n            {\n                Player.ClientMessage(\"Healed\"@count@\"nearby player(s) for\"@totalamount$\"HP\");\n            }\n        }\n        else LoopSound=None;\n    }\n    else if(TCDeathmatch(Player.DXGame) != None)\n    {\n\t\tforeach RadiusActors(class'Actor', a, 256, Player.Location)\n        {\n            if(a.IsA('TCPlayer')) // TODO: Only heal teammates\n            {\n                target = TCPlayer(a);\n                if(target.PlayerReplicationInfo != None && target != TCPlayer(Player) && !target.PlayerReplicationInfo.bIsSpectator && target.Health > 0 && target.Health < 100 && (target.lastTeamHeal+1 <= Level.TimeSeconds) && AreAlliesBasic(target, TCPlayer(Player)))\n                {\n                    targetList[count] = target;\n                    count++;\n                    edrain = 3 * count;\n                    if(count == 3) // We heal a maximum of 3 players\n                        break;\n                }\n            }\n        }\n        \n        if(count > 0)\n        {\n\t\t\tLoopSound=Sound'DeusExSounds.Augmentation.AugLoop';\n            healamount = Min(30, (45/count));\n            totalamount = healamount*count;\n            for(i = 0; i < count; i++)\n            {\n                if(targetList[i] != None)\n                {\n\t\t\t\t\tPlayer.Energy -= edrain;\n                    targetList[i].HealPlayer(healamount, False);\n                    targetList[i].ClientFlash(0.5, vect(0, 0, 500));\n                    targetList[i].lastTeamHeal = Level.TimeSeconds;\n                }\n            }\n            if(totalamount > 0)\n            {\n                Player.ClientMessage(\"Healed\"@count@\"nearby player(s) for\"@totalamount$\"HP\");\n            }\n        }\n        else LoopSound=none;\n\t}\n}",
                        "locals": [
                            "local Actor a;",
                            "local TCPlayer target, targetList[3];",
                            "local int count, i, healamount, totalamount, edrain;"
                        ],
                        "modifiers": [],
                        "name": "HealPlayers",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n        AugmentationLocation = LOC_Torso;\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 164,
                "replication": "",
                "states": [],
                "variables": [
                    "var float mpAugValue;",
                    "var float mpEnergyDrain;"
                ]
            }
        },
        "AugNuke.uc": {
            "body": "//=============================================================================\n// AugHealing.\n//=============================================================================\nclass AugNuke extends Augmentation;\n\n#exec TEXTURE IMPORT NAME=\"AugIconNuke_Small\" FILE=\"Textures\\AugIconNuke_Small.pcx\" GROUP=Icons FLAGS=2\n#exec TEXTURE IMPORT NAME=\"AugIconNuke\" FILE=\"Textures\\AugIconNuke.pcx\" GROUP=Icons FLAGS=2\n\nvar float mpAugValue;\nvar float mpEnergyDrain;\n\nstate Active\n{\nBegin:\nLoop:\n\tSleep(1.0);\n\n\tGoto('Loop');\n}\n\nfunction Deactivate()\n{\n\tSuper.Deactivate();\n}\n\nsimulated function PreBeginPlay()\n{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n\t}\n}\n\ndefaultproperties\n{\n\tmpAugValue=5\n\tmpEnergyDrain=5\n\tEnergyRate=5\n\tIcon=Texture'AugIconNuke'\n\tsmallIcon=Texture'AugIconNuke_Small'\n\tAugmentationName=\"Nuke\"\n\tDescription=\"Programmable polymerase automatically directs construction of proteins in injured cells, restoring an agent to full health over time.|n|nTECH ONE: Healing occurs at a normal rate.|n|nTECH TWO: Healing occurs at a slightly faster rate.|n|nTECH THREE: Healing occurs at a moderately faster rate.|n|nTECH FOUR: Healing occurs at a significantly faster rate.\"\n\tMPInfo=\"When active, you heal, but at a rate insufficient for healing in combat.  Energy Drain: High\"\n\tLevelValues(0)=5.000000\n\tLevelValues(1)=5\n\tLevelValues(2)=5\n\tLevelValues(3)=5\n\tAugmentationLocation=LOC_Torso\n\tMPConflictSlot=4\n}\n\n",
            "name": "AugNuke.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "mpAugValue=5",
                    "mpEnergyDrain=5",
                    "EnergyRate=5",
                    "Icon=Texture'AugIconNuke'",
                    "smallIcon=Texture'AugIconNuke_Small'",
                    "AugmentationName=\"Nuke\"",
                    "Description=\"Programmable polymerase automatically directs construction of proteins in injured cells, restoring an agent to full health over time.|n|nTECH ONE: Healing occurs at a normal rate.|n|nTECH TWO: Healing occurs at a slightly faster rate.|n|nTECH THREE: Healing occurs at a moderately faster rate.|n|nTECH FOUR: Healing occurs at a significantly faster rate.\"",
                    "MPInfo=\"When active, you heal, but at a rate insufficient for healing in combat.  Energy Drain: High\"",
                    "LevelValues(0)=5.000000",
                    "LevelValues(1)=5",
                    "LevelValues(2)=5",
                    "LevelValues(3)=5",
                    "AugmentationLocation=LOC_Torso",
                    "MPConflictSlot=4"
                ],
                "exec": [
                    "#exec TEXTURE IMPORT NAME=\"AugIconNuke_Small\" FILE=\"Textures\\AugIconNuke_Small.pcx\" GROUP=Icons FLAGS=2",
                    "#exec TEXTURE IMPORT NAME=\"AugIconNuke\" FILE=\"Textures\\AugIconNuke.pcx\" GROUP=Icons FLAGS=2"
                ],
                "extends": "Augmentation",
                "functions": {
                    "Deactivate": {
                        "body": "{\n\tSuper.Deactivate();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Deactivate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 56,
                "replication": "",
                "states": [],
                "variables": [
                    "var float mpAugValue;",
                    "var float mpEnergyDrain;"
                ]
            }
        },
        "AugRadar.uc": {
            "body": "//=============================================================================\n// Radar\n//=============================================================================\nclass AugRadar extends Augmentation;\n\nvar float mpAugValue;\nvar float mpEnergyDrain;\n\nstate Active\n{\nBegin:\n\tif(Player.Energy < 1)\n\t\tDeactivate();\nLoop:\n\tif(Player.Energy > 0)\n\t{\n\t\tScan();\n\t}\n\telse\n\t\tDeactivate();\n\t\t\n\tSleep(5.0);\n\t\n\tGoto('Loop');\n}\n\nfunction Scan()\n{\n    local Actor a;\n    local TCPlayer target;\n    local int count, allycount;\n\n    count = 0;\n\tallycount = 0;\n\tforeach RadiusActors(class'Actor', a, 256, Player.Location)\n\t{\n\t\tif(a.IsA('TCPlayer'))\n\t\t{\n\t\t\ttarget = TCPlayer(a);\n\t\t\tif(target.PlayerReplicationInfo != None && target != TCPlayer(Player) && !target.PlayerReplicationInfo.bIsSpectator && target.Health > 0 && target.AugmentationSystem.GetAugLevelValue(class'AugRadarTrans') == -1.0 && !target.bHidden )\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\n\t\t\t\tif(AreAllies(TCPlayer(Player), target))\n\t\t\t\t\tallycount++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(count > 0)\n\t{\n\t\tPlayer.Energy -= 1;\n\t\tPlayer.ClientMessage(\"Hostiles detected. \"$count$\" targets, \"$allycount$\" allies.\");\n\t}\n}\n\nfunction bool AreAllies(TCPlayer POne, TCPlayer PTwo)\n{\n\tif(TCDeathmatch(player.DXGame) != None)\n\t\treturn TCDeathmatch(player.DXGame).ArePlayersAllied2(POne,PTwo);\n\t\t\n\tif(TCTeam(player.DXGame) != None)\n\t\treturn TCTeam(player.DXGame).ArePlayersAllied(POne,PTwo);\t\n}\n\n\nsimulated function PreBeginPlay()\n{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n        AugmentationLocation = LOC_Cranial;\n\t}\n}\n\ndefaultproperties\n{\n    mpAugValue=0\n    mpEnergyDrain=0\n    EnergyRate=0\n    Icon=Texture'AugIconDataLink'\n    smallIcon=Texture'AugIconDataLink_Small'\n    AugmentationName=\"Radar\"\n    Description=\"\"\n    MPInfo=\"Scans nearby hostiles\"\n    LevelValues(0)=0\n    LevelValues(1)=0\n    LevelValues(2)=0\n    LevelValues(3)=0\n    AugmentationLocation=5\n    MPConflictSlot=9\n}\n",
            "name": "AugRadar.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "mpAugValue=0",
                    "mpEnergyDrain=0",
                    "EnergyRate=0",
                    "Icon=Texture'AugIconDataLink'",
                    "smallIcon=Texture'AugIconDataLink_Small'",
                    "AugmentationName=\"Radar\"",
                    "Description=\"\"",
                    "MPInfo=\"Scans nearby hostiles\"",
                    "LevelValues(0)=0",
                    "LevelValues(1)=0",
                    "LevelValues(2)=0",
                    "LevelValues(3)=0",
                    "AugmentationLocation=5",
                    "MPConflictSlot=9"
                ],
                "exec": [],
                "extends": "Augmentation",
                "functions": {
                    "AreAllies": {
                        "body": "{\n\tif(TCDeathmatch(player.DXGame) != None)\n\t\treturn TCDeathmatch(player.DXGame).ArePlayersAllied2(POne,PTwo);\n\t\t\n\tif(TCTeam(player.DXGame) != None)\n\t\treturn TCTeam(player.DXGame).ArePlayersAllied(POne,PTwo);\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AreAllies",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "POne"
                            ],
                            [
                                "TCPlayer",
                                "PTwo"
                            ]
                        ],
                        "return": "bool"
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n        AugmentationLocation = LOC_Cranial;\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Scan": {
                        "body": "{\n\n    count = 0;\n\tallycount = 0;\n\tforeach RadiusActors(class'Actor', a, 256, Player.Location)\n\t{\n\t\tif(a.IsA('TCPlayer'))\n\t\t{\n\t\t\ttarget = TCPlayer(a);\n\t\t\tif(target.PlayerReplicationInfo != None && target != TCPlayer(Player) && !target.PlayerReplicationInfo.bIsSpectator && target.Health > 0 && target.AugmentationSystem.GetAugLevelValue(class'AugRadarTrans') == -1.0 && !target.bHidden )\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t\n\t\t\t\tif(AreAllies(TCPlayer(Player), target))\n\t\t\t\t\tallycount++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(count > 0)\n\t{\n\t\tPlayer.Energy -= 1;\n\t\tPlayer.ClientMessage(\"Hostiles detected. \"$count$\" targets, \"$allycount$\" allies.\");\n\t}\n}",
                        "locals": [
                            "local Actor a;",
                            "local TCPlayer target;",
                            "local int count, allycount;"
                        ],
                        "modifiers": [],
                        "name": "Scan",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 97,
                "replication": "",
                "states": [],
                "variables": [
                    "var float mpAugValue;",
                    "var float mpEnergyDrain;"
                ]
            }
        },
        "AugRepel.uc": {
            "body": "//=============================================================================\n// AugRepel\n// Concept : Requires > 10, any higher than that increases the range or power, then drains\n//=============================================================================\nclass AugRepel extends Augmentation;\n\nvar int velz, CheckRadius;\n\nfunction SpawnExplosion(vector Loc)\n{\nlocal ShockRing s1, s2, s3;\nlocal SphereEffect se;\n\n    s1 = spawn(class'ShockRing',,,Loc,rot(16384,0,0));\n\ts1.Lifespan = 5.5;\n    s2 = spawn(class'ShockRing',,,Loc,rot(0,16384,0));\n\ts2.Lifespan = 5.5;\n    s3 = spawn(class'ShockRing',,,Loc,rot(0,0,16384));\n\tS3.Lifespan = 5.5;\n\tse = spawn(class'SphereEffect',,,Loc,rot(16384,0,0));\n\tse.Lifespan = 5.5;\n\tse.MultiSkins[0]=Texture'DeusExDeco.Skins.AlarmLightTex7';\n}\n\nfunction Skullshot()\n{\n\tlocal vector loc, vline, HitLocation, hitNormal, altloc;\n\tlocal rotator altrot;\n\tlocal Actor HitActor;\n\tlocal actor a;\n\tlocal ScriptedPawn     hitPawn;\n\tlocal PlayerPawn       hitPlayer;\n\tlocal DeusExMover      hitMover;\n\tlocal DeusExDecoration hitDecoration;\n\t\n\tloc = Player.Location;\n\tloc.Z -= 32;\n\tPlayer.Energy -= 10;\n\tSpawnExplosion(Loc);\n\tforeach Player.VisibleActors(class'Actor', A, CheckRadius)\n\t{\n\t\tif (a != None && a != Player)\n\t\t{\n\t\t\thitPawn = ScriptedPawn(a);\n\t\t\thitDecoration = DeusExDecoration(a);\n\t\t\thitPlayer = PlayerPawn(a);\n\t\t\thitMover = DeusExMover(a);\n\t\t\tif (hitPawn != None)\n\t\t\t{\n\t\t\t\thitPawn.SetPhysics(Phys_Falling);\n\t\t\t\thitPawn.Velocity = (normal(loc - hitPawn.Location) * velz);\n\t\t\t\t//hitPawn.TakeDamage(Player.Energy, Player, hitLocation, normal(loc - hitPawn.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\telse if (hitDecoration != None)\n\t\t\t{\n\t\t\t\thitDecoration.SetPhysics(Phys_Falling);\n\t\t\t\thitDecoration.Velocity = (normal(loc - hitDecoration.Location) * velz);\t\n\t\t\t\t//hitDecoration.TakeDamage(Player.Energy, Player, hitLocation, normal(loc - hitDecoration.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\telse if (hitPlayer != None)\n\t\t\t{\n\t\t\t\thitPlayer.SetPhysics(Phys_Falling);\n\t\t\t\thitPlayer.Velocity = (normal(loc - hitPlayer.Location) * velz);\n\t\t\t\t//hitPlayer.TakeDamage(Player.Energy / 3, Player, hitLocation, normal(loc - hitPlayer.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\tif (hitMover != None)\n\t\t\t{\n\t\t\t\t\thitMover.bDrawExplosion = True;\n\t\t\t\t//\thitMover.TakeDamage(Player.Energy * 3, Player, hitLocation,normal(loc - hitMover.Location) * velz, 'Exploded'); \n\t\t\t}\n\t\t}\t\t\n\t}\n}\n\nstate Active\n{\nBegin:\n\tif(Player.Energy >= 10)\n\t\tSkullshot();\n\t\n\tDeactivate();\n}\n\nfunction Deactivate()\n{\n\tSuper.Deactivate();\n}\n\ndefaultproperties\n{\n\tCheckRadius=256\n\tvelz=-750\n\tEnergyRate=0.000000\n\tIcon=Texture'DeusExUI.UserInterface.AugIconEMP'\n\tsmallIcon=Texture'DeusExUI.UserInterface.AugIconEMP_Small'\n\tAugmentationName=\"Blast Shield\"\n\tDescription=\"\"\n\tMPInfo=\"When active, the aug repels all objects around you\"\n\tLevelValues(0)=5.000000\n\tLevelValues(1)=15.000000\n\tLevelValues(2)=25.000000\n\tLevelValues(3)=40.000000\n    AugmentationLocation=5\n    MPConflictSlot=9\n}\n\n",
            "name": "AugRepel.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "CheckRadius=256",
                    "velz=-750",
                    "EnergyRate=0.000000",
                    "Icon=Texture'DeusExUI.UserInterface.AugIconEMP'",
                    "smallIcon=Texture'DeusExUI.UserInterface.AugIconEMP_Small'",
                    "AugmentationName=\"Blast Shield\"",
                    "Description=\"\"",
                    "MPInfo=\"When active, the aug repels all objects around you\"",
                    "LevelValues(0)=5.000000",
                    "LevelValues(1)=15.000000",
                    "LevelValues(2)=25.000000",
                    "LevelValues(3)=40.000000",
                    "AugmentationLocation=5",
                    "MPConflictSlot=9"
                ],
                "exec": [],
                "extends": "Augmentation",
                "functions": {
                    "Deactivate": {
                        "body": "{\n\tSuper.Deactivate();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Deactivate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Skullshot": {
                        "body": "{\n\t\n\tloc = Player.Location;\n\tloc.Z -= 32;\n\tPlayer.Energy -= 10;\n\tSpawnExplosion(Loc);\n\tforeach Player.VisibleActors(class'Actor', A, CheckRadius)\n\t{\n\t\tif (a != None && a != Player)\n\t\t{\n\t\t\thitPawn = ScriptedPawn(a);\n\t\t\thitDecoration = DeusExDecoration(a);\n\t\t\thitPlayer = PlayerPawn(a);\n\t\t\thitMover = DeusExMover(a);\n\t\t\tif (hitPawn != None)\n\t\t\t{\n\t\t\t\thitPawn.SetPhysics(Phys_Falling);\n\t\t\t\thitPawn.Velocity = (normal(loc - hitPawn.Location) * velz);\n\t\t\t\t//hitPawn.TakeDamage(Player.Energy, Player, hitLocation, normal(loc - hitPawn.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\telse if (hitDecoration != None)\n\t\t\t{\n\t\t\t\thitDecoration.SetPhysics(Phys_Falling);\n\t\t\t\thitDecoration.Velocity = (normal(loc - hitDecoration.Location) * velz);\t\n\t\t\t\t//hitDecoration.TakeDamage(Player.Energy, Player, hitLocation, normal(loc - hitDecoration.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\telse if (hitPlayer != None)\n\t\t\t{\n\t\t\t\thitPlayer.SetPhysics(Phys_Falling);\n\t\t\t\thitPlayer.Velocity = (normal(loc - hitPlayer.Location) * velz);\n\t\t\t\t//hitPlayer.TakeDamage(Player.Energy / 3, Player, hitLocation, normal(loc - hitPlayer.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\tif (hitMover != None)\n\t\t\t{\n\t\t\t\t\thitMover.bDrawExplosion = True;\n\t\t\t\t//\thitMover.TakeDamage(Player.Energy * 3, Player, hitLocation,normal(loc - hitMover.Location) * velz, 'Exploded'); \n\t\t\t}\n\t\t}\t\t\n\t}\n}",
                        "locals": [
                            "local vector loc, vline, HitLocation, hitNormal, altloc;",
                            "local rotator altrot;",
                            "local Actor HitActor;",
                            "local actor a;",
                            "local ScriptedPawn     hitPawn;",
                            "local PlayerPawn       hitPlayer;",
                            "local DeusExMover      hitMover;",
                            "local DeusExDecoration hitDecoration;"
                        ],
                        "modifiers": [],
                        "name": "Skullshot",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpawnExplosion": {
                        "body": "{\n\n    s1 = spawn(class'ShockRing',,,Loc,rot(16384,0,0));\n\ts1.Lifespan = 5.5;\n    s2 = spawn(class'ShockRing',,,Loc,rot(0,16384,0));\n\ts2.Lifespan = 5.5;\n    s3 = spawn(class'ShockRing',,,Loc,rot(0,0,16384));\n\tS3.Lifespan = 5.5;\n\tse = spawn(class'SphereEffect',,,Loc,rot(16384,0,0));\n\tse.Lifespan = 5.5;\n\tse.MultiSkins[0]=Texture'DeusExDeco.Skins.AlarmLightTex7';\n}",
                        "locals": [
                            "local ShockRing s1, s2, s3;",
                            "local SphereEffect se;"
                        ],
                        "modifiers": [],
                        "name": "SpawnExplosion",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "Loc"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 107,
                "replication": "",
                "states": [],
                "variables": [
                    "var int velz, CheckRadius;"
                ]
            }
        },
        "AugSkullgun.uc": {
            "body": "//=============================================================================\n// AugFlight\n// CONCEPT AUG\n// Trace to crosshair, if target is found (Deco or Pawn), do damage, then de-activate\n//=============================================================================\nclass AugSkullgun extends Augmentation;\n\n#exec TEXTURE IMPORT NAME=\"AugIconSkull_Small\" FILE=\"Textures\\AugIconSkull_Small.pcx\" GROUP=Icons FLAGS=2\n#exec TEXTURE IMPORT NAME=\"AugIconSkull\" FILE=\"Textures\\AugIconSkull.pcx\" GROUP=Icons FLAGS=2\n\nvar int BioDrainODX;\n\nfunction Skullshot()\n{\n\tlocal Actor hitActor;\n\tlocal vector loc, line, HitLocation, hitNormal;\n\tlocal ScriptedPawn     hitPawn;\n\tlocal PlayerPawn       hitPlayer;\n\tlocal DeusExMover      hitMover;\n\tlocal DeusExDecoration hitDecoration;\n\tlocal DeusExProjectile hitProjectile;\n\tlocal bool             bTakeDamage;\n\tlocal int              damage;\n\tlocal vector v2;\n\t\n\tPlayer.Energy -= BioDrainODX;\n\t\n\tv2 = Player.location;\n\tv2.z += 20;\n\tSpawn(class'Tracer',Player,,v2,Player.ViewRotation);\n\t\n\tPlayer.PlaySound(sound'RifleFire');\n\t\n\tloc = Player.Location;\n\tloc.Z += Player.BaseEyeHeight;\n\tline = Vector(Player.ViewRotation) * 4000;\n\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\tif (hitActor != None)\n\t\t\t{\n\t\t\t\thitMover = DeusExMover(hitActor);\n\t\t\t\thitPawn = ScriptedPawn(hitActor);\n\t\t\t\thitDecoration = DeusExDecoration(hitActor);\n\t\t\t\thitPlayer = PlayerPawn(hitActor);\n\t\t\t\tif (hitMover != None)\n\t\t\t\t{\n\t\t\t\t\tdamage=50;\n\t\t\t\t\tbTakeDamage = true;\n\t\t\t\t}\n\t\t\t\telse if (hitPawn != None)\n\t\t\t\t{\n\t\t\t\t\tdamage=50;\n\t\t\t\t\tbTakeDamage = true;\n\t\t\t\t}\n\t\t\t\telse if (hitDecoration != None)\n\t\t\t\t{\n\t\t\t\t\tdamage = 50;\n\t\t\t\t\tbTakeDamage = true;\n\t\t\t\t}\n\t\t\t\telse if (hitPlayer != None)\n\t\t\t\t{\n\t\t\t\t\tdamage = 50;\n\t\t\t\t\tbTakeDamage = true;\n\t\t\t\t}\n\t\t\t\telse if (hitActor != Level)\n\t\t\t\t{\n\t\t\t\t\tdamage = 50;\n\t\t\t\t\tbTakeDamage = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bTakeDamage)\n\t\t\t\thitActor.TakeDamage(damage, Player, hitLocation, line, 'Shot'); \t\n}\n\nstate Active\n{\nBegin:\n\tif(Player.Energy >= BioDrainODX)\n\t\tSkullshot();\n\t\n\tDeactivate();\n//Loop:\n\t//Sleep(0.1);\n//Player\n\n}\n\nfunction Deactivate()\n{\n\tSuper.Deactivate();\n}\n\nsimulated function PreBeginPlay()\n{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\t//LevelValues[3] = mpAugValue;\n\t\t//EnergyRate = mpEnergyDrain;\n\t}\n}\n\ndefaultproperties\n{\n\tBioDrainODX=10\n\t//mpAugValue=0.000000\n\t//mpEnergyDrain=0.000000\n\tEnergyRate=0.000000\n\tIcon=Texture'AugIconSkull'\n\tsmallIcon=Texture'AugIconSkull_Small'\n\tAugmentationName=\"Skullgun\"\n\tDescription=\"\"\n\tMPInfo=\"When active, the aug fires a shot from your eye...\"\n\tLevelValues(0)=5.000000\n\tLevelValues(1)=15.000000\n\tLevelValues(2)=25.000000\n\tLevelValues(3)=40.000000\n\tAugmentationLocation=LOC_Eye\n\tMPConflictSlot=4\n\tDeActivateSound=none\n}\n\n",
            "name": "AugSkullgun.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "BioDrainODX=10",
                    "//mpAugValue=0.000000",
                    "//mpEnergyDrain=0.000000",
                    "EnergyRate=0.000000",
                    "Icon=Texture'AugIconSkull'",
                    "smallIcon=Texture'AugIconSkull_Small'",
                    "AugmentationName=\"Skullgun\"",
                    "Description=\"\"",
                    "MPInfo=\"When active, the aug fires a shot from your eye...\"",
                    "LevelValues(0)=5.000000",
                    "LevelValues(1)=15.000000",
                    "LevelValues(2)=25.000000",
                    "LevelValues(3)=40.000000",
                    "AugmentationLocation=LOC_Eye",
                    "MPConflictSlot=4",
                    "DeActivateSound=none"
                ],
                "exec": [
                    "#exec TEXTURE IMPORT NAME=\"AugIconSkull_Small\" FILE=\"Textures\\AugIconSkull_Small.pcx\" GROUP=Icons FLAGS=2",
                    "#exec TEXTURE IMPORT NAME=\"AugIconSkull\" FILE=\"Textures\\AugIconSkull.pcx\" GROUP=Icons FLAGS=2"
                ],
                "extends": "Augmentation",
                "functions": {
                    "Deactivate": {
                        "body": "{\n\tSuper.Deactivate();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Deactivate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\t//LevelValues[3] = mpAugValue;\n\t\t//EnergyRate = mpEnergyDrain;\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Skullshot": {
                        "body": "{\n\t\n\tPlayer.Energy -= BioDrainODX;\n\t\n\tv2 = Player.location;\n\tv2.z += 20;\n\tSpawn(class'Tracer',Player,,v2,Player.ViewRotation);\n\t\n\tPlayer.PlaySound(sound'RifleFire');\n\t\n\tloc = Player.Location;\n\tloc.Z += Player.BaseEyeHeight;\n\tline = Vector(Player.ViewRotation) * 4000;\n\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\tif (hitActor != None)\n\t\t\t{\n\t\t\t\thitMover = DeusExMover(hitActor);\n\t\t\t\thitPawn = ScriptedPawn(hitActor);\n\t\t\t\thitDecoration = DeusExDecoration(hitActor);\n\t\t\t\thitPlayer = PlayerPawn(hitActor);\n\t\t\t\tif (hitMover != None)\n\t\t\t\t{\n\t\t\t\t\tdamage=50;\n\t\t\t\t\tbTakeDamage = true;\n\t\t\t\t}\n\t\t\t\telse if (hitPawn != None)\n\t\t\t\t{\n\t\t\t\t\tdamage=50;\n\t\t\t\t\tbTakeDamage = true;\n\t\t\t\t}\n\t\t\t\telse if (hitDecoration != None)\n\t\t\t\t{\n\t\t\t\t\tdamage = 50;\n\t\t\t\t\tbTakeDamage = true;\n\t\t\t\t}\n\t\t\t\telse if (hitPlayer != None)\n\t\t\t\t{\n\t\t\t\t\tdamage = 50;\n\t\t\t\t\tbTakeDamage = true;\n\t\t\t\t}\n\t\t\t\telse if (hitActor != Level)\n\t\t\t\t{\n\t\t\t\t\tdamage = 50;\n\t\t\t\t\tbTakeDamage = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bTakeDamage)\n\t\t\t\thitActor.TakeDamage(damage, Player, hitLocation, line, 'Shot'); \t\n}",
                        "locals": [
                            "local Actor hitActor;",
                            "local vector loc, line, HitLocation, hitNormal;",
                            "local ScriptedPawn     hitPawn;",
                            "local PlayerPawn       hitPlayer;",
                            "local DeusExMover      hitMover;",
                            "local DeusExDecoration hitDecoration;",
                            "local DeusExProjectile hitProjectile;",
                            "local bool             bTakeDamage;",
                            "local int              damage;",
                            "local vector v2;"
                        ],
                        "modifiers": [],
                        "name": "Skullshot",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 125,
                "replication": "",
                "states": [],
                "variables": [
                    "var int BioDrainODX;"
                ]
            }
        },
        "AugTakedown.uc": {
            "body": "//=============================================================================\n// AugTakedown\n// For.. something\n//=============================================================================\nclass AugTakedown extends Augmentation;\n\n#exec TEXTURE IMPORT NAME=\"AugIconSkull_Small\" FILE=\"Textures\\AugIconSkull_Small.pcx\" GROUP=Icons FLAGS=2\n#exec TEXTURE IMPORT NAME=\"AugIconSkull\" FILE=\"Textures\\AugIconSkull.pcx\" GROUP=Icons FLAGS=2\n\nvar float mpAugValue;\nvar float mpEnergyDrain;\n\nfunction Skullshot()\n{\n\tlocal Actor hitActor;\n\tlocal vector loc, line, HitLocation, hitNormal;\n\tlocal ScriptedPawn     hitPawn;\n\tlocal PlayerPawn       hitPlayer;\n\tlocal int              damage;\n\tlocal vector v2;\n\t\n\tPlayer.Energy -= 25;\n\t\n\n\tPlayer.PlaySound(sound'RifleFire');\n\t\n\tloc = Player.Location;\n\tloc.Z += Player.BaseEyeHeight;\n\tline = Vector(Player.ViewRotation) * 100;\n\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\tif (hitActor != None)\n\t\t\t{\n\t\t\t\thitPawn = ScriptedPawn(hitActor);\n\t\t\t\thitPlayer = PlayerPawn(hitActor);\n\t\t\t\tif (hitPawn != None)\n\t\t\t\t{\n\t\t\t\t\tPlayer.ClientMessage(\"Placeholder: taking down \"$hitpawn);\n\t\t\t\t}\n\t\t\t\telse if (hitPlayer != None)\n\t\t\t\t{\n\t\t\t\t\tPlayer.ClientMessage(\"Placeholder: taking down \"$hitplayer.playerreplicationinfo.playername);\n\t\t\t\t}\n\t\t\t}\t\n}\n\nstate Active\n{\n\nBegin:\nLoop:\n\tSleep(0.1);\n//Player\n\tif(Player.Energy >= 25)\n\t\tSkullshot();\n\t\n\tDeactivate();\n}\n\nfunction Deactivate()\n{\n\tSuper.Deactivate();\n}\n\nsimulated function PreBeginPlay()\n{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n\t}\n}\n\ndefaultproperties\n{\n\tmpAugValue=10.000000\n\tmpEnergyDrain=0.000000\n\tEnergyRate=0.000000\n\tIcon=Texture'AugIconSkull'\n\tsmallIcon=Texture'AugIconSkull_Small'\n\tAugmentationName=\"Takedown\"\n\tDescription=\"\"\n\tMPInfo=\"When active, something something\"\n\tLevelValues(0)=5.000000\n\tLevelValues(1)=15.000000\n\tLevelValues(2)=25.000000\n\tLevelValues(3)=40.000000\n\tAugmentationLocation=LOC_Arm\n\tMPConflictSlot=4\n}\n\n",
            "name": "AugTakedown.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "mpAugValue=10.000000",
                    "mpEnergyDrain=0.000000",
                    "EnergyRate=0.000000",
                    "Icon=Texture'AugIconSkull'",
                    "smallIcon=Texture'AugIconSkull_Small'",
                    "AugmentationName=\"Takedown\"",
                    "Description=\"\"",
                    "MPInfo=\"When active, something something\"",
                    "LevelValues(0)=5.000000",
                    "LevelValues(1)=15.000000",
                    "LevelValues(2)=25.000000",
                    "LevelValues(3)=40.000000",
                    "AugmentationLocation=LOC_Arm",
                    "MPConflictSlot=4"
                ],
                "exec": [
                    "#exec TEXTURE IMPORT NAME=\"AugIconSkull_Small\" FILE=\"Textures\\AugIconSkull_Small.pcx\" GROUP=Icons FLAGS=2",
                    "#exec TEXTURE IMPORT NAME=\"AugIconSkull\" FILE=\"Textures\\AugIconSkull.pcx\" GROUP=Icons FLAGS=2"
                ],
                "extends": "Augmentation",
                "functions": {
                    "Deactivate": {
                        "body": "{\n\tSuper.Deactivate();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Deactivate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tSuper.PreBeginPlay();\n\n\t// If this is a netgame, then override defaults\n\tif ( Level.NetMode != NM_StandAlone )\n\t{\n\t\tLevelValues[3] = mpAugValue;\n\t\tEnergyRate = mpEnergyDrain;\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Skullshot": {
                        "body": "{\n\t\n\tPlayer.Energy -= 25;\n\t\n\n\tPlayer.PlaySound(sound'RifleFire');\n\t\n\tloc = Player.Location;\n\tloc.Z += Player.BaseEyeHeight;\n\tline = Vector(Player.ViewRotation) * 100;\n\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\tif (hitActor != None)\n\t\t\t{\n\t\t\t\thitPawn = ScriptedPawn(hitActor);\n\t\t\t\thitPlayer = PlayerPawn(hitActor);\n\t\t\t\tif (hitPawn != None)\n\t\t\t\t{\n\t\t\t\t\tPlayer.ClientMessage(\"Placeholder: taking down \"$hitpawn);\n\t\t\t\t}\n\t\t\t\telse if (hitPlayer != None)\n\t\t\t\t{\n\t\t\t\t\tPlayer.ClientMessage(\"Placeholder: taking down \"$hitplayer.playerreplicationinfo.playername);\n\t\t\t\t}\n\t\t\t}\t\n}",
                        "locals": [
                            "local Actor hitActor;",
                            "local vector loc, line, HitLocation, hitNormal;",
                            "local ScriptedPawn     hitPawn;",
                            "local PlayerPawn       hitPlayer;",
                            "local int              damage;",
                            "local vector v2;"
                        ],
                        "modifiers": [],
                        "name": "Skullshot",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 94,
                "replication": "",
                "states": [],
                "variables": [
                    "var float mpAugValue;",
                    "var float mpEnergyDrain;"
                ]
            }
        },
        "DXL.uc": {
            "body": "class DXL extends Actor;\n\nvar localized string l_lvote, l_wonvote;\n\nvar DXL Prev, Next;\nvar DXMVMapVoteMenu MVM;\n\nvar string Maps[arraycount(class'MVMutator'.default.Maps)];\nvar byte VoteTotals[arraycount(Maps)];\n\nVar MVMutator Mut;\nvar float RepTime;\nvar int MapCount, iCurrentVote, iNextMap, iRepMaps;\nvar bool bVoteDone, bAdminVoteDone, bAdminVoteYes;\nvar bool DoesNotVote; //Ayleth: used to seperate the master DXL from the player dxls\n\n//Ayleth: Any Function or Variable that names AdminVote refers to\n//the admin prompting for a serverwide decision to switch to the\n//most popular vote b4 the match ends. These are all my addition.\n//Somewhat hacky in places tho. Sorry for the indent mess. Too\n//lazy to clean up his mess. Throws off my indenting as well :(\n\n//don't save data and function calls to the demorec\nreplication\n{\n  reliable if (!bDemoRecording && bNetOwner && (Role == ROLE_Authority))\n   MapCount, iNextMap, VoteTotals;\n\n  reliable if (!bDemoRecording && (Role == ROLE_Authority))\n   ClientResetAdminVote, OpenAVMenu, OpenMVMenu, CloseMVMenu, ShowWinner, ClientAddMaps;\n\n  reliable if (!bDemoRecording && (Role < ROLE_Authority))\n   ServerSetVote, ServerAdminVote, ServerResetAdminVote;\n}\n\n//Ayleth: this allows us to get and set variables within the mutator.\nsimulated function PostBeginPlay()\n{\n  local MVMutator c;\n  foreach allactors (class'MVMutator', c)\n  {\n      mut = c;\n      return;\n  }\n\n    if (c == None)\n        Mut = Spawn(class'MVMutator');\n  SetTimer(1, true);\n}\n\n\nsimulated final function bool ValidOwner() {\n  return ( (DeusExPlayer(Owner) != None) && DeusExPlayer(Owner).PlayerIsClient() && (DeusExPlayer(Owner).Player != None) && (DeusExPlayer(Owner).Player.CurrentNetSpeed != 1000000) );  //demo check\n}\n\n\nsimulated function Timer() {\n  if (ValidOwner()) {\n   if (MapCount <= 0)\n    return;\n   ClientSetVote(-1);\n   if (Role == ROLE_Authority)\n    iRepMaps = MapCount;\n   OpenMVMenu();\n  } else if ((Role < ROLE_Authority) && (Owner == None))\n     return;\n\n  SetTimer(0, false);\n}\n\n\nsimulated final function AddMap(int I, string M) {\n  if ((iRepMaps < MapCount) && (I < MapCount) && (M != \"\") && (Maps[I] == \"\")) {\n   Maps[I] = M;\n   iRepMaps++;\n  }\n}\n\n\nsimulated final function ClientAddMaps(int I, string M, string M1, string M2, string M3) {\n  AddMap(I  , M);\n  AddMap(I+1, M1);\n  AddMap(I+2, M2);\n  AddMap(I+3, M3);\n}\n\n\n//use function replication to work around the large array replication GPF\n//send about 80 maps/sec\nfunction Tick(float Delta) {\n   local string M[4];\n   local int I;\n\n  if (Owner == None) {\n   Destroy();\n   return;\n  }\n\n  if ((iRepMaps < MapCount) && (iCurrentVote != -2)) {\n   RepTime += Delta / Level.TimeDilation;\n   if (RepTime >= 0.05) {\n    RepTime = FMin(RepTime - 0.05, 0.01);\n    for (I = 0; I < 4; I++) {\n     if (iRepMaps < MapCount) {\n      M[I] = Maps[iRepMaps];\n      iRepMaps++;\n     }\n     else\n     break;\n    }\n   ClientAddMaps(iRepMaps - I, M[0], M[1], M[2], M[3]);\n   }\n  }\n}\n\n\nsimulated function Destroyed() {\n  if (MVM != None)\n   MVM.root.PopWindow();\n\n  MVM = None;\n\n  if (Role == ROLE_Authority) {\n   if (Prev != None) Prev.Next = Next;\n   if (Next != None) Next.Prev = Prev;\n   Prev = None;\n   Next = None;\n  }\n}\n\n\nfinal function ServerSetVote(int I) {\n   iCurrentVote = I;\n}\n\n//Allow the player to vote once a new vote has been called. ServerSide.\nfinal function ServerResetAdminVote()\n{\n    bAdminVoteDone=False;\n}\n\n//Set the vote that the player made. ServerSide.\nfinal function ServerAdminVote(bool Vote)\n{\n    bAdminVoteDone=True;\n    bAdminVoteYes=Vote;\n}\n\n//Allow the player to vote once a new vote has been called. ClientSide.\nSimulated final function ClientResetAdminVote()\n{\n    bAdminVoteDone=False;\n    ServerResetAdminVote();\n}\n\n//Set the vote that the player made. ClientSide.\nsimulated final function ClientAdminVote(bool Vote)\n{\n    bAdminVoteDone=True;\n    bAdminVoteYes=Vote;\n    ServerAdminVote(Vote);\n}\n\nsimulated final function ClientSetVote(int I) {\n  if (iCurrentVote != I) {\n   iCurrentVote = I;\n   ServerSetVote(I);\n  }\n}\n\nsimulated final function OpenMVMenu() {\n  local DeusExRootWindow W;\n\n  if (!bVoteDone && (MVM == None) && ValidOwner()) {\n   W = DeusExRootWindow(DeusExPlayer(Owner).RootWindow);\n   if (W != None) {\n    MVM = DXMVMapVoteMenu(W.InvokeMenuScreen(Class'DXMVMapVoteMenu', true));\n    if (MVM != None)\n     MVM.PlayerVote = Self;\n   }\n  }\n}\n\n//OpenAdminVoteMenu: Opens the admin prompted vote window to alow players to\n//vote for immediate mapchange.\nSimulated final function OpenAVMenu(bool bForceShow)\n{\n    local AdminVoteWindow AVW;\n    local DeusExRootWindow W;\n    if ((!bAdminVoteDone || bForceShow) && ValidOwner())\n    {\n        W = DeusExRootWindow(DeusExPlayer(Owner).RootWindow);\n        if (W != None)\n        {\n            AVW = AdminVoteWindow(W.InvokeMenuScreen(Class'AdminVoteWindow', true));\n    \t\tAVW.SetMessageText(\"An administrator has instigated a|nservertravel vote. Do you wish to|nchange to the most voted map,|n\"@Maps[iNextMap]$\"?\");\n    \t\tAVW.Caller=Self;\n            W.ShowCursor(True);\n    \t}\n    }\n}\n\n//Sprintf is not simulated - must call it from player\n\nsimulated final function CloseMVMenu(string sNextMap) {\n if (!bVoteDone) {\n  bVoteDone = true;\n  if (MVM != None)\n   MVM.root.PopWindow();\n  if (ValidOwner())\n   DeusExPlayer(Owner).ClientMessage(Owner.Sprintf(l_wonvote, sNextMap), 'Say', true);\n }\n}\n\n\nsimulated final function ShowWinner() {\n  if ((iNextMap >= 0) && ValidOwner())\n   DeusExPlayer(Owner).ClientMessage(Owner.Sprintf(l_lvote, Maps[iNextMap]));\n}\n\n\ndefaultproperties\n{\n    l_lvote=\"%s is currently leading the vote.\"\n    l_wonvote=\"%s has won the map vote!\"\n    iCurrentVote=-2\n    iNextMap=-1\n    bHidden=True\n    RemoteRole=2\n    NetPriority=1.50\n}\n",
            "name": "DXL.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "l_lvote=\"%s is currently leading the vote.\"",
                    "l_wonvote=\"%s has won the map vote!\"",
                    "iCurrentVote=-2",
                    "iNextMap=-1",
                    "bHidden=True",
                    "RemoteRole=2",
                    "NetPriority=1.50"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "AddMap": {
                        "body": "if ((iRepMaps < MapCount) && (I < MapCount) && (M != \"\") && (Maps[I] == \"\")) {",
                        "locals": [],
                        "modifiers": [
                            "final",
                            "simulated"
                        ],
                        "name": "AddMap",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "I"
                            ],
                            [
                                "string",
                                "M"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientAddMaps": {
                        "body": "AddMap(I  , M);",
                        "locals": [],
                        "modifiers": [
                            "final",
                            "simulated"
                        ],
                        "name": "ClientAddMaps",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "I"
                            ],
                            [
                                "string",
                                "M"
                            ],
                            [
                                "string",
                                "M1"
                            ],
                            [
                                "string",
                                "M2"
                            ],
                            [
                                "string",
                                "M3"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientAdminVote": {
                        "body": "{\n    bAdminVoteDone=True;\n    bAdminVoteYes=Vote;\n    ServerAdminVote(Vote);\n}",
                        "locals": [],
                        "modifiers": [
                            "final",
                            "simulated"
                        ],
                        "name": "ClientAdminVote",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "Vote"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientResetAdminVote": {
                        "body": "{\n    bAdminVoteDone=False;\n    ServerResetAdminVote();\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "ClientResetAdminVote",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ClientSetVote": {
                        "body": "if (iCurrentVote != I) {",
                        "locals": [],
                        "modifiers": [
                            "final",
                            "simulated"
                        ],
                        "name": "ClientSetVote",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "I"
                            ]
                        ],
                        "return": ""
                    },
                    "CloseMVMenu": {
                        "body": "if (!bVoteDone) {",
                        "locals": [],
                        "modifiers": [
                            "final",
                            "simulated"
                        ],
                        "name": "CloseMVMenu",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "sNextMap"
                            ]
                        ],
                        "return": ""
                    },
                    "Destroyed": {
                        "body": "if (MVM != None)",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Destroyed",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "OpenAVMenu": {
                        "body": "{\n    if ((!bAdminVoteDone || bForceShow) && ValidOwner())\n    {\n        W = DeusExRootWindow(DeusExPlayer(Owner).RootWindow);\n        if (W != None)\n        {\n            AVW = AdminVoteWindow(W.InvokeMenuScreen(Class'AdminVoteWindow', true));\n    \t\tAVW.SetMessageText(\"An administrator has instigated a|nservertravel vote. Do you wish to|nchange to the most voted map,|n\"@Maps[iNextMap]$\"?\");\n    \t\tAVW.Caller=Self;\n            W.ShowCursor(True);\n    \t}\n    }\n}",
                        "locals": [
                            "local AdminVoteWindow AVW;",
                            "local DeusExRootWindow W;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "OpenAVMenu",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "bForceShow"
                            ]
                        ],
                        "return": ""
                    },
                    "OpenMVMenu": {
                        "body": "",
                        "locals": [
                            "local DeusExRootWindow W;"
                        ],
                        "modifiers": [
                            "final",
                            "simulated"
                        ],
                        "name": "OpenMVMenu",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n  foreach allactors (class'MVMutator', c)\n  {\n      mut = c;\n      return;\n  }\n\n    if (c == None)\n        Mut = Spawn(class'MVMutator');\n  SetTimer(1, true);\n}",
                        "locals": [
                            "local MVMutator c;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ServerAdminVote": {
                        "body": "{\n    bAdminVoteDone=True;\n    bAdminVoteYes=Vote;\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "ServerAdminVote",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "Vote"
                            ]
                        ],
                        "return": ""
                    },
                    "ServerResetAdminVote": {
                        "body": "{\n    bAdminVoteDone=False;\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "ServerResetAdminVote",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ServerSetVote": {
                        "body": "iCurrentVote = I;",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "ServerSetVote",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "I"
                            ]
                        ],
                        "return": ""
                    },
                    "ShowWinner": {
                        "body": "if ((iNextMap >= 0) && ValidOwner())",
                        "locals": [],
                        "modifiers": [
                            "final",
                            "simulated"
                        ],
                        "name": "ShowWinner",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Tick": {
                        "body": "",
                        "locals": [
                            "local string M[4];",
                            "local int I;"
                        ],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Delta"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "if (ValidOwner()) {",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ValidOwner": {
                        "body": "return ( (DeusExPlayer(Owner) != None) && DeusExPlayer(Owner).PlayerIsClient() && (DeusExPlayer(Owner).Player != None) && (DeusExPlayer(Owner).Player.CurrentNetSpeed != 1000000) );  //demo check",
                        "locals": [],
                        "modifiers": [
                            "final",
                            "simulated"
                        ],
                        "name": "ValidOwner",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 232,
                "replication": "",
                "states": [],
                "variables": [
                    "var localized string l_lvote, l_wonvote;",
                    "var DXL Prev, Next;",
                    "var DXMVMapVoteMenu MVM;",
                    "var string Maps[arraycount(class'MVMutator'.default.Maps)];",
                    "var byte VoteTotals[arraycount(Maps)];",
                    "Var MVMutator Mut;",
                    "var float RepTime;",
                    "var int MapCount, iCurrentVote, iNextMap, iRepMaps;",
                    "var bool bVoteDone, bAdminVoteDone, bAdminVoteYes;",
                    "var bool DoesNotVote; //Ayleth: used to seperate the master DXL from the player dxls"
                ]
            }
        },
        "DXMVMapVoteMenu.uc": {
            "body": "class DXMVMapVoteMenu extends MenuUIScreenWindow;\n\nvar localized string l_help1, l_help2, l_help3, l_help4, l_cvote, l_lmap;\nvar MenuUIScrollAreaWindow winScroll;\nvar MenuUIListWindow lstMaps, lstVotes;\nvar MenuUISmallLabelWindow CurrentVote, LeadingMap;\nvar DXL PlayerVote;\nvar float RepTime;\nvar bool bListDone, bStacking;\n\n\nevent InitWindow() {\n   local Window W;\n\n   Super.InitWindow();\n\n   if (actionButtons[2].btn != None)\n    if ((Player == None) || (Player.PlayerReplicationInfo == None) || !Player.PlayerReplicationInfo.bAdmin)\n     actionButtons[2].btn.SetSensitivity(false);\n\n   winClient.SetBackground(Texture'DeusExUI.MaskTexture');\n   winClient.SetBackgroundStyle(DSTY_Modulated);\n\n   W = winClient.NewChild(Class'Window');\n   W.SetSize(ClientWidth, ClientHeight-20);\n   W.SetBackground(Texture'DeusExUI.MaskTexture');\n   W.SetBackgroundStyle(DSTY_Modulated);\n   W.Lower();\n\n   CreateLabel(8, 7, l_lmap);\n   LeadingMap = CreateLabel(16, 20, \"\");\n   LeadingMap.SetWidth(180);\n\n   lstVotes = MenuUIListWindow(winClient.NewChild(Class'MenuUIListWindow'));\n   lstVotes.SetPos(8, 40);\n   lstVotes.SetSize(208, 172);\n   lstVotes.SetSensitivity(false);\n   lstVotes.EnableAutoExpandColumns(false);\n   lstVotes.EnableAutoSort(true);\n   lstVotes.SetNumColumns(2);\n   lstVotes.SetColumnType(0, COLTYPE_Float, \"%.0f\");\n   lstVotes.SetColumnType(1, COLTYPE_String);\n   lstVotes.SetSortColumn(0, true, false);  //reverse order\n   lstVotes.SetColumnWidth(0, 28);\n   lstVotes.SetColumnWidth(1, 180);\n\n   CreateLabel(236, 7, l_cvote);\n   CurrentVote = CreateLabel(244, 20, \"\");\n   CurrentVote.SetWidth(180);\n\n   winScroll = CreateScrollAreaWindow(winClient);\n   winScroll.SetPos(236, 40);\n   winScroll.SetSize(196, 192);\n\n   lstMaps = MenuUIListWindow(winScroll.clipWindow.NewChild(Class'MenuUIListWindow'));\n   lstMaps.EnableMultiSelect(false);\n   lstMaps.EnableAutoExpandColumns(false);\n   lstMaps.EnableAutoSort(false);\n   lstMaps.SetNumColumns(2);\n   lstMaps.SetColumnType(0, COLTYPE_String);\n   lstMaps.SetColumnType(1, COLTYPE_String);\n   lstMaps.SetSortColumn(0, false, false);  //case insensitive\n   lstMaps.SetColumnWidth(0, 180);\n   lstMaps.HideColumn(1);\n\n   bTickEnabled = true;\n}\n\n\nfinal function MenuUISmallLabelWindow CreateLabel(int X, int Y, string S) {\n   local MenuUISmallLabelWindow W;\n\n   W = MenuUISmallLabelWindow(winClient.NewChild(Class'MenuUISmallLabelWindow'));\n   W.SetPos(X, Y);\n   W.SetText(S);\n   W.SetWordWrap(false);\n\n   return W;\n}\n\n\n//do not change this cleanup code\nevent DestroyWindow() {\n   bTickEnabled = false;\n   Player = DeusExPlayer(GetPlayerPawn());\n   if ((Player != None) && !Player.bDeleteMe) {\n    if (ViewPort(Player.Player) != None) {\n     Player.ClientMessage(l_help1);\n     Player.ClientMessage(l_help2);\n     Player.Clientmessage(l_help3);\n     if (Player.bAdmin)\n     Player.Clientmessage(l_help4);\n    }\n    foreach Player.allactors(class'DXL', PlayerVote)\n     if (PlayerVote.Owner == Player)\n      PlayerVote.MVM = None;\n   }\n\n   PlayerVote = None;\n   Super.DestroyWindow();\n}\n\n\n//close window when death or end game screen displays\nfunction bool CanPushScreen(class<DeusExBaseWindow> C) {\n   if (ClassIsChildOf(C, class'HUDMultiplayer') || ClassIsChildOf(C, class'MultiplayerMessageWin')) {\n    bStacking = true;\n    return true;\n   }\n   return Super.CanPushScreen(C);\n}\n\n\nfunction bool CanStack() {\n   if (bStacking) {\n    bStacking = false;\n    return false;\n   }\n   return Super.CanStack();\n}\n\n\nfunction Tick(float Delta) {\n   local int I, C;\n   if ((lstMaps == None) || (lstVotes == None) || (PlayerVote == None))\n    return;\n\n   if (bListDone) {\n    RepTime += Delta;\n    if (RepTime >= 0.1) {\n     RepTime = 0;\n     if (PlayerVote.iNextMap >= 0)\n      LeadingMap.SetText(PlayerVote.Maps[PlayerVote.iNextMap]);\n\n     lstVotes.DeleteAllRows();\n     for (I = 0; I < PlayerVote.MapCount; I++)\n      if (PlayerVote.VoteTotals[I] != 0)\n       lstVotes.AddRow(PlayerVote.VoteTotals[I] $ \";\" $ PlayerVote.Maps[I]);\n    }\n   return;\n  }\n\n  lstMaps.DeleteAllRows();\n  for (I = 0; I < PlayerVote.MapCount; I++)\n   if (PlayerVote.Maps[I] != \"\") {\n    lstMaps.AddRow(PlayerVote.Maps[I] $ \";\" $ I);\n    C++;\n   }\n\n  if (C > 0) {\n   lstMaps.Sort();\n   if (C == PlayerVote.MapCount) {\n    bListDone = true;\n    I = MapNumToRow(PlayerVote.iCurrentVote);\n    if (I != 0) {\n     lstMaps.SetFocusRow(I, true, false);\n     lstMaps.SelectRow(I);\n     CurrentVote.SetText(lstMaps.GetField(I, 0));\n    }\n   }\n  }\n}\n\n\nfinal function int MapNumToRow(int N) {\n   local int I, R;\n\n   if ((lstMaps != None) && (N >= 0))\n    for (I = 0; I < lstMaps.GetNumRows(); I++) {\n     R = lstMaps.IndexToRowId(I);\n     if (int(lstMaps.GetField(R, 1)) == N)\n      return R;\n   }\n\n   return 0;\n}\n\n\nevent bool ListRowActivated(window W, int R) {\n   if ((W == lstMaps) && bListDone) {\n    PlayerVote.ClientSetVote(int(lstMaps.GetField(R, 1)));\n    CurrentVote.SetText(lstMaps.GetField(R, 0));\n    return true;\n   }\n\n   return Super.ListRowActivated(W, R);\n}\n\n\nevent bool RawKeyPressed(EInputKey key, EInputState iState, bool bRepeat) {\n   if ((key == IK_Enter) && (iState == IST_Release)) {\n    root.PopWindow();\n    return True;\n   }\n   return Super.RawKeyPressed(key, iState, bRepeat);\n}\n\n\nfunction ProcessAction(String S) {\n   Super.ProcessAction(S);\n   if (S == \"NOVOTE\") {\n    PlayerVote.ClientSetVote(-1);\n    CurrentVote.SetText(\"\");\n   }\n   else if (S == \"TRAVEL\") {\n    if (bListDone && (lstMaps.GetSelectedRow() != 0)) {\n     Player.SwitchLevel(lstMaps.GetField(lstMaps.GetSelectedRow(), 0));  //server checks for admin\n     actionButtons[2].btn.SetSensitivity(false);\n    }\n   }\n}\n\n\ndefaultproperties\n{\n    l_help1=\"Type 'Mutate MapVote' to display the menu.\"\n    l_help2=\"Type 'Mutate VoteResult' to display the leading map.\"\n    l_help3=\"Type 'Mutate Vote' to display the vote menu when a vote is in effect.\"\n    l_help4=\"Type 'Mutate StartVote' to begin a vote to immediatly change the map.\"\n    l_cvote=\"Current Vote:\"\n    l_lmap=\"Leading Map:\"\n    RepTime=1.00\n    actionButtons(0)=(Align=2,Action=1,Text=\"\",Key=\"\",btn=None),\n    actionButtons(1)=(Align=0,Action=5,Text=\"Clear Vote\",Key=\"NOVOTE\",btn=None),\n    actionButtons(2)=(Align=0,Action=5,Text=\"ServerTravel\",Key=\"TRAVEL\",btn=None),\n    Title=\"MapVote Menu v1.1.0\"\n    ClientWidth=440\n    ClientHeight=244\n    bUsesHelpWindow=False\n}\n",
            "name": "DXMVMapVoteMenu.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "l_help1=\"Type 'Mutate MapVote' to display the menu.\"",
                    "l_help2=\"Type 'Mutate VoteResult' to display the leading map.\"",
                    "l_help3=\"Type 'Mutate Vote' to display the vote menu when a vote is in effect.\"",
                    "l_help4=\"Type 'Mutate StartVote' to begin a vote to immediatly change the map.\"",
                    "l_cvote=\"Current Vote:\"",
                    "l_lmap=\"Leading Map:\"",
                    "RepTime=1.00",
                    "actionButtons(0)=(Align=2,Action=1,Text=\"\",Key=\"\",btn=None),",
                    "actionButtons(1)=(Align=0,Action=5,Text=\"Clear Vote\",Key=\"NOVOTE\",btn=None),",
                    "actionButtons(2)=(Align=0,Action=5,Text=\"ServerTravel\",Key=\"TRAVEL\",btn=None),",
                    "Title=\"MapVote Menu v1.1.0\"",
                    "ClientWidth=440",
                    "ClientHeight=244",
                    "bUsesHelpWindow=False"
                ],
                "exec": [],
                "extends": "MenuUIScreenWindow",
                "functions": {
                    "CanPushScreen": {
                        "body": "if (ClassIsChildOf(C, class'HUDMultiplayer') || ClassIsChildOf(C, class'MultiplayerMessageWin')) {",
                        "locals": [],
                        "modifiers": [],
                        "name": "CanPushScreen",
                        "native": false,
                        "param": [
                            [
                                "class<DeusExBaseWindow>",
                                "C"
                            ]
                        ],
                        "return": "bool"
                    },
                    "CanStack": {
                        "body": "if (bStacking) {",
                        "locals": [],
                        "modifiers": [],
                        "name": "CanStack",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "CreateLabel": {
                        "body": "",
                        "locals": [
                            "local MenuUISmallLabelWindow W;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "CreateLabel",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "X"
                            ],
                            [
                                "int",
                                "Y"
                            ],
                            [
                                "string",
                                "S"
                            ]
                        ],
                        "return": "MenuUISmallLabelWindow"
                    },
                    "DestroyWindow": {
                        "body": "bTickEnabled = false;",
                        "locals": [],
                        "modifiers": [],
                        "name": "DestroyWindow",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "InitWindow": {
                        "body": "",
                        "locals": [
                            "local Window W;"
                        ],
                        "modifiers": [],
                        "name": "InitWindow",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ListRowActivated": {
                        "body": "if ((W == lstMaps) && bListDone) {",
                        "locals": [],
                        "modifiers": [],
                        "name": "ListRowActivated",
                        "native": false,
                        "param": [
                            [
                                "window",
                                "W"
                            ],
                            [
                                "int",
                                "R"
                            ]
                        ],
                        "return": "bool"
                    },
                    "MapNumToRow": {
                        "body": "",
                        "locals": [
                            "local int I, R;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "MapNumToRow",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "N"
                            ]
                        ],
                        "return": "int"
                    },
                    "ProcessAction": {
                        "body": "Super.ProcessAction(S);",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessAction",
                        "native": false,
                        "param": [
                            [
                                "String",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "RawKeyPressed": {
                        "body": "if ((key == IK_Enter) && (iState == IST_Release)) {",
                        "locals": [],
                        "modifiers": [],
                        "name": "RawKeyPressed",
                        "native": false,
                        "param": [
                            [
                                "EInputKey",
                                "key"
                            ],
                            [
                                "EInputState",
                                "iState"
                            ],
                            [
                                "bool",
                                "bRepeat"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Tick": {
                        "body": "if ((lstMaps == None) || (lstVotes == None) || (PlayerVote == None))",
                        "locals": [
                            "local int I, C;"
                        ],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Delta"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 231,
                "replication": "",
                "states": [],
                "variables": [
                    "var localized string l_help1, l_help2, l_help3, l_help4, l_cvote, l_lmap;",
                    "var MenuUIScrollAreaWindow winScroll;",
                    "var MenuUIListWindow lstMaps, lstVotes;",
                    "var MenuUISmallLabelWindow CurrentVote, LeadingMap;",
                    "var DXL PlayerVote;",
                    "var float RepTime;",
                    "var bool bListDone, bStacking;"
                ]
            }
        },
        "GunGame.uc": {
            "body": "//=============================================================================\n// yee\n//=============================================================================\nclass GunGame expands TCDeathmatch;\n\nfunction PostBeginPlay()\n{\nlocal DeusExWeapon w;\nlocal int r;\n\n    super.PostBeginPlay();\n\t\n\t\tSetTimer(5,true);\n\n\t\tfor(r=0;r<Arraycount(Settings.SaveSpawnWeapons);r++) //Weapon clearing and saving array weapons.\n\t\t{\n\t\t\tForeach AllActors(class'DeusExWeapon',w)\n\t\t\t{\t\n\t\t\t\tif(w.tag != Settings.SaveSpawnWeapons[r])\n\t\t\t\t{\n\t\t\t\t\tw.Destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n}\n\nfunction Timer()\n{\n\tlocal TCPlayer ssp;\n\tforeach AllActors(class'TCPlayer',ssp)\t\t\n\t\tif (ssp !=None)\n\t\t\tSSP.AmmoRestock();\n}\n\nfunction Killed( pawn Killer, pawn Other, name damageType )\n{\n\tlocal bool NotifyDeath;\n\tlocal DeusExPlayer otherPlayer;\n\tlocal Pawn CurPawn;\n\tlocal class<actor> checkClass;\n\tlocal int i;\n\tlocal TCPlayer TCP;\n\tlocal class<Inventory> GiveClass;\n\tlocal int Passes, r;\n\tlocal Inventory anItem, anItem2;\n   local Class<Inventory> w;\n   //both players...\n   if ((Killer.bIsPlayer) && (Other.bIsPlayer))\n   {\n\t\t\tfor(i=0;i<Arraycount(Settings.DemoteWeapons) && Settings.DemoteWeapons[i] != \"\";i++)\n\t\t\t{\n\t\t\t\tcheckClass=class<Actor>(DynamicLoadObject(Settings.DemoteWeapons[i],class'class'));\n\n\t\t\t\tif(TCPlayer(Killer).inHand.class != none && checkClass != none)\n\t\t\t\t{\n\t\t\t\t\tif(TCPlayer(Killer).inHand.class == checkClass)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(TCPRI(TCPlayer(Other).PlayerReplicationInfo).Rank > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTCPRI(TCPlayer(Other).PlayerReplicationInfo).Rank -= 1;\t\n\t\t\t\t\t\t\tBroadcastMessage(Other.PlayerReplicationInfo.PlayerName$\" was demoted!\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif (Killer != Other)\n\t\t{\n\t\t\t\t// Grant the kill to the killer, and increase his streak\n\t\t\t\tKiller.PlayerReplicationInfo.Score += 1;\n\t\t\t\tif(TCPRI(TCPlayer(Killer).PlayerReplicationInfo).Rank < 12)\n\t\t\t\t{\t\t\n\t\t\t\t\tTCPRI(TCPlayer(Killer).PlayerReplicationInfo).Rank += 1;\n\t\t\t\t\tRemovePlayerInventory(TCPlayer(Killer));\n\t\t\t\t\t//TCPlayer(Killer).GGRank();\n\t\t\t\t\tr = TCPRI(TCPlayer(Killer).PlayerReplicationInfo).Rank;\n\n\t\t\t\t\t if (r == 1)\n\t\t\t\t\t   w = class'WeaponStealthPistol';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 2)\n\t\t\t\t\t   w = class'WeaponPistol';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 3)\n\t\t\t\t\t   w = class'WeaponFlamethrower';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 4)\n\t\t\t\t\t   w = class'WeaponMiniCrossbow';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 5)\n\t\t\t\t\t   w = class'WeaponShuriken';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 6)\n\t\t\t\t\t   w = class'WeaponSawedOffShotgun';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 7)\n\t\t\t\t\t   w = class'WeaponAssaultShotgun';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 8)\n\t\t\t\t\t   w = class'WeaponAssaultgun';\n\n\t\t\t\t\t if (r == 9)\n\t\t\t\t\t   w = class'WeaponPlasmaRifle';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 10)\n\t\t\t\t\t   w = class'WeaponGepGun';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 11)\n\t\t\t\t\t   w = class'Weaponrifle';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 12)\n\t\t\t\t\t   w = class'WeaponNanoSword';\n\t\t\t\t\t   \n\t\t\t\t\tanItem = Spawn(w);\n\t\t\t\t\tanItem.Frob(TCPlayer(Killer),None);\t  \n\t\t\t\t\tInventory.bInObjectBelt = True;\n\t\t\t\t\tanItem.Destroy();\n\t\t\t\t\t\t \n\t\t\t\t\tanItem = Spawn(class'WeaponCombatKnife');\n\t\t\t\t\tanItem.Frob(TCPlayer(Killer),None);\t  \n\t\t\t\t\tInventory.bInObjectBelt = True;\n\t\t\t\t\tanItem.Destroy();\n\t\t\t\t\tTCPlayer(Killer).ClientMessage(\"|P7Ranked up to \"$TCPRI(TCPlayer(Killer).PlayerReplicationInfo).Rank$\"!\");\n\t\t\t\t}\n\t\t}\n   }\n\n      Super.Killed(Killer,Other,damageType);\n\n}\n\nfunction RemovePlayerInventory(DeusExPlayer Player)\n{\n   local Inventory item, nextItem, lastItem;\n\n   if (Player.Inventory != None)\n   {\n      item = Player.Inventory;\n      nextItem = item.Inventory;\n      lastItem = item;\n\n      do\n      {\n         if ((item != None) && item.bDisplayableInv || item.IsA('Ammo'))\n         {\n            // make sure everything is turned off\n            if (item.IsA('DeusExWeapon'))\n            {\n               DeusExWeapon(item).ScopeOff();\n               DeusExWeapon(item).LaserOff();\n            }\n            if (item.IsA('DeusExPickup'))\n            {\n               if (DeusExPickup(item).bActive)\n                  DeusExPickup(item).Activate();\n            }\n\n            if (item.IsA('ChargedPickup'))\n               Player.RemoveChargedDisplay(ChargedPickup(item));\n\n            Player.DeleteInventory(item);\n            item.Destroy();\n            item = Player.Inventory;\n         }\n         else\n            item = nextItem;\n\n         if (item != None)\n            nextItem = item.Inventory;\n      }\n      until ((item == None) || (item == lastItem));\n   }\n}\n\ndefaultproperties\n{\n\tGTName=\"Arsenal (WIP)\"\n\tVictoryConString1=\"|P1Hit the score limit! (|P3 \"\n    VictoryConString2=\" |P1) - |P2(Your weapon changes as you streak)\"\n    TimeLimitString1=\"|P1Score the most! (|P3 \"\n    TimeLimitString2=\" |P1) - |P2(Your weapon changes as you streak)\"\n}\n",
            "name": "GunGame.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "GTName=\"Arsenal (WIP)\"",
                    "VictoryConString1=\"|P1Hit the score limit! (|P3 \"",
                    "VictoryConString2=\" |P1) - |P2(Your weapon changes as you streak)\"",
                    "TimeLimitString1=\"|P1Score the most! (|P3 \"",
                    "TimeLimitString2=\" |P1) - |P2(Your weapon changes as you streak)\""
                ],
                "exec": [],
                "extends": "TCDeathmatch",
                "functions": {
                    "Killed": {
                        "body": "{\n   //both players...\n   if ((Killer.bIsPlayer) && (Other.bIsPlayer))\n   {\n\t\t\tfor(i=0;i<Arraycount(Settings.DemoteWeapons) && Settings.DemoteWeapons[i] != \"\";i++)\n\t\t\t{\n\t\t\t\tcheckClass=class<Actor>(DynamicLoadObject(Settings.DemoteWeapons[i],class'class'));\n\n\t\t\t\tif(TCPlayer(Killer).inHand.class != none && checkClass != none)\n\t\t\t\t{\n\t\t\t\t\tif(TCPlayer(Killer).inHand.class == checkClass)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(TCPRI(TCPlayer(Other).PlayerReplicationInfo).Rank > 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTCPRI(TCPlayer(Other).PlayerReplicationInfo).Rank -= 1;\t\n\t\t\t\t\t\t\tBroadcastMessage(Other.PlayerReplicationInfo.PlayerName$\" was demoted!\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tif (Killer != Other)\n\t\t{\n\t\t\t\t// Grant the kill to the killer, and increase his streak\n\t\t\t\tKiller.PlayerReplicationInfo.Score += 1;\n\t\t\t\tif(TCPRI(TCPlayer(Killer).PlayerReplicationInfo).Rank < 12)\n\t\t\t\t{\t\t\n\t\t\t\t\tTCPRI(TCPlayer(Killer).PlayerReplicationInfo).Rank += 1;\n\t\t\t\t\tRemovePlayerInventory(TCPlayer(Killer));\n\t\t\t\t\t//TCPlayer(Killer).GGRank();\n\t\t\t\t\tr = TCPRI(TCPlayer(Killer).PlayerReplicationInfo).Rank;\n\n\t\t\t\t\t if (r == 1)\n\t\t\t\t\t   w = class'WeaponStealthPistol';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 2)\n\t\t\t\t\t   w = class'WeaponPistol';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 3)\n\t\t\t\t\t   w = class'WeaponFlamethrower';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 4)\n\t\t\t\t\t   w = class'WeaponMiniCrossbow';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 5)\n\t\t\t\t\t   w = class'WeaponShuriken';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 6)\n\t\t\t\t\t   w = class'WeaponSawedOffShotgun';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 7)\n\t\t\t\t\t   w = class'WeaponAssaultShotgun';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 8)\n\t\t\t\t\t   w = class'WeaponAssaultgun';\n\n\t\t\t\t\t if (r == 9)\n\t\t\t\t\t   w = class'WeaponPlasmaRifle';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 10)\n\t\t\t\t\t   w = class'WeaponGepGun';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 11)\n\t\t\t\t\t   w = class'Weaponrifle';\n\t\t\t\t\t   \n\t\t\t\t\t if (r == 12)\n\t\t\t\t\t   w = class'WeaponNanoSword';\n\t\t\t\t\t   \n\t\t\t\t\tanItem = Spawn(w);\n\t\t\t\t\tanItem.Frob(TCPlayer(Killer),None);\t  \n\t\t\t\t\tInventory.bInObjectBelt = True;\n\t\t\t\t\tanItem.Destroy();\n\t\t\t\t\t\t \n\t\t\t\t\tanItem = Spawn(class'WeaponCombatKnife');\n\t\t\t\t\tanItem.Frob(TCPlayer(Killer),None);\t  \n\t\t\t\t\tInventory.bInObjectBelt = True;\n\t\t\t\t\tanItem.Destroy();\n\t\t\t\t\tTCPlayer(Killer).ClientMessage(\"|P7Ranked up to \"$TCPRI(TCPlayer(Killer).PlayerReplicationInfo).Rank$\"!\");\n\t\t\t\t}\n\t\t}\n   }\n\n      Super.Killed(Killer,Other,damageType);\n\n}",
                        "locals": [
                            "local bool NotifyDeath;",
                            "local DeusExPlayer otherPlayer;",
                            "local Pawn CurPawn;",
                            "local class<actor> checkClass;",
                            "local int i;",
                            "local TCPlayer TCP;",
                            "local class<Inventory> GiveClass;",
                            "local int Passes, r;",
                            "local Inventory anItem, anItem2;",
                            "local Class<Inventory> w;"
                        ],
                        "modifiers": [],
                        "name": "Killed",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\n    super.PostBeginPlay();\n\t\n\t\tSetTimer(5,true);\n\n\t\tfor(r=0;r<Arraycount(Settings.SaveSpawnWeapons);r++) //Weapon clearing and saving array weapons.\n\t\t{\n\t\t\tForeach AllActors(class'DeusExWeapon',w)\n\t\t\t{\t\n\t\t\t\tif(w.tag != Settings.SaveSpawnWeapons[r])\n\t\t\t\t{\n\t\t\t\t\tw.Destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n}",
                        "locals": [
                            "local DeusExWeapon w;",
                            "local int r;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "RemovePlayerInventory": {
                        "body": "{\n\n   if (Player.Inventory != None)\n   {\n      item = Player.Inventory;\n      nextItem = item.Inventory;\n      lastItem = item;\n\n      do\n      {\n         if ((item != None) && item.bDisplayableInv || item.IsA('Ammo'))\n         {\n            // make sure everything is turned off\n            if (item.IsA('DeusExWeapon'))\n            {\n               DeusExWeapon(item).ScopeOff();\n               DeusExWeapon(item).LaserOff();\n            }\n            if (item.IsA('DeusExPickup'))\n            {\n               if (DeusExPickup(item).bActive)\n                  DeusExPickup(item).Activate();\n            }\n\n            if (item.IsA('ChargedPickup'))\n               Player.RemoveChargedDisplay(ChargedPickup(item));\n\n            Player.DeleteInventory(item);\n            item.Destroy();\n            item = Player.Inventory;\n         }\n         else\n            item = nextItem;\n\n         if (item != None)\n            nextItem = item.Inventory;\n      }\n      until ((item == None) || (item == lastItem));\n   }\n}",
                        "locals": [
                            "local Inventory item, nextItem, lastItem;"
                        ],
                        "modifiers": [],
                        "name": "RemovePlayerInventory",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "Player"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tforeach AllActors(class'TCPlayer',ssp)\t\t\n\t\tif (ssp !=None)\n\t\t\tSSP.AmmoRestock();\n}",
                        "locals": [
                            "local TCPlayer ssp;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 184,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "Infection.uc": {
            "body": "//=============================================================================\n// yee\n//=============================================================================\nclass Infection expands TCDeathmatch;\n\nvar TCPlayer MainCarrier; //Just a track of who the original infected is.\n\nvar int PIK; //Pre-Infected Kills\nvar int IK; \n\nfunction PostBeginPlay()\n{\nlocal DeusExWeapon w;\nlocal int r;\nlocal Infectiontimer SST;\n\n    super.PostBeginPlay();\n\t\n\tSST = Spawn(class'Infectiontimer');\n\tSST.SetTimer(1,true);\n\t\n\tSST.myGame = Self;\n}\n\n//Add MC kills level up everyones infection perk\n//Anyone with infection heals 5 * level\nfunction Killed( pawn Killer, pawn Other, name damageType )\n{\n\tlocal TCPlayer KillerTC, VictimTC;\n\tlocal PerkInfection PI;\n\tKillerTC = TCPlayer(Killer);\n\tVictimTC = TCPlayer(Other);\n\tSuper.Killed(Killer,Other,damageType);\n\t\n\tif(KillerTC != None && VictimTC != None)\n\t{\n\t\tif(MainCarrier == None) \n\t\t{\n\t\t\tPIK++;\n\t\t\tif(FRand() < (0.1 * PIK)) //50% chance of every death of the beginning match triggering the infection\n\t\t\t{\n\t\t\t\tSettings.Print(\"|P2The infection begins spreading...\");\n\t\t\t\tMainCarrier = VictimTC;\n\t\t\t\tVictimTC.GetPerk(\"OpenDX.PerkInfection\");\n\t\t\t\tTCPRI(VictimTC.PlayerReplicationInfo).bInfected = True;\n\t\t\t\tVictoryConString2=\" |P1) - |P2(Death brings the infection.. be the last human standing!)\";\n\t\t\t\tTimeLimitString2=\" |P1) - |P2(Death brings the infection.. be the last human standing!)\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(TCPRI(KillerTC.PlayerReplicationInfo).bInfected && !TCPRI(VictimTC.PlayerReplicationInfo).bInfected)\n\t\t{\n\t\t\tif(KillerTC == MainCarrier)\n\t\t\t{\n\t\t\t\tIK += 1;\n\t\t\t\tif(GetOdds(True))\n\t\t\t\t{\n\t\t\t\t\tTCPRI(VictimTC.PlayerReplicationInfo).bInfected = True;\n\t\t\t\t\tVictimTC.GetPerk(\"OpenDX.PerkInfection\");\n\t\t\t\t\tSettings.Print(\"|P2\"$VictimTC.PlayerReplicationInfo.PlayerName$\" was infected.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(GetOdds(False))\n\t\t\t\t{\n\t\t\t\t\tKillerTC.HealPlayer(IK, False);\n\t\t\t\t\tTCPRI(VictimTC.PlayerReplicationInfo).bInfected = True;\n\t\t\t\t\tVictimTC.GetPerk(\"OpenDX.PerkInfection\");\n\t\t\t\t\tSettings.Print(\"|P2\"$VictimTC.PlayerReplicationInfo.PlayerName$\" was infected.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction bool GetOdds(bool bMain)\n{\n\tlocal float baseOdds;\n\tlocal TCPRI infecteds;\n\t\n\tbaseOdds = 0.5;\n\t\n\tforeach AllActors(class'TCPRI', infecteds)\n\t\tbaseOdds += 0.1;\n\t\t\n\tif(bMain)\n\t\tbaseOdds += 0.2;\n\t\n\tif(FRand() < baseOdds)\n\t\treturn True;\n\telse\n\t\treturn False;\n}\n\nfunction bool bAllInfected()\n{\n\tlocal TCPRI infecteds;\n\n\tforeach AllActors(class'TCPRI', infecteds)\n\t\tif(!infecteds.bInfected)\n\t\t\treturn False;\n\t\t\n\treturn True;\n}\n\ndefaultproperties\n{\n\tGTName=\"Infection\"\n\tVictoryConString1=\"|P1Hit the score limit! (|P3 \"\n    VictoryConString2=\" |P1) - |P2(Beware of the infection...)\"\n    TimeLimitString1=\"|P1Score the most! (|P3 \"\n    TimeLimitString2=\" |P1) - |P2(Beware of the infection...)\"\n\t\t//bDisableDefaultScoring=True\n}\n",
            "name": "Infection.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "GTName=\"Infection\"",
                    "VictoryConString1=\"|P1Hit the score limit! (|P3 \"",
                    "VictoryConString2=\" |P1) - |P2(Beware of the infection...)\"",
                    "TimeLimitString1=\"|P1Score the most! (|P3 \"",
                    "TimeLimitString2=\" |P1) - |P2(Beware of the infection...)\"",
                    "//bDisableDefaultScoring=True"
                ],
                "exec": [],
                "extends": "TCDeathmatch",
                "functions": {
                    "GetOdds": {
                        "body": "{\n\t\n\tbaseOdds = 0.5;\n\t\n\tforeach AllActors(class'TCPRI', infecteds)\n\t\tbaseOdds += 0.1;\n\t\t\n\tif(bMain)\n\t\tbaseOdds += 0.2;\n\t\n\tif(FRand() < baseOdds)\n\t\treturn True;\n\telse\n\t\treturn False;\n}",
                        "locals": [
                            "local float baseOdds;",
                            "local TCPRI infecteds;"
                        ],
                        "modifiers": [],
                        "name": "GetOdds",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "bMain"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Killed": {
                        "body": "{\n\tKillerTC = TCPlayer(Killer);\n\tVictimTC = TCPlayer(Other);\n\tSuper.Killed(Killer,Other,damageType);\n\t\n\tif(KillerTC != None && VictimTC != None)\n\t{\n\t\tif(MainCarrier == None) \n\t\t{\n\t\t\tPIK++;\n\t\t\tif(FRand() < (0.1 * PIK)) //50% chance of every death of the beginning match triggering the infection\n\t\t\t{\n\t\t\t\tSettings.Print(\"|P2The infection begins spreading...\");\n\t\t\t\tMainCarrier = VictimTC;\n\t\t\t\tVictimTC.GetPerk(\"OpenDX.PerkInfection\");\n\t\t\t\tTCPRI(VictimTC.PlayerReplicationInfo).bInfected = True;\n\t\t\t\tVictoryConString2=\" |P1) - |P2(Death brings the infection.. be the last human standing!)\";\n\t\t\t\tTimeLimitString2=\" |P1) - |P2(Death brings the infection.. be the last human standing!)\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(TCPRI(KillerTC.PlayerReplicationInfo).bInfected && !TCPRI(VictimTC.PlayerReplicationInfo).bInfected)\n\t\t{\n\t\t\tif(KillerTC == MainCarrier)\n\t\t\t{\n\t\t\t\tIK += 1;\n\t\t\t\tif(GetOdds(True))\n\t\t\t\t{\n\t\t\t\t\tTCPRI(VictimTC.PlayerReplicationInfo).bInfected = True;\n\t\t\t\t\tVictimTC.GetPerk(\"OpenDX.PerkInfection\");\n\t\t\t\t\tSettings.Print(\"|P2\"$VictimTC.PlayerReplicationInfo.PlayerName$\" was infected.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(GetOdds(False))\n\t\t\t\t{\n\t\t\t\t\tKillerTC.HealPlayer(IK, False);\n\t\t\t\t\tTCPRI(VictimTC.PlayerReplicationInfo).bInfected = True;\n\t\t\t\t\tVictimTC.GetPerk(\"OpenDX.PerkInfection\");\n\t\t\t\t\tSettings.Print(\"|P2\"$VictimTC.PlayerReplicationInfo.PlayerName$\" was infected.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local TCPlayer KillerTC, VictimTC;",
                            "local PerkInfection PI;"
                        ],
                        "modifiers": [],
                        "name": "Killed",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\n    super.PostBeginPlay();\n\t\n\tSST = Spawn(class'Infectiontimer');\n\tSST.SetTimer(1,true);\n\t\n\tSST.myGame = Self;\n}",
                        "locals": [
                            "local DeusExWeapon w;",
                            "local int r;",
                            "local Infectiontimer SST;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "bAllInfected": {
                        "body": "{\n\n\tforeach AllActors(class'TCPRI', infecteds)\n\t\tif(!infecteds.bInfected)\n\t\t\treturn False;\n\t\t\n\treturn True;\n}",
                        "locals": [
                            "local TCPRI infecteds;"
                        ],
                        "modifiers": [],
                        "name": "bAllInfected",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 117,
                "replication": "",
                "states": [],
                "variables": [
                    "var TCPlayer MainCarrier; //Just a track of who the original infected is.",
                    "var int PIK; //Pre-Infected Kills",
                    "var int IK;"
                ]
            }
        },
        "InfectionTimer.uc": {
            "body": "//================================================================================\n// External time-keeper for Sharpshooter\n//================================================================================\nclass InfectionTimer extends Actor;\n\nvar Infection myGame;\n\nfunction bool bAllInfected()\n{\n\tlocal TCPRI infecteds;\n\n\tforeach AllActors(class'TCPRI', infecteds)\n\t\tif(!infecteds.bInfected)\n\t\t\treturn False;\n\t\n\treturn True;\n}\n\nfunction Timer()\n{\n\tlocal TCPRI infecteds;\n\tlocal int c;\n\t\n\tforeach AllActors(class'TCPRI', infecteds)\n\t\tc++;\n\t\n\tif(c != 0)\n\t{\n\t\t//NEW: If all players are infected, the infected \"team\" wins, naming the main carrier\n\t\tif(bAllInfected())\n\t\t{\n\t\t\tmyGame.PreGameOver();\n\t\t\tmyGame.PlayerHasWon( myGame.MainCarrier, myGame.MainCarrier, None, \"Infection\" );\n\t\t\tmyGame.GameOver();\n\t\t}\n\t}\n}\n\ndefaultproperties\n{\n    bHidden=true\n}\n",
            "name": "InfectionTimer.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=true"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "Timer": {
                        "body": "{\n\t\n\tforeach AllActors(class'TCPRI', infecteds)\n\t\tc++;\n\t\n\tif(c != 0)\n\t{\n\t\t//NEW: If all players are infected, the infected \"team\" wins, naming the main carrier\n\t\tif(bAllInfected())\n\t\t{\n\t\t\tmyGame.PreGameOver();\n\t\t\tmyGame.PlayerHasWon( myGame.MainCarrier, myGame.MainCarrier, None, \"Infection\" );\n\t\t\tmyGame.GameOver();\n\t\t}\n\t}\n}",
                        "locals": [
                            "local TCPRI infecteds;",
                            "local int c;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "bAllInfected": {
                        "body": "{\n\n\tforeach AllActors(class'TCPRI', infecteds)\n\t\tif(!infecteds.bInfected)\n\t\t\treturn False;\n\t\n\treturn True;\n}",
                        "locals": [
                            "local TCPRI infecteds;"
                        ],
                        "modifiers": [],
                        "name": "bAllInfected",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 43,
                "replication": "",
                "states": [],
                "variables": [
                    "var Infection myGame;"
                ]
            }
        },
        "Juggernaut.uc": {
            "body": "//=============================================================================\n// yee\n//=============================================================================\nclass Juggernaut expands TCTeam;\n\nvar TCPlayer Juggernaut;\nvar bool bShouldRun;\n\nfunction Tick(float Deltatime)\n{\n\tif(bShouldRun && Juggernaut == None)\n\t{\n\t\tSettings.Print(\"Juggernaut was missing.. resetting teams.\");\n\t\tbShouldRun=False;\n\t\tResetTeams();\n\t}\n}\n\nfunction Killed( pawn Killer, pawn Other, name damageType )\n{\n\tlocal TCPlayer KillerTC, VictimTC;\n\t\n\tKillerTC = TCPlayer(Killer);\n\tVictimTC = TCPlayer(Other);\n\tSuper.Killed(Killer,Other,damageType);\n\t\n\tif(VictimTC == Juggernaut && Juggernaut != None) //Did the juggernaut just die\n\t{\n\t\tSettings.Print(\"|P2The juggernaut has died!\");\n\t\tJuggernaut = None;\n\t\tbShouldRun = False;\n\t\tVictimTC.RemovePerkbyName(\"Juggernaut\");\n\t\tTCPRI(VictimTC.PlayerReplicationInfo).bJuggernaut = False;\n\t\tResetTeams();\n\t}\n\t\n\tif(Juggernaut == None)\n\t{\n\t\tif(KillerTC != None && KillerTC.PlayerReplicationInfo.Streak >= Settings.StreakLimit)\n\t\t{\n\t\t\tbShouldRun = True;\n\t\t\tJuggernaut = KillerTC;\n\t\t\tTCPRI(KillerTC.PlayerReplicationInfo).bJuggernaut = True;\n\t\t\tSettings.Print(\"|P2\"$KillerTC.PlayerReplicationInfo.PlayerName$\" became the juggernaut!\");\n\t\t\tJuggernautTeams();\n\t\t\tKillerTC.GetPerk(\"OpenDX.Juggernaut\");\n\t\t}\n\t}\n}\n\nfunction JuggernautTeams()\n{\n\tlocal TCPlayer TCP;\n\tlocal int jteam;\n\t\n\tjteam = Juggernaut.PlayerReplicationInfo.Team;\n\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t{\n\t\tif(!TCPRI(TCP.PlayerReplicationInfo).bJuggernaut)\n\t\t{\n\t\t\tTCPRI(TCP.PlayerReplicationInfo).tOldTeam = TCP.PlayerReplicationInfo.Team;\n\t\t\t\n\t\t\tif(jteam == 0)\n\t\t\t\ttSwapPlayer(TCP, 1, True, True);\n\t\t\telse\n\t\t\t\ttSwapPlayer(TCP, 0, True, True);\n\t\t}\n\t}\n}\n\nfunction ResetTeams()\n{\n\tlocal TCPlayer TCP;\n\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t{\n\t\ttSwapPlayer(TCP, TCPRI(TCP.PlayerReplicationInfo).tOldTeam, True, True);\n\t}\n}\n\ndefaultproperties\n{\n\tGTName=\"Juggernaut Team\"\n\tVictoryConString1=\"|P1Hit the score limit! (|P3 \"\n    VictoryConString2=\" |P1) - |P2(Get a high streak to become the juggernaut!)\"\n    TimeLimitString1=\"|P1Score the most! (|P3 \"\n    TimeLimitString2=\" |P1) - |P2(Get a high streak to become the juggernaut!)\"\n\t\t//bDisableDefaultScoring=True\n}\n",
            "name": "Juggernaut.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "GTName=\"Juggernaut Team\"",
                    "VictoryConString1=\"|P1Hit the score limit! (|P3 \"",
                    "VictoryConString2=\" |P1) - |P2(Get a high streak to become the juggernaut!)\"",
                    "TimeLimitString1=\"|P1Score the most! (|P3 \"",
                    "TimeLimitString2=\" |P1) - |P2(Get a high streak to become the juggernaut!)\"",
                    "//bDisableDefaultScoring=True"
                ],
                "exec": [],
                "extends": "TCTeam",
                "functions": {
                    "JuggernautTeams": {
                        "body": "{\n\t\n\tjteam = Juggernaut.PlayerReplicationInfo.Team;\n\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t{\n\t\tif(!TCPRI(TCP.PlayerReplicationInfo).bJuggernaut)\n\t\t{\n\t\t\tTCPRI(TCP.PlayerReplicationInfo).tOldTeam = TCP.PlayerReplicationInfo.Team;\n\t\t\t\n\t\t\tif(jteam == 0)\n\t\t\t\ttSwapPlayer(TCP, 1, True, True);\n\t\t\telse\n\t\t\t\ttSwapPlayer(TCP, 0, True, True);\n\t\t}\n\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;",
                            "local int jteam;"
                        ],
                        "modifiers": [],
                        "name": "JuggernautTeams",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Killed": {
                        "body": "{\n\t\n\tKillerTC = TCPlayer(Killer);\n\tVictimTC = TCPlayer(Other);\n\tSuper.Killed(Killer,Other,damageType);\n\t\n\tif(VictimTC == Juggernaut && Juggernaut != None) //Did the juggernaut just die\n\t{\n\t\tSettings.Print(\"|P2The juggernaut has died!\");\n\t\tJuggernaut = None;\n\t\tbShouldRun = False;\n\t\tVictimTC.RemovePerkbyName(\"Juggernaut\");\n\t\tTCPRI(VictimTC.PlayerReplicationInfo).bJuggernaut = False;\n\t\tResetTeams();\n\t}\n\t\n\tif(Juggernaut == None)\n\t{\n\t\tif(KillerTC != None && KillerTC.PlayerReplicationInfo.Streak >= Settings.StreakLimit)\n\t\t{\n\t\t\tbShouldRun = True;\n\t\t\tJuggernaut = KillerTC;\n\t\t\tTCPRI(KillerTC.PlayerReplicationInfo).bJuggernaut = True;\n\t\t\tSettings.Print(\"|P2\"$KillerTC.PlayerReplicationInfo.PlayerName$\" became the juggernaut!\");\n\t\t\tJuggernautTeams();\n\t\t\tKillerTC.GetPerk(\"OpenDX.Juggernaut\");\n\t\t}\n\t}\n}",
                        "locals": [
                            "local TCPlayer KillerTC, VictimTC;"
                        ],
                        "modifiers": [],
                        "name": "Killed",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": ""
                    },
                    "ResetTeams": {
                        "body": "{\n\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t{\n\t\ttSwapPlayer(TCP, TCPRI(TCP.PlayerReplicationInfo).tOldTeam, True, True);\n\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [],
                        "name": "ResetTeams",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n\tif(bShouldRun && Juggernaut == None)\n\t{\n\t\tSettings.Print(\"Juggernaut was missing.. resetting teams.\");\n\t\tbShouldRun=False;\n\t\tResetTeams();\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Deltatime"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 91,
                "replication": "",
                "states": [],
                "variables": [
                    "var TCPlayer Juggernaut;",
                    "var bool bShouldRun;"
                ]
            }
        },
        "JuggernautDM.uc": {
            "body": "//=============================================================================\n// yee\n//=============================================================================\nclass JuggernautDM expands TCDeathmatch;\n\nvar TCPlayer Juggernaut;\n\n\nfunction Killed( pawn Killer, pawn Other, name damageType )\n{\n\tlocal TCPlayer KillerTC, VictimTC;\n\t\n\tKillerTC = TCPlayer(Killer);\n\tVictimTC = TCPlayer(Other);\n\tSuper.Killed(Killer,Other,damageType);\n\t\n\tif(VictimTC == Juggernaut && Juggernaut != None) //Did the juggernaut just die\n\t{\n\t\tSettings.Print(\"|P2The juggernaut has died!\");\n\t\tJuggernaut = None;\n\t\tVictimTC.RemovePerkbyName(\"Juggernaut\");\n\t\tTCPRI(VictimTC.PlayerReplicationInfo).bJuggernaut = False;\n\t}\n\t\n\tif(Juggernaut == None)\n\t{\n\t\tif(KillerTC != None && KillerTC.PlayerReplicationInfo.Streak >= Settings.StreakLimit)\n\t\t{\n\t\t\tJuggernaut = KillerTC;\n\t\t\tTCPRI(KillerTC.PlayerReplicationInfo).bJuggernaut = True;\n\t\t\tKillerTC.GetPerk(\"OpenDX.Juggernaut\");\n\t\t\tSettings.Print(\"|P2\"$KillerTC.PlayerReplicationInfo.PlayerName$\" became the juggernaut!\");\n\t\t}\n\t}\n}\n\ndefaultproperties\n{\n\tGTName=\"Juggernaut DM\"\n\tVictoryConString1=\"|P1Hit the score limit! (|P3 \"\n    VictoryConString2=\" |P1) - |P2(Get a high streak to become the juggernaut!)\"\n    TimeLimitString1=\"|P1Score the most! (|P3 \"\n    TimeLimitString2=\" |P1) - |P2(Get a high streak to become the juggernaut!)\"\n\t\t//bDisableDefaultScoring=True\n}\n",
            "name": "JuggernautDM.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "GTName=\"Juggernaut DM\"",
                    "VictoryConString1=\"|P1Hit the score limit! (|P3 \"",
                    "VictoryConString2=\" |P1) - |P2(Get a high streak to become the juggernaut!)\"",
                    "TimeLimitString1=\"|P1Score the most! (|P3 \"",
                    "TimeLimitString2=\" |P1) - |P2(Get a high streak to become the juggernaut!)\"",
                    "//bDisableDefaultScoring=True"
                ],
                "exec": [],
                "extends": "TCDeathmatch",
                "functions": {
                    "Killed": {
                        "body": "{\n\t\n\tKillerTC = TCPlayer(Killer);\n\tVictimTC = TCPlayer(Other);\n\tSuper.Killed(Killer,Other,damageType);\n\t\n\tif(VictimTC == Juggernaut && Juggernaut != None) //Did the juggernaut just die\n\t{\n\t\tSettings.Print(\"|P2The juggernaut has died!\");\n\t\tJuggernaut = None;\n\t\tVictimTC.RemovePerkbyName(\"Juggernaut\");\n\t\tTCPRI(VictimTC.PlayerReplicationInfo).bJuggernaut = False;\n\t}\n\t\n\tif(Juggernaut == None)\n\t{\n\t\tif(KillerTC != None && KillerTC.PlayerReplicationInfo.Streak >= Settings.StreakLimit)\n\t\t{\n\t\t\tJuggernaut = KillerTC;\n\t\t\tTCPRI(KillerTC.PlayerReplicationInfo).bJuggernaut = True;\n\t\t\tKillerTC.GetPerk(\"OpenDX.Juggernaut\");\n\t\t\tSettings.Print(\"|P2\"$KillerTC.PlayerReplicationInfo.PlayerName$\" became the juggernaut!\");\n\t\t}\n\t}\n}",
                        "locals": [
                            "local TCPlayer KillerTC, VictimTC;"
                        ],
                        "modifiers": [],
                        "name": "Killed",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 46,
                "replication": "",
                "states": [],
                "variables": [
                    "var TCPlayer Juggernaut;"
                ]
            }
        },
        "KCObj.uc": {
            "body": "class KCObj extends DeusExDecoration;\n\n/* KC RULES *\n * If the activating player is the killer, +1 score to activator\n * If the activating player is the victim, +1 score to activator\n * If the activating player is anyone else, +2 score to activator\n */\n\nvar float ScoreMultiplier; //no planned use yet, but future proofing any modifications.\nvar TCPlayer KillerPlayer, KilledPlayer;\nvar int tLifespan;\n\n//delay its activation so it doesnt trigger on death\nfunction Timer()\n{\t\n\ttLifespan--;\n\tif(tLifespan <= 0)\n\t{\n\t\tBroadcastMessage(\"|P2\"$GetName(KillerPlayer)$\"'s kill against \"$GetName(KilledPlayer)$\" failed.\");\n\t\tDestroy();\n\t}\n\tRadialCollect();\n}\n\nfunction Tick(float Deltatime)\n{\n\tRadialCollect();\n}\n\n// Upon activation, the nearest player will collect the skull.\nfunction RadialCollect()\n{\n\tlocal TCPlayer P, winP;\n\tlocal vector dist;\n\tlocal float lowestDist;\n\n\tlowestDist = 1024;\n\n\tforeach VisibleActors(class'TCPlayer', P, 50)\n\t{\n\t\tif(P != None && !P.IsInState('Dying') && P.Health > 0)\n\t\t{\n\t\t\tif(vSize(P.Location - Location) < lowestDist)\n\t\t\t{\n\t\t\t\twinP = P;\n\t\t\t\tlowestDist = vSize(P.Location - Location);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(winP != None)\n\t\tkcTriggered(winp);\n}\n\nfunction kcTriggered(TCPlayer myActivator)\n{\n\tlocal int modScore;\n\t\n\tmodScore = 1;\n\t\n\tif(myActivator == KillerPlayer)\n\t{\n\t\tmodScore *= ScoreMultiplier;\n\t\t\n\t\tmyActivator.ClientMessage(\"|C8B6914 Confirmed your kill against \"$GetName(KilledPlayer)$\"! |P2+\"$modScore$\" |C8B6914score\");\n\t\tKilledPlayer.ClientMessage(\"|C8B6914 Your death to \"$GetName(KillerPlayer)$\" was confirmed!\");\n\t}\n\telse if(myActivator == KilledPlayer)\n\t{\n\t\tmodScore *= ScoreMultiplier;\n\t\t\n\t\tmyActivator.ClientMessage(\"|C8B6914 Denied your kill by \"$GetName(KillerPlayer)$\"! |P2+\"$modScore$\" |C8B6914score\");\n\t\tKillerPlayer.ClientMessage(\"|C8B6914 Your kill against \"$GetName(KilledPlayer)$\" was denied!\");\n\t}\t\n\telse\n\t{\n\t\tmodScore += 1;\n\t\tmodScore *= ScoreMultiplier;\n\t\tmyActivator.ClientMessage(\"|C8B6914 Denied \"$GetName(KillerPlayer)$\"'s kill! |P2+\"$modScore$\" |C8B6914score\");\n\t\tKilledPlayer.ClientMessage(\"|C8B6914 Your death to \"$GetName(KillerPlayer)$\" was denied by \"$GetName(myActivator)$\"!\");\n\t\tKillerPlayer.ClientMessage(\"|C8B6914 Your kill against \"$GetName(KilledPlayer)$\" was denied by \"$GetName(myActivator)$\"!\");\n\t}\n\t\n\tTarget.PlaySound(Sound'DeusExSounds.UserInterface.LogGoalCompleted',,,, 256);\n\tmyActivator.PlayerReplicationInfo.Score += modScore;\n\tDestroy();\n}\n\nfunction Bump(actor Other)\n{\n\tif(TCPlayer(Other) != None && !TCPlayer(Other).IsInState('Dying') && TCPlayer(Other).Health > 0)\n\t\tkcTriggered(TCPlayer(Other));\n}\n\nfunction Frob(actor Frobber, inventory FrobWith)\n{\n\tkcTriggered(TCPlayer(Frobber));\n}\n\nfunction string GetName(TCPlayer p)\n{\n\treturn p.PlayerReplicationInfo.PlayerName;\n}\n\ndefaultproperties\n{\n\tScoreMultiplier=1\n\tbStatic=False\n\tPhysics=PHYS_Rotating\n\tTexture=Texture'DeusExDeco.Skins.DXLogoTex1'\n\tbMeshEnviroMap=True\n\tItemName=\"Skull\"\n    Mesh=LodMesh'DeusExDeco.BoneSkull'\n    CollisionRadius=5.800000\n    CollisionHeight=4.750000\n\tbFixedRotationDir=True\n\tbBlockPlayers=False\n    bInvincible=True\n    bPushable=False\n\tMass=50.000000\n\tBuoyancy=500.000000\n\tRotationRate=(Yaw=8192)\n}\n",
            "name": "KCObj.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "ScoreMultiplier=1",
                    "bStatic=False",
                    "Physics=PHYS_Rotating",
                    "Texture=Texture'DeusExDeco.Skins.DXLogoTex1'",
                    "bMeshEnviroMap=True",
                    "ItemName=\"Skull\"",
                    "Mesh=LodMesh'DeusExDeco.BoneSkull'",
                    "CollisionRadius=5.800000",
                    "CollisionHeight=4.750000",
                    "bFixedRotationDir=True",
                    "bBlockPlayers=False",
                    "bInvincible=True",
                    "bPushable=False",
                    "Mass=50.000000",
                    "Buoyancy=500.000000",
                    "RotationRate=(Yaw=8192)"
                ],
                "exec": [],
                "extends": "DeusExDecoration",
                "functions": {
                    "Bump": {
                        "body": "{\n\tif(TCPlayer(Other) != None && !TCPlayer(Other).IsInState('Dying') && TCPlayer(Other).Health > 0)\n\t\tkcTriggered(TCPlayer(Other));\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Bump",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "Frob": {
                        "body": "{\n\tkcTriggered(TCPlayer(Frobber));\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Frob",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Frobber"
                            ],
                            [
                                "inventory",
                                "FrobWith"
                            ]
                        ],
                        "return": ""
                    },
                    "GetName": {
                        "body": "{\n\treturn p.PlayerReplicationInfo.PlayerName;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetName",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "p"
                            ]
                        ],
                        "return": "string"
                    },
                    "RadialCollect": {
                        "body": "{\n\n\tlowestDist = 1024;\n\n\tforeach VisibleActors(class'TCPlayer', P, 50)\n\t{\n\t\tif(P != None && !P.IsInState('Dying') && P.Health > 0)\n\t\t{\n\t\t\tif(vSize(P.Location - Location) < lowestDist)\n\t\t\t{\n\t\t\t\twinP = P;\n\t\t\t\tlowestDist = vSize(P.Location - Location);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(winP != None)\n\t\tkcTriggered(winp);\n}",
                        "locals": [
                            "local TCPlayer P, winP;",
                            "local vector dist;",
                            "local float lowestDist;"
                        ],
                        "modifiers": [],
                        "name": "RadialCollect",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n\tRadialCollect();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Deltatime"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\t\n\ttLifespan--;\n\tif(tLifespan <= 0)\n\t{\n\t\tBroadcastMessage(\"|P2\"$GetName(KillerPlayer)$\"'s kill against \"$GetName(KilledPlayer)$\" failed.\");\n\t\tDestroy();\n\t}\n\tRadialCollect();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "kcTriggered": {
                        "body": "{\n\t\n\tmodScore = 1;\n\t\n\tif(myActivator == KillerPlayer)\n\t{\n\t\tmodScore *= ScoreMultiplier;\n\t\t\n\t\tmyActivator.ClientMessage(\"|C8B6914 Confirmed your kill against \"$GetName(KilledPlayer)$\"! |P2+\"$modScore$\" |C8B6914score\");\n\t\tKilledPlayer.ClientMessage(\"|C8B6914 Your death to \"$GetName(KillerPlayer)$\" was confirmed!\");\n\t}\n\telse if(myActivator == KilledPlayer)\n\t{\n\t\tmodScore *= ScoreMultiplier;\n\t\t\n\t\tmyActivator.ClientMessage(\"|C8B6914 Denied your kill by \"$GetName(KillerPlayer)$\"! |P2+\"$modScore$\" |C8B6914score\");\n\t\tKillerPlayer.ClientMessage(\"|C8B6914 Your kill against \"$GetName(KilledPlayer)$\" was denied!\");\n\t}\t\n\telse\n\t{\n\t\tmodScore += 1;\n\t\tmodScore *= ScoreMultiplier;\n\t\tmyActivator.ClientMessage(\"|C8B6914 Denied \"$GetName(KillerPlayer)$\"'s kill! |P2+\"$modScore$\" |C8B6914score\");\n\t\tKilledPlayer.ClientMessage(\"|C8B6914 Your death to \"$GetName(KillerPlayer)$\" was denied by \"$GetName(myActivator)$\"!\");\n\t\tKillerPlayer.ClientMessage(\"|C8B6914 Your kill against \"$GetName(KilledPlayer)$\" was denied by \"$GetName(myActivator)$\"!\");\n\t}\n\t\n\tTarget.PlaySound(Sound'DeusExSounds.UserInterface.LogGoalCompleted',,,, 256);\n\tmyActivator.PlayerReplicationInfo.Score += modScore;\n\tDestroy();\n}",
                        "locals": [
                            "local int modScore;"
                        ],
                        "modifiers": [],
                        "name": "kcTriggered",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "myActivator"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 124,
                "replication": "",
                "states": [],
                "variables": [
                    "var float ScoreMultiplier; //no planned use yet, but future proofing any modifications.",
                    "var TCPlayer KillerPlayer, KilledPlayer;",
                    "var int tLifespan;"
                ]
            }
        },
        "KillConfirmed.uc": {
            "body": "//=============================================================================\n// yee\n//=============================================================================\nclass KillConfirmed expands TCDeathmatch;\n\nfunction Killed( pawn Killer, pawn Other, name damageType )\n{\n\tlocal KCObj KC;\n\tlocal TCPlayer KillerTC, VictimTC;\n\t\n\tKillerTC = TCPlayer(Killer);\n\tVictimTC = TCPlayer(Other);\n\tSuper.Killed(Killer,Other,damageType);\n\t\n\tif((KillerTC != VictimTC) && (KillerTC != None && VictimTC != None)) //Making sure it isn't suicide and both players do actually exist.\n\t{\n\t\tKillerTC.PlayerReplicationInfo.Streak += 1;\n\t\tKC = Spawn(class'KCObj', VictimTC,, VictimTC.Location);\n\t\tKC.KilledPlayer = VictimTC;\n\t\tKC.KillerPlayer = KillerTC;\n\t\tKC.SetTimer(0.5,True);\n\t\tKC.tLifespan = Settings.KCLifespan;\n\t\tKC.scoreMultiplier = Settings.BaseScoreMultiplier;\n\t}\n}\n\ndefaultproperties\n{\n\tVictoryConString1=\"|P1Hit the score limit! (|P3 \"\n    VictoryConString2=\" |P1) -|P2 (Grab the skulls of your victims to score!)\"\n    TimeLimitString1=\"|P1Score the most! (|P3 \"\n    TimeLimitString2=\" |P1) -|P2 (Grab the skulls of your victims to score!)\"\n\tGTName=\"Kill Confirmed\"\n\tbDisableDefaultScoring=True\n}\n",
            "name": "KillConfirmed.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "VictoryConString1=\"|P1Hit the score limit! (|P3 \"",
                    "VictoryConString2=\" |P1) -|P2 (Grab the skulls of your victims to score!)\"",
                    "TimeLimitString1=\"|P1Score the most! (|P3 \"",
                    "TimeLimitString2=\" |P1) -|P2 (Grab the skulls of your victims to score!)\"",
                    "GTName=\"Kill Confirmed\"",
                    "bDisableDefaultScoring=True"
                ],
                "exec": [],
                "extends": "TCDeathmatch",
                "functions": {
                    "Killed": {
                        "body": "{\n\t\n\tKillerTC = TCPlayer(Killer);\n\tVictimTC = TCPlayer(Other);\n\tSuper.Killed(Killer,Other,damageType);\n\t\n\tif((KillerTC != VictimTC) && (KillerTC != None && VictimTC != None)) //Making sure it isn't suicide and both players do actually exist.\n\t{\n\t\tKillerTC.PlayerReplicationInfo.Streak += 1;\n\t\tKC = Spawn(class'KCObj', VictimTC,, VictimTC.Location);\n\t\tKC.KilledPlayer = VictimTC;\n\t\tKC.KillerPlayer = KillerTC;\n\t\tKC.SetTimer(0.5,True);\n\t\tKC.tLifespan = Settings.KCLifespan;\n\t\tKC.scoreMultiplier = Settings.BaseScoreMultiplier;\n\t}\n}",
                        "locals": [
                            "local KCObj KC;",
                            "local TCPlayer KillerTC, VictimTC;"
                        ],
                        "modifiers": [],
                        "name": "Killed",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 36,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "KillConfirmedTeam.uc": {
            "body": "//=============================================================================\n// yee\n//=============================================================================\nclass KillConfirmedTeam expands TCTeam;\n\nfunction Killed( pawn Killer, pawn Other, name damageType )\n{\n\tlocal KCObj KC;\n\tlocal TCPlayer KillerTC, VictimTC;\n\t\n\tKillerTC = TCPlayer(Killer);\n\tVictimTC = TCPlayer(Other);\n\tSuper.Killed(Killer,Other,damageType);\n\t\n\tif((KillerTC != VictimTC) && (KillerTC != None && VictimTC != None)) //Making sure it isn't suicide and both players do actually exist.\n\t{\n\t\tKillerTC.PlayerReplicationInfo.Streak += 1;\n\t\tKC = Spawn(class'KCObj', VictimTC,, VictimTC.Location);\n\t\tKC.KilledPlayer = VictimTC;\n\t\tKC.KillerPlayer = KillerTC;\n\t\tKC.SetTimer(0.5,True);\n\t\tKC.tLifespan = Settings.KCLifespan;\n\t\tKC.scoreMultiplier = Settings.BaseScoreMultiplier;\n\t}\n}\n\ndefaultproperties\n{\n\tVictoryConString1=\"|P1Hit the score limit! (|P3 \"\n    VictoryConString2=\" |P1) - |P2(Grab the skulls of your victims to score!)\"\n    TimeLimitString1=\"|P1Score the most! (|P3 \"\n    TimeLimitString2=\" |P1) - |P2(Grab the skulls of your victims to score!)\"\n\tGTName=\"Kill Confirmed Team\"\n\tbDisableDefaultScoring=True\n}\n",
            "name": "KillConfirmedTeam.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "VictoryConString1=\"|P1Hit the score limit! (|P3 \"",
                    "VictoryConString2=\" |P1) - |P2(Grab the skulls of your victims to score!)\"",
                    "TimeLimitString1=\"|P1Score the most! (|P3 \"",
                    "TimeLimitString2=\" |P1) - |P2(Grab the skulls of your victims to score!)\"",
                    "GTName=\"Kill Confirmed Team\"",
                    "bDisableDefaultScoring=True"
                ],
                "exec": [],
                "extends": "TCTeam",
                "functions": {
                    "Killed": {
                        "body": "{\n\t\n\tKillerTC = TCPlayer(Killer);\n\tVictimTC = TCPlayer(Other);\n\tSuper.Killed(Killer,Other,damageType);\n\t\n\tif((KillerTC != VictimTC) && (KillerTC != None && VictimTC != None)) //Making sure it isn't suicide and both players do actually exist.\n\t{\n\t\tKillerTC.PlayerReplicationInfo.Streak += 1;\n\t\tKC = Spawn(class'KCObj', VictimTC,, VictimTC.Location);\n\t\tKC.KilledPlayer = VictimTC;\n\t\tKC.KillerPlayer = KillerTC;\n\t\tKC.SetTimer(0.5,True);\n\t\tKC.tLifespan = Settings.KCLifespan;\n\t\tKC.scoreMultiplier = Settings.BaseScoreMultiplier;\n\t}\n}",
                        "locals": [
                            "local KCObj KC;",
                            "local TCPlayer KillerTC, VictimTC;"
                        ],
                        "modifiers": [],
                        "name": "Killed",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 36,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "MVMutator.uc": {
            "body": "class MVMutator extends Mutator config(Mutators);\n\nenum ETimeToDisplay\n{\n TTD_OnDeath,\n TTD_Immediatly\n};\n\nenum ECycleType\n{\n CT_Static,\n CT_Random,\n CT_Cycle\n};\n\nenum eDefaultVote   //Ayleth: Default vote for nonvoters.\n{\n    DV_Yes,\n    DV_No,\n    DV_Ignore     //doesn't count them in the votes.\n};\n//Ayleth: Removed the \"NeverVote\" and \"Autovote\" features as they were never implemented.\n\nvar config string ExcludeList[32];\nvar config ECycleType CycleType;\nvar config eDefaultVote DefaultVote;\nvar config ETimeToDisplay TimeToDisplay;\nvar config bool bUseMapListOnly, bFilterSPMaps, bAllowRepeatMap;\nvar int VoteTime;\nvar int CountDown;  //Ayleth: for changemap.\n\nvar string Maps[250];\nvar int MapCount;\nvar byte VoteTotals[arraycount(Maps)];\n\nvar DXL DXLList;\nvar string sNextMap;\nvar float CWTime;\nvar int LoadingTime, iDefMap, iNextMap, iListSize, EggTimer;\nvar bool bInit, bVoteDone, bDoAdminVote, bDoMapChange;\n\n//Ayleth: Any Function or Variable that names AdminVote refers to\n//the admin prompting for a serverwide decision to switch to the\n//most popular vote b4 the match ends. These are all my addition.\n//Somewhat hacky in places tho. Sorry for the indent mess. Too\n//lazy to clean up his mess. Throws off my indenting as well :(\n\nfunction PostBeginPlay() {\n   local string CM;\n   local int I;\n\n   if (bInit)\n    return;\n\n   bInit = true;\n   MapCount = 0;\n\n   if (bUseMapListOnly)\n    GetMapList();\n   else\n    GetMapFiles();\n\n   CM = Left(Self, InStr(Self, \".\"));\n\n   if (MapCount <= 0) {\n    MapCount = 1;\n    Maps[0] = CM;\n    iListSize += Len(CM);\n   }\n\n   log(MapCount @ \"Maps,\" @ iListSize @ \"Bytes\", 'MVMutator');\n\n   if (CycleType == CT_Random)\n    iDefMap = Rand(MapCount);\n   else {\n    iDefMap = -1;\n    for (I = 0; I < MapCount; I++)\n     if (Maps[I] ~= CM) {\n      iDefMap = I;\n     break;\n     }\n    if (iDefMap >= 0) {\n     if ((CycleType == CT_Cycle) && (++iDefMap >= MapCount))\n      iDefMap = 0;\n   }\n   else\n    iDefMap = Rand(MapCount);\n  }\n\n   ChooseWinner();\n   DXLList = Spawn(class'DXL', Self);\n   DXLList.DoesNotVote=True;   //used later on to differentiate between\n   SetTimer(1, true);                //player DXLs and the Master DXL.\n   SaveConfig();\n   Level.Game.BaseMutator.AddMutator(Self);\n}\n\n\n// 'mutate mapvote' shows the menu.\n// 'mutate voteresult' shows current leading map.\n// trm101:\n// 'mutate cycletype' toggles between the cycletypes\n// 'mutate usemaplist' toggles bUseMapListOnly\n// 'mutate filtersp' toggles bFilterSPMaps\n\n// Ayleth:Fixed spelling mistake in filtersp  (was fildersp)\n// and added Vote and StartVote.\nfunction Mutate(string S, PlayerPawn P)\n{\n  Local DXL GetVotes;\n  local DeusExPlayer Player;\n  if (DXLList != None)\n  {\n   if (S ~= \"MapVote\")\n   {\n    if (!bVoteDone)\n    {\n     GetDXL(P, true).OpenMVMenu();\n    }\n   }\n   else if (S ~= \"VoteResult\")\n   {\n     GetDXL(P, true).ShowWinner();\n   }\n   else if (S~= \"Vote\")     //allows the player to vote for immediate changemap\n   {\n   if(bDoAdminVote==True)\n   GetDXL(P,true).OpenAVMenu(True);\n   else\n   DeusExPlayer(P).Clientmessage(\"There is no vote in progress to change the map\");\n   }\n   //trm\n   else if (P.bAdmin)\n   {\n    if (S ~= \"filtersp\")\n    {\n     bFilterSPMaps=!bFilterSPMaps;\n     P.ClientMessage(\"MAPVOTE: Filtering SP Maps:\"@bFilterSPMaps);\n    }\n    else if (S ~= \"usemaplist\")\n    {\n     bUseMapListOnly=!bUseMapListOnly;\n     P.ClientMessage(\"MAPVOTE: Using Map List Only:\"@bUseMapListOnly);\n    }\n    else if (S ~= \"cycletype\")\n    {\n     if (CycleType==CT_Static)\n     {\n      CycleType = CT_Random;\n      P.ClientMessage(\"MAPVOTE: CycleType now [Random].\");\n     }\n     else if (CycleType==CT_Random)\n     {\n      CycleType = CT_Cycle;\n      P.ClientMessage(\"MAPVOTE: CycleType now [Cycle].\");\n     }\n     else\n     {\n      CycleType = CT_Static;\n      P.ClientMessage(\"MAPVOTE: CycleType now [Static].\");\n     }\n    }\n    Else if (S~= \"StartVote\")  //admin calls this to begin changemap vote.\n    {\n      if(!bDoAdminVote)\n      {\n      foreach allactors(class'DXL',GetVotes)\n     {\n         GetVotes.ClientResetAdminVote();\n         GetVotes.ServerResetAdminVote();\n         GetVotes.bAdminVoteDone=false;\n     }\n      if(TimeToDisplay==TTD_Immediatly)\n      BroadCastMessage(\"An administrator has called for a servertravel mapvote to the map\"@Maps[iNextMap]$\". Please cast your vote when you have died or type 'Mutate Vote' to cast your vote now.\");\n      Else\n      BroadCastMessage(\"An administrator has called for a servertravel mapvote to the map\"@Maps[iNextMap]$\".\");\n      bDoAdminVote=True;\n      settimer(1,true);\n      if(TimeToDisplay==TTD_Immediatly)\n      foreach allactors(Class'DeusExPlayer',Player)\n       GetDXL(Player, true).OpenAVMenu(false);\n      }\n      else  DeusExPlayer(P).Clientmessage(\"A vote is already in progress.\");\n    }\n   }\n  }\n\n  Super.Mutate(S, P);\n}\n\nfunction ModifyPlayer(Pawn P) {\n   if (!bVoteDone && (DeusExPlayer(P) != None) && (GetDXL(P) == None))\n    AddDXL(P);\n   Super.ModifyPlayer(P);\n}\n\n\nfunction ScoreKill(pawn Killer, pawn Other)\n{\n   if(bDoAdminVote && TimeToDisplay==TTD_OnDeath)   //this is where the player recieves the message window to vote.\n       GetDXL(Other, true).OpenAVMenu(false);\n}\n\nfunction Tick(float Delta) {\n   if (bVoteDone)\n    return;\n\n   CWTime += Delta / Level.TimeDilation;\n   if (CWTime < 1)\n    return;\n\n   CWTime = 0;\n   ChooseWinner();\n   UpdateVoteData();\n}\n\n\n// Check if its end of match, if so, travel to our new map.\n//Ayleth: the +1 -1 crap refers to an extra DXL that is the Master DXL, and needs to be ignored.\n//take care that you disinclude this DXL in any calculations.\nsimulated function Timer() {\n local DXL GetVotes;\n local int Yeses, Nos, NumVotes;\n\tlocal string gtv;\n\tlocal ODXVoteActor VA;\n\t\n if(bDoAdminVote)  //this part does the checks when a vote is in progress.\n {\n     if (EggTimer>=VoteTime)  //if we haven't gone past the time limit...\n     {\n        foreach allactors(class'DXL',GetVotes)\n        {\n            if(!GetVotes.DoesNotVote)   //there is one extra DXL always. IgNore this DXL\n            {\n                IF (!GetVotes.bAdminVoteDone && DefaultVote==DV_No) GetVotes.ClientAdminVote(False);  //these are for non-voters.\n                IF (!GetVotes.bAdminVoteDone && DefaultVote==DV_Yes) GetVotes.ClientAdminVote(True);  //basically server sees them as voted\n            }                                                                                         //if they havent voted. Defined bt DefaultVote.\n        }\n\n         bDoAdminVote=False;  //stop the vote.\n         BroadCastMessage(\"The current vote has run past its time limit of\"@VoteTime@\"seconds.\");\n         EggTimer=0;\n     }\n     foreach allactors(class'DXL',GetVotes)\n     {                         //talley up the votes. Also get number of voters\n                 NumVotes++;\n                 if (GetVotes.bAdminVoteDone && GetVotes.bAdminVoteYes==False) Nos++;\n                 if (GetVotes.bAdminVoteDone && GetVotes.bAdminVoteYes==True) Yeses++;\n     }\n     If ((Yeses>(NumVotes/2)) || (NumVotes==Yeses+1)) //if the votes are > than 1/2..\n     {\n         bDoAdminVote=False;      //then close down the vote and get ready for mapchange.\n         bDoMapChange=True;\n         BroadcastMessage(\"Prepare for ServerTravel in:\");\n         BroadCastMessage(\"|P25 Seconds\");\n         CountDown=5;       //sets for 5 second delay until mapchange.\n         Return;\n     }\n     If (Nos>=((NumVotes/2))&& !bDoMapChange)  //if Nos are > or = to 1/2 server population\n     {\n         bDoAdminVote=False;   //just cancel the vote.\n         EggTimer=0;\n         BroadCastMessage(\"The vote has been cancelled; not enough players voted for a servertravel\");\n     }\n     EggTimer++;\n }\n if(bDoMapChange)\n {\n     if (Countdown>0)\n     {\n         CountDown--;\n         if (CountDown!=1)                             //actual countdown code.\n         BroadCastMessage(\"|P2\"$CountDown@\"Seconds\");\n         Else\n         BroadCastMessage(\"|P2\"$CountDown@\"Second\");   //\"1 Seconds\" looks kinda weird ^^\n     }\n     if (CountDown==0)\n     {\n         Level.Game.SetTimer(0,false);\n\t\tforeach AllActors(class'ODXVoteActor', VA)\n\t\t\tgtv = VA.FinalVoteStr;\n\t\t  \n\t\t  if(gtv != \"\")\n\t\t\tLevel.ServerTravel( sNextMap$\"?Game=OpenDX.\"$gtv, False );\n\t\telse\n\t\t\tLevel.ServerTravel( sNextMap, False );\n     }\n }\n if ((DeusExMPGame(Level.Game) != None) && DeusExMPGame(Level.Game).bNewMap) {\n  Level.Game.SetTimer(0, false);\n  if (!bVoteDone) {\n   ChooseWinner(true);\n   UpdateVoteData(true);\n   LoadingTime = 0;\n   bVoteDone = true;\n  }\n  if (LoadingTime++ == 11)\n\t{\n\t\tforeach AllActors(class'ODXVoteActor', VA)\n\t\t\tgtv = VA.FinalVoteStr;\n\t\t  \n\t\t  if(gtv != \"\")\n\t\t\tLevel.ServerTravel( sNextMap$\"?Game=OpenDX.\"$gtv, False );\n\t\telse\n\t\t\tLevel.ServerTravel( sNextMap, False );\n\t}\n }\n}\n\nfinal function UpdateVoteData(optional bool bFinal) {\n   local DXL D;\n   local int I;\n\n   if (DXLList != None)\n    for (D = DXLList.Next; D != None; D = D.Next) {\n     D.iNextMap = iNextMap;\n     for (I = 0; I < MapCount; I++)\n      D.VoteTotals[I] = VoteTotals[I];\n     if (bFinal)\n      D.CloseMVMenu(sNextMap);\n    }\n}\n\n\nfinal function AddDXL(Actor A) {\n   local DXL D;\n   local int I;\n\n   if ((A != None) && !A.bDeleteMe && (DXLList != None)) {\n    D = A.Spawn(class'DXL', A);\n    D.Prev = DXLList;\n    D.Next = DXLList.Next;\n    if (DXLList.Next != None)\n     DXLList.Next.Prev = D;\n    DXLList.Next = D;\n    D.MapCount = MapCount;\n    for (I = 0; I < MapCount; I++)\n     D.Maps[I] = Maps[I];\n   }\n}\n\n\nfinal function DXL GetDXL(Actor A, optional bool bSafe) {\n   local DXL D;\n\n   if ((A != None) && (DXLList != None))\n    for (D = DXLList.Next; D != None; D = D.Next)\n     if (D.Owner == A)\n      return D;\n\n   if (bSafe)\n    return DXLList;\n\n   return None;\n}\n\n\nfinal function ChooseWinner(optional bool bFinal) {\n   local DXL D;\n   local int I;\n   local byte BestScore;\n\n   if (bVoteDone)\n    return;\n\n   for (I = 0; I < MapCount; I++)\n    VoteTotals[I] = 0;\n\n   I = 0;\n   if (DXLList != None)\n    for (D = DXLList.Next; D != None; D = D.Next)\n     if ((D.iCurrentVote >= 0) && (D.iCurrentVote < MapCount)) {\n      VoteTotals[D.iCurrentVote]++;\n      I = 1;\n     }\n\n   iNextMap = iDefMap;\n   if (I != 0)\n    for (I = 0; I < MapCount; I++) {\n     if (VoteTotals[I] > BestScore) {\n      BestScore = VoteTotals[I];\n      iNextMap = I;\n     }\n     else if (bFinal && (BestScore > 0) && (VoteTotals[I] == BestScore) && (FRand() < 0.5))\n      iNextMap = I;\n  }\n\n   sNextMap = Maps[iNextMap];\n}\n\n\nfinal function AddMap(string M) {\n   local string S;\n   local int I;\n\n   if ((M != \"\") && (MapCount < arraycount(Maps))) {\n    if (bFilterSPMaps) {\n     S = Left(M, 3);\n     if ((S ~= \"00_\") || ((int(S) != 0) && (Right(S, 1) ~= \"_\")))\n      return;\n    }\n    if (((M~=left(string(level),instr(string(level),\".\"))) && !bAllowRepeatMap) ||\n    (M ~= \"AutoPlay\") || (M ~= \"DX\") || (M ~= \"DXOnly\") ||\n    (M ~= \"Entry\") || (M ~= \"Index\"))\n     return;\n\n    for (I = 0; I < arraycount(ExcludeList); I++)\n     if (ExcludeList[I] ~= M)\n      return;\n\n    Maps[MapCount++] = M;\n    iListSize += Len(M);\n   }\n}\n\n\nfinal function GetMapList() {\n   local string S;\n   local int I, C;\n\n   for (I = 0; I < arraycount(class'DXMapList'.Default.Maps); I++) {\n    S = class'DXMapList'.Default.Maps[I];\n    if (S != \"\") {\n     C = InStr(S, \".\");\n     if (C >= 0)\n      S = Left(S, C);\n     if (S != \"\") {\n      for (C = 0; C < MapCount; C++)\n       if (Maps[C] ~= S) {\n        S = \"\";\n        break;\n       }\n      AddMap(S);\n     }\n    }\n   }\n}\n\n\nfinal function GetMapFiles() {\n   local string First, Next, Last;\n\n   First = GetMapName(\"\", \"\", 0);\n   Next = First;\n\n   while (!(Last ~= First) && (Next != \"\") && (MapCount < arraycount(Maps))) {\n    if (Right(Next, 3) ~= \".dx\")\n     AddMap(Left(Next, Len(Next) - 3));\n\n   Next = GetMapName(\"\", Next, 1);\n   Last = Next;\n  }\n}\n\n\ndefaultproperties\n{\n    CycleType=2\n    DefaultVote=1\n    bFilterSPMaps=True\n    VoteTime=45\n}\n",
            "name": "MVMutator.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "CycleType=2",
                    "DefaultVote=1",
                    "bFilterSPMaps=True",
                    "VoteTime=45"
                ],
                "exec": [],
                "extends": "Mutator",
                "functions": {
                    "AddDXL": {
                        "body": "",
                        "locals": [
                            "local DXL D;",
                            "local int I;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "AddDXL",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "A"
                            ]
                        ],
                        "return": ""
                    },
                    "AddMap": {
                        "body": "",
                        "locals": [
                            "local string S;",
                            "local int I;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "AddMap",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "M"
                            ]
                        ],
                        "return": ""
                    },
                    "ChooseWinner": {
                        "body": "",
                        "locals": [
                            "local DXL D;",
                            "local int I;",
                            "local byte BestScore;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "ChooseWinner",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "bool",
                                "bFinal"
                            ]
                        ],
                        "return": ""
                    },
                    "GetDXL": {
                        "body": "",
                        "locals": [
                            "local DXL D;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetDXL",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "A"
                            ],
                            [
                                "optional",
                                "bool",
                                "bSafe"
                            ]
                        ],
                        "return": "DXL"
                    },
                    "GetMapFiles": {
                        "body": "",
                        "locals": [
                            "local string First, Next, Last;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetMapFiles",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GetMapList": {
                        "body": "",
                        "locals": [
                            "local string S;",
                            "local int I, C;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetMapList",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ModifyPlayer": {
                        "body": "if (!bVoteDone && (DeusExPlayer(P) != None) && (GetDXL(P) == None))",
                        "locals": [],
                        "modifiers": [],
                        "name": "ModifyPlayer",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "P"
                            ]
                        ],
                        "return": ""
                    },
                    "Mutate": {
                        "body": "{\n  if (DXLList != None)\n  {\n   if (S ~= \"MapVote\")\n   {\n    if (!bVoteDone)\n    {\n     GetDXL(P, true).OpenMVMenu();\n    }\n   }\n   else if (S ~= \"VoteResult\")\n   {\n     GetDXL(P, true).ShowWinner();\n   }\n   else if (S~= \"Vote\")     //allows the player to vote for immediate changemap\n   {\n   if(bDoAdminVote==True)\n   GetDXL(P,true).OpenAVMenu(True);\n   else\n   DeusExPlayer(P).Clientmessage(\"There is no vote in progress to change the map\");\n   }\n   //trm\n   else if (P.bAdmin)\n   {\n    if (S ~= \"filtersp\")\n    {\n     bFilterSPMaps=!bFilterSPMaps;\n     P.ClientMessage(\"MAPVOTE: Filtering SP Maps:\"@bFilterSPMaps);\n    }\n    else if (S ~= \"usemaplist\")\n    {\n     bUseMapListOnly=!bUseMapListOnly;\n     P.ClientMessage(\"MAPVOTE: Using Map List Only:\"@bUseMapListOnly);\n    }\n    else if (S ~= \"cycletype\")\n    {\n     if (CycleType==CT_Static)\n     {\n      CycleType = CT_Random;\n      P.ClientMessage(\"MAPVOTE: CycleType now [Random].\");\n     }\n     else if (CycleType==CT_Random)\n     {\n      CycleType = CT_Cycle;\n      P.ClientMessage(\"MAPVOTE: CycleType now [Cycle].\");\n     }\n     else\n     {\n      CycleType = CT_Static;\n      P.ClientMessage(\"MAPVOTE: CycleType now [Static].\");\n     }\n    }\n    Else if (S~= \"StartVote\")  //admin calls this to begin changemap vote.\n    {\n      if(!bDoAdminVote)\n      {\n      foreach allactors(class'DXL',GetVotes)\n     {\n         GetVotes.ClientResetAdminVote();\n         GetVotes.ServerResetAdminVote();\n         GetVotes.bAdminVoteDone=false;\n     }\n      if(TimeToDisplay==TTD_Immediatly)\n      BroadCastMessage(\"An administrator has called for a servertravel mapvote to the map\"@Maps[iNextMap]$\". Please cast your vote when you have died or type 'Mutate Vote' to cast your vote now.\");\n      Else\n      BroadCastMessage(\"An administrator has called for a servertravel mapvote to the map\"@Maps[iNextMap]$\".\");\n      bDoAdminVote=True;\n      settimer(1,true);\n      if(TimeToDisplay==TTD_Immediatly)\n      foreach allactors(Class'DeusExPlayer',Player)\n       GetDXL(Player, true).OpenAVMenu(false);\n      }\n      else  DeusExPlayer(P).Clientmessage(\"A vote is already in progress.\");\n    }\n   }\n  }\n\n  Super.Mutate(S, P);\n}",
                        "locals": [
                            "Local DXL GetVotes;",
                            "local DeusExPlayer Player;"
                        ],
                        "modifiers": [],
                        "name": "Mutate",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "S"
                            ],
                            [
                                "PlayerPawn",
                                "P"
                            ]
                        ],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "",
                        "locals": [
                            "local string CM;",
                            "local int I;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ScoreKill": {
                        "body": "{\n   if(bDoAdminVote && TimeToDisplay==TTD_OnDeath)   //this is where the player recieves the message window to vote.\n       GetDXL(Other, true).OpenAVMenu(false);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ScoreKill",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "Tick": {
                        "body": "if (bVoteDone)",
                        "locals": [],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Delta"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "",
                        "locals": [
                            "local DXL GetVotes;",
                            "local int Yeses, Nos, NumVotes;",
                            "local string gtv;",
                            "local ODXVoteActor VA;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "UpdateVoteData": {
                        "body": "",
                        "locals": [
                            "local DXL D;",
                            "local int I;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "UpdateVoteData",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "bool",
                                "bFinal"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 463,
                "replication": "",
                "states": [],
                "variables": [
                    "var config string ExcludeList[32];",
                    "var config ECycleType CycleType;",
                    "var config eDefaultVote DefaultVote;",
                    "var config ETimeToDisplay TimeToDisplay;",
                    "var config bool bUseMapListOnly, bFilterSPMaps, bAllowRepeatMap;",
                    "var int VoteTime;",
                    "var int CountDown;  //Ayleth: for changemap.",
                    "var string Maps[250];",
                    "var int MapCount;",
                    "var byte VoteTotals[arraycount(Maps)];",
                    "var DXL DXLList;",
                    "var string sNextMap;",
                    "var float CWTime;",
                    "var int LoadingTime, iDefMap, iNextMap, iListSize, EggTimer;",
                    "var bool bInit, bVoteDone, bDoAdminVote, bDoMapChange;"
                ]
            }
        },
        "N_ShockWave.uc": {
            "body": "class N_ShockWave extends Effects;\n\nreplication\n{\nreliable if (Role == ROLE_Authority)\n nscale;\n}\n\nvar float OldShockDistance, ShockSize;\nvar float nscale;\n\n\nfunction setnscale(float newvalue)\n{\nnscale = newvalue;\n}\n\n\nsimulated function Tick( float DeltaTime )\n{\nif ( Level.NetMode != NM_DedicatedServer )\n {\n// ShockSize = 13 * (Default.LifeSpan - LifeSpan) + 3.5/(LifeSpan/Default.LifeSpan+0.05);\n ShockSize = 59.0 * (Default.LifeSpan - LifeSpan) + 1.0;\n ScaleGlow = Lifespan;\n AmbientGlow = ScaleGlow * 255;\n DrawScale = ShockSize * 0.10 * nscale;  //scale Earth to correct size\n }\n}\n\n\nsimulated function Timer()\n{\nlocal actor Victims;\nlocal float dist, MoScale;\nlocal vector dir;\n\nShockSize = 59.0 * (Default.LifeSpan - LifeSpan) + 1.0;\nif ( Level.NetMode != NM_DedicatedServer )\n {\n if ( Level.NetMode == NM_Client )\n  {\n  foreach VisibleCollidingActors( class 'Actor', Victims, ShockSize*6*nscale, Location )\n   if ( Victims.Role == ROLE_Authority )\n    {\n    dir = Victims.Location - Location;\n    dist = FMax(1,VSize(dir));\n    dir = dir/dist +vect(0,0,0.3); \n    if ( (dist> OldShockDistance) || (dir dot Victims.Velocity <= 0))\n     {\n     MoScale = FMax(0, 1000 - (1.862 * Dist)/nscale);\n     Victims.Velocity = Victims.Velocity + dir * (MoScale + 20);\t\n     Victims.TakeDamage( MoScale, Instigator,\n       Victims.Location - 0.5 * (Victims.CollisionHeight + Victims.CollisionRadius) * dir,\n       (1000 * dir), 'Burned' );\n     }\n    }\t\n  return;\n  }\n }\n\nforeach VisibleCollidingActors( class 'Actor', Victims, ShockSize*6*nscale, Location )\n {\n dir = Victims.Location - Location;\n dist = FMax(1,VSize(dir));\n dir = dir/dist + vect(0,0,0.3); \n if (dist> OldShockDistance || (dir dot Victims.Velocity < 0))\n  {\n  MoScale = FMax(0, 1000 - (1.862 * Dist)/nscale);\n  if ( Victims.bIsPawn )\n   Pawn(Victims).AddVelocity(dir * (MoScale + 20));\n  else\n   Victims.Velocity = Victims.Velocity + dir * (MoScale + 20);\t\n  Victims.TakeDamage( MoScale, Instigator,\n    Victims.Location - 0.5 * (Victims.CollisionHeight + Victims.CollisionRadius) * dir,\n    (1000 * dir), 'Burned' );\n  }\n }\t\n\nOldShockDistance = ShockSize*6*nscale;\t\n}\n\n\nsimulated function PostBeginPlay()\n{\nlocal Pawn P;\n\nif ( Role == ROLE_Authority ) \n {\n for ( P=Level.PawnList; P!=None; P=P.NextPawn )\n  if ( P.IsA('Human') && (VSize(P.Location - Location) < (1000 * nscale)) )\n   Human(P).ShakeView(0.5, (250000.0*nscale)/VSize(P.Location - Location), 10);\n\n if ( Instigator != None )\n  MakeNoise(10.0*nscale);\n }\n\nSetTimer(0.125, True);\n\nif ( Level.NetMode != NM_DedicatedServer )\n SpawnEffects();\n}\n\n\nsimulated function SpawnEffects()\n{\nlocal ExplosionLarge E;\n\nPlaySound(sound'LargeExplosion2', SLOT_Misc,,, 2000*nscale);\nE = spawn(class'ExplosionLarge',,,Location);\nE.RemoteRole = ROLE_None;\n}\n\n\ndefaultproperties\n{\n    nscale=0.75\n    LifeSpan=1.50\n     DrawType=DT_Mesh\n     Style=STY_Translucent\n    AmbientGlow=255\n    bUnlit=True\n    bAlwaysRelevant=True\n    MultiSkins(0)=FireTexture'Effects.liquid.Virus_SFX'\n    MultiSkins(1)=FireTexture'Effects.liquid.Virus_SFX'\n    Skin=FireTexture'Effects.liquid.Virus_SFX'\n     Mesh=LodMesh'DeusExItems.SphereEffect'\n}\n",
            "name": "N_ShockWave.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "nscale=0.75",
                    "LifeSpan=1.50",
                    "DrawType=DT_Mesh",
                    "Style=STY_Translucent",
                    "AmbientGlow=255",
                    "bUnlit=True",
                    "bAlwaysRelevant=True",
                    "MultiSkins(0)=FireTexture'Effects.liquid.Virus_SFX'",
                    "MultiSkins(1)=FireTexture'Effects.liquid.Virus_SFX'",
                    "Skin=FireTexture'Effects.liquid.Virus_SFX'",
                    "Mesh=LodMesh'DeusExItems.SphereEffect'"
                ],
                "exec": [],
                "extends": "Effects",
                "functions": {
                    "PostBeginPlay": {
                        "body": "{\n\nif ( Role == ROLE_Authority ) \n {\n for ( P=Level.PawnList; P!=None; P=P.NextPawn )\n  if ( P.IsA('Human') && (VSize(P.Location - Location) < (1000 * nscale)) )\n   Human(P).ShakeView(0.5, (250000.0*nscale)/VSize(P.Location - Location), 10);\n\n if ( Instigator != None )\n  MakeNoise(10.0*nscale);\n }\n\nSetTimer(0.125, True);\n\nif ( Level.NetMode != NM_DedicatedServer )\n SpawnEffects();\n}",
                        "locals": [
                            "local Pawn P;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpawnEffects": {
                        "body": "{\n\nPlaySound(sound'LargeExplosion2', SLOT_Misc,,, 2000*nscale);\nE = spawn(class'ExplosionLarge',,,Location);\nE.RemoteRole = ROLE_None;\n}",
                        "locals": [
                            "local ExplosionLarge E;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "SpawnEffects",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\nif ( Level.NetMode != NM_DedicatedServer )\n {\n// ShockSize = 13 * (Default.LifeSpan - LifeSpan) + 3.5/(LifeSpan/Default.LifeSpan+0.05);\n ShockSize = 59.0 * (Default.LifeSpan - LifeSpan) + 1.0;\n ScaleGlow = Lifespan;\n AmbientGlow = ScaleGlow * 255;\n DrawScale = ShockSize * 0.10 * nscale;  //scale Earth to correct size\n }\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\nShockSize = 59.0 * (Default.LifeSpan - LifeSpan) + 1.0;\nif ( Level.NetMode != NM_DedicatedServer )\n {\n if ( Level.NetMode == NM_Client )\n  {\n  foreach VisibleCollidingActors( class 'Actor', Victims, ShockSize*6*nscale, Location )\n   if ( Victims.Role == ROLE_Authority )\n    {\n    dir = Victims.Location - Location;\n    dist = FMax(1,VSize(dir));\n    dir = dir/dist +vect(0,0,0.3); \n    if ( (dist> OldShockDistance) || (dir dot Victims.Velocity <= 0))\n     {\n     MoScale = FMax(0, 1000 - (1.862 * Dist)/nscale);\n     Victims.Velocity = Victims.Velocity + dir * (MoScale + 20);\t\n     Victims.TakeDamage( MoScale, Instigator,\n       Victims.Location - 0.5 * (Victims.CollisionHeight + Victims.CollisionRadius) * dir,\n       (1000 * dir), 'Burned' );\n     }\n    }\t\n  return;\n  }\n }\n\nforeach VisibleCollidingActors( class 'Actor', Victims, ShockSize*6*nscale, Location )\n {\n dir = Victims.Location - Location;\n dist = FMax(1,VSize(dir));\n dir = dir/dist + vect(0,0,0.3); \n if (dist> OldShockDistance || (dir dot Victims.Velocity < 0))\n  {\n  MoScale = FMax(0, 1000 - (1.862 * Dist)/nscale);\n  if ( Victims.bIsPawn )\n   Pawn(Victims).AddVelocity(dir * (MoScale + 20));\n  else\n   Victims.Velocity = Victims.Velocity + dir * (MoScale + 20);\t\n  Victims.TakeDamage( MoScale, Instigator,\n    Victims.Location - 0.5 * (Victims.CollisionHeight + Victims.CollisionRadius) * dir,\n    (1000 * dir), 'Burned' );\n  }\n }\t\n\nOldShockDistance = ShockSize*6*nscale;\t\n}",
                        "locals": [
                            "local actor Victims;",
                            "local float dist, MoScale;",
                            "local vector dir;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "setnscale": {
                        "body": "{\nnscale = newvalue;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "setnscale",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "newvalue"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 129,
                "replication": "",
                "states": [],
                "variables": [
                    "var float OldShockDistance, ShockSize;",
                    "var float nscale;"
                ]
            }
        },
        "ODXBoost.uc": {
            "body": "class ODXBoost extends ODXPickup;\n\ndefaultproperties\n{\n\tPhysics=PHYS_Rotating\n\tPickupMode=EP_Perk\n\tbHidden=False\n\tDrawType=DT_Mesh\n\tMesh=Mesh'DXLogo'\n\tDrawscale=0.3\n\tODXPerk=\"PerkBoost\"\n\tTexture=FireTexture'Effects.Electricity.Ambrosia_Sfx'\n\tSkin=FireTexture'Effects.Electricity.Ambrosia_Sfx'\n\tRotationRate=(Yaw=36000)\n}\n",
            "name": "ODXBoost.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Physics=PHYS_Rotating",
                    "PickupMode=EP_Perk",
                    "bHidden=False",
                    "DrawType=DT_Mesh",
                    "Mesh=Mesh'DXLogo'",
                    "Drawscale=0.3",
                    "ODXPerk=\"PerkBoost\"",
                    "Texture=FireTexture'Effects.Electricity.Ambrosia_Sfx'",
                    "Skin=FireTexture'Effects.Electricity.Ambrosia_Sfx'",
                    "RotationRate=(Yaw=36000)"
                ],
                "exec": [],
                "extends": "ODXPickup",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 16,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "ODXHiddenActor.uc": {
            "body": "class ODXHiddenActor extends Actor;\n\ndefaultproperties\n{\n\tbHidden=True\n}\n",
            "name": "ODXHiddenActor.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=True"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 7,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "ODXJump.uc": {
            "body": "class ODXJump extends ODXPickup;\n\ndefaultproperties\n{\n\tSleepTimer=0\n\tPickupMode=EP_Jump\n\tbHidden=False\n\tDrawType=DT_Sprite\n\tDrawscale=0.6\n\tTexture=Texture'AugIconDrone_Small'\n\tSkin=Texture'AugIconDrone_Small'\n}\n",
            "name": "ODXJump.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "SleepTimer=0",
                    "PickupMode=EP_Jump",
                    "bHidden=False",
                    "DrawType=DT_Sprite",
                    "Drawscale=0.6",
                    "Texture=Texture'AugIconDrone_Small'",
                    "Skin=Texture'AugIconDrone_Small'"
                ],
                "exec": [],
                "extends": "ODXPickup",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 13,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "ODXPickup.uc": {
            "body": "//=============================================\n// Master class Psuedo-Unreal pickup object\n//=============================================\nClass ODXPickup extends DeusExDecoration;\n\nvar() class<Inventory> ODXInv;\nvar class<inventory> CurClass;\nvar string EffectString;\nvar bool bNeverDestroy;\nvar bool bSleeping;\nvar DeusExPlayer Pup;\nvar() int SleepTimer;\nvar() class<Augmentation> ODXAug;\nvar() string ODXPerk;\nvar int Count;\nvar() int JumpVel;\n\nenum EPMode\n{\n   EP_None,\n   EP_Jump,\n   EP_Pickup,\n   EP_Aug,\n   EP_Perk\n};\n\nvar EPMode PickupMode;\n\nfunction BeginPlay()\n{\n\tSetTimer(1,True);\n}\n\nfunction SilentAdd(class<inventory> addClass, DeusExPlayer addTarget)\n{ \n\tlocal Inventory anItem;\n\t\n\tanItem = Spawn(addClass,,,addTarget.Location); \n\tanItem.SpawnCopy(addTarget);\n\tanItem.Destroy();\n}\n\nfunction Tick(float deltatime)\n{\n\tlocal DeusExPlayer DXP;\n\t\n\tsuper.Tick(deltatime);\n\t\n\tif(bSleeping)\n\t\treturn;\n\n\tRadialCollect();\n\t\n\tif(PickupMode == EP_None)\n\t\tbHidden=True;\n\t\t\n\tif(PickupMode == EP_Pickup && ODXInv != None && curclass != ODXInv)\n\t{\n\t\tbHidden=False;\n\t\tCurClass = ODXInv;\n\t\tDrawType=DT_Mesh;\n\t\tStyle=STY_Normal;\n\t\tMesh = ODXInv.default.Mesh;\n\t\tDrawscale = ODXInv.default.Drawscale;\n\t\tSetCollisionSize(ODXInv.default.CollisionRadius, ODXInv.default.CollisionHeight);\n\t}\n}\n\nfunction RadialCollect()\n{\n\tlocal TCPlayer P, winP;\n\tlocal vector dist;\n\tlocal float lowestDist;\n\n\tlowestDist = 1024;\n\n\tforeach VisibleActors(class'TCPlayer', P, 50)\n\t{\n\t\tif(P != None && !P.IsInState('Dying') && P.Health > 0)\n\t\t{\n\t\t\tif(vSize(P.Location - Location) < lowestDist)\n\t\t\t{\n\t\t\t\twinP = P;\n\t\t\t\tlowestDist = vSize(P.Location - Location);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(winP != None)\n\t\tPickupGet(winp);\n}\n\nfunction Timer()\n{\n\tif(bSleeping)\n\t{\n\t\tCount--;\n\t\tif(Count <= 0)\n\t\t{\n\t\t\tLog(Self$\" respawned.\");\n\t\t\tbHidden=False;\n\t\t\tbSleeping=False;\n\t\t}\n\t}\n}\n\nfunction PickupGet(TCPlayer myActivator)\n{\n\t\n\tmyActivator.PlaySound(Sound'DeusExSounds.UserInterface.LogGoalCompleted',,,, 256);\n\tif(PickupMode == EP_Pickup)\n\t\tSilentAdd(ODXInv, myActivator);\n\t\n\tif(PickupMode == EP_Perk)\n\t{\n\t\tmyActivator.GetPerk(ODXPerk);\n\t}\n\t\n\tif(PickupMode == EP_Aug)\n\t{\n\t\tmyActivator.AugmentationSystem.GivePlayerAugmentation(ODXAug);\n\t\tmyActivator.AugmentationSystem.GivePlayerAugmentation(ODXAug);\n\t}\t\n\t\n\tif(PickupMode == EP_Jump)\n\t{\n\t\tmyActivator.DoJump();\n\t\tmyActivator.Velocity.Z = JumpVel;\n\t\tmyActivator.SetPhysics(Phys_Falling);\t\n\t}\n\tbHidden=True;\n\tbSleeping=True;\n\tCount=SleepTimer;\n\treturn;\n}\n\nfunction PSUEffect(DeusExPlayer DXP, string EffectStr)\n{}\n\nfunction Destroyed()\n{\nif(bNeverDestroy)\n\treturn;\n\nSuper.Destroyed();\n}\n\ndefaultproperties\n{\n\tJumpVel=750\n\tSleepTimer=30\n     bInvincible=True\n     HitPoints=100\n     ItemName=\"PSUPICKUP\"\n     //bMovable=False\n     bPushable=False\n     bHighlight=False\n     LightBrightness=100\n     Physics=PHYS_Rotating\n     Lighttype=LT_Steady\n     LightRadius=10\n     Ambientglow=255\n     LightSaturation=255\n\t Drawscale=1\n\t Fatness=140\n\t style=sty_translucent\n\t bBlockPlayers=False\n     Mesh=LodMesh'DeusExDeco.Lightbulb'\n     Texture=Texture'DeusExUI.UserInterface.AugIconCombat_Small';\n     CollisionRadius=5.000000\n     CollisionHeight=8.000000\n          bFixedRotationDir=True\n     RotationRate=(Yaw=8192)\n}\n",
            "name": "ODXPickup.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "JumpVel=750",
                    "SleepTimer=30",
                    "bInvincible=True",
                    "HitPoints=100",
                    "ItemName=\"PSUPICKUP\"",
                    "//bMovable=False",
                    "bPushable=False",
                    "bHighlight=False",
                    "LightBrightness=100",
                    "Physics=PHYS_Rotating",
                    "Lighttype=LT_Steady",
                    "LightRadius=10",
                    "Ambientglow=255",
                    "LightSaturation=255",
                    "Drawscale=1",
                    "Fatness=140",
                    "style=sty_translucent",
                    "bBlockPlayers=False",
                    "Mesh=LodMesh'DeusExDeco.Lightbulb'",
                    "Texture=Texture'DeusExUI.UserInterface.AugIconCombat_Small';",
                    "CollisionRadius=5.000000",
                    "CollisionHeight=8.000000",
                    "bFixedRotationDir=True",
                    "RotationRate=(Yaw=8192)"
                ],
                "exec": [],
                "extends": "DeusExDecoration",
                "functions": {
                    "BeginPlay": {
                        "body": "{\n\tSetTimer(1,True);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PSUEffect": {
                        "body": "{}\n\nfunction Destroyed()\n{",
                        "locals": [],
                        "modifiers": [],
                        "name": "PSUEffect",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "DXP"
                            ],
                            [
                                "string",
                                "EffectStr"
                            ]
                        ],
                        "return": ""
                    },
                    "PickupGet": {
                        "body": "{\n\t\n\tmyActivator.PlaySound(Sound'DeusExSounds.UserInterface.LogGoalCompleted',,,, 256);\n\tif(PickupMode == EP_Pickup)\n\t\tSilentAdd(ODXInv, myActivator);\n\t\n\tif(PickupMode == EP_Perk)\n\t{\n\t\tmyActivator.GetPerk(ODXPerk);\n\t}\n\t\n\tif(PickupMode == EP_Aug)\n\t{\n\t\tmyActivator.AugmentationSystem.GivePlayerAugmentation(ODXAug);\n\t\tmyActivator.AugmentationSystem.GivePlayerAugmentation(ODXAug);\n\t}\t\n\t\n\tif(PickupMode == EP_Jump)\n\t{\n\t\tmyActivator.DoJump();\n\t\tmyActivator.Velocity.Z = JumpVel;\n\t\tmyActivator.SetPhysics(Phys_Falling);\t\n\t}\n\tbHidden=True;\n\tbSleeping=True;\n\tCount=SleepTimer;\n\treturn;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PickupGet",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "myActivator"
                            ]
                        ],
                        "return": ""
                    },
                    "RadialCollect": {
                        "body": "{\n\n\tlowestDist = 1024;\n\n\tforeach VisibleActors(class'TCPlayer', P, 50)\n\t{\n\t\tif(P != None && !P.IsInState('Dying') && P.Health > 0)\n\t\t{\n\t\t\tif(vSize(P.Location - Location) < lowestDist)\n\t\t\t{\n\t\t\t\twinP = P;\n\t\t\t\tlowestDist = vSize(P.Location - Location);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(winP != None)\n\t\tPickupGet(winp);\n}",
                        "locals": [
                            "local TCPlayer P, winP;",
                            "local vector dist;",
                            "local float lowestDist;"
                        ],
                        "modifiers": [],
                        "name": "RadialCollect",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SilentAdd": {
                        "body": "{ \n\t\n\tanItem = Spawn(addClass,,,addTarget.Location); \n\tanItem.SpawnCopy(addTarget);\n\tanItem.Destroy();\n}",
                        "locals": [
                            "local Inventory anItem;"
                        ],
                        "modifiers": [],
                        "name": "SilentAdd",
                        "native": false,
                        "param": [
                            [
                                "class<inventory>",
                                "addClass"
                            ],
                            [
                                "DeusExPlayer",
                                "addTarget"
                            ]
                        ],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n\t\n\tsuper.Tick(deltatime);\n\t\n\tif(bSleeping)\n\t\treturn;\n\n\tRadialCollect();\n\t\n\tif(PickupMode == EP_None)\n\t\tbHidden=True;\n\t\t\n\tif(PickupMode == EP_Pickup && ODXInv != None && curclass != ODXInv)\n\t{\n\t\tbHidden=False;\n\t\tCurClass = ODXInv;\n\t\tDrawType=DT_Mesh;\n\t\tStyle=STY_Normal;\n\t\tMesh = ODXInv.default.Mesh;\n\t\tDrawscale = ODXInv.default.Drawscale;\n\t\tSetCollisionSize(ODXInv.default.CollisionRadius, ODXInv.default.CollisionHeight);\n\t}\n}",
                        "locals": [
                            "local DeusExPlayer DXP;"
                        ],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "deltatime"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tif(bSleeping)\n\t{\n\t\tCount--;\n\t\tif(Count <= 0)\n\t\t{\n\t\t\tLog(Self$\" respawned.\");\n\t\t\tbHidden=False;\n\t\t\tbSleeping=False;\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 175,
                "replication": "",
                "states": [],
                "variables": [
                    "var() class<Inventory> ODXInv;",
                    "var class<inventory> CurClass;",
                    "var string EffectString;",
                    "var bool bNeverDestroy;",
                    "var bool bSleeping;",
                    "var DeusExPlayer Pup;",
                    "var() int SleepTimer;",
                    "var() class<Augmentation> ODXAug;",
                    "var() string ODXPerk;",
                    "var int Count;",
                    "var() int JumpVel;",
                    "var EPMode PickupMode;"
                ]
            }
        },
        "ODXQuad.uc": {
            "body": "class ODXQuad extends ODXPickup;\n\ndefaultproperties\n{\n\tPhysics=PHYS_Rotating\n\tPickupMode=EP_Perk\n\tbHidden=False\n\tDrawType=DT_Mesh\n\tMesh=Mesh'DXLogo'\n\tDrawscale=0.3\n\tODXPerk=\"PerkQuad\"\n\tTexture=FireTexture'Effects.Electricity.Nano_SFX_A'\n\tSkin=FireTexture'Effects.Electricity.Nano_SFX_A'\n\tRotationRate=(Yaw=8192)\n}\n",
            "name": "ODXQuad.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Physics=PHYS_Rotating",
                    "PickupMode=EP_Perk",
                    "bHidden=False",
                    "DrawType=DT_Mesh",
                    "Mesh=Mesh'DXLogo'",
                    "Drawscale=0.3",
                    "ODXPerk=\"PerkQuad\"",
                    "Texture=FireTexture'Effects.Electricity.Nano_SFX_A'",
                    "Skin=FireTexture'Effects.Electricity.Nano_SFX_A'",
                    "RotationRate=(Yaw=8192)"
                ],
                "exec": [],
                "extends": "ODXPickup",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 16,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "ODXTrigger.uc": {
            "body": "//=============================================================================\n//ODX - parent class.\n//======================================\n\nclass ODXTrigger extends Trigger abstract;\n\nvar(Events) class<Actor> LimitingClass;\n\nfunction Trigger(Actor other,Pawn instigator)\n{\n\tBeenTriggeredODX(TCPlayer(instigator));\n\tif(bTriggerOnceOnly)\n\t\tDestroy();\n}\n\nfunction Touch(Actor other)\n{\n\tif(IsRelevant(other))\n\t{\n\t\tBeenTriggeredODX(TCPlayer(other));\n\t\tif(bTriggerOnceOnly)\n\t\t\tDestroy();\n\t}\n}\n\nfunction BeenTriggeredODX(TCPlayer instigator)\n{} //set by subclasses\n\ndefaultproperties\n{\n     LimitingClass=Class'Engine.Actor'\n    // Texture=Texture'MoreTriggersIcon'\n}\n",
            "name": "ODXTrigger.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "LimitingClass=Class'Engine.Actor'",
                    "// Texture=Texture'MoreTriggersIcon'"
                ],
                "exec": [],
                "extends": "Trigger",
                "functions": {
                    "BeenTriggeredODX": {
                        "body": "{} //set by subclasses",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeenTriggeredODX",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "instigator"
                            ]
                        ],
                        "return": ""
                    },
                    "Touch": {
                        "body": "{\n\tif(IsRelevant(other))\n\t{\n\t\tBeenTriggeredODX(TCPlayer(other));\n\t\tif(bTriggerOnceOnly)\n\t\t\tDestroy();\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Touch",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "other"
                            ]
                        ],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "{\n\tBeenTriggeredODX(TCPlayer(instigator));\n\tif(bTriggerOnceOnly)\n\t\tDestroy();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "other"
                            ],
                            [
                                "Pawn",
                                "instigator"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 34,
                "replication": "",
                "states": [],
                "variables": [
                    "var(Events) class<Actor> LimitingClass;"
                ]
            }
        },
        "ODXVoteActor.uc": {
            "body": "//================================================================================\n// Votes\n//1 tdm\n//2 dm\n//3 jugger\n//4 team jugger\n//5 kc\n//6 team kc\n//7 inf\n//8 gg\n//9 ss\n//================================================================================\nclass ODXVoteActor extends Actor;\n\nvar TCPlayer VPs[32];\nvar int VoteCounter[10];\n\nvar string FinalVoteStr;\n\nfunction CalcHighest()\n{\n\tlocal int i, a, s;\n\t\n\ti=0;\n\t\n\tfor(a=0;a<10;a++)\n\t{\n\t\tLog(VoteCounter[a]$\" at \"$a$\" \"$GetGT(a));\n\t\tif(VoteCounter[a] > i)\n\t\t{\n\t\t\tLog(\"New leader \"$a$\" \"$GetGT(a));\n\t\t\ti = VoteCounter[a];\n\t\t\ts = a;\n\t\t}\n\t}\n\t\n\tif(s == 1)\n\t\tFinalVoteStr = \"TCTeam\";\n\tif(s == 2)\n\t\tFinalVoteStr = \"TCDeathmatch\";\n\tif(s == 3)\n\t\tFinalVoteStr = \"JuggernautDM\";\n\tif(s == 4)\n\t\tFinalVoteStr = \"Juggernaut\";\n\tif(s == 5)\n\t\tFinalVoteStr = \"KillConfirmed\";\n\tif(s == 6)\n\t\tFinalVoteStr = \"KillConfirmedTeam\";\n\tif(s == 7)\n\t\tFinalVoteStr = \"Infection\";\n\tif(s == 8)\n\t\tFinalVoteStr = \"GunGame\";\n\tif(s == 9)\n\t\tFinalVoteStr = \"Sharpshooter\";\n}\n\nfunction AcceptVote(TCPlayer Voter, int i)\n{\n\tlocal int f;\n\tlocal bool bFound;\n\tlocal string n;\n\t\n\tfor(f=0;f<32;f++)\n\t\tif(VPs[f] == Voter)\n\t\t\tbFound=True;\n\t\t\t\n\tif(!bFound)\n\t{\n\t\tn = GetGT(i);\n\t\tVoteCounter[i]++;\n\t\tCalcHighest();\n\t\tBroadcastMessage(Voter.PlayerReplicationInfo.PlayerName$\" voted for \"$n$\". Game mode will be \"$FinalVoteStr$\" next.\");\n\t\tfor(f=0;f<32;f++)\n\t\t\tif(VPs[f] == None)\n\t\t\t{\n\t\t\t\tVPs[f] = Voter;\n\t\t\t\treturn;\n\t\t\t}\n\t}\n}\n\nfunction string GetGT(int i)\n{\n\tif(i == 1)\n\t\treturn \"Team Deathmatch\";\n\tif(i == 2)\n\t\treturn \"Deathmatch\";\n\tif(i == 3)\n\t\treturn \"Juggernaut\";\n\tif(i == 4)\n\t\treturn \"Team Juggernaut\";\n\tif(i == 5)\n\t\treturn \"Kill Confirmed\";\n\tif(i == 6)\n\t\treturn \"Team Kill Confirmed\";\n\tif(i == 7)\n\t\treturn \"Infection\";\n\tif(i == 8)\n\t\treturn \"Arsenal GunGame\";\n\tif(i == 9)\n\t\treturn \"Sharpshooter\";\n}\ndefaultproperties\n{\n    bHidden=true\n}\n",
            "name": "ODXVoteActor.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=true"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "AcceptVote": {
                        "body": "{\n\t\n\tfor(f=0;f<32;f++)\n\t\tif(VPs[f] == Voter)\n\t\t\tbFound=True;\n\t\t\t\n\tif(!bFound)\n\t{\n\t\tn = GetGT(i);\n\t\tVoteCounter[i]++;\n\t\tCalcHighest();\n\t\tBroadcastMessage(Voter.PlayerReplicationInfo.PlayerName$\" voted for \"$n$\". Game mode will be \"$FinalVoteStr$\" next.\");\n\t\tfor(f=0;f<32;f++)\n\t\t\tif(VPs[f] == None)\n\t\t\t{\n\t\t\t\tVPs[f] = Voter;\n\t\t\t\treturn;\n\t\t\t}\n\t}\n}",
                        "locals": [
                            "local int f;",
                            "local bool bFound;",
                            "local string n;"
                        ],
                        "modifiers": [],
                        "name": "AcceptVote",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "Voter"
                            ],
                            [
                                "int",
                                "i"
                            ]
                        ],
                        "return": ""
                    },
                    "CalcHighest": {
                        "body": "{\n\t\n\ti=0;\n\t\n\tfor(a=0;a<10;a++)\n\t{\n\t\tLog(VoteCounter[a]$\" at \"$a$\" \"$GetGT(a));\n\t\tif(VoteCounter[a] > i)\n\t\t{\n\t\t\tLog(\"New leader \"$a$\" \"$GetGT(a));\n\t\t\ti = VoteCounter[a];\n\t\t\ts = a;\n\t\t}\n\t}\n\t\n\tif(s == 1)\n\t\tFinalVoteStr = \"TCTeam\";\n\tif(s == 2)\n\t\tFinalVoteStr = \"TCDeathmatch\";\n\tif(s == 3)\n\t\tFinalVoteStr = \"JuggernautDM\";\n\tif(s == 4)\n\t\tFinalVoteStr = \"Juggernaut\";\n\tif(s == 5)\n\t\tFinalVoteStr = \"KillConfirmed\";\n\tif(s == 6)\n\t\tFinalVoteStr = \"KillConfirmedTeam\";\n\tif(s == 7)\n\t\tFinalVoteStr = \"Infection\";\n\tif(s == 8)\n\t\tFinalVoteStr = \"GunGame\";\n\tif(s == 9)\n\t\tFinalVoteStr = \"Sharpshooter\";\n}",
                        "locals": [
                            "local int i, a, s;"
                        ],
                        "modifiers": [],
                        "name": "CalcHighest",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GetGT": {
                        "body": "{\n\tif(i == 1)\n\t\treturn \"Team Deathmatch\";\n\tif(i == 2)\n\t\treturn \"Deathmatch\";\n\tif(i == 3)\n\t\treturn \"Juggernaut\";\n\tif(i == 4)\n\t\treturn \"Team Juggernaut\";\n\tif(i == 5)\n\t\treturn \"Kill Confirmed\";\n\tif(i == 6)\n\t\treturn \"Team Kill Confirmed\";\n\tif(i == 7)\n\t\treturn \"Infection\";\n\tif(i == 8)\n\t\treturn \"Arsenal GunGame\";\n\tif(i == 9)\n\t\treturn \"Sharpshooter\";\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetGT",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "i"
                            ]
                        ],
                        "return": "string"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 107,
                "replication": "",
                "states": [],
                "variables": [
                    "var TCPlayer VPs[32];",
                    "var int VoteCounter[10];",
                    "var string FinalVoteStr;"
                ]
            }
        },
        "ODXWaypoint.uc": {
            "body": "//=============================================================================\n// Sets the player class waypoint to any object\n//=============================================================================\n\nclass ODXWaypoint extends ODXTrigger;\n\nvar() name MarkerTag; //Tag of the actor we want to mark\nvar() int MarkerLifespan; //Optional lifespan of the marker\nvar() string MarkerName; //Optional name of the marker\nvar() bool bMarkerDeleter; //If true, ignore all variables and only deletes the current markers\nvar() bool bLocalPlayerOnly; //Only do the markers for the triggering player, false triggers for ALL\nvar() string PrintMsg; //Do we also want to print a clientmessage to the player\n\nfunction BeenTriggeredODX(TCPlayer Ins)\n{\n\tlocal TCPlayer TCP;\n\tlocal actor a;\n\t\n\tif(PrintMsg != \"\") //Do the print before anything\n\t{\n\t\tif(bLocalPlayerOnly)\n\t\t{\n\t\t\tins.ClientMessage(PrintMsg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.ClientMessage(PrintMsg);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(bMarkerDeleter) //If we're deleting...\n\t{\n\t\tif(bLocalPlayerOnly)\n\t\t{\n\t\t\tins.CancelWaypoint();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.CancelWaypoint();\n\t\t\t}\n\t\t}\n\t\treturn; //Don't go to the marker creating if we're a deleter\n\t}\n\t\n\tif(MarkerTag != 'None')\n\t{\n\t\tforeach AllActors(class'Actor',A)\n\t\t{\n\t\t\tif(A.Tag == MarkerTag)\n\t\t\t{\n\t\t\t\tif(bLocalPlayerOnly)\n\t\t\t\t{\n\t\t\t\t\tins.SetWaypoint(A, MarkerName, MarkerLifespan);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t\t\t{\n\t\t\t\t\t\tTCP.SetWaypoint(A, MarkerName, MarkerLifespan);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ndefaultproperties\n{\n\n}\n",
            "name": "ODXWaypoint.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "ODXTrigger",
                "functions": {
                    "BeenTriggeredODX": {
                        "body": "{\n\t\n\tif(PrintMsg != \"\") //Do the print before anything\n\t{\n\t\tif(bLocalPlayerOnly)\n\t\t{\n\t\t\tins.ClientMessage(PrintMsg);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.ClientMessage(PrintMsg);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(bMarkerDeleter) //If we're deleting...\n\t{\n\t\tif(bLocalPlayerOnly)\n\t\t{\n\t\t\tins.CancelWaypoint();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.CancelWaypoint();\n\t\t\t}\n\t\t}\n\t\treturn; //Don't go to the marker creating if we're a deleter\n\t}\n\t\n\tif(MarkerTag != 'None')\n\t{\n\t\tforeach AllActors(class'Actor',A)\n\t\t{\n\t\t\tif(A.Tag == MarkerTag)\n\t\t\t{\n\t\t\t\tif(bLocalPlayerOnly)\n\t\t\t\t{\n\t\t\t\t\tins.SetWaypoint(A, MarkerName, MarkerLifespan);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t\t\t{\n\t\t\t\t\t\tTCP.SetWaypoint(A, MarkerName, MarkerLifespan);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;",
                            "local actor a;"
                        ],
                        "modifiers": [],
                        "name": "BeenTriggeredODX",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "Ins"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 76,
                "replication": "",
                "states": [],
                "variables": [
                    "var() name MarkerTag; //Tag of the actor we want to mark",
                    "var() int MarkerLifespan; //Optional lifespan of the marker",
                    "var() string MarkerName; //Optional name of the marker",
                    "var() bool bMarkerDeleter; //If true, ignore all variables and only deletes the current markers",
                    "var() bool bLocalPlayerOnly; //Only do the markers for the triggering player, false triggers for ALL",
                    "var() string PrintMsg; //Do we also want to print a clientmessage to the player"
                ]
            }
        },
        "OSDActor.uc": {
            "body": "//================================================================================\n// Auto-shutdown Actor\n//================================================================================\nclass OSDActor extends Actor;\n\nvar bool bSDAt, bSDIn;\n\nvar int ShutdownInTime; //Shuts down in X minutes;\nvar string ShutdownAtTime; //Shutsdown at X time;\n\nvar int SDaMins, SDaHours;\nvar int SDInCur;\nvar bool bSDReady;\nvar bool bDebug;\nvar TCDeathmatch myDMGame;\nvar TCTeam myTDMGame;\n\nfunction TCControls GetControls()\n{\n\tlocal TCControls TCC;\n\tif(TCDeathmatch(Level.Game) != None) TCC = TCDeathMatch(Level.Game).Settings;\n\tif(TCTeam(Level.Game) != None) TCC = TCTeam(Level.Game).Settings;\n\t\n\tif(TCC == None)\n\t\tlog(\"ERROR: SETTINGS NOT FOUND\", 'OSDA');\n\t\t\n\treturn TCC;\n}\n\nfunction PostBeginPlay()\n{\n\tif(TCDeathMatch(level.game) != None)\n\t{\n\t\tTCDeathMatch(level.game).bSDFound=True;\t\t\n\t\tmyDMGame = TCDeathmatch(level.game);\n\t\tif(bDebug) log(\"Deathmatch found.\",'OSDA');\n\t}\n\t\n\tif(TCTeam(level.game) != None)\n\t{\n\t\tTCTeam(level.game).bSDFound=True;\t\t\n\t\tmyTDMGame = TCTeam(level.game);\n\t\tif(bDebug) log(\"TeamDeathmatch found.\",'OSDA');\n\t}\n\tsuper.PostBeginPlay();\n}\n\nfunction Destroyed() \n{\n\tif(myDMGame != None)\n\t{\n\t\tmyDMGame.bSDFound=False;\t\n\t\tmyDMGame.SDStr = \"\";\n\t\tif(bDebug) log(\"Deathmatch found on Destroyed().\",'OSDA');\n\t}\n\t\n\tif(TCTeam(level.game) != None)\n\t{\n\t\tmyTDMGame.bSDFound=False;\t\n\t\tmyTDMGame.SDStr = \"\";\n\t\tif(bDebug) log(\"TeamDeathmatch found on Destroyed().\",'OSDA');\n\t}\n\tsuper.Destroyed();\n}\n\nfunction SetSDStr(string str)\n{\n\tif(myDMGame != None)\n\t{\t\n\t\tmyDMGame.SDStr = str;\n\t}\n\t\n\tif(TCTeam(level.game) != None)\n\t{\n\t\tmyTDMGame.SDStr = str;\n\t}\n}\n\nfunction Timer()\n{\n\tlocal string curtime;\n\tlocal int curmins, curhours;\n\tif(bSDReady)\n\t{\n\t\tLog(\"Server was closed due to OSDA System\",'OpenDX');\n\t\tConsoleCommand(\"exit\");\n\t}\n\t\n\tif(bSDAt)\n\t{\n\t\tcurtime = Level.hour $ \":\" $ Level.minute;\n\t\tif(MinsRemain(60))\n\t\t{\n\t\t\tGetControls().Print(\"Sixty minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(50))\n\t\t{\n\t\t\tGetControls().Print(\"Fifty minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(40))\n\t\t{\n\t\t\tGetControls().Print(\"Fourty minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(30))\n\t\t{\n\t\t\tGetControls().Print(\"Thirty minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(20))\n\t\t{\n\t\t\tGetControls().Print(\"Twenty minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(15))\n\t\t{\n\t\t\tGetControls().Print(\"Fifteen minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(10))\n\t\t{\n\t\t\tGetControls().Print(\"Ten minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(5))\n\t\t{\n\t\t\tGetControls().Print(\"Five minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(4))\n\t\t{\n\t\t\tGetControls().Print(\"Four minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(3))\n\t\t{\n\t\t\tGetControls().Print(\"Three minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(2))\n\t\t{\n\t\t\tGetControls().Print(\"Two minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(1))\n\t\t{\n\t\t\tGetControls().Print(\"One minute remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(0))\n\t\t{\n\t\t\tGetControls().Print(\"Server will be closing shortly due to scheduled shutdown.\");\n\t\t\tbSDReady=True;\n\t\t}\n\t}\n\tif(bSDIn)\n\t{\n\t\tSDInCur++;\n\t\tSetSDStr(\"Shuts down in \"$ShutdownInTime - SDInCur);\n\t\t\n\t\tif(SDInCur == (ShutdownInTime - 60))\n\t\t{\n\t\t\tGetControls().Print(\"Sixty minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 50))\n\t\t{\n\t\t\tGetControls().Print(\"Fifty minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 40))\n\t\t{\n\t\t\tGetControls().Print(\"Forty minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 30))\n\t\t{\n\t\t\tGetControls().Print(\"Thirty minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 20))\n\t\t{\n\t\t\tGetControls().Print(\"Twenty minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 15))\n\t\t{\n\t\t\tGetControls().Print(\"Fifteen minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 10))\n\t\t{\n\t\t\tGetControls().Print(\"Ten minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 5))\n\t\t{\n\t\t\tGetControls().Print(\"Five minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 3))\n\t\t{\n\t\t\tGetControls().Print(\"Three minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 2))\n\t\t{\n\t\t\tGetControls().Print(\"Two minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 1))\n\t\t{\n\t\t\tGetControls().Print(\"One minute remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime))\n\t\t{\n\t\t\tGetControls().Print(\"Server will be closing shortly....\");\n\t\t\tbSDReady=True;\n\t\t}\n\t}\n}\n\n/*\n * if sd time is 1:00\n * 5 mins remain at 55\n * or if sd is 1:03\n * 5 mins remain at 58\n * so we need a var; remainder = Level.minutes (example: 5) then - the minsremaining\n * so 5 - 10 = -5\n * if under 0 then + 60 and - 1 hour\n*/\n\n//if 17 01\n// m = 5\n// 01 - 5 = -4\n// -4 + 60 = 54 then hour becomes 16\n// final result is 16 54\nfunction bool MinsRemain(int m)\n{\n\tlocal int ch, cm;\n\tlocal bool bLastHour;\n\tlocal string cmf;\n\t\n\tch = SDAHours;\n\tcm = SDAMins;\n\t\n\tcm -= m;\n\tif(cm < 0)\n\t{\n\t\tcm += 60;\n\t\tch -= 1;\n\t\tif(ch == -1)\n\t\t\tch = 23;\n\t\tbLastHour=True;\n\t}\n\t\n\tif(cm == 60)\n\t{\n\t\tcm = 0;\n\t\tch += 1;\n\t\tbLastHour=False;\n\t}\n\t\n\tif(bDebug)\n\t\tLog(Level.hour$\":\"$level.minute$\" Checking: [\"$bLastHour$\"] \"$ch$\":\"$cm$\" against \"$m$\" remaining... \"$SDAHours$\":\"$SDAMins$\" (\"$ShutdownAtTime$\")\");\n\t\n\tif(cm == Level.minute)\n\t{\n\t\t\tif(Level.Hour == ch)\n\t\t\t{\n\t\t\t\tif(bDebug)\n\t\t\t\t\tLog(\"Returning true\");\n\t\t\t\treturn true;\n\t\t\t}\n\t}\n}\n\ndefaultproperties\n{\n    bHidden=true\n}\n",
            "name": "OSDActor.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=true"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "Destroyed": {
                        "body": "{\n\tif(myDMGame != None)\n\t{\n\t\tmyDMGame.bSDFound=False;\t\n\t\tmyDMGame.SDStr = \"\";\n\t\tif(bDebug) log(\"Deathmatch found on Destroyed().\",'OSDA');\n\t}\n\t\n\tif(TCTeam(level.game) != None)\n\t{\n\t\tmyTDMGame.bSDFound=False;\t\n\t\tmyTDMGame.SDStr = \"\";\n\t\tif(bDebug) log(\"TeamDeathmatch found on Destroyed().\",'OSDA');\n\t}\n\tsuper.Destroyed();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Destroyed",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GetControls": {
                        "body": "{\n\tif(TCDeathmatch(Level.Game) != None) TCC = TCDeathMatch(Level.Game).Settings;\n\tif(TCTeam(Level.Game) != None) TCC = TCTeam(Level.Game).Settings;\n\t\n\tif(TCC == None)\n\t\tlog(\"ERROR: SETTINGS NOT FOUND\", 'OSDA');\n\t\t\n\treturn TCC;\n}",
                        "locals": [
                            "local TCControls TCC;"
                        ],
                        "modifiers": [],
                        "name": "GetControls",
                        "native": false,
                        "param": [],
                        "return": "TCControls"
                    },
                    "MinsRemain": {
                        "body": "{\n\t\n\tch = SDAHours;\n\tcm = SDAMins;\n\t\n\tcm -= m;\n\tif(cm < 0)\n\t{\n\t\tcm += 60;\n\t\tch -= 1;\n\t\tif(ch == -1)\n\t\t\tch = 23;\n\t\tbLastHour=True;\n\t}\n\t\n\tif(cm == 60)\n\t{\n\t\tcm = 0;\n\t\tch += 1;\n\t\tbLastHour=False;\n\t}\n\t\n\tif(bDebug)\n\t\tLog(Level.hour$\":\"$level.minute$\" Checking: [\"$bLastHour$\"] \"$ch$\":\"$cm$\" against \"$m$\" remaining... \"$SDAHours$\":\"$SDAMins$\" (\"$ShutdownAtTime$\")\");\n\t\n\tif(cm == Level.minute)\n\t{\n\t\t\tif(Level.Hour == ch)\n\t\t\t{\n\t\t\t\tif(bDebug)\n\t\t\t\t\tLog(\"Returning true\");\n\t\t\t\treturn true;\n\t\t\t}\n\t}\n}",
                        "locals": [
                            "local int ch, cm;",
                            "local bool bLastHour;",
                            "local string cmf;"
                        ],
                        "modifiers": [],
                        "name": "MinsRemain",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "m"
                            ]
                        ],
                        "return": "bool"
                    },
                    "PostBeginPlay": {
                        "body": "{\n\tif(TCDeathMatch(level.game) != None)\n\t{\n\t\tTCDeathMatch(level.game).bSDFound=True;\t\t\n\t\tmyDMGame = TCDeathmatch(level.game);\n\t\tif(bDebug) log(\"Deathmatch found.\",'OSDA');\n\t}\n\t\n\tif(TCTeam(level.game) != None)\n\t{\n\t\tTCTeam(level.game).bSDFound=True;\t\t\n\t\tmyTDMGame = TCTeam(level.game);\n\t\tif(bDebug) log(\"TeamDeathmatch found.\",'OSDA');\n\t}\n\tsuper.PostBeginPlay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetSDStr": {
                        "body": "{\n\tif(myDMGame != None)\n\t{\t\n\t\tmyDMGame.SDStr = str;\n\t}\n\t\n\tif(TCTeam(level.game) != None)\n\t{\n\t\tmyTDMGame.SDStr = str;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetSDStr",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tif(bSDReady)\n\t{\n\t\tLog(\"Server was closed due to OSDA System\",'OpenDX');\n\t\tConsoleCommand(\"exit\");\n\t}\n\t\n\tif(bSDAt)\n\t{\n\t\tcurtime = Level.hour $ \":\" $ Level.minute;\n\t\tif(MinsRemain(60))\n\t\t{\n\t\t\tGetControls().Print(\"Sixty minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(50))\n\t\t{\n\t\t\tGetControls().Print(\"Fifty minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(40))\n\t\t{\n\t\t\tGetControls().Print(\"Fourty minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(30))\n\t\t{\n\t\t\tGetControls().Print(\"Thirty minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(20))\n\t\t{\n\t\t\tGetControls().Print(\"Twenty minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(15))\n\t\t{\n\t\t\tGetControls().Print(\"Fifteen minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(10))\n\t\t{\n\t\t\tGetControls().Print(\"Ten minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(5))\n\t\t{\n\t\t\tGetControls().Print(\"Five minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(4))\n\t\t{\n\t\t\tGetControls().Print(\"Four minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(3))\n\t\t{\n\t\t\tGetControls().Print(\"Three minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(2))\n\t\t{\n\t\t\tGetControls().Print(\"Two minutes remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(1))\n\t\t{\n\t\t\tGetControls().Print(\"One minute remains until scheduled shutdown at \"$ShutdownAtTime);\n\t\t}\n\t\tif(MinsRemain(0))\n\t\t{\n\t\t\tGetControls().Print(\"Server will be closing shortly due to scheduled shutdown.\");\n\t\t\tbSDReady=True;\n\t\t}\n\t}\n\tif(bSDIn)\n\t{\n\t\tSDInCur++;\n\t\tSetSDStr(\"Shuts down in \"$ShutdownInTime - SDInCur);\n\t\t\n\t\tif(SDInCur == (ShutdownInTime - 60))\n\t\t{\n\t\t\tGetControls().Print(\"Sixty minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 50))\n\t\t{\n\t\t\tGetControls().Print(\"Fifty minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 40))\n\t\t{\n\t\t\tGetControls().Print(\"Forty minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 30))\n\t\t{\n\t\t\tGetControls().Print(\"Thirty minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 20))\n\t\t{\n\t\t\tGetControls().Print(\"Twenty minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 15))\n\t\t{\n\t\t\tGetControls().Print(\"Fifteen minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 10))\n\t\t{\n\t\t\tGetControls().Print(\"Ten minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 5))\n\t\t{\n\t\t\tGetControls().Print(\"Five minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 3))\n\t\t{\n\t\t\tGetControls().Print(\"Three minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 2))\n\t\t{\n\t\t\tGetControls().Print(\"Two minutes remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime - 1))\n\t\t{\n\t\t\tGetControls().Print(\"One minute remains until shutdown.\");\n\t\t}\n\t\tif(SDInCur == (ShutdownInTime))\n\t\t{\n\t\t\tGetControls().Print(\"Server will be closing shortly....\");\n\t\t\tbSDReady=True;\n\t\t}\n\t}\n}",
                        "locals": [
                            "local string curtime;",
                            "local int curmins, curhours;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 262,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool bSDAt, bSDIn;",
                    "var int ShutdownInTime; //Shuts down in X minutes;",
                    "var string ShutdownAtTime; //Shutsdown at X time;",
                    "var int SDaMins, SDaHours;",
                    "var int SDInCur;",
                    "var bool bSDReady;",
                    "var bool bDebug;",
                    "var TCDeathmatch myDMGame;",
                    "var TCTeam myTDMGame;"
                ]
            }
        },
        "OpenDX.uc": {
            "body": "class OpenDX extends TCDeathmatch;\n",
            "name": "OpenDX.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "TCDeathmatch",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 2,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "OpenDXDevTest.uc": {
            "body": "class OpenDXDevTest extends TCDeathmatch;\n",
            "name": "OpenDXDevTest.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "TCDeathmatch",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 2,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PerkBoost.uc": {
            "body": "class PerkBoost extends Perks;\n\nvar int Count;\n\nfunction PerkOn()\n{\n\tSetTimer(1, True);\n\n\tPerkOwner.GroundSpeed *= 1.8;\n\tPerkOwner.mpGroundSpeed *= 1.8;\n\tPerkOwner.JumpZ *= 1.8;\n\tPerkOwner.UpdateAnimRate(1.8);\t\t\n}\n\nfunction PerkOff()\n{\n\tPerkOwner.GroundSpeed = PerkOwner.Default.mpGroundSpeed;\n\tPerkOwner.mpGroundSpeed = PerkOwner.Default.mpGroundSpeed;\n\tPerkOwner.JumpZ = PerkOwner.Default.JumpZ;\n\tPerkOwner.UpdateAnimRate( -1.0 );\n}\n\nfunction Timer()\n{\n\tCount--;\n\t\n\tif(Count <= 5)\n\t\tPerkOwner.Notif(\"(Boost) \"$Count$\" seconds remaining.\");\n\t\t\n\tif(Count <= 0)\n\t\tPerkOwner.RemovePerkbyName(\"Speed Boost\");\n}\n\ndefaultproperties\n{\n\tCount=30\n\tPerkName=\"Speed Boost\"\n\tPerkShortName=\"boost\"\n\tbLock=True\n}\n",
            "name": "PerkBoost.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Count=30",
                    "PerkName=\"Speed Boost\"",
                    "PerkShortName=\"boost\"",
                    "bLock=True"
                ],
                "exec": [],
                "extends": "Perks",
                "functions": {
                    "PerkOff": {
                        "body": "{\n\tPerkOwner.GroundSpeed = PerkOwner.Default.mpGroundSpeed;\n\tPerkOwner.mpGroundSpeed = PerkOwner.Default.mpGroundSpeed;\n\tPerkOwner.JumpZ = PerkOwner.Default.JumpZ;\n\tPerkOwner.UpdateAnimRate( -1.0 );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkOff",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PerkOn": {
                        "body": "{\n\tSetTimer(1, True);\n\n\tPerkOwner.GroundSpeed *= 1.8;\n\tPerkOwner.mpGroundSpeed *= 1.8;\n\tPerkOwner.JumpZ *= 1.8;\n\tPerkOwner.UpdateAnimRate(1.8);\t\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkOn",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tCount--;\n\t\n\tif(Count <= 5)\n\t\tPerkOwner.Notif(\"(Boost) \"$Count$\" seconds remaining.\");\n\t\t\n\tif(Count <= 0)\n\t\tPerkOwner.RemovePerkbyName(\"Speed Boost\");\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 41,
                "replication": "",
                "states": [],
                "variables": [
                    "var int Count;"
                ]
            }
        },
        "PerkDebug.uc": {
            "body": "class PerkDebug extends Perks;\nvar int db;\n\nfunction PerkOn()\n{\n\tPerkOwner.ClientMessage(\"Debug perk activated.\");\n}\n\nfunction PerkOff()\n{\n\tPerkOwner.ClientMessage(\"Debug perk de-activated.\");\n}\n\nfunction PerkTick()\n{\n\tdb += 1;\n\t\n\tif(db % 10 == 0)\n\tPerkOwner.ClientMessage(\"The perk is debugging.\");\n}\n\ndefaultproperties\n{\n\tPerkName=\"Debugger\"\n}\n",
            "name": "PerkDebug.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PerkName=\"Debugger\""
                ],
                "exec": [],
                "extends": "Perks",
                "functions": {
                    "PerkOff": {
                        "body": "{\n\tPerkOwner.ClientMessage(\"Debug perk de-activated.\");\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkOff",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PerkOn": {
                        "body": "{\n\tPerkOwner.ClientMessage(\"Debug perk activated.\");\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkOn",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PerkTick": {
                        "body": "{\n\tdb += 1;\n\t\n\tif(db % 10 == 0)\n\tPerkOwner.ClientMessage(\"The perk is debugging.\");\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkTick",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 26,
                "replication": "",
                "states": [],
                "variables": [
                    "var int db;"
                ]
            }
        },
        "PerkHero.uc": {
            "body": "class PerkHero extends Perks;\n\nvar int HC, HHC, MaxCount, HMaxCount;\nvar float HRange;\n\nvar bool bWasHeal;\n\nfunction bool bSafe()\n{\n\tlocal bool bSafety;\n\tlocal TCPlayer TCP;\n\tlocal ScriptedPawn SP;\n\t\n\tbSafety=True; //Start true\n\t\n\tif(PerkOwner.InHand != None) //check one, are we armed\n\t{\n\t\tbSafety=False;\n\t}\n\t\n\tforeach PerkOwner.VisibleActors(class'ScriptedPawn', SP, HRange)\n\t{\n\t\tif(SP != None)\n\t\t\tbSafety=False;\n\t}\n\n\tforeach PerkOwner.VisibleActors(class'TCPlayer', TCP, HRange) //check two, is anyone near by\n\t{\n\t\tif(TCP != PerkOwner)\n\t\t{\n\t\t\tif(TCDeathmatch(Level.game) != None)\n\t\t\t{\n\t\t\t\tif(TCPRI(TCP.PlayerReplicationInfo).TeamNamePRI == \"\") //Target not in team, assume enemy\n\t\t\t\t\tbSafety=False;\n\t\t\t\telse //Target is in a team, move to ally check\n\t\t\t\t{\n\t\t\t\t\tif(TCPRI(TCP.PlayerReplicationInfo).TeamNamePRI != TCPRI(PerkOwner.PlayerReplicationInfo).TeamNamePRI) //Not the same team\n\t\t\t\t\t\tbSafety=False;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(TCTeam(Level.Game) != None)\n\t\t\t{\n\t\t\t\tif(TCP.PlayerReplicationInfo.Team != PerkOwner.PlayerReplicationInfo.Team)\n\t\t\t\t\tbSafety=False;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn bSafety;\n}\n\nfunction PerkTick()\n{\n\tif(bSafe()) //If both checks pass and we're still in safety, begin counting\n\t{\n\t\tif(HC <= MaxCount) //If counter is below the target, keep adding\n\t\t\tHC++;\n\t\telse //If counter is above the max, start healing\n\t\t{\n\t\t\tif(!bWasHeal)\n\t\t\t{\n\t\t\t\tbWasHeal=True;\n\t\t\t\tif(PerkOwner.Health < 100 || PerkOwner.Energy < PerkOwner.EnergyMax)//Only print message if not fully healed\n\t\t\t\t\tPerkOwner.ClientMessage(\"|P3Health has begun regenerating...\");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tHeroHeal();\n\t\t}\n\t\t\n\t}\n\telse //if check fails and we're not in safety, reset counter\n\t{\n\t\tif(bWasHeal && (PerkOwner.Health < 100 || PerkOwner.Energy < PerkOwner.EnergyMax))\n\t\t\tPerkOwner.ClientMessage(\"|P2Healing cancelled due to possible danger.\");\n\t\tHC = 0;\n\t\tbWasHeal=False;\n\t}\n}\n\nfunction HeroHeal()\n{\n\tlocal bool bHealed;\n\t\n\tHHC++;\n\t\n\tif(HHC > HMaxCount)\n\t{\n\t\tHHC = 0;\n\t\tif(PerkOwner.Health < 100)\n\t\t{\n\t\t\tPerkOwner.HealPlayer(15, False);\n\t\t\tbHealed=True;\n\t\t}\n\t\t\n\t\tif(PerkOwner.Energy < PerkOwner.EnergyMax)\n\t\t{\n\t\t\tPerkOwner.Energy += 15;\n\t\t\tif(PerkOwner.Energy > PerkOwner.EnergyMax)\n\t\t\t\tPerkOwner.Energy = PerkOwner.EnergyMax;\n\t\t\t\n\t\t\tbHealed=True;\n\t\t}\n\t\t\n\t\tif(bHealed)\n\t\t\tPerkOwner.ClientFlash(0.5, vect(0, 0, 500));\n\t}\n}\n\ndefaultproperties\n{\n\tHRange=512\n\tMaxCount=75\n\tHMaxCount=10\n\tPerkName=\"Hero Health\"\n}\n",
            "name": "PerkHero.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "HRange=512",
                    "MaxCount=75",
                    "HMaxCount=10",
                    "PerkName=\"Hero Health\""
                ],
                "exec": [],
                "extends": "Perks",
                "functions": {
                    "HeroHeal": {
                        "body": "{\n\t\n\tHHC++;\n\t\n\tif(HHC > HMaxCount)\n\t{\n\t\tHHC = 0;\n\t\tif(PerkOwner.Health < 100)\n\t\t{\n\t\t\tPerkOwner.HealPlayer(15, False);\n\t\t\tbHealed=True;\n\t\t}\n\t\t\n\t\tif(PerkOwner.Energy < PerkOwner.EnergyMax)\n\t\t{\n\t\t\tPerkOwner.Energy += 15;\n\t\t\tif(PerkOwner.Energy > PerkOwner.EnergyMax)\n\t\t\t\tPerkOwner.Energy = PerkOwner.EnergyMax;\n\t\t\t\n\t\t\tbHealed=True;\n\t\t}\n\t\t\n\t\tif(bHealed)\n\t\t\tPerkOwner.ClientFlash(0.5, vect(0, 0, 500));\n\t}\n}",
                        "locals": [
                            "local bool bHealed;"
                        ],
                        "modifiers": [],
                        "name": "HeroHeal",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PerkTick": {
                        "body": "{\n\tif(bSafe()) //If both checks pass and we're still in safety, begin counting\n\t{\n\t\tif(HC <= MaxCount) //If counter is below the target, keep adding\n\t\t\tHC++;\n\t\telse //If counter is above the max, start healing\n\t\t{\n\t\t\tif(!bWasHeal)\n\t\t\t{\n\t\t\t\tbWasHeal=True;\n\t\t\t\tif(PerkOwner.Health < 100 || PerkOwner.Energy < PerkOwner.EnergyMax)//Only print message if not fully healed\n\t\t\t\t\tPerkOwner.ClientMessage(\"|P3Health has begun regenerating...\");\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tHeroHeal();\n\t\t}\n\t\t\n\t}\n\telse //if check fails and we're not in safety, reset counter\n\t{\n\t\tif(bWasHeal && (PerkOwner.Health < 100 || PerkOwner.Energy < PerkOwner.EnergyMax))\n\t\t\tPerkOwner.ClientMessage(\"|P2Healing cancelled due to possible danger.\");\n\t\tHC = 0;\n\t\tbWasHeal=False;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkTick",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "bSafe": {
                        "body": "{\n\t\n\tbSafety=True; //Start true\n\t\n\tif(PerkOwner.InHand != None) //check one, are we armed\n\t{\n\t\tbSafety=False;\n\t}\n\t\n\tforeach PerkOwner.VisibleActors(class'ScriptedPawn', SP, HRange)\n\t{\n\t\tif(SP != None)\n\t\t\tbSafety=False;\n\t}\n\n\tforeach PerkOwner.VisibleActors(class'TCPlayer', TCP, HRange) //check two, is anyone near by\n\t{\n\t\tif(TCP != PerkOwner)\n\t\t{\n\t\t\tif(TCDeathmatch(Level.game) != None)\n\t\t\t{\n\t\t\t\tif(TCPRI(TCP.PlayerReplicationInfo).TeamNamePRI == \"\") //Target not in team, assume enemy\n\t\t\t\t\tbSafety=False;\n\t\t\t\telse //Target is in a team, move to ally check\n\t\t\t\t{\n\t\t\t\t\tif(TCPRI(TCP.PlayerReplicationInfo).TeamNamePRI != TCPRI(PerkOwner.PlayerReplicationInfo).TeamNamePRI) //Not the same team\n\t\t\t\t\t\tbSafety=False;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(TCTeam(Level.Game) != None)\n\t\t\t{\n\t\t\t\tif(TCP.PlayerReplicationInfo.Team != PerkOwner.PlayerReplicationInfo.Team)\n\t\t\t\t\tbSafety=False;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn bSafety;\n}",
                        "locals": [
                            "local bool bSafety;",
                            "local TCPlayer TCP;",
                            "local ScriptedPawn SP;"
                        ],
                        "modifiers": [],
                        "name": "bSafe",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 117,
                "replication": "",
                "states": [],
                "variables": [
                    "var int HC, HHC, MaxCount, HMaxCount;",
                    "var float HRange;",
                    "var bool bWasHeal;"
                ]
            }
        },
        "PerkIcarus.uc": {
            "body": "class PerkIcarus extends Perks;\n\nvar bool bReverse, bTrig;\n\nfunction PerkTick()\n{\t\n\tif(PerkOwner.Velocity.Z < -600 && !bReverse)\n\t{\n\t\tbTrig=True;\n\t\tbReverse=True;\n\t\tPerkOwner.ClientMessage(\"|P3Icarus landing system activated...\");\n\t}\n\t\n\tif(bTrig)\n\t{\n\t\tif(bReverse)\n\t\t\tPerkOwner.Velocity.Z += 100;\n\t\t\n\t\tif(PerkOwner.Velocity.Z > 0)\n\t\t{\n\t\t\tbTrig=False;\n\t\t\tbReverse=False;\n\t\t\tPerkOwner.ClientMessage(\"|P3Icarus landing system de-activated...\");\n\t\t}\n\t}\n}\n\ndefaultproperties\n{\n\tPerkName=\"Icarus Landing System\"\n\tPerkShortName=\"Icarus\"\n}\n",
            "name": "PerkIcarus.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PerkName=\"Icarus Landing System\"",
                    "PerkShortName=\"Icarus\""
                ],
                "exec": [],
                "extends": "Perks",
                "functions": {
                    "PerkTick": {
                        "body": "{\t\n\tif(PerkOwner.Velocity.Z < -600 && !bReverse)\n\t{\n\t\tbTrig=True;\n\t\tbReverse=True;\n\t\tPerkOwner.ClientMessage(\"|P3Icarus landing system activated...\");\n\t}\n\t\n\tif(bTrig)\n\t{\n\t\tif(bReverse)\n\t\t\tPerkOwner.Velocity.Z += 100;\n\t\t\n\t\tif(PerkOwner.Velocity.Z > 0)\n\t\t{\n\t\t\tbTrig=False;\n\t\t\tbReverse=False;\n\t\t\tPerkOwner.ClientMessage(\"|P3Icarus landing system de-activated...\");\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkTick",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 33,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool bReverse, bTrig;"
                ]
            }
        },
        "PerkInfection.uc": {
            "body": "class PerkInfection extends Perks;\n\ndefaultproperties\n{\n\tPerkName=\"Infection\"\n\tbLock=True\n}\n",
            "name": "PerkInfection.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PerkName=\"Infection\"",
                    "bLock=True"
                ],
                "exec": [],
                "extends": "Perks",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 8,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PerkJuggernaut.uc": {
            "body": "class PerkJuggernaut extends Perks;\n//Icarus + Repel + Nuke\nvar bool bReverse, bTrig;\nvar int velz, CheckRadius;\n\nfunction SpawnExplosion(vector Loc)\n{\nlocal ShockRing s1, s2, s3;\nlocal SphereEffect se;\n\n    s1 = spawn(class'ShockRing',,,Loc,rot(16384,0,0));\n\ts1.Lifespan = 5.5;\n    s2 = spawn(class'ShockRing',,,Loc,rot(0,16384,0));\n\ts2.Lifespan = 5.5;\n    s3 = spawn(class'ShockRing',,,Loc,rot(0,0,16384));\n\tS3.Lifespan = 5.5;\n\tse = spawn(class'SphereEffect',,,Loc,rot(16384,0,0));\n\tse.Lifespan = 5.5;\n\tse.MultiSkins[0]=Texture'DeusExDeco.Skins.AlarmLightTex7';\n}\n\nfunction Skullshot()\n{\n\tlocal vector loc, vline, HitLocation, hitNormal, altloc;\n\tlocal rotator altrot;\n\tlocal Actor HitActor;\n\tlocal actor a;\n\tlocal ScriptedPawn     hitPawn;\n\tlocal PlayerPawn       hitPlayer;\n\tlocal DeusExMover      hitMover;\n\tlocal DeusExDecoration hitDecoration;\n\tlocal TCPlayer Player;\n\tPlayer = PerkOwner;\n\t\n\tSpawnExplosion(Player.Location);\n\tloc = Player.Location;\n\tloc.Z -= 32;\n\t\n\t\n\tforeach Player.VisibleActors(class'Actor', A, CheckRadius)\n\t{\n\t\tif (a != None && a != Player)\n\t\t{\n\t\t\thitPawn = ScriptedPawn(a);\n\t\t\thitDecoration = DeusExDecoration(a);\n\t\t\thitPlayer = PlayerPawn(a);\n\t\t\thitMover = DeusExMover(a);\n\t\t\tif (hitPawn != None)\n\t\t\t{\n\t\t\t\thitPawn.SetPhysics(Phys_Falling);\n\t\t\t\thitPawn.Velocity = (normal(loc - hitPawn.Location) * velz);\n\t\t\t\t//hitPawn.TakeDamage(Player.Energy, Player, hitLocation, normal(loc - hitPawn.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\telse if (hitDecoration != None)\n\t\t\t{\n\t\t\t\thitDecoration.SetPhysics(Phys_Falling);\n\t\t\t\thitDecoration.Velocity = (normal(loc - hitDecoration.Location) * velz);\t\n\t\t\t\t//hitDecoration.TakeDamage(Player.Energy, Player, hitLocation, normal(loc - hitDecoration.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\telse if (hitPlayer != None)\n\t\t\t{\n\t\t\t\thitPlayer.SetPhysics(Phys_Falling);\n\t\t\t\thitPlayer.Velocity = (normal(loc - hitPlayer.Location) * velz);\n\t\t\t\t//hitPlayer.TakeDamage(Player.Energy / 3, Player, hitLocation, normal(loc - hitPlayer.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\tif (hitMover != None)\n\t\t\t{\n\t\t\t\t\thitMover.bDrawExplosion = True;\n\t\t\t\t//\thitMover.TakeDamage(Player.Energy * 3, Player, hitLocation,normal(loc - hitMover.Location) * velz, 'Exploded'); \n\t\t\t}\n\t\t}\t\t\n\t}\n}\n\nfunction PerkOn()\n{\n\tPerkOwner.bNuke=True;\n}\n\nfunction PerkOff()\n{\n\tPerkOwner.bNuke=False;\n}\n\nfunction PerkTick()\n{\n\tif(PerkOwner.HealthLegLeft <= 0)\n\t{\n\t\tSkullshot();\n\t\tBroadcastMessage(\"The Juggernaut is crippled!\");\n\t\tPerkSleep(30);\n\t}\n\t\n\tif(PerkOwner.Velocity.Z < -600 && !bReverse)\n\t{\n\t\tbTrig=True;\n\t\tbReverse=True;\n\t\tPerkOwner.ClientMessage(\"|P3Juggernaut landing system activated...\");\n\t}\n\t\n\tif(bTrig)\n\t{\n\t\tif(bReverse)\n\t\t\tPerkOwner.Velocity.Z += 100;\n\t\t\n\t\tif(PerkOwner.Velocity.Z > 0)\n\t\t{\n\t\t\tbTrig=False;\n\t\t\tbReverse=False;\n\t\t\tPerkOwner.ClientMessage(\"|P3Juggernaut landing system de-activated...\");\n\t\t}\n\t}\n}\n\ndefaultproperties\n{\n\tCheckRadius=256\n\tPerkName=\"Juggernaut\"\n\tbLock=True\n}\n",
            "name": "PerkJuggernaut.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "CheckRadius=256",
                    "PerkName=\"Juggernaut\"",
                    "bLock=True"
                ],
                "exec": [],
                "extends": "Perks",
                "functions": {
                    "PerkOff": {
                        "body": "{\n\tPerkOwner.bNuke=False;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkOff",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PerkOn": {
                        "body": "{\n\tPerkOwner.bNuke=True;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkOn",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PerkTick": {
                        "body": "{\n\tif(PerkOwner.HealthLegLeft <= 0)\n\t{\n\t\tSkullshot();\n\t\tBroadcastMessage(\"The Juggernaut is crippled!\");\n\t\tPerkSleep(30);\n\t}\n\t\n\tif(PerkOwner.Velocity.Z < -600 && !bReverse)\n\t{\n\t\tbTrig=True;\n\t\tbReverse=True;\n\t\tPerkOwner.ClientMessage(\"|P3Juggernaut landing system activated...\");\n\t}\n\t\n\tif(bTrig)\n\t{\n\t\tif(bReverse)\n\t\t\tPerkOwner.Velocity.Z += 100;\n\t\t\n\t\tif(PerkOwner.Velocity.Z > 0)\n\t\t{\n\t\t\tbTrig=False;\n\t\t\tbReverse=False;\n\t\t\tPerkOwner.ClientMessage(\"|P3Juggernaut landing system de-activated...\");\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkTick",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Skullshot": {
                        "body": "{\n\tPlayer = PerkOwner;\n\t\n\tSpawnExplosion(Player.Location);\n\tloc = Player.Location;\n\tloc.Z -= 32;\n\t\n\t\n\tforeach Player.VisibleActors(class'Actor', A, CheckRadius)\n\t{\n\t\tif (a != None && a != Player)\n\t\t{\n\t\t\thitPawn = ScriptedPawn(a);\n\t\t\thitDecoration = DeusExDecoration(a);\n\t\t\thitPlayer = PlayerPawn(a);\n\t\t\thitMover = DeusExMover(a);\n\t\t\tif (hitPawn != None)\n\t\t\t{\n\t\t\t\thitPawn.SetPhysics(Phys_Falling);\n\t\t\t\thitPawn.Velocity = (normal(loc - hitPawn.Location) * velz);\n\t\t\t\t//hitPawn.TakeDamage(Player.Energy, Player, hitLocation, normal(loc - hitPawn.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\telse if (hitDecoration != None)\n\t\t\t{\n\t\t\t\thitDecoration.SetPhysics(Phys_Falling);\n\t\t\t\thitDecoration.Velocity = (normal(loc - hitDecoration.Location) * velz);\t\n\t\t\t\t//hitDecoration.TakeDamage(Player.Energy, Player, hitLocation, normal(loc - hitDecoration.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\telse if (hitPlayer != None)\n\t\t\t{\n\t\t\t\thitPlayer.SetPhysics(Phys_Falling);\n\t\t\t\thitPlayer.Velocity = (normal(loc - hitPlayer.Location) * velz);\n\t\t\t\t//hitPlayer.TakeDamage(Player.Energy / 3, Player, hitLocation, normal(loc - hitPlayer.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\tif (hitMover != None)\n\t\t\t{\n\t\t\t\t\thitMover.bDrawExplosion = True;\n\t\t\t\t//\thitMover.TakeDamage(Player.Energy * 3, Player, hitLocation,normal(loc - hitMover.Location) * velz, 'Exploded'); \n\t\t\t}\n\t\t}\t\t\n\t}\n}",
                        "locals": [
                            "local vector loc, vline, HitLocation, hitNormal, altloc;",
                            "local rotator altrot;",
                            "local Actor HitActor;",
                            "local actor a;",
                            "local ScriptedPawn     hitPawn;",
                            "local PlayerPawn       hitPlayer;",
                            "local DeusExMover      hitMover;",
                            "local DeusExDecoration hitDecoration;",
                            "local TCPlayer Player;"
                        ],
                        "modifiers": [],
                        "name": "Skullshot",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpawnExplosion": {
                        "body": "{\n\n    s1 = spawn(class'ShockRing',,,Loc,rot(16384,0,0));\n\ts1.Lifespan = 5.5;\n    s2 = spawn(class'ShockRing',,,Loc,rot(0,16384,0));\n\ts2.Lifespan = 5.5;\n    s3 = spawn(class'ShockRing',,,Loc,rot(0,0,16384));\n\tS3.Lifespan = 5.5;\n\tse = spawn(class'SphereEffect',,,Loc,rot(16384,0,0));\n\tse.Lifespan = 5.5;\n\tse.MultiSkins[0]=Texture'DeusExDeco.Skins.AlarmLightTex7';\n}",
                        "locals": [
                            "local ShockRing s1, s2, s3;",
                            "local SphereEffect se;"
                        ],
                        "modifiers": [],
                        "name": "SpawnExplosion",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "Loc"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 121,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool bReverse, bTrig;",
                    "var int velz, CheckRadius;"
                ]
            }
        },
        "PerkMediAura.uc": {
            "body": "class PerkMediAura extends Perks;\nvar int db;\n\nfunction HealPlayers()\n{\n    local Actor a;\n    local TCPlayer target, targetList[3], Player;\n    local int count, i, healamount, totalamount;\n\n\tPlayer = PerkOwner;\n    count = 0;\n\n    if(TCTeam(Player.DXGame) != None) // Healing teammates in deathmatch is useless.\n    {\n        foreach RadiusActors(class'Actor', a, 256, Player.Location)\n        {\n            if(a.IsA('TCPlayer')) // TODO: Only heal teammates\n            {\n                target = TCPlayer(a);\n                if(target.PlayerReplicationInfo != None && target != Player &&!target.PlayerReplicationInfo.bIsSpectator && target.Health > 0 && target.Health < 100 && (target.lastTeamHeal+1 <= Level.TimeSeconds) && (target.PlayerReplicationInfo.Team == player.PlayerReplicationInfo.Team))\n                {\n                    targetList[count] = target;\n                    count++;\n                    if(count == 3) // We heal a maximum of 3 players\n                        break;\n                }\n            }\n        }\n        \n        if(count > 0)\n        {\n            healamount = Min(30, (45/count));\n            totalamount = healamount*count;\n            for(i = 0; i < count; i++)\n            {\n                if(targetList[i] != None)\n                {\n                    targetList[i].HealPlayer(healamount, False);\n                    targetList[i].ClientFlash(0.5, vect(0, 0, 500));\n                    targetList[i].lastTeamHeal = Level.TimeSeconds;\n                }\n            }\n            if(totalamount > 0)\n            {\n                Player.ClientMessage(\"Healed\"@count@\"nearby player(s) for\"@totalamount$\"HP\");\n            }\n        }\n    }\n    else if(TCDeathmatch(Player.DXGame) != None)\n    {\n\t\tforeach RadiusActors(class'Actor', a, 256, Player.Location)\n        {\n            if(a.IsA('TCPlayer')) // TODO: Only heal teammates\n            {\n                target = TCPlayer(a);\n                if(target.PlayerReplicationInfo != None && target != player &&!target.PlayerReplicationInfo.bIsSpectator && target.Health > 0 && target.Health < 100 && (target.lastTeamHeal+1 <= Level.TimeSeconds) && AreAlliesBasic(target, Player))\n                {\n                    targetList[count] = target;\n                    count++;\n                    if(count == 3) // We heal a maximum of 3 players\n                        break;\n                }\n            }\n        }\n        \n        if(count > 0)\n        {\n            healamount = Min(30, (45/count));\n            totalamount = healamount*count;\n            for(i = 0; i < count; i++)\n            {\n                if(targetList[i] != None)\n                {\n                    targetList[i].HealPlayer(healamount, False);\n                    targetList[i].ClientFlash(0.5, vect(0, 0, 500));\n                    targetList[i].lastTeamHeal = Level.TimeSeconds;\n                }\n            }\n            if(totalamount > 0)\n            {\n                Player.ClientMessage(\"Healed\"@count@\"nearby player(s) for\"@totalamount$\"HP\");\n            }\n        }\n\t}\n}\n\nfunction bool AreAlliesBasic(TCPlayer one, tcplayer two)\n{\n\tif(TCPRI(One.PlayerReplicationInfo).TeamNamePRI == \"\" || TCPRI(Two.PlayerReplicationInfo).TeamNamePRI == \"\")\n\t\treturn false;\n\t\n\tif(TCPRI(One.PlayerReplicationInfo).TeamNamePRI == TCPRI(Two.PlayerReplicationInfo).TeamNamePRI)\n\t\treturn true;\n}\n\nfunction PerkTick()\n{\n\tdb += 1;\n\t\n\tif(db % 100 == 0)\n\t\tHealPlayers();\n}\n\ndefaultproperties\n{\n\tPerkName=\"Medical Aura\"\n}\n",
            "name": "PerkMediAura.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PerkName=\"Medical Aura\""
                ],
                "exec": [],
                "extends": "Perks",
                "functions": {
                    "AreAlliesBasic": {
                        "body": "{\n\tif(TCPRI(One.PlayerReplicationInfo).TeamNamePRI == \"\" || TCPRI(Two.PlayerReplicationInfo).TeamNamePRI == \"\")\n\t\treturn false;\n\t\n\tif(TCPRI(One.PlayerReplicationInfo).TeamNamePRI == TCPRI(Two.PlayerReplicationInfo).TeamNamePRI)\n\t\treturn true;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AreAlliesBasic",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "one"
                            ],
                            [
                                "tcplayer",
                                "two"
                            ]
                        ],
                        "return": "bool"
                    },
                    "HealPlayers": {
                        "body": "{\n\n\tPlayer = PerkOwner;\n    count = 0;\n\n    if(TCTeam(Player.DXGame) != None) // Healing teammates in deathmatch is useless.\n    {\n        foreach RadiusActors(class'Actor', a, 256, Player.Location)\n        {\n            if(a.IsA('TCPlayer')) // TODO: Only heal teammates\n            {\n                target = TCPlayer(a);\n                if(target.PlayerReplicationInfo != None && target != Player &&!target.PlayerReplicationInfo.bIsSpectator && target.Health > 0 && target.Health < 100 && (target.lastTeamHeal+1 <= Level.TimeSeconds) && (target.PlayerReplicationInfo.Team == player.PlayerReplicationInfo.Team))\n                {\n                    targetList[count] = target;\n                    count++;\n                    if(count == 3) // We heal a maximum of 3 players\n                        break;\n                }\n            }\n        }\n        \n        if(count > 0)\n        {\n            healamount = Min(30, (45/count));\n            totalamount = healamount*count;\n            for(i = 0; i < count; i++)\n            {\n                if(targetList[i] != None)\n                {\n                    targetList[i].HealPlayer(healamount, False);\n                    targetList[i].ClientFlash(0.5, vect(0, 0, 500));\n                    targetList[i].lastTeamHeal = Level.TimeSeconds;\n                }\n            }\n            if(totalamount > 0)\n            {\n                Player.ClientMessage(\"Healed\"@count@\"nearby player(s) for\"@totalamount$\"HP\");\n            }\n        }\n    }\n    else if(TCDeathmatch(Player.DXGame) != None)\n    {\n\t\tforeach RadiusActors(class'Actor', a, 256, Player.Location)\n        {\n            if(a.IsA('TCPlayer')) // TODO: Only heal teammates\n            {\n                target = TCPlayer(a);\n                if(target.PlayerReplicationInfo != None && target != player &&!target.PlayerReplicationInfo.bIsSpectator && target.Health > 0 && target.Health < 100 && (target.lastTeamHeal+1 <= Level.TimeSeconds) && AreAlliesBasic(target, Player))\n                {\n                    targetList[count] = target;\n                    count++;\n                    if(count == 3) // We heal a maximum of 3 players\n                        break;\n                }\n            }\n        }\n        \n        if(count > 0)\n        {\n            healamount = Min(30, (45/count));\n            totalamount = healamount*count;\n            for(i = 0; i < count; i++)\n            {\n                if(targetList[i] != None)\n                {\n                    targetList[i].HealPlayer(healamount, False);\n                    targetList[i].ClientFlash(0.5, vect(0, 0, 500));\n                    targetList[i].lastTeamHeal = Level.TimeSeconds;\n                }\n            }\n            if(totalamount > 0)\n            {\n                Player.ClientMessage(\"Healed\"@count@\"nearby player(s) for\"@totalamount$\"HP\");\n            }\n        }\n\t}\n}",
                        "locals": [
                            "local Actor a;",
                            "local TCPlayer target, targetList[3], Player;",
                            "local int count, i, healamount, totalamount;"
                        ],
                        "modifiers": [],
                        "name": "HealPlayers",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PerkTick": {
                        "body": "{\n\tdb += 1;\n\t\n\tif(db % 100 == 0)\n\t\tHealPlayers();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkTick",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 108,
                "replication": "",
                "states": [],
                "variables": [
                    "var int db;"
                ]
            }
        },
        "PerkNuke.uc": {
            "body": "class PerkNuke extends Perks;\n\nfunction PerkOn()\n{\n\tPerkOwner.bNuke=True;\n}\n\nfunction PerkOff()\n{\n\tPerkOwner.bNuke=False;\n}\n\ndefaultproperties\n{\n\tPerkName=\"Death Nuke\"\n\tPerkShortName=\"Nuke\"\n}\n",
            "name": "PerkNuke.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PerkName=\"Death Nuke\"",
                    "PerkShortName=\"Nuke\""
                ],
                "exec": [],
                "extends": "Perks",
                "functions": {
                    "PerkOff": {
                        "body": "{\n\tPerkOwner.bNuke=False;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkOff",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PerkOn": {
                        "body": "{\n\tPerkOwner.bNuke=True;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkOn",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 18,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PerkQuad.uc": {
            "body": "class PerkQuad extends Perks;\n\nvar int Count;\n\nfunction PerkOn()\n{\n\tSetTimer(1, True);\t\n}\n\nfunction PerkOff()\n{\n}\n\nfunction Timer()\n{\n\tCount--;\n\t\n\tif(Count <= 5)\n\t\tPerkOwner.Notif(\"(Quad) \"$Count$\" seconds remaining.\");\n\t\t\n\tif(Count <= 0)\n\t\tPerkOwner.RemovePerkbyName(\"Quad Damage\");\n}\n\ndefaultproperties\n{\n\tCount=30\n\tPerkName=\"Quad Damage\"\n\tPerkShortName=\"quad\"\n\tbLock=True\n}\n",
            "name": "PerkQuad.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Count=30",
                    "PerkName=\"Quad Damage\"",
                    "PerkShortName=\"quad\"",
                    "bLock=True"
                ],
                "exec": [],
                "extends": "Perks",
                "functions": {
                    "PerkOff": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkOff",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PerkOn": {
                        "body": "{\n\tSetTimer(1, True);\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkOn",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tCount--;\n\t\n\tif(Count <= 5)\n\t\tPerkOwner.Notif(\"(Quad) \"$Count$\" seconds remaining.\");\n\t\t\n\tif(Count <= 0)\n\t\tPerkOwner.RemovePerkbyName(\"Quad Damage\");\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 32,
                "replication": "",
                "states": [],
                "variables": [
                    "var int Count;"
                ]
            }
        },
        "PerkRepel.uc": {
            "body": "class PerkRepel extends Perks;\n\nvar int velz, CheckRadius;\n\nfunction PerkTick()\n{\t\n\tif(PerkOwner.HealthLegLeft <= 0)\n\t{\n\t\tSkullshot();\n\t\tPerkOwner.ClientMessage(\"|P3Repulsion activated!\");\n\t\tPerkSleep(30);\n\t}\n}\n\nfunction SpawnExplosion(vector Loc)\n{\nlocal ShockRing s1, s2, s3;\nlocal SphereEffect se;\n\n    s1 = spawn(class'ShockRing',,,Loc,rot(16384,0,0));\n\ts1.Lifespan = 5.5;\n    s2 = spawn(class'ShockRing',,,Loc,rot(0,16384,0));\n\ts2.Lifespan = 5.5;\n    s3 = spawn(class'ShockRing',,,Loc,rot(0,0,16384));\n\tS3.Lifespan = 5.5;\n\tse = spawn(class'SphereEffect',,,Loc,rot(16384,0,0));\n\tse.Lifespan = 5.5;\n\tse.MultiSkins[0]=Texture'DeusExDeco.Skins.AlarmLightTex7';\n}\n\nfunction Skullshot()\n{\n\tlocal vector loc, vline, HitLocation, hitNormal, altloc;\n\tlocal rotator altrot;\n\tlocal Actor HitActor;\n\tlocal actor a;\n\tlocal ScriptedPawn     hitPawn;\n\tlocal PlayerPawn       hitPlayer;\n\tlocal DeusExMover      hitMover;\n\tlocal DeusExDecoration hitDecoration;\n\tlocal TCPlayer Player;\n\tPlayer = PerkOwner;\n\tSpawnExplosion(PerkOwner.Location);\n\tloc = Player.Location;\n\tloc.Z -= 32;\n\tforeach Player.VisibleActors(class'Actor', A, CheckRadius)\n\t{\n\t\tif (a != None && a != Player)\n\t\t{\n\t\t\thitPawn = ScriptedPawn(a);\n\t\t\thitDecoration = DeusExDecoration(a);\n\t\t\thitPlayer = PlayerPawn(a);\n\t\t\thitMover = DeusExMover(a);\n\t\t\tif (hitPawn != None)\n\t\t\t{\n\t\t\t\thitPawn.SetPhysics(Phys_Falling);\n\t\t\t\thitPawn.Velocity = (normal(loc - hitPawn.Location) * velz);\n\t\t\t\t//hitPawn.TakeDamage(Player.Energy, Player, hitLocation, normal(loc - hitPawn.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\telse if (hitDecoration != None)\n\t\t\t{\n\t\t\t\thitDecoration.SetPhysics(Phys_Falling);\n\t\t\t\thitDecoration.Velocity = (normal(loc - hitDecoration.Location) * velz);\t\n\t\t\t\t//hitDecoration.TakeDamage(Player.Energy, Player, hitLocation, normal(loc - hitDecoration.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\telse if (hitPlayer != None)\n\t\t\t{\n\t\t\t\thitPlayer.SetPhysics(Phys_Falling);\n\t\t\t\thitPlayer.Velocity = (normal(loc - hitPlayer.Location) * velz);\n\t\t\t\t//hitPlayer.TakeDamage(Player.Energy / 3, Player, hitLocation, normal(loc - hitPlayer.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\tif (hitMover != None)\n\t\t\t{\n\t\t\t\t\thitMover.bDrawExplosion = True;\n\t\t\t\t//\thitMover.TakeDamage(Player.Energy * 3, Player, hitLocation,normal(loc - hitMover.Location) * velz, 'Exploded'); \n\t\t\t}\n\t\t}\t\t\n\t}\n}\n\ndefaultproperties\n{\n\tCheckRadius=256\n\tPerkName=\"Repulsion\"\n\tPerkShortName=\"Repel\"\n}\n",
            "name": "PerkRepel.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "CheckRadius=256",
                    "PerkName=\"Repulsion\"",
                    "PerkShortName=\"Repel\""
                ],
                "exec": [],
                "extends": "Perks",
                "functions": {
                    "PerkTick": {
                        "body": "{\t\n\tif(PerkOwner.HealthLegLeft <= 0)\n\t{\n\t\tSkullshot();\n\t\tPerkOwner.ClientMessage(\"|P3Repulsion activated!\");\n\t\tPerkSleep(30);\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkTick",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Skullshot": {
                        "body": "{\n\tPlayer = PerkOwner;\n\tSpawnExplosion(PerkOwner.Location);\n\tloc = Player.Location;\n\tloc.Z -= 32;\n\tforeach Player.VisibleActors(class'Actor', A, CheckRadius)\n\t{\n\t\tif (a != None && a != Player)\n\t\t{\n\t\t\thitPawn = ScriptedPawn(a);\n\t\t\thitDecoration = DeusExDecoration(a);\n\t\t\thitPlayer = PlayerPawn(a);\n\t\t\thitMover = DeusExMover(a);\n\t\t\tif (hitPawn != None)\n\t\t\t{\n\t\t\t\thitPawn.SetPhysics(Phys_Falling);\n\t\t\t\thitPawn.Velocity = (normal(loc - hitPawn.Location) * velz);\n\t\t\t\t//hitPawn.TakeDamage(Player.Energy, Player, hitLocation, normal(loc - hitPawn.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\telse if (hitDecoration != None)\n\t\t\t{\n\t\t\t\thitDecoration.SetPhysics(Phys_Falling);\n\t\t\t\thitDecoration.Velocity = (normal(loc - hitDecoration.Location) * velz);\t\n\t\t\t\t//hitDecoration.TakeDamage(Player.Energy, Player, hitLocation, normal(loc - hitDecoration.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\telse if (hitPlayer != None)\n\t\t\t{\n\t\t\t\thitPlayer.SetPhysics(Phys_Falling);\n\t\t\t\thitPlayer.Velocity = (normal(loc - hitPlayer.Location) * velz);\n\t\t\t\t//hitPlayer.TakeDamage(Player.Energy / 3, Player, hitLocation, normal(loc - hitPlayer.Location) * velz, 'Exploded'); \t\n\t\t\t}\n\t\t\tif (hitMover != None)\n\t\t\t{\n\t\t\t\t\thitMover.bDrawExplosion = True;\n\t\t\t\t//\thitMover.TakeDamage(Player.Energy * 3, Player, hitLocation,normal(loc - hitMover.Location) * velz, 'Exploded'); \n\t\t\t}\n\t\t}\t\t\n\t}\n}",
                        "locals": [
                            "local vector loc, vline, HitLocation, hitNormal, altloc;",
                            "local rotator altrot;",
                            "local Actor HitActor;",
                            "local actor a;",
                            "local ScriptedPawn     hitPawn;",
                            "local PlayerPawn       hitPlayer;",
                            "local DeusExMover      hitMover;",
                            "local DeusExDecoration hitDecoration;",
                            "local TCPlayer Player;"
                        ],
                        "modifiers": [],
                        "name": "Skullshot",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpawnExplosion": {
                        "body": "{\n\n    s1 = spawn(class'ShockRing',,,Loc,rot(16384,0,0));\n\ts1.Lifespan = 5.5;\n    s2 = spawn(class'ShockRing',,,Loc,rot(0,16384,0));\n\ts2.Lifespan = 5.5;\n    s3 = spawn(class'ShockRing',,,Loc,rot(0,0,16384));\n\tS3.Lifespan = 5.5;\n\tse = spawn(class'SphereEffect',,,Loc,rot(16384,0,0));\n\tse.Lifespan = 5.5;\n\tse.MultiSkins[0]=Texture'DeusExDeco.Skins.AlarmLightTex7';\n}",
                        "locals": [
                            "local ShockRing s1, s2, s3;",
                            "local SphereEffect se;"
                        ],
                        "modifiers": [],
                        "name": "SpawnExplosion",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "Loc"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 87,
                "replication": "",
                "states": [],
                "variables": [
                    "var int velz, CheckRadius;"
                ]
            }
        },
        "PerkSpy.uc": {
            "body": "class PerkSpy extends Perks;\n\nfunction PerkOn()\n{\n\tTCPRI(PerkOwner.PlayerReplicationInfo).bSpy = True;\n}\n\nfunction PerkOff()\n{\n\tTCPRI(PerkOwner.PlayerReplicationInfo).bSpy = False;\n}\n\ndefaultproperties\n{\n\tPerkName=\"Spy\"\n}\n",
            "name": "PerkSpy.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PerkName=\"Spy\""
                ],
                "exec": [],
                "extends": "Perks",
                "functions": {
                    "PerkOff": {
                        "body": "{\n\tTCPRI(PerkOwner.PlayerReplicationInfo).bSpy = False;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkOff",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PerkOn": {
                        "body": "{\n\tTCPRI(PerkOwner.PlayerReplicationInfo).bSpy = True;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PerkOn",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 17,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PerkTakedown.uc": {
            "body": "class PerkTakedown extends Perks;\n\ndefaultproperties\n{\n\tPerkName=\"Takedown\"\n}\n",
            "name": "PerkTakedown.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PerkName=\"Takedown\""
                ],
                "exec": [],
                "extends": "Perks",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 7,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "Perks.uc": {
            "body": "class Perks extends Actor;\n\nvar TCPlayer PerkOwner; //The player\nvar string PerkName; //Its name\nvar string PerkShortName; //For when the normal name is too long, make detection easier by using a smaller identifier\nvar bool bLock; //Can the /perk command disable it\nvar bool bOn; //Master on switch, will function if on unless sleep\nvar bool bSleep; //Disables the tick while staying on\n\nfunction PostBeginPlay()\n{\n\tif(PerkShortName == \"\")\n\t\tPerkShortName = PerkName;\n}\n\nfunction PerkSleep(float Delay) //Called when the perk needs to be temporarily disabled\n{\n\tPerkOwner.ClientMessage(\"|P2\"$PerkName$\" has been temporarily disabled...\");\n\tbSleep=True;\n\tSetTimer(Delay, False);\n}\n\nfunction Timer()\n{\n\tif(PerkOwner != None && bSleep)\n\t{\n\t\tPerkOwner.ClientMessage(\"|P2\"$PerkName$\" has been recharged...\");\n\t\tbSleep=False;\n\t}\n}\n\nfunction ToggleActivation() //Called by the Player activator\n{\n\tif(bOn)\n\t{\n\t\tPerkOwner.ClientMessage(\"|P4\"$PerkName$\" de-activated.\");\n\t\tPerkOff();\n\t\tbOn=False;\n\t}\n\telse\n\t{\n\t\tPerkOwner.ClientMessage(\"|P4\"$PerkName$\" activated.\");\n\t\tPerkOn();\n\t\tbOn=True;\n\t}\n}\n\nfunction PerkOn() //called when activated\n{}\n\nfunction PerkOff() //called when de-activated\n{}\n\nfunction PerkTick() //called by tick if active\n{}\n\nfunction Tick(float Deltatime) //for passive effects, check if bOn and run code\n{\n\tif( PerkOwner != None && bOn && !bSleep )\n\t\tPerkTick();\n}\n\ndefaultproperties\n{\n\tbHidden=True\n}\n",
            "name": "Perks.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=True"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "PostBeginPlay": {
                        "body": "{\n\tif(PerkShortName == \"\")\n\t\tPerkShortName = PerkName;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tif(PerkOwner != None && bSleep)\n\t{\n\t\tPerkOwner.ClientMessage(\"|P2\"$PerkName$\" has been recharged...\");\n\t\tbSleep=False;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 67,
                "replication": "",
                "states": [],
                "variables": [
                    "var TCPlayer PerkOwner; //The player",
                    "var string PerkName; //Its name",
                    "var string PerkShortName; //For when the normal name is too long, make detection easier by using a smaller identifier",
                    "var bool bLock; //Can the /perk command disable it",
                    "var bool bOn; //Master on switch, will function if on unless sleep",
                    "var bool bSleep; //Disables the tick while staying on"
                ]
            }
        },
        "Playground.uc": {
            "body": "class Playground extends TCDeathmatch;\n",
            "name": "Playground.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "TCDeathmatch",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 2,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisBallistic.uc": {
            "body": "class PraxisBallistic extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugBallistic'\n\tItemName=\"Praxis Kit (Aug Ballistic)\"\n}\n",
            "name": "PraxisBallistic.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugBallistic'",
                    "ItemName=\"Praxis Kit (Aug Ballistic)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisCloak.uc": {
            "body": "class PraxisCloak extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugCloak'\n\tItemName=\"Praxis Kit (Aug Cloak)\"\n}\n",
            "name": "PraxisCloak.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugCloak'",
                    "ItemName=\"Praxis Kit (Aug Cloak)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisCombat.uc": {
            "body": "class PraxisCombat extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugCombat'\n\tItemName=\"Praxis Kit (Aug Combat)\"\n}\n",
            "name": "PraxisCombat.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugCombat'",
                    "ItemName=\"Praxis Kit (Aug Combat)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisDefense.uc": {
            "body": "class PraxisDefense extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugDefense'\n\tItemName=\"Praxis Kit (Aug Defense)\"\n}\n",
            "name": "PraxisDefense.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugDefense'",
                    "ItemName=\"Praxis Kit (Aug Defense)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisDrone.uc": {
            "body": "class PraxisDrone extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugDrone'\n\tItemName=\"Praxis Kit (Aug Drone)\"\n}\n",
            "name": "PraxisDrone.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugDrone'",
                    "ItemName=\"Praxis Kit (Aug Drone)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisEMP.uc": {
            "body": "class PraxisEMP extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugEMP'\n\tItemName=\"Praxis Kit (Aug EMP)\"\n}\n",
            "name": "PraxisEMP.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugEMP'",
                    "ItemName=\"Praxis Kit (Aug EMP)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisEnviro.uc": {
            "body": "class PraxisEnviro extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugEnviro'\n\tItemName=\"Praxis Kit (Aug Enviro)\"\n}\n",
            "name": "PraxisEnviro.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugEnviro'",
                    "ItemName=\"Praxis Kit (Aug Enviro)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisHealing.uc": {
            "body": "class PraxisHealing extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'OpenDX.AugHealing2'\n\tItemName=\"Praxis Kit (Aug Modified Healing)\"\n}\n",
            "name": "PraxisHealing.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'OpenDX.AugHealing2'",
                    "ItemName=\"Praxis Kit (Aug Modified Healing)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisHeroHealth.uc": {
            "body": "class PraxisHeroHealth extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisPerk=\"PerkHero\"\n\tItemName=\"Praxis Kit (Perk Hero Health)\"\n}\n",
            "name": "PraxisHeroHealth.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisPerk=\"PerkHero\"",
                    "ItemName=\"Praxis Kit (Perk Hero Health)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisIcarus.uc": {
            "body": "class PraxisIcarus extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'OpenDX.AugIcarus'\n\tItemName=\"Praxis Kit (Aug Icarus Landing)\"\n}\n",
            "name": "PraxisIcarus.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'OpenDX.AugIcarus'",
                    "ItemName=\"Praxis Kit (Aug Icarus Landing)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisIcarusPerk.uc": {
            "body": "class PraxisIcarusPerk extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisPerk=\"PerkIcarus\"\n\tItemName=\"Praxis Kit (Perk Icarus Landing)\"\n}\n",
            "name": "PraxisIcarusPerk.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisPerk=\"PerkIcarus\"",
                    "ItemName=\"Praxis Kit (Perk Icarus Landing)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisKillswitch.uc": {
            "body": "class PraxisKillswitch extends PraxisKit;\n\n\ndefaultproperties\n{\n\tbResetAugSystem=True\n\tbResetPerks=True\n\tItemName=\"Praxis Kit (Total Killswitch - REMOVES ALL PERKS AND AUGS)\"\n}\n",
            "name": "PraxisKillswitch.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bResetAugSystem=True",
                    "bResetPerks=True",
                    "ItemName=\"Praxis Kit (Total Killswitch - REMOVES ALL PERKS AND AUGS)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 10,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisKit.uc": {
            "body": "//=============================================================================\n// Pickup class that can be set to give any aug.\n//=============================================================================\nclass PraxisKit extends DeusExPickup;\n\n#exec TEXTURE IMPORT NAME=\"PraxisTex1\" FILE=\"Textures\\Praxis1.pcx\" GROUP=\"Skins\"\n\n#exec TEXTURE IMPORT NAME=\"LargeIconPraxis\" FILE=\"Textures\\LargeIconPraxis.pcx\" GROUP=Icons FLAGS=2\n#exec TEXTURE IMPORT NAME=\"BeltIconPraxis\" FILE=\"Textures\\BeltIconPraxis.pcx\" GROUP=Icons FLAGS=2\n\nvar() bool bResetAugSystem, bResetPerks;\n\nvar() class<Augmentation> PraxisAug;\nvar() string PraxisPerk;\n\nstate Activated\n{\n\tfunction Activate()\n\t{\n\t\t// can't turn it off\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tlocal DeusExPlayer player;\n\t\tlocal bool bUseUp;\n\t\t\tlocal int i;\n\t\t\t\n\t\tSuper.BeginState();\n\n\t\tplayer = DeusExPlayer(Owner);\n\t\tif (player != None)\n\t\t{\n\t\t\tif(bResetAugSystem)\n\t\t\t{\n\t\t\t\tif (Player.AugmentationSystem != None)\n\t\t\t\t{\n\t\t\t\t\tPlayer.AugmentationSystem.DeactivateAll();\n\t\t\t\t\tPlayer.AugmentationSystem.ResetAugmentations();\n\t\t\t\t\tPlayer.AugmentationSystem.Destroy();\n\t\t\t\t\tPlayer.AugmentationSystem = None;\n\t\t\t\t\tPlayer.ClientMessage(\"|P2Removing augmentations...\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (Player.AugmentationSystem == None)\n\t\t\t\t{\n\t\t\t\t\tPlayer.AugmentationSystem = Spawn(class'TCAugmentationManager', Player);\n\t\t\t\t\tPlayer.AugmentationSystem.CreateAugmentations(Player);\n\t\t\t\t\tPlayer.AugmentationSystem.AddDefaultAugmentations();        \n\t\t\t\t\tPlayer.AugmentationSystem.SetOwner(Player);     \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(bResetPerks)\n\t\t\t{\n\t\t\t\tPlayer.ClientMessage(\"|P2Resetting perks...\");\n\t\t\t\tfor(i=0;i<10;i++)\n\t\t\t\t\tTCPlayer(Player).RemovePerk(i);\n\t\t\t\tbUseUp=True;\n\t\t\t}\n\t\t\t\n\t\t\tif(PraxisAug != None)\n\t\t\t{\n\t\t\t\t\tbUseUp=True;\n\t\t\t\t\tplayer.AugmentationSystem.GivePlayerAugmentation(PraxisAug);\n\t\t\t\t\tplayer.AugmentationSystem.GivePlayerAugmentation(PraxisAug);\n\t\t\t}\n\t\t\t\n\t\t\tif(PraxisPerk != \"\")\n\t\t\t{\n\t\t\t\t\t\tTCPlayer(Player).GetPerk(PraxisPerk);\n\t\t\t\t\t\tbUseUp=True;\n\t\t\t}\n\t\t}\n\t\t\n\tif(bUseUp)\n\t\tUseOnce();\n\t}\nBegin:\n}\n\ndefaultproperties\n{\n     maxCopies=1\n     bCanHaveMultipleCopies=True\n     bActivatable=True\n     ItemName=\"Praxis Kit\"\n     M_Activated=\"\"\n     ItemArticle=\"a\"\n     PlayerViewOffset=(X=30.000000,Z=-12.000000)\n     PlayerViewMesh=LodMesh'DeusExItems.MedKit'\n     PickupViewMesh=LodMesh'DeusExItems.MedKit'\n     ThirdPersonMesh=LodMesh'DeusExItems.MedKit3rd'\n     LandSound=Sound'DeusExSounds.Generic.PlasticHit2'\n     Icon=Texture'AugIconDatalink_Small'\n     largeIcon=Texture'AugIconDatalink'\n     largeIconWidth=39\n     largeIconHeight=46\n     MultiSkins(0)=Texture'PraxisTex1'\n     Description=\"Contained the nano-data for augmentations.\"\n     beltDescription=\"PRAXIS\"\n     Mesh=LodMesh'DeusExItems.MedKit'\n     CollisionRadius=7.500000\n     CollisionHeight=1.000000\n     Mass=10.000000\n     Buoyancy=8.000000\n}\n",
            "name": "PraxisKit.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "maxCopies=1",
                    "bCanHaveMultipleCopies=True",
                    "bActivatable=True",
                    "ItemName=\"Praxis Kit\"",
                    "M_Activated=\"\"",
                    "ItemArticle=\"a\"",
                    "PlayerViewOffset=(X=30.000000,Z=-12.000000)",
                    "PlayerViewMesh=LodMesh'DeusExItems.MedKit'",
                    "PickupViewMesh=LodMesh'DeusExItems.MedKit'",
                    "ThirdPersonMesh=LodMesh'DeusExItems.MedKit3rd'",
                    "LandSound=Sound'DeusExSounds.Generic.PlasticHit2'",
                    "Icon=Texture'AugIconDatalink_Small'",
                    "largeIcon=Texture'AugIconDatalink'",
                    "largeIconWidth=39",
                    "largeIconHeight=46",
                    "MultiSkins(0)=Texture'PraxisTex1'",
                    "Description=\"Contained the nano-data for augmentations.\"",
                    "beltDescription=\"PRAXIS\"",
                    "Mesh=LodMesh'DeusExItems.MedKit'",
                    "CollisionRadius=7.500000",
                    "CollisionHeight=1.000000",
                    "Mass=10.000000",
                    "Buoyancy=8.000000"
                ],
                "exec": [
                    "#exec TEXTURE IMPORT NAME=\"PraxisTex1\" FILE=\"Textures\\Praxis1.pcx\" GROUP=\"Skins\"",
                    "#exec TEXTURE IMPORT NAME=\"LargeIconPraxis\" FILE=\"Textures\\LargeIconPraxis.pcx\" GROUP=Icons FLAGS=2",
                    "#exec TEXTURE IMPORT NAME=\"BeltIconPraxis\" FILE=\"Textures\\BeltIconPraxis.pcx\" GROUP=Icons FLAGS=2"
                ],
                "extends": "DeusExPickup",
                "functions": {
                    "Activate": {
                        "body": "{\n\t\t// can't turn it off\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Activate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BeginState": {
                        "body": "{\n\t\t\t\n\t\tSuper.BeginState();\n\n\t\tplayer = DeusExPlayer(Owner);\n\t\tif (player != None)\n\t\t{\n\t\t\tif(bResetAugSystem)\n\t\t\t{\n\t\t\t\tif (Player.AugmentationSystem != None)\n\t\t\t\t{\n\t\t\t\t\tPlayer.AugmentationSystem.DeactivateAll();\n\t\t\t\t\tPlayer.AugmentationSystem.ResetAugmentations();\n\t\t\t\t\tPlayer.AugmentationSystem.Destroy();\n\t\t\t\t\tPlayer.AugmentationSystem = None;\n\t\t\t\t\tPlayer.ClientMessage(\"|P2Removing augmentations...\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (Player.AugmentationSystem == None)\n\t\t\t\t{\n\t\t\t\t\tPlayer.AugmentationSystem = Spawn(class'TCAugmentationManager', Player);\n\t\t\t\t\tPlayer.AugmentationSystem.CreateAugmentations(Player);\n\t\t\t\t\tPlayer.AugmentationSystem.AddDefaultAugmentations();        \n\t\t\t\t\tPlayer.AugmentationSystem.SetOwner(Player);     \n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(bResetPerks)\n\t\t\t{\n\t\t\t\tPlayer.ClientMessage(\"|P2Resetting perks...\");\n\t\t\t\tfor(i=0;i<10;i++)\n\t\t\t\t\tTCPlayer(Player).RemovePerk(i);\n\t\t\t\tbUseUp=True;\n\t\t\t}\n\t\t\t\n\t\t\tif(PraxisAug != None)\n\t\t\t{\n\t\t\t\t\tbUseUp=True;\n\t\t\t\t\tplayer.AugmentationSystem.GivePlayerAugmentation(PraxisAug);\n\t\t\t\t\tplayer.AugmentationSystem.GivePlayerAugmentation(PraxisAug);\n\t\t\t}\n\t\t\t\n\t\t\tif(PraxisPerk != \"\")\n\t\t\t{\n\t\t\t\t\t\tTCPlayer(Player).GetPerk(PraxisPerk);\n\t\t\t\t\t\tbUseUp=True;\n\t\t\t}\n\t\t}\n\t\t\n\tif(bUseUp)\n\t\tUseOnce();\n\t}",
                        "locals": [
                            "local DeusExPlayer player;",
                            "local bool bUseUp;",
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "BeginState",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 108,
                "replication": "",
                "states": [],
                "variables": [
                    "var() bool bResetAugSystem, bResetPerks;",
                    "var() class<Augmentation> PraxisAug;",
                    "var() string PraxisPerk;"
                ]
            }
        },
        "PraxisMagnet.uc": {
            "body": "class PraxisMagnet extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'OpenDX.AugMagnet'\n\tItemName=\"Praxis Kit (Aug Magnet)\"\n}\n",
            "name": "PraxisMagnet.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'OpenDX.AugMagnet'",
                    "ItemName=\"Praxis Kit (Aug Magnet)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisMediAura.uc": {
            "body": "class PraxisMediAura extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'OpenDX.AugMediAura'\n\tItemName=\"Praxis Kit (Aug Medical Aura)\"\n}\n",
            "name": "PraxisMediAura.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'OpenDX.AugMediAura'",
                    "ItemName=\"Praxis Kit (Aug Medical Aura)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisMediAuraPerk.uc": {
            "body": "class PraxisMediAuraPerk extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisPerk=\"PerkMediAura\"\n\tItemName=\"Praxis Kit (Perk Medical Aura)\"\n}\n",
            "name": "PraxisMediAuraPerk.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisPerk=\"PerkMediAura\"",
                    "ItemName=\"Praxis Kit (Perk Medical Aura)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisMuscle.uc": {
            "body": "class PraxisMuscle extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugMuscle'\n\tItemName=\"Praxis Kit (Aug Muscle)\"\n}\n",
            "name": "PraxisMuscle.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugMuscle'",
                    "ItemName=\"Praxis Kit (Aug Muscle)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisNuke.uc": {
            "body": "class PraxisNuke extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisPerk=\"PerkNuke\"\n\tItemName=\"Praxis Kit (Perk Nuke)\"\n}\n",
            "name": "PraxisNuke.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisPerk=\"PerkNuke\"",
                    "ItemName=\"Praxis Kit (Perk Nuke)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisRadar.uc": {
            "body": "class PraxisRadar extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'OpenDX.AugRadar';\n\tItemName=\"Praxis Kit (Aug Radar)\"\n}\n",
            "name": "PraxisRadar.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'OpenDX.AugRadar';",
                    "ItemName=\"Praxis Kit (Aug Radar)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisRadarTrans.uc": {
            "body": "class PraxisRadarTrans extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugRadarTrans'\n\tItemName=\"Praxis Kit (Aug RadarTrans)\"\n}\n",
            "name": "PraxisRadarTrans.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugRadarTrans'",
                    "ItemName=\"Praxis Kit (Aug RadarTrans)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisRepel.uc": {
            "body": "class PraxisRepel extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'OpenDX.AugRepel'\n\tItemName=\"Praxis Kit (Aug Repulsion)\"\n}\n",
            "name": "PraxisRepel.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'OpenDX.AugRepel'",
                    "ItemName=\"Praxis Kit (Aug Repulsion)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisShield.uc": {
            "body": "class PraxisShield extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugShield'\n\tItemName=\"Praxis Kit (Aug Shield)\"\n}\n",
            "name": "PraxisShield.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugShield'",
                    "ItemName=\"Praxis Kit (Aug Shield)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisSkullgun.uc": {
            "body": "class PraxisSkullgun extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'OpenDX.AugSkullgun'\n\tItemName=\"Praxis Kit (Aug Skullgun)\"\n}\n",
            "name": "PraxisSkullgun.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'OpenDX.AugSkullgun'",
                    "ItemName=\"Praxis Kit (Aug Skullgun)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisSpeed.uc": {
            "body": "class PraxisSpeed extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugSpeed'\n\tItemName=\"Praxis Kit (Aug Speed)\"\n}\n",
            "name": "PraxisSpeed.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugSpeed'",
                    "ItemName=\"Praxis Kit (Aug Speed)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisSpy.uc": {
            "body": "class PraxisSpy extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisPerk=\"PerkSpy\"\n\tItemName=\"Praxis Kit (Perk Spy)\"\n}\n",
            "name": "PraxisSpy.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisPerk=\"PerkSpy\"",
                    "ItemName=\"Praxis Kit (Perk Spy)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisStealth.uc": {
            "body": "class PraxisStealth extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugStealth'\n\tItemName=\"Praxis Kit (Aug Stealth)\"\n}\n",
            "name": "PraxisStealth.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugStealth'",
                    "ItemName=\"Praxis Kit (Aug Stealth)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisTakedown.uc": {
            "body": "class PraxisTakedown extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'AugTakedown'\n\tItemName=\"Praxis Kit (Aug Takedown)\"\n}\n",
            "name": "PraxisTakedown.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'AugTakedown'",
                    "ItemName=\"Praxis Kit (Aug Takedown)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisTarget.uc": {
            "body": "class PraxisTarget extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugTarget'\n\tItemName=\"Praxis Kit (Aug Target)\"\n}\n",
            "name": "PraxisTarget.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugTarget'",
                    "ItemName=\"Praxis Kit (Aug Target)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PraxisVision.uc": {
            "body": "class PraxisVision extends PraxisKit;\n\n\ndefaultproperties\n{\n\tPraxisAug=class'DeusEx.AugVision'\n\tItemName=\"Praxis Kit (Aug Vision)\"\n}\n",
            "name": "PraxisVision.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PraxisAug=class'DeusEx.AugVision'",
                    "ItemName=\"Praxis Kit (Aug Vision)\""
                ],
                "exec": [],
                "extends": "PraxisKit",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "SSTimer.uc": {
            "body": "//================================================================================\n// External time-keeper for Sharpshooter\n//================================================================================\nclass SSTimer extends Actor;\n\nvar Sharpshooter myGame;\nvar int SSCount, SSDefaultCount;\n\nfunction Timer()\n{\n\tlocal TCPlayer TCP;\n\t\n\tSSCount--;\n\tif(SSCount == 5)\n\t{\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\tTCP.Notif(\"Five seconds remaining.\");\n\t}\n\tif(SSCount <= 0)\n\t{\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\tTCP.Notif(\"New round!\");\n\t\tSSCount = SSDefaultCount;\n\t\tmyGame.RollItems();\n\t}\n}\n\ndefaultproperties\n{\n    bHidden=true\n}\n",
            "name": "SSTimer.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=true"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "Timer": {
                        "body": "{\n\t\n\tSSCount--;\n\tif(SSCount == 5)\n\t{\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\tTCP.Notif(\"Five seconds remaining.\");\n\t}\n\tif(SSCount <= 0)\n\t{\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\tTCP.Notif(\"New round!\");\n\t\tSSCount = SSDefaultCount;\n\t\tmyGame.RollItems();\n\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 32,
                "replication": "",
                "states": [],
                "variables": [
                    "var Sharpshooter myGame;",
                    "var int SSCount, SSDefaultCount;"
                ]
            }
        },
        "Sharpshooter.uc": {
            "body": "//=============================================================================\n// yee\n//=============================================================================\nclass Sharpshooter expands TCDeathmatch;\nvar int SSCount, SSDefaultCount;\nfunction PostBeginPlay()\n{\nlocal DeusExWeapon w;\nlocal int r;\nlocal SSTimer SST;\n\n    super.PostBeginPlay();\n\t\n\t\n\tLog(Settings.SSRoundDelay$\" round timer.\");\n\tSST = Spawn(class'SSTimer');\n\tSST.SetTimer(1,true);\n\tSST.SSCount = Settings.SSRoundDelay;\n\tSST.SSDefaultCount = Settings.SSRoundDelay;\n\tSST.myGame = Self;\n\tForeach AllActors(class'DeusExWeapon',w)\n\t{\t\n\t\t\tw.Destroy();\n\t}\n}\n\nfunction RollItems()\n{\n\tlocal TCPlayer TCP;\n\tlocal class<Inventory> GiveClass;\n\tlocal int Passes, r;\n\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t{\n\t\tif(Settings.bHealTimer)\n\t\t\tTCP.HealPlayer(15, True);\n\t\t\t\n\t\tRemovePlayerInventory(TCP);\n\t\twhile(Passes < 3)\n\t\t{\n\t\t\tif(Passes == 0) r = RandRange(0,10);\n\t\t\tif(Passes == 1) r = RandRange(11, 20);\n\t\t\tif(Passes == 2) r = RandRange(21,29);\n\t\t\tPasses++;\n\t\t\t\n\t\t\tGiveClass = class<inventory>( DynamicLoadObject( Settings.SSWeapons[r], class'Class' ) );\n\t\t\tif( GiveClass!=None )\n\t\t\t\tSilentAdd(GiveClass, TCP);\n\t\t\telse\n\t\t\t\tLog(\"Error in TCControls.SSWeapons array: \"$r$\" slot could not be spawned.\");\n\t\t}\n\t\tPasses = 0;\n\t}\n}\n\nfunction SilentAdd(class<inventory> addClass, DeusExPlayer addTarget)\n{ \n\tlocal Inventory anItem;\n\t\n\tif(Settings.bMethodOne)\n\t{\n\t\tanItem = Spawn(addClass,,,addTarget.Location); \n\t\tanItem.SpawnCopy(addTarget);\n\t\tanItem.Destroy();\n\t}\n\telse\n\t{\n\t\tanItem.Instigator = addTarget; \n\t\tanItem.GotoState('Idle2'); \n\t\tanItem.bHeldItem = true; \n\t\tanItem.bTossedOut = false; \n\t\t\n\t\tif(Weapon(anItem) != None) \n\t\t\tWeapon(anItem).GiveAmmo(addTarget); \n\t\tanItem.GiveTo(addTarget);\n\t}\n}\n\nfunction RemovePlayerInventory(DeusExPlayer Player)\n{\n   local Inventory item, nextItem, lastItem;\n\n   if (Player.Inventory != None)\n   {\n      item = Player.Inventory;\n      nextItem = item.Inventory;\n      lastItem = item;\n\n      do\n      {\n         if ((item != None) && item.bDisplayableInv || item.IsA('Ammo'))\n         {\n            // make sure everything is turned off\n            if (item.IsA('DeusExWeapon'))\n            {\n               DeusExWeapon(item).ScopeOff();\n               DeusExWeapon(item).LaserOff();\n            }\n            if (item.IsA('DeusExPickup'))\n            {\n               if (DeusExPickup(item).bActive)\n                  DeusExPickup(item).Activate();\n            }\n\n            if (item.IsA('ChargedPickup'))\n               Player.RemoveChargedDisplay(ChargedPickup(item));\n\n            Player.DeleteInventory(item);\n            item.Destroy();\n            item = Player.Inventory;\n         }\n         else\n            item = nextItem;\n\n         if (item != None)\n            nextItem = item.Inventory;\n      }\n      until ((item == None) || (item == lastItem));\n   }\n}\n\ndefaultproperties\n{\n\tVictoryConString1=\"|P1Hit the score limit! (|P3 \"\n    VictoryConString2=\" |P1) -|P2 (Weapons randomized through the match)\"\n    TimeLimitString1=\"|P1Score the most! (|P3 \"\n    TimeLimitString2=\" |P1) -|P2 (Weapons randomized through the match)\"\n\tGTName=\"Sharpshooter (WIP)\"\n}\n",
            "name": "Sharpshooter.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "VictoryConString1=\"|P1Hit the score limit! (|P3 \"",
                    "VictoryConString2=\" |P1) -|P2 (Weapons randomized through the match)\"",
                    "TimeLimitString1=\"|P1Score the most! (|P3 \"",
                    "TimeLimitString2=\" |P1) -|P2 (Weapons randomized through the match)\"",
                    "GTName=\"Sharpshooter (WIP)\""
                ],
                "exec": [],
                "extends": "TCDeathmatch",
                "functions": {
                    "PostBeginPlay": {
                        "body": "{\n\n    super.PostBeginPlay();\n\t\n\t\n\tLog(Settings.SSRoundDelay$\" round timer.\");\n\tSST = Spawn(class'SSTimer');\n\tSST.SetTimer(1,true);\n\tSST.SSCount = Settings.SSRoundDelay;\n\tSST.SSDefaultCount = Settings.SSRoundDelay;\n\tSST.myGame = Self;\n\tForeach AllActors(class'DeusExWeapon',w)\n\t{\t\n\t\t\tw.Destroy();\n\t}\n}",
                        "locals": [
                            "local DeusExWeapon w;",
                            "local int r;",
                            "local SSTimer SST;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "RemovePlayerInventory": {
                        "body": "{\n\n   if (Player.Inventory != None)\n   {\n      item = Player.Inventory;\n      nextItem = item.Inventory;\n      lastItem = item;\n\n      do\n      {\n         if ((item != None) && item.bDisplayableInv || item.IsA('Ammo'))\n         {\n            // make sure everything is turned off\n            if (item.IsA('DeusExWeapon'))\n            {\n               DeusExWeapon(item).ScopeOff();\n               DeusExWeapon(item).LaserOff();\n            }\n            if (item.IsA('DeusExPickup'))\n            {\n               if (DeusExPickup(item).bActive)\n                  DeusExPickup(item).Activate();\n            }\n\n            if (item.IsA('ChargedPickup'))\n               Player.RemoveChargedDisplay(ChargedPickup(item));\n\n            Player.DeleteInventory(item);\n            item.Destroy();\n            item = Player.Inventory;\n         }\n         else\n            item = nextItem;\n\n         if (item != None)\n            nextItem = item.Inventory;\n      }\n      until ((item == None) || (item == lastItem));\n   }\n}",
                        "locals": [
                            "local Inventory item, nextItem, lastItem;"
                        ],
                        "modifiers": [],
                        "name": "RemovePlayerInventory",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "Player"
                            ]
                        ],
                        "return": ""
                    },
                    "RollItems": {
                        "body": "{\n\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t{\n\t\tif(Settings.bHealTimer)\n\t\t\tTCP.HealPlayer(15, True);\n\t\t\t\n\t\tRemovePlayerInventory(TCP);\n\t\twhile(Passes < 3)\n\t\t{\n\t\t\tif(Passes == 0) r = RandRange(0,10);\n\t\t\tif(Passes == 1) r = RandRange(11, 20);\n\t\t\tif(Passes == 2) r = RandRange(21,29);\n\t\t\tPasses++;\n\t\t\t\n\t\t\tGiveClass = class<inventory>( DynamicLoadObject( Settings.SSWeapons[r], class'Class' ) );\n\t\t\tif( GiveClass!=None )\n\t\t\t\tSilentAdd(GiveClass, TCP);\n\t\t\telse\n\t\t\t\tLog(\"Error in TCControls.SSWeapons array: \"$r$\" slot could not be spawned.\");\n\t\t}\n\t\tPasses = 0;\n\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;",
                            "local class<Inventory> GiveClass;",
                            "local int Passes, r;"
                        ],
                        "modifiers": [],
                        "name": "RollItems",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SilentAdd": {
                        "body": "{ \n\t\n\tif(Settings.bMethodOne)\n\t{\n\t\tanItem = Spawn(addClass,,,addTarget.Location); \n\t\tanItem.SpawnCopy(addTarget);\n\t\tanItem.Destroy();\n\t}\n\telse\n\t{\n\t\tanItem.Instigator = addTarget; \n\t\tanItem.GotoState('Idle2'); \n\t\tanItem.bHeldItem = true; \n\t\tanItem.bTossedOut = false; \n\t\t\n\t\tif(Weapon(anItem) != None) \n\t\t\tWeapon(anItem).GiveAmmo(addTarget); \n\t\tanItem.GiveTo(addTarget);\n\t}\n}",
                        "locals": [
                            "local Inventory anItem;"
                        ],
                        "modifiers": [],
                        "name": "SilentAdd",
                        "native": false,
                        "param": [
                            [
                                "class<inventory>",
                                "addClass"
                            ],
                            [
                                "DeusExPlayer",
                                "addTarget"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 130,
                "replication": "",
                "states": [],
                "variables": [
                    "var int SSCount, SSDefaultCount;"
                ]
            }
        },
        "TCAugmentationDisplayWindow.uc": {
            "body": "//=============================================================================\n// AugmentationDisplayWindow.\n//=============================================================================\nclass TCAugmentationDisplayWindow extends CBPAugmentationDisplayWindow;\n\nvar Color colYellow, colPurple;\nvar Color\tcolBlue1, colWhite;\nvar Color\tcolGreen1, colLtGreen;\nvar Color\tcolRed1, colLtRed;\nvar string keyFreeMode, keyPersonView, keyMainMenu, keySkills;\n\nfunction TCPlayer getPlayer()\n{\n   return TCPlayer(player);\n}\n\nfunction bool GetAllies(TCPlayer POne, TCPlayer PTwo)\n{\n\tif(TCDeathmatch(player.DXGame) != None)\n\t\treturn TCDeathmatch(player.DXGame).ArePlayersAllied2(POne,PTwo);\n\t\t\n\tif(TCTeam(player.DXGame) != None)\n\t\treturn TCTeam(player.DXGame).ArePlayersAllied(POne,PTwo);\t\n}\n\n//EDIT: Added new check for \"Smell\" system\nfunction bool IsHeatSource(Actor A)\n{\n\tif(A.IsA('ODXHiddenActor')) //Check this first, so it doesnt reach the \"Hidden\" check below\n\t\treturn True;\n\t\t\n   if ((A.bHidden) && (Player.Level.NetMode != NM_Standalone))\n      return False;\n   if (A.IsA('Pawn'))\n   {\n      if (A.IsA('ScriptedPawn'))\n         return True;\n      else if ( (A.IsA('DeusExPlayer')) && (A != Player) )//DEUS_EX AMSD For multiplayer.\n         return True;\n      return False;\n   }\n\telse if (A.IsA('DeusExCarcass'))\n\t\treturn True;   \n\telse if (A.IsA('FleshFragment'))\n\t\treturn True;\n   else\n\t\treturn False;\n}\n\nfunction GetTargetReticleColor( Actor target, out Color xcolor )\n{\n\tlocal DeusExPlayer safePlayer;\n\tlocal AutoTurret turret;\n\tlocal bool bDM, bTeamDM;\n\tlocal Vector dist;\n\tlocal float SightDist;\n\tlocal DeusExWeapon w;\n\tlocal int team;\n\tlocal String titleString;\n\tlocal TCControls TCC;\n\tlocal string str;\n\tlocal TCStorageBox TCS;\n\tlocal string teamstr;\n\tlocal TCPRI plPRI, tPRI;\n\tlocal TCPlayer tcTarg, tcSelf;\n\tlocal ScriptedPawn sPawn;\n\n\tbDM = (TCDeathmatch(player.DXGame) != None);\n\tbTeamDM = (TCTeam(player.DXGame) != None);\n\ttcSelf = GetPlayer();\n\tif(tcSelf != None)\n\t\tplPRI = TCPRI(tcSelf.PlayerReplicationInfo);\n\tsPawn = ScriptedPawn(Target);\n\n\tif(plPRI == None) // tcSelf == none is implicit if this is true.\n\t{\n\t\txColor = colWhite;\n\t\treturn;\n\t}\n\n\tif ( sPawn != None )\n\t{\n\t\tif(tcSelf.HUDTYpe == HUD_Extended) //Shows all info\n\t\t{\n\t\t\ttargetPlayerName = sPawn.FamiliarName$\" (\"$Left(VSize(target.Location - Player.Location), Len(VSize(target.Location - Player.Location))-7)$\")\";\n\t\t\txcolor = colYellow;\n\t\t}\n\t\telse if(tcSelf.HUDTYpe == HUD_Basic) //Shows basic info\n\t\t{\n\t\t\ttargetPlayerName = sPawn.FamiliarName;\n\t\t\txcolor = colYellow;\n\t\t}\n\t\telse if(tcSelf.HUDTYpe == HUD_Unified) //Masks bots as players\n\t\t{\n\t\t\ttargetPlayerName = sPawn.FamiliarName;\n\t\t\txcolor = colRed;\n\t\t}\n\t\telse if(tcSelf.HUDTYpe == HUD_Original) //As original DX, bots are friendlies, no name display\n\t\t{\n\t\t\ttargetPlayerName = \"\";\n\t\t\txcolor = colGreen;\n\t\t}\n\t\telse if(tcSelf.HUDTYpe == HUD_Off)\n\t\t\ttargetPlayerName = \"\";\n\t\t\t\n\t\ttargetPlayerTime = Player.Level.Timeseconds + targetPlayerDelay;\n\t\ttargetPlayerColor = xcolor;\n\t}\n\telse if ( Player.Level.NetMode != NM_Standalone )\t// Only do the rest in multiplayer\n\t{\n\t\tif ( target.IsA('TCStorageBox') )\n\t\t{\n\t\t\tTCS = TCStorageBox(Target);\n\t\t\tif (bTeamDM)\n\t\t\t{ \n\t\t\t\tif(GetAllies(TCPlayer(TCS.Owner),tcSelf) || tcSelf == TCS.Owner)\n\t\t\t\t\txcolor = colGreen;\n\t\t\t\telse\n\t\t\t\t\txcolor = colRed;\n\t\t\t\t\t\n\t\t\t\tif(TCS.myName != \"\")\n\t\t\t\t\tstr = TCS.myName;\n\t\t\t\telse str = TCS.OwnerName$\"'s storage\";\n\t\t\t\ttargetPlayerName = str;\n\t\t\t\ttargetPlayerTime = Player.Level.Timeseconds + targetPlayerDelay;\n\t\t\t\ttargetPlayerColor = xcolor;\n\t\t\t}\n\t\t\telse if(bDM)\n\t\t\t{\n\t\t\t\tif(GetAllies(TCPlayer(TCS.Owner),tcSelf) || tcSelf == TCS.Owner)\n\t\t\t\t\txcolor = colGreen;\n\t\t\t\telse\n\t\t\t\t\txcolor = colRed;\n\t\t\t\t\n\t\t\t\tif(TCS.myName != \"\")\n\t\t\t\t\tstr = TCS.myName;\n\t\t\t\telse str = TCS.OwnerName$\"'s storage\";\n\t\t\t\ttargetPlayerName = str;\n\t\t\t\ttargetPlayerTime = Player.Level.Timeseconds + targetPlayerDelay;\n\t\t\t\ttargetPlayerColor = xcolor;\n\t\t\t}\n\t\t}\n\t\telse if ( target.IsA('DeusExPlayer') && (target != player) )\t// Other players IFF\n\t\t{\n\t\t\ttcTarg = TCPlayer(Target);\n\t\t\tif(tcTarg != none)\n\t\t\t\ttPRI = TCPRI(tcTarg.PlayerReplicationInfo);\n\n\t\t\tif(tPRI != None)\n\t\t\t{\n\t\t\t\tif (bTeamDM)\n\t\t\t\t{ \n\t\t\t\t\tstr = tPRI.PlayerName;\n\n\t\t\t\t\tif(tPRI.bSpy || GetAllies(tcTarg,tcSelf))\n\t\t\t\t\t{\n\t\t\t\t\t\tTargetPlayerHealthString = \" (\" $ 100 * (tcTarg.Health / tcTarg.Default.Health) $ \"%)\";\n\t\t\t\t\t\txcolor = colGreen;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\txcolor = colRed;\n\t\t\t\t\t\n\t\t\t\t\ttargetPlayerName = str;\n\t\t\t\t}\n\t\t\t\telse if(bDM && target.Style != STY_Translucent) //Kaiz0r - Adding DM Stuff here\n\t\t\t\t{\t\t\t\t\t\n\t\t\t\t\tif(tcSelf.HUDTYpe == HUD_Extended) //Shows all info\n\t\t\t\t\t{\n\t\t\t\t\t\tif(plPRI.TeamNamePRI == \"\") //If not in team\n\t\t\t\t\t\t\txcolor = colPurple;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(plPRI.TeamNamePRI != \"\") //if WE are in a team\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(tPRI.bSpy || GetAllies(tcTarg,tcSelf))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTargetPlayerHealthString = \" (\" $ 100 * (tcTarg.Health / tcTarg.Default.Health) $ \"%)\";\n\t\t\t\t\t\t\t\txcolor = colGreen;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\txcolor = colRed;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstr = tPRI.PlayerName;\n\t\t\t\t\t\t\n\t\t\t\t\t\tstr = str$\" (\"$Left(VSize(target.Location - Player.Location), Len(VSize(target.Location - Player.Location))-7)$\")\";\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(tPRI.TeamNamePRI != \"\")\n\t\t\t\t\t\t\tstr = str$\" |C616200#|P7\"$tPRI.TeamNamePRI;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\ttargetPlayerName = str;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(tcSelf.HUDTYpe == HUD_Basic) //Shows basic info\n\t\t\t\t\t{\n\t\t\t\t\t\tif(tPRI.TeamNamePRI == \"\")//If not in team\n\t\t\t\t\t\t\txcolor = colPurple;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(tPRI.TeamNamePRI != \"\") //if WE are in a team\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(GetAllies(tcTarg,tcSelf))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTargetPlayerHealthString = \" (\" $ 100 * (tcTarg.Health / tcTarg.Default.Health) $ \"%)\";\n\t\t\t\t\t\t\t\txcolor = colGreen;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\txcolor = colRed;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstr = tPRI.PlayerName;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(tPRI.TeamNamePRI != \"\")\n\t\t\t\t\t\t\tstr = str$\" |C616200#|P7\"$TCPRI(TCPlayer(Target).PlayerReplicationInfo).TeamNamePRI;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\ttargetPlayerName = str;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(tcSelf.HUDTYpe == HUD_Unified || tcSelf.HUDTYpe == HUD_Original)\n\t\t\t\t\t{\n\t\t\t\t\t\ttargetPlayerName = tPRI.PlayerName;\n\t\t\t\t\t\txcolor = colRed;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(tcSelf.HUDTYpe == HUD_Off)\n\t\t\t\t\t{\n\t\t\t\t\t\ttargetPlayerName = \"\";\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttargetPlayerTime = Player.Level.Timeseconds + targetPlayerDelay;\n\t\t\t\t\ttargetPlayerColor = xcolor;\n\t\t\t\t}\n\n\t\t\t\tSightDist = VSize(target.Location - Player.Location);\n\t\t\t\t// This was one of the errors - the brackets prioritised the TeamDMGame cast over the bTeamDM check.\n\t\t\t\tif\t(((bTeamDM) && TeamDMGame(player.DXGame).ArePlayersAllied(DeusExPlayer(target),player))\n\t\t\t\t||\t(target.Style != STY_Translucent)\n\t\t\t\t||\t(bVisionActive && (Sightdist <= visionLevelvalue)) )\n\t\t\t\t{\n\t\t\t\t\t//targetPlayerName = DeusExPlayer(target).PlayerReplicationInfo.PlayerName;\n\t\t\t\t\t// DEUS_EX AMSD Show health of enemies with the target active.\n\t\t\t\t\tif (bTargetActive)\n\t\t\t\t\t\tTargetPlayerHealthString = \"(\" $ 100 * (tcTarg.Health / tcTarg.Default.Health) $ \"%)\";\n\n\t\t\t\t\ttargetOutOfRange = False;\n\t\t\t\t\tw = DeusExWeapon(player.Weapon);\n\t\t\t\t\tif (( w != None ) && ( xcolor != colGreen ))\n\t\t\t\t\t{\n\t\t\t\t\t\tdist = player.Location - target.Location;\n\t\t\t\t\t\tif ( VSize(dist) > w.maxRange ) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!(( WeaponAssaultGun(w) != None ) && ( Ammo20mm(WeaponAssaultGun(w).AmmoType) != None )))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttargetRangeTime = Player.Level.Timeseconds + 0.1;\n\t\t\t\t\t\t\t\ttargetOutOfRange = True;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttargetPlayerTime = Player.Level.Timeseconds + targetPlayerDelay;\n\t\t\t\t\ttargetPlayerColor = xcolor;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\txcolor = colWhite;\t// cloaked enemy\n\t\t}\n\t\telse if (target.IsA('ThrownProjectile'))\t// Grenades IFF\n\t\t{\n\t\t\tif ( ThrownProjectile(target).bDisabled )\n\t\t\t\txcolor = colWhite;\n\t\t\telse if ( (GetAllies(TCPlayer(target.Owner),tcSelf)) || \n\t\t\t\t(player == TCPlayer(target.Owner)) )\n\t\t\t\txcolor = colGreen;\n\t\t\telse\n\t\t\t\txcolor = colRed;\n\t\t}\n\t\telse if ( target.IsA('TCAutoTurret') || target.IsA('AutoTurretGun') ) // Autoturrets IFF\n\t\t{\n\t\t\tif ( target.IsA('AutoTurretGun') )\n\t\t\t{\n\t\t\t\tteam = AutoTurretGun(target).team;\n\t\t\t\ttitleString = AutoTurretGun(target).titleString;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tteam = AutoTurret(target).team;\n\t\t\t\ttitleString = AutoTurret(target).titleString;\n\t\t\t\tteamstr = TCPRI(TCPlayer(TCAutoTurret(target).safeTarget).PlayerReplicationInfo).TeamNamePRI;\n\t\t\t}\n\t\t\tif ( (TCDeathmatch(player.dxgame) != none && team == plPRI.playerid) || TCTeam(player.dxgame) != none && team == plPRI.team)\n\t\t\t\txcolor = colGreen;\n\t\t\telse if (team == -1)\n\t\t\t\txcolor = colWhite;\n\t\t\telse\n\t\t\t\txcolor = colRed;\n\n\t\t\ttargetPlayerName = titleString$teamstr;\n\t\t\ttargetOutOfRange = False;\n\t\t\ttargetPlayerTime = Player.Level.Timeseconds + targetPlayerDelay;\n\t\t\ttargetPlayerColor = xcolor;\n\t\t}\n\t\telse if ( target.IsA('ComputerSecurity'))\n\t\t{\n\t\t\tif ( ComputerSecurity(target).team == -1 )\n\t\t\t\txcolor = colWhite;\n\t\t\telse if ( (bTeamDM && GetAllies(TCPlayer(target.Owner), tcSelf)) ||\n\t\t\t\t  (!bTeamDM && (player.PlayerReplicationInfo.PlayerID == team || \n\t\t\t\t  GetAllies(TCPlayer(target.Owner), tcSelf))) )\n\t\t\t\txcolor = colGreen;\n\t\t\telse\n\t\t\t\txcolor = colRed;\n\t\t}\n\t\telse if ( target.IsA('SecurityCamera'))\n\t\t{\n\t\t\tif ( !SecurityCamera(target).bActive )\n\t\t\t\txcolor = colWhite;\n\t\t\telse if ( SecurityCamera(target).team == -1 )\n\t\t\t\txcolor = colWhite;\n\t\t\telse if ( (bTeamDM && GetAllies(TCPlayer(target.Owner), tcSelf)) ||\n\t\t\t\t  (!bTeamDM && (player.PlayerReplicationInfo.PlayerID == team || \n\t\t\t\t  GetAllies(TCPlayer(target.Owner), tcSelf))) )\n\t\t\t\txcolor = colGreen;\n\t\t\telse\n\t\t\t\txcolor = colRed;\n\t\t}\n\t}\n}\n\nfunction DrawRemoteInventory(GC gc, TCPlayer mmp)\n{\n\tlocal int xoff, yoff, ytoff, i;\n\n\tyoff = height - 48;\n\tytoff = yoff + 32;\n\txoff = width - 54;\n\n\tgc.SetStyle(DSTY_Masked);\n\tgc.SetTileColorRGB(255, 255, 255);\n\n\tgc.SetAlignments(HALIGN_Center, VALIGN_Center);\n\tgc.EnableWordWrap(false);\n\tgc.SetTextColorRGB(255, 255, 255);\n\tgc.SetFont(Font'FontTiny');\n\n\t// draw biocells\n\tif (mmp.TargetBioCells > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconBioCell');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetBioCells);\n\t}\n\txoff -= 48;\n\t// draw medkit\n\tif (mmp.TargetMedkits > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconMedKit');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetMedkits);\t\n\t}\n\txoff -= 48;\n\t// draw multitool\n\tif (mmp.TargetMultitools > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconMultitool');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetMultitools);\n\t}\n\txoff -= 48;\n\t// draw lockpick\n\tif (mmp.TargetLockpicks > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconLockPick');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetLockpicks);\n\t}\n\txoff -= 48;\n\t// draw lam\n\tif (mmp.TargetLAMs > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconLAM');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetLAMs);\n\t}\n\n\txoff = 16;\n\n\t// draw weapons\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tif (mmp.TargetWeapons[i] != none)\n\t\t{\n\t\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, mmp.TargetWeapons[i].default.Icon);\n\t\t}\n\t\txoff += 48;\n\t}\n\n\t// draw emp\n\tif (mmp.TargetEMPs > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconEMPGrenade');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetEMPs);\n\t}\n\txoff += 48;\n\t// draw gas\n\tif (mmp.TargetGGs > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconGasGrenade');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetGGs);\n\t}\n}\n\nfunction Texture GetGridTexture(Texture tex)\n{\n\tif (tex == None)\n\t\treturn Texture'BlackMaskTex';\n\telse if (tex == Texture'BlackMaskTex')\n\t\treturn Texture'BlackMaskTex';\n\telse if (tex == Texture'GrayMaskTex')\n\t\treturn Texture'BlackMaskTex';\n\telse if (tex == Texture'PinkMaskTex')\n\t\treturn Texture'BlackMaskTex';\n\telse if (VisionTargetStatus == VISIONENEMY)         \n      return Texture'Virus_SFX';\n   else if (VisionTargetStatus == VISIONALLY)\n\t\treturn Texture'Wepn_Prifle_SFX';\n   else if (VisionTargetStatus == VISIONNEUTRAL)\n      return Texture'WhiteStatic';\n   else\n      return Texture'WhiteStatic';\n}\n\nfunction NameAllViewedPlayers(GC gc, TCPlayer mmp)\n{\n    local Actor target;\n\tlocal TCPlayer P;\n\tlocal float x, y;\n\tlocal vector loc;\n\tlocal bool viewenemy;\n\n\tforeach mmp.VisibleCollidingActors(class'Actor', target, 3000.0, mmp.Location, false)\n\t{\n\t    if (target.IsA('TCPlayer') && (FacingActor(Pawn(target), mmp) > 0.0))\n        {\n            P = TCPlayer(target);\n            if (P.PlayerReplicationInfo.bIsSpectator || (!mmp.bSpecEnemies && P.PlayerReplicationInfo.Team != mmp.PlayerReplicationInfo.Team)) continue;\n            loc = P.Location;\n            loc.Z -= P.CollisionHeight + 10.0;\n            ConvertVectorToCoordinates(loc, x, y);\n            DrawPlayerName(gc, x, y, (mmp.PlayerReplicationInfo.Team == P.PlayerReplicationInfo.Team) && mmp.GameReplicationInfo.bTeamGame, P.PlayerReplicationInfo.PlayerName);\n        }\n    }\n}\n\nfunction DrawPlayerName(GC gc, float x, float y, bool sameteam, string pname)\n{\n    local float w, h;\n\n    gc.SetFont(Font'FontMenuSmall');\n    gc.SetStyle(DSTY_Translucent);\n    if (sameteam) gc.SetTextColor(colGreen);\n    else gc.SetTextColor(colRed);\n    gc.GetTextExtent(0, w, h, pname);\n    x -= w * 0.5;\n    y -= h * 0.5;\n\tgc.DrawText(x, y, w, h, pname);\n\tgc.SetStyle(DSTY_Normal);\n}\n\nfunction PostDrawWindow(GC gc)\n{\n\tlocal PlayerPawn pp;\n\tlocal TCPlayer mmp;\n\tlocal color col;\n\tlocal string str;\n\tlocal color colGold;\n\tlocal int tmpVisionLevel, tmpVisionLevelValue;\n\tlocal int VotePoints, mVP;\n\tlocal float xx;\n\tlocal actor wpTarget;\n\tlocal float infoX, infoY, infoW, infoH;\n\tlocal string strInfo;\n\tlocal int dist;\n\tlocal float offset;\n\tlocal vector centerLoc;\n\tlocal float centerX, centerY;\n\tlocal float markX, markY, markW, markH;\n\tlocal string markInfo;\n\tlocal TCPRI tPRI;\n\n\tpp = Player.GetPlayerPawn();\n\tif(TCPlayer(pp) != None)\n\t\tmmp = TCPlayer(pp);\n\tcolGold.R = 255;\n    colGold.G = 255;\n\n\tif(TCPRI(mmp.PlayerReplicationInfo) != None)\n\t\ttPRI = TCPRI(mmp.PlayerReplicationInfo);\n\t\t\n\tif(tPRI == None)\n\t\treturn;\n\t\n\t//BEGIN WP\n\tif(tPRI.wpTargetPRI != None)\n\t\twpTarget = tPRI.wpTargetPRI;\n\n\tif (wpTarget != None)\n\t{\n\t\tcenterLoc = wpTarget.Location;\n\n\t\tif (ConvertVectorToCoordinates(centerLoc, centerX, centerY))\n\t\t{\n\t\t\t// convert to meters\n\t\t\tdist = int(vsize(mmp.Location-wpTarget.Location)/52);\n\n\t\t\tif(tPRI.wpName != \"\")\n\t\t\t\tstrInfo = tPRI.wpName $ \" (\" $ dist $ \"m)\";\n\t\t\telse\n\t\t\t\tstrInfo = wpTarget.Tag $ \" (\" $ dist $ \"m)\";\n\n\t\t\tgc.SetFont(Font'FontMenuHeaders_DS');\n\t\t\tgc.GetTextExtent(0, infoW, infoH, strInfo);\n\n\t\t\tinfoX = centerX - 0.5*(infoW+12);\n\t\t\tinfoY = centerY - 0.5*(infoH+10);\n\n\t\t\toffset = 0.5*(infoW+12+32);\n\t\t\tif (centerX >= 0.5*width)\n\t\t\t{\n\t\t\t\tif (centerX < width-infoW-12-32-16)\n\t\t\t\t\tinfoX += offset;\n\t\t\t\telse\n\t\t\t\t\tinfoX -= offset;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (centerX > infoW+12+32+16)\n\t\t\t\t\tinfoX -= offset;\n\t\t\t\telse\n\t\t\t\t\tinfoX += offset;\n\t\t\t}\n\n\t\t\tinfoX = FClamp(infoX, 32, width-infoW-12-32);\n\t\t\tinfoY = FClamp(infoY, 16, height-infoH-10-72);\n\t\t}\n\n\t\t// draw a dark background\n\t\tgc.SetStyle(DSTY_Modulated);\n\t\tgc.SetTileColorRGB(0, 0, 0);\n\t\tgc.DrawPattern(infoX, infoY, infoW+12, infoH+10, 0, 0, Texture'ConWindowBackground');\n\n\t\t// draw the text\n\t\tgc.SetTextColor(colText);\n\t\tgc.DrawText(infoX+6, infoY+6, infoW, infoH, strInfo);\n\n\t\t// draw the two highlight boxes\n\t\tgc.SetStyle(DSTY_Translucent);\n\t\tgc.SetTileColor(colBorder);\n\t\tgc.DrawBox(infoX, infoY, infoW+12, infoH+10, 0, 0, 1, Texture'Solid');\n\t\tgc.SetTileColor(colBackground);\n\t\tgc.DrawBox(infoX+1, infoY+1, infoW+10, infoH+8, 0, 0, 1, Texture'Solid');\n\n\t\t//draw waypoint X mark\n\t\tmarkInfo = \"X\";\n\t\tgc.SetFont(Font'FontMenuHeaders_DS');\n\t\tgc.GetTextExtent(0, markW, markH, markInfo);\n\t\tmarkX = centerX-0.5*markW;\n\t\tmarkY = centerY-0.5*markH;\n\t\tmarkX = FClamp(markX, 16-0.5*markW, width-16-0.5*markW);\n\t\tmarkY = FClamp(infoY, 16, height-infoH-10-72);\n\t\tgc.SetTextColor(colText);\n\t\tgc.DrawText(markX, markY+6, markW, markH, markInfo);\n\t}\n\t//ENDWP\n\t\t \n\tif (!tPRI.bIsSpectator) \n    {\n\t\t//if (mmp.GetControls().bNameDisplay)\n\t\t//\tNameAllViewedPlayers(gc, mmp);\n\t\t\t\n\t\tSuper.PostDrawWindow(gc);\n    \t//Super(AugmentationDisplayWindow).PostDrawWindow(gc);\n    }\n    else\n    {\n\t\tif (mmp.FreeSpecMode)\n\t\t{\n\t\t\tNameAllViewedPlayers(gc, mmp);\n\t\t\tDrawStaticText(gc, \" < Free spectating >\", 0.73, colGold, false);\n\t\t\tDrawStaticText(gc, \"Press <\" $ keySkills $ \"> to spectate players.\", 0.75, colGold, false);\n\t\t}\n\t\telse if (mmp.ViewTarget != none)\n\t\t{\n\t\t\tif (PlayerPawn(mmp.ViewTarget).PlayerReplicationInfo.Team != mmp.PlayerReplicationInfo.Team ||\n\t\t\t\t!mmp.GameReplicationInfo.bTeamGame) col = colRed;\n\t\t\telse col = colGreen;\n\t\t\tstr = \"Viewing \" $ PlayerPawn(mmp.ViewTarget).PlayerReplicationInfo.PlayerName;\n\n\t\t\tDrawStaticText(gc, str, 0.65, col, true);\n\t\t\tDrawStaticText(gc, \"<- LMB       RMB ->\", 0.69, colGold, false);\n\t\t\tif (!mmp.bBehindView)\n\t\t\t{\n\t\t\t\t//DrawRemotePlayerSkills(gc, mmp);\n\t\t\t\tDrawRemoteInventory(gc, mmp);\n\t\t\t}\n\t\t\tDrawStaticText(gc, \"Press <\" $ keySkills $ \"> to go into free spectator mode.\", 0.75, colGold, false);\n\t\t}\n        \n        if(!mmp.bNoRespawn)\n\t\t\tDrawStaticText(gc, \"Press <\" $ keyMainMenu $ \"> or enter chat command /spec to start playing.\", 0.77, colGold, false);\n\n        gc.SetFont(Font'FontMenuSmall_DS');\n\t    gc.SetTextColor(colHeaderText);\n\t    gc.SetStyle(DSTY_Normal);\n\t    gc.SetTileColor(colBorder);\n\t\tif (mmp.bShowScores)\n\t    {\n            if (DeathMatchGame(mmp.DXGame) != None)\n\t\t\t    DeathMatchGame(mmp.DXGame).ShowDMScoreboard(mmp, gc, width, height);\n\t\t    else if (TeamDMGame(mmp.DXGame) != None)\n\t\t\t    TeamDMGame(mmp.DXGame).ShowTeamDMScoreboard(mmp, gc, width, height);\n\t    }\n\t}\n}\n\nfunction RefreshMultiplayerKeys()\n{\n\tlocal String Alias, keyName;\n\tlocal int i;\n\n\tfor ( i = 0; i < 255; i++ )\n\t{\n\t\tkeyName = player.ConsoleCommand ( \"KEYNAME \"$i );\n\t\tif ( keyName != \"\" )\n\t\t{\n\t\t\tAlias = player.ConsoleCommand( \"KEYBINDING \"$keyName );\n\t\t\tif ( Alias ~= \"DropItem\" )\n\t\t\t\tkeyDropItem = keyName;\n\t\t\telse if ( Alias ~= \"Talk\" )\n\t\t\t\tkeyTalk = keyName;\n\t\t\telse if ( Alias ~= \"TeamTalk\" )\n\t\t\t\tkeyTeamTalk = keyName;\n\t\t\telse if ( Alias ~= \"ShowInventoryWindow\" )\n\t\t\t    keyFreeMode = keyName;\n            else if ( Alias ~= \"ShowGoalsWindow\" )\n                keyPersonView = keyName;\n            else if ( Alias ~= \"ShowMainMenu\" )\n                keyMainMenu = keyName;\n\t\t\telse if ( Alias ~= \"BuySkills\" )\n\t\t\t\tkeySkills = KeyName;\n\t\t}\n\t}\n\tif ( keyDropItem ~= \"\" )\n\t\tkeyDropItem = KeyNotBoundString;\n\tif ( keyTalk ~= \"\" )\n\t\tkeyTalk = KeyNotBoundString;\n\tif ( keyTeamTalk ~= \"\" )\n\t\tkeyTeamTalk = KeyNotBoundString;\n\tif ( keyFreeMode ~= \"\" )\n\t    keyFreeMode = KeyNotBoundString;\n    if ( keyPersonView ~= \"\" )\n        keyPersonView = KeyNotBoundString;\n    if ( keyMainMenu ~= \"\" )\n        keyMainMenu = KeyNotBoundString;\n\tif ( keySkills ~= \"\" )\n\t\tkeySkills = KeyNotBoundString;\n}\n\nfunction DrawStaticText(GC gc, string text, float y_ratio, color col, bool big)\n{\n    local float x, y, w, h;\n\n    if (big) gc.SetFont(Font'FontMenuTitle');\n    else gc.SetFont(Font'FontMenuSmall');\n    gc.SetStyle(DSTY_Translucent);\n    gc.SetTextColor(col);\n    gc.GetTextExtent(0, w, h, text);\n    x = (width * 0.5) - (w * 0.5);\n\ty = height * y_ratio;\n\tgc.DrawText(x, y, w, h, text);\n\tgc.SetStyle(DSTY_Normal);\n}\n\nfunction float FacingActor(Pawn A, Pawn B)\n{\n    local vector X,Y,Z, Dir;\n\n    if (B == None || A == None) return -1.0;\n    GetAxes(B.ViewRotation, X, Y, Z);\n    Dir = A.Location - B.Location;\n    X.Z = 0;\n    Dir.Z = 0;\n    return Normal(Dir) dot Normal(X);\n}\n\ndefaultproperties\n{\n     colWhite=(R=255,G=255,B=255)\n     colYellow=(R=255,G=255,B=0)\n     colPurple=(R=128,G=0,B=128)\n     \n}\n",
            "name": "TCAugmentationDisplayWindow.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "colWhite=(R=255,G=255,B=255)",
                    "colYellow=(R=255,G=255,B=0)",
                    "colPurple=(R=128,G=0,B=128)"
                ],
                "exec": [],
                "extends": "CBPAugmentationDisplayWindow",
                "functions": {
                    "DrawPlayerName": {
                        "body": "{\n\n    gc.SetFont(Font'FontMenuSmall');\n    gc.SetStyle(DSTY_Translucent);\n    if (sameteam) gc.SetTextColor(colGreen);\n    else gc.SetTextColor(colRed);\n    gc.GetTextExtent(0, w, h, pname);\n    x -= w * 0.5;\n    y -= h * 0.5;\n\tgc.DrawText(x, y, w, h, pname);\n\tgc.SetStyle(DSTY_Normal);\n}",
                        "locals": [
                            "local float w, h;"
                        ],
                        "modifiers": [],
                        "name": "DrawPlayerName",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "float",
                                "x"
                            ],
                            [
                                "float",
                                "y"
                            ],
                            [
                                "bool",
                                "sameteam"
                            ],
                            [
                                "string",
                                "pname"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawRemoteInventory": {
                        "body": "{\n\n\tyoff = height - 48;\n\tytoff = yoff + 32;\n\txoff = width - 54;\n\n\tgc.SetStyle(DSTY_Masked);\n\tgc.SetTileColorRGB(255, 255, 255);\n\n\tgc.SetAlignments(HALIGN_Center, VALIGN_Center);\n\tgc.EnableWordWrap(false);\n\tgc.SetTextColorRGB(255, 255, 255);\n\tgc.SetFont(Font'FontTiny');\n\n\t// draw biocells\n\tif (mmp.TargetBioCells > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconBioCell');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetBioCells);\n\t}\n\txoff -= 48;\n\t// draw medkit\n\tif (mmp.TargetMedkits > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconMedKit');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetMedkits);\t\n\t}\n\txoff -= 48;\n\t// draw multitool\n\tif (mmp.TargetMultitools > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconMultitool');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetMultitools);\n\t}\n\txoff -= 48;\n\t// draw lockpick\n\tif (mmp.TargetLockpicks > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconLockPick');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetLockpicks);\n\t}\n\txoff -= 48;\n\t// draw lam\n\tif (mmp.TargetLAMs > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconLAM');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetLAMs);\n\t}\n\n\txoff = 16;\n\n\t// draw weapons\n\tfor (i = 0; i < 3; i++)\n\t{\n\t\tif (mmp.TargetWeapons[i] != none)\n\t\t{\n\t\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, mmp.TargetWeapons[i].default.Icon);\n\t\t}\n\t\txoff += 48;\n\t}\n\n\t// draw emp\n\tif (mmp.TargetEMPs > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconEMPGrenade');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetEMPs);\n\t}\n\txoff += 48;\n\t// draw gas\n\tif (mmp.TargetGGs > 0)\n\t{\n\t\tgc.DrawTexture(xoff, yoff, 42, 37, 0, 0, Texture'DeusExUI.Icons.BeltIconGasGrenade');\n\t\tgc.DrawText(xoff + 1, ytoff, 42, 8, \"COUNT:\" @ mmp.TargetGGs);\n\t}\n}",
                        "locals": [
                            "local int xoff, yoff, ytoff, i;"
                        ],
                        "modifiers": [],
                        "name": "DrawRemoteInventory",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "TCPlayer",
                                "mmp"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawStaticText": {
                        "body": "{\n\n    if (big) gc.SetFont(Font'FontMenuTitle');\n    else gc.SetFont(Font'FontMenuSmall');\n    gc.SetStyle(DSTY_Translucent);\n    gc.SetTextColor(col);\n    gc.GetTextExtent(0, w, h, text);\n    x = (width * 0.5) - (w * 0.5);\n\ty = height * y_ratio;\n\tgc.DrawText(x, y, w, h, text);\n\tgc.SetStyle(DSTY_Normal);\n}",
                        "locals": [
                            "local float x, y, w, h;"
                        ],
                        "modifiers": [],
                        "name": "DrawStaticText",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "string",
                                "text"
                            ],
                            [
                                "float",
                                "y_ratio"
                            ],
                            [
                                "color",
                                "col"
                            ],
                            [
                                "bool",
                                "big"
                            ]
                        ],
                        "return": ""
                    },
                    "FacingActor": {
                        "body": "{\n\n    if (B == None || A == None) return -1.0;\n    GetAxes(B.ViewRotation, X, Y, Z);\n    Dir = A.Location - B.Location;\n    X.Z = 0;\n    Dir.Z = 0;\n    return Normal(Dir) dot Normal(X);\n}",
                        "locals": [
                            "local vector X,Y,Z, Dir;"
                        ],
                        "modifiers": [],
                        "name": "FacingActor",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "A"
                            ],
                            [
                                "Pawn",
                                "B"
                            ]
                        ],
                        "return": "float"
                    },
                    "GetAllies": {
                        "body": "{\n\tif(TCDeathmatch(player.DXGame) != None)\n\t\treturn TCDeathmatch(player.DXGame).ArePlayersAllied2(POne,PTwo);\n\t\t\n\tif(TCTeam(player.DXGame) != None)\n\t\treturn TCTeam(player.DXGame).ArePlayersAllied(POne,PTwo);\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetAllies",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "POne"
                            ],
                            [
                                "TCPlayer",
                                "PTwo"
                            ]
                        ],
                        "return": "bool"
                    },
                    "GetGridTexture": {
                        "body": "{\n\tif (tex == None)\n\t\treturn Texture'BlackMaskTex';\n\telse if (tex == Texture'BlackMaskTex')\n\t\treturn Texture'BlackMaskTex';\n\telse if (tex == Texture'GrayMaskTex')\n\t\treturn Texture'BlackMaskTex';\n\telse if (tex == Texture'PinkMaskTex')\n\t\treturn Texture'BlackMaskTex';\n\telse if (VisionTargetStatus == VISIONENEMY)         \n      return Texture'Virus_SFX';\n   else if (VisionTargetStatus == VISIONALLY)\n\t\treturn Texture'Wepn_Prifle_SFX';\n   else if (VisionTargetStatus == VISIONNEUTRAL)\n      return Texture'WhiteStatic';\n   else\n      return Texture'WhiteStatic';\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetGridTexture",
                        "native": false,
                        "param": [
                            [
                                "Texture",
                                "tex"
                            ]
                        ],
                        "return": "Texture"
                    },
                    "GetTargetReticleColor": {
                        "body": "{\n\n\tbDM = (TCDeathmatch(player.DXGame) != None);\n\tbTeamDM = (TCTeam(player.DXGame) != None);\n\ttcSelf = GetPlayer();\n\tif(tcSelf != None)\n\t\tplPRI = TCPRI(tcSelf.PlayerReplicationInfo);\n\tsPawn = ScriptedPawn(Target);\n\n\tif(plPRI == None) // tcSelf == none is implicit if this is true.\n\t{\n\t\txColor = colWhite;\n\t\treturn;\n\t}\n\n\tif ( sPawn != None )\n\t{\n\t\tif(tcSelf.HUDTYpe == HUD_Extended) //Shows all info\n\t\t{\n\t\t\ttargetPlayerName = sPawn.FamiliarName$\" (\"$Left(VSize(target.Location - Player.Location), Len(VSize(target.Location - Player.Location))-7)$\")\";\n\t\t\txcolor = colYellow;\n\t\t}\n\t\telse if(tcSelf.HUDTYpe == HUD_Basic) //Shows basic info\n\t\t{\n\t\t\ttargetPlayerName = sPawn.FamiliarName;\n\t\t\txcolor = colYellow;\n\t\t}\n\t\telse if(tcSelf.HUDTYpe == HUD_Unified) //Masks bots as players\n\t\t{\n\t\t\ttargetPlayerName = sPawn.FamiliarName;\n\t\t\txcolor = colRed;\n\t\t}\n\t\telse if(tcSelf.HUDTYpe == HUD_Original) //As original DX, bots are friendlies, no name display\n\t\t{\n\t\t\ttargetPlayerName = \"\";\n\t\t\txcolor = colGreen;\n\t\t}\n\t\telse if(tcSelf.HUDTYpe == HUD_Off)\n\t\t\ttargetPlayerName = \"\";\n\t\t\t\n\t\ttargetPlayerTime = Player.Level.Timeseconds + targetPlayerDelay;\n\t\ttargetPlayerColor = xcolor;\n\t}\n\telse if ( Player.Level.NetMode != NM_Standalone )\t// Only do the rest in multiplayer\n\t{\n\t\tif ( target.IsA('TCStorageBox') )\n\t\t{\n\t\t\tTCS = TCStorageBox(Target);\n\t\t\tif (bTeamDM)\n\t\t\t{ \n\t\t\t\tif(GetAllies(TCPlayer(TCS.Owner),tcSelf) || tcSelf == TCS.Owner)\n\t\t\t\t\txcolor = colGreen;\n\t\t\t\telse\n\t\t\t\t\txcolor = colRed;\n\t\t\t\t\t\n\t\t\t\tif(TCS.myName != \"\")\n\t\t\t\t\tstr = TCS.myName;\n\t\t\t\telse str = TCS.OwnerName$\"'s storage\";\n\t\t\t\ttargetPlayerName = str;\n\t\t\t\ttargetPlayerTime = Player.Level.Timeseconds + targetPlayerDelay;\n\t\t\t\ttargetPlayerColor = xcolor;\n\t\t\t}\n\t\t\telse if(bDM)\n\t\t\t{\n\t\t\t\tif(GetAllies(TCPlayer(TCS.Owner),tcSelf) || tcSelf == TCS.Owner)\n\t\t\t\t\txcolor = colGreen;\n\t\t\t\telse\n\t\t\t\t\txcolor = colRed;\n\t\t\t\t\n\t\t\t\tif(TCS.myName != \"\")\n\t\t\t\t\tstr = TCS.myName;\n\t\t\t\telse str = TCS.OwnerName$\"'s storage\";\n\t\t\t\ttargetPlayerName = str;\n\t\t\t\ttargetPlayerTime = Player.Level.Timeseconds + targetPlayerDelay;\n\t\t\t\ttargetPlayerColor = xcolor;\n\t\t\t}\n\t\t}\n\t\telse if ( target.IsA('DeusExPlayer') && (target != player) )\t// Other players IFF\n\t\t{\n\t\t\ttcTarg = TCPlayer(Target);\n\t\t\tif(tcTarg != none)\n\t\t\t\ttPRI = TCPRI(tcTarg.PlayerReplicationInfo);\n\n\t\t\tif(tPRI != None)\n\t\t\t{\n\t\t\t\tif (bTeamDM)\n\t\t\t\t{ \n\t\t\t\t\tstr = tPRI.PlayerName;\n\n\t\t\t\t\tif(tPRI.bSpy || GetAllies(tcTarg,tcSelf))\n\t\t\t\t\t{\n\t\t\t\t\t\tTargetPlayerHealthString = \" (\" $ 100 * (tcTarg.Health / tcTarg.Default.Health) $ \"%)\";\n\t\t\t\t\t\txcolor = colGreen;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\txcolor = colRed;\n\t\t\t\t\t\n\t\t\t\t\ttargetPlayerName = str;\n\t\t\t\t}\n\t\t\t\telse if(bDM && target.Style != STY_Translucent) //Kaiz0r - Adding DM Stuff here\n\t\t\t\t{\t\t\t\t\t\n\t\t\t\t\tif(tcSelf.HUDTYpe == HUD_Extended) //Shows all info\n\t\t\t\t\t{\n\t\t\t\t\t\tif(plPRI.TeamNamePRI == \"\") //If not in team\n\t\t\t\t\t\t\txcolor = colPurple;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(plPRI.TeamNamePRI != \"\") //if WE are in a team\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(tPRI.bSpy || GetAllies(tcTarg,tcSelf))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTargetPlayerHealthString = \" (\" $ 100 * (tcTarg.Health / tcTarg.Default.Health) $ \"%)\";\n\t\t\t\t\t\t\t\txcolor = colGreen;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\txcolor = colRed;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstr = tPRI.PlayerName;\n\t\t\t\t\t\t\n\t\t\t\t\t\tstr = str$\" (\"$Left(VSize(target.Location - Player.Location), Len(VSize(target.Location - Player.Location))-7)$\")\";\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(tPRI.TeamNamePRI != \"\")\n\t\t\t\t\t\t\tstr = str$\" |C616200#|P7\"$tPRI.TeamNamePRI;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\ttargetPlayerName = str;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(tcSelf.HUDTYpe == HUD_Basic) //Shows basic info\n\t\t\t\t\t{\n\t\t\t\t\t\tif(tPRI.TeamNamePRI == \"\")//If not in team\n\t\t\t\t\t\t\txcolor = colPurple;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(tPRI.TeamNamePRI != \"\") //if WE are in a team\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(GetAllies(tcTarg,tcSelf))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTargetPlayerHealthString = \" (\" $ 100 * (tcTarg.Health / tcTarg.Default.Health) $ \"%)\";\n\t\t\t\t\t\t\t\txcolor = colGreen;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\txcolor = colRed;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstr = tPRI.PlayerName;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(tPRI.TeamNamePRI != \"\")\n\t\t\t\t\t\t\tstr = str$\" |C616200#|P7\"$TCPRI(TCPlayer(Target).PlayerReplicationInfo).TeamNamePRI;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\ttargetPlayerName = str;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(tcSelf.HUDTYpe == HUD_Unified || tcSelf.HUDTYpe == HUD_Original)\n\t\t\t\t\t{\n\t\t\t\t\t\ttargetPlayerName = tPRI.PlayerName;\n\t\t\t\t\t\txcolor = colRed;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(tcSelf.HUDTYpe == HUD_Off)\n\t\t\t\t\t{\n\t\t\t\t\t\ttargetPlayerName = \"\";\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttargetPlayerTime = Player.Level.Timeseconds + targetPlayerDelay;\n\t\t\t\t\ttargetPlayerColor = xcolor;\n\t\t\t\t}\n\n\t\t\t\tSightDist = VSize(target.Location - Player.Location);\n\t\t\t\t// This was one of the errors - the brackets prioritised the TeamDMGame cast over the bTeamDM check.\n\t\t\t\tif\t(((bTeamDM) && TeamDMGame(player.DXGame).ArePlayersAllied(DeusExPlayer(target),player))\n\t\t\t\t||\t(target.Style != STY_Translucent)\n\t\t\t\t||\t(bVisionActive && (Sightdist <= visionLevelvalue)) )\n\t\t\t\t{\n\t\t\t\t\t//targetPlayerName = DeusExPlayer(target).PlayerReplicationInfo.PlayerName;\n\t\t\t\t\t// DEUS_EX AMSD Show health of enemies with the target active.\n\t\t\t\t\tif (bTargetActive)\n\t\t\t\t\t\tTargetPlayerHealthString = \"(\" $ 100 * (tcTarg.Health / tcTarg.Default.Health) $ \"%)\";\n\n\t\t\t\t\ttargetOutOfRange = False;\n\t\t\t\t\tw = DeusExWeapon(player.Weapon);\n\t\t\t\t\tif (( w != None ) && ( xcolor != colGreen ))\n\t\t\t\t\t{\n\t\t\t\t\t\tdist = player.Location - target.Location;\n\t\t\t\t\t\tif ( VSize(dist) > w.maxRange ) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!(( WeaponAssaultGun(w) != None ) && ( Ammo20mm(WeaponAssaultGun(w).AmmoType) != None )))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttargetRangeTime = Player.Level.Timeseconds + 0.1;\n\t\t\t\t\t\t\t\ttargetOutOfRange = True;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttargetPlayerTime = Player.Level.Timeseconds + targetPlayerDelay;\n\t\t\t\t\ttargetPlayerColor = xcolor;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\txcolor = colWhite;\t// cloaked enemy\n\t\t}\n\t\telse if (target.IsA('ThrownProjectile'))\t// Grenades IFF\n\t\t{\n\t\t\tif ( ThrownProjectile(target).bDisabled )\n\t\t\t\txcolor = colWhite;\n\t\t\telse if ( (GetAllies(TCPlayer(target.Owner),tcSelf)) || \n\t\t\t\t(player == TCPlayer(target.Owner)) )\n\t\t\t\txcolor = colGreen;\n\t\t\telse\n\t\t\t\txcolor = colRed;\n\t\t}\n\t\telse if ( target.IsA('TCAutoTurret') || target.IsA('AutoTurretGun') ) // Autoturrets IFF\n\t\t{\n\t\t\tif ( target.IsA('AutoTurretGun') )\n\t\t\t{\n\t\t\t\tteam = AutoTurretGun(target).team;\n\t\t\t\ttitleString = AutoTurretGun(target).titleString;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tteam = AutoTurret(target).team;\n\t\t\t\ttitleString = AutoTurret(target).titleString;\n\t\t\t\tteamstr = TCPRI(TCPlayer(TCAutoTurret(target).safeTarget).PlayerReplicationInfo).TeamNamePRI;\n\t\t\t}\n\t\t\tif ( (TCDeathmatch(player.dxgame) != none && team == plPRI.playerid) || TCTeam(player.dxgame) != none && team == plPRI.team)\n\t\t\t\txcolor = colGreen;\n\t\t\telse if (team == -1)\n\t\t\t\txcolor = colWhite;\n\t\t\telse\n\t\t\t\txcolor = colRed;\n\n\t\t\ttargetPlayerName = titleString$teamstr;\n\t\t\ttargetOutOfRange = False;\n\t\t\ttargetPlayerTime = Player.Level.Timeseconds + targetPlayerDelay;\n\t\t\ttargetPlayerColor = xcolor;\n\t\t}\n\t\telse if ( target.IsA('ComputerSecurity'))\n\t\t{\n\t\t\tif ( ComputerSecurity(target).team == -1 )\n\t\t\t\txcolor = colWhite;\n\t\t\telse if ( (bTeamDM && GetAllies(TCPlayer(target.Owner), tcSelf)) ||\n\t\t\t\t  (!bTeamDM && (player.PlayerReplicationInfo.PlayerID == team || \n\t\t\t\t  GetAllies(TCPlayer(target.Owner), tcSelf))) )\n\t\t\t\txcolor = colGreen;\n\t\t\telse\n\t\t\t\txcolor = colRed;\n\t\t}\n\t\telse if ( target.IsA('SecurityCamera'))\n\t\t{\n\t\t\tif ( !SecurityCamera(target).bActive )\n\t\t\t\txcolor = colWhite;\n\t\t\telse if ( SecurityCamera(target).team == -1 )\n\t\t\t\txcolor = colWhite;\n\t\t\telse if ( (bTeamDM && GetAllies(TCPlayer(target.Owner), tcSelf)) ||\n\t\t\t\t  (!bTeamDM && (player.PlayerReplicationInfo.PlayerID == team || \n\t\t\t\t  GetAllies(TCPlayer(target.Owner), tcSelf))) )\n\t\t\t\txcolor = colGreen;\n\t\t\telse\n\t\t\t\txcolor = colRed;\n\t\t}\n\t}\n}",
                        "locals": [
                            "local DeusExPlayer safePlayer;",
                            "local AutoTurret turret;",
                            "local bool bDM, bTeamDM;",
                            "local Vector dist;",
                            "local float SightDist;",
                            "local DeusExWeapon w;",
                            "local int team;",
                            "local String titleString;",
                            "local TCControls TCC;",
                            "local string str;",
                            "local TCStorageBox TCS;",
                            "local string teamstr;",
                            "local TCPRI plPRI, tPRI;",
                            "local TCPlayer tcTarg, tcSelf;",
                            "local ScriptedPawn sPawn;"
                        ],
                        "modifiers": [],
                        "name": "GetTargetReticleColor",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "target"
                            ],
                            [
                                "out",
                                "Color",
                                "xcolor"
                            ]
                        ],
                        "return": ""
                    },
                    "IsHeatSource": {
                        "body": "{\n\tif(A.IsA('ODXHiddenActor')) //Check this first, so it doesnt reach the \"Hidden\" check below\n\t\treturn True;\n\t\t\n   if ((A.bHidden) && (Player.Level.NetMode != NM_Standalone))\n      return False;\n   if (A.IsA('Pawn'))\n   {\n      if (A.IsA('ScriptedPawn'))\n         return True;\n      else if ( (A.IsA('DeusExPlayer')) && (A != Player) )//DEUS_EX AMSD For multiplayer.\n         return True;\n      return False;\n   }\n\telse if (A.IsA('DeusExCarcass'))\n\t\treturn True;   \n\telse if (A.IsA('FleshFragment'))\n\t\treturn True;\n   else\n\t\treturn False;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "IsHeatSource",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "A"
                            ]
                        ],
                        "return": "bool"
                    },
                    "NameAllViewedPlayers": {
                        "body": "{\n\n\tforeach mmp.VisibleCollidingActors(class'Actor', target, 3000.0, mmp.Location, false)\n\t{\n\t    if (target.IsA('TCPlayer') && (FacingActor(Pawn(target), mmp) > 0.0))\n        {\n            P = TCPlayer(target);\n            if (P.PlayerReplicationInfo.bIsSpectator || (!mmp.bSpecEnemies && P.PlayerReplicationInfo.Team != mmp.PlayerReplicationInfo.Team)) continue;\n            loc = P.Location;\n            loc.Z -= P.CollisionHeight + 10.0;\n            ConvertVectorToCoordinates(loc, x, y);\n            DrawPlayerName(gc, x, y, (mmp.PlayerReplicationInfo.Team == P.PlayerReplicationInfo.Team) && mmp.GameReplicationInfo.bTeamGame, P.PlayerReplicationInfo.PlayerName);\n        }\n    }\n}",
                        "locals": [
                            "local Actor target;",
                            "local TCPlayer P;",
                            "local float x, y;",
                            "local vector loc;",
                            "local bool viewenemy;"
                        ],
                        "modifiers": [],
                        "name": "NameAllViewedPlayers",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "TCPlayer",
                                "mmp"
                            ]
                        ],
                        "return": ""
                    },
                    "PostDrawWindow": {
                        "body": "{\n\n\tpp = Player.GetPlayerPawn();\n\tif(TCPlayer(pp) != None)\n\t\tmmp = TCPlayer(pp);\n\tcolGold.R = 255;\n    colGold.G = 255;\n\n\tif(TCPRI(mmp.PlayerReplicationInfo) != None)\n\t\ttPRI = TCPRI(mmp.PlayerReplicationInfo);\n\t\t\n\tif(tPRI == None)\n\t\treturn;\n\t\n\t//BEGIN WP\n\tif(tPRI.wpTargetPRI != None)\n\t\twpTarget = tPRI.wpTargetPRI;\n\n\tif (wpTarget != None)\n\t{\n\t\tcenterLoc = wpTarget.Location;\n\n\t\tif (ConvertVectorToCoordinates(centerLoc, centerX, centerY))\n\t\t{\n\t\t\t// convert to meters\n\t\t\tdist = int(vsize(mmp.Location-wpTarget.Location)/52);\n\n\t\t\tif(tPRI.wpName != \"\")\n\t\t\t\tstrInfo = tPRI.wpName $ \" (\" $ dist $ \"m)\";\n\t\t\telse\n\t\t\t\tstrInfo = wpTarget.Tag $ \" (\" $ dist $ \"m)\";\n\n\t\t\tgc.SetFont(Font'FontMenuHeaders_DS');\n\t\t\tgc.GetTextExtent(0, infoW, infoH, strInfo);\n\n\t\t\tinfoX = centerX - 0.5*(infoW+12);\n\t\t\tinfoY = centerY - 0.5*(infoH+10);\n\n\t\t\toffset = 0.5*(infoW+12+32);\n\t\t\tif (centerX >= 0.5*width)\n\t\t\t{\n\t\t\t\tif (centerX < width-infoW-12-32-16)\n\t\t\t\t\tinfoX += offset;\n\t\t\t\telse\n\t\t\t\t\tinfoX -= offset;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (centerX > infoW+12+32+16)\n\t\t\t\t\tinfoX -= offset;\n\t\t\t\telse\n\t\t\t\t\tinfoX += offset;\n\t\t\t}\n\n\t\t\tinfoX = FClamp(infoX, 32, width-infoW-12-32);\n\t\t\tinfoY = FClamp(infoY, 16, height-infoH-10-72);\n\t\t}\n\n\t\t// draw a dark background\n\t\tgc.SetStyle(DSTY_Modulated);\n\t\tgc.SetTileColorRGB(0, 0, 0);\n\t\tgc.DrawPattern(infoX, infoY, infoW+12, infoH+10, 0, 0, Texture'ConWindowBackground');\n\n\t\t// draw the text\n\t\tgc.SetTextColor(colText);\n\t\tgc.DrawText(infoX+6, infoY+6, infoW, infoH, strInfo);\n\n\t\t// draw the two highlight boxes\n\t\tgc.SetStyle(DSTY_Translucent);\n\t\tgc.SetTileColor(colBorder);\n\t\tgc.DrawBox(infoX, infoY, infoW+12, infoH+10, 0, 0, 1, Texture'Solid');\n\t\tgc.SetTileColor(colBackground);\n\t\tgc.DrawBox(infoX+1, infoY+1, infoW+10, infoH+8, 0, 0, 1, Texture'Solid');\n\n\t\t//draw waypoint X mark\n\t\tmarkInfo = \"X\";\n\t\tgc.SetFont(Font'FontMenuHeaders_DS');\n\t\tgc.GetTextExtent(0, markW, markH, markInfo);\n\t\tmarkX = centerX-0.5*markW;\n\t\tmarkY = centerY-0.5*markH;\n\t\tmarkX = FClamp(markX, 16-0.5*markW, width-16-0.5*markW);\n\t\tmarkY = FClamp(infoY, 16, height-infoH-10-72);\n\t\tgc.SetTextColor(colText);\n\t\tgc.DrawText(markX, markY+6, markW, markH, markInfo);\n\t}\n\t//ENDWP\n\t\t \n\tif (!tPRI.bIsSpectator) \n    {\n\t\t//if (mmp.GetControls().bNameDisplay)\n\t\t//\tNameAllViewedPlayers(gc, mmp);\n\t\t\t\n\t\tSuper.PostDrawWindow(gc);\n    \t//Super(AugmentationDisplayWindow).PostDrawWindow(gc);\n    }\n    else\n    {\n\t\tif (mmp.FreeSpecMode)\n\t\t{\n\t\t\tNameAllViewedPlayers(gc, mmp);\n\t\t\tDrawStaticText(gc, \" < Free spectating >\", 0.73, colGold, false);\n\t\t\tDrawStaticText(gc, \"Press <\" $ keySkills $ \"> to spectate players.\", 0.75, colGold, false);\n\t\t}\n\t\telse if (mmp.ViewTarget != none)\n\t\t{\n\t\t\tif (PlayerPawn(mmp.ViewTarget).PlayerReplicationInfo.Team != mmp.PlayerReplicationInfo.Team ||\n\t\t\t\t!mmp.GameReplicationInfo.bTeamGame) col = colRed;\n\t\t\telse col = colGreen;\n\t\t\tstr = \"Viewing \" $ PlayerPawn(mmp.ViewTarget).PlayerReplicationInfo.PlayerName;\n\n\t\t\tDrawStaticText(gc, str, 0.65, col, true);\n\t\t\tDrawStaticText(gc, \"<- LMB       RMB ->\", 0.69, colGold, false);\n\t\t\tif (!mmp.bBehindView)\n\t\t\t{\n\t\t\t\t//DrawRemotePlayerSkills(gc, mmp);\n\t\t\t\tDrawRemoteInventory(gc, mmp);\n\t\t\t}\n\t\t\tDrawStaticText(gc, \"Press <\" $ keySkills $ \"> to go into free spectator mode.\", 0.75, colGold, false);\n\t\t}\n        \n        if(!mmp.bNoRespawn)\n\t\t\tDrawStaticText(gc, \"Press <\" $ keyMainMenu $ \"> or enter chat command /spec to start playing.\", 0.77, colGold, false);\n\n        gc.SetFont(Font'FontMenuSmall_DS');\n\t    gc.SetTextColor(colHeaderText);\n\t    gc.SetStyle(DSTY_Normal);\n\t    gc.SetTileColor(colBorder);\n\t\tif (mmp.bShowScores)\n\t    {\n            if (DeathMatchGame(mmp.DXGame) != None)\n\t\t\t    DeathMatchGame(mmp.DXGame).ShowDMScoreboard(mmp, gc, width, height);\n\t\t    else if (TeamDMGame(mmp.DXGame) != None)\n\t\t\t    TeamDMGame(mmp.DXGame).ShowTeamDMScoreboard(mmp, gc, width, height);\n\t    }\n\t}\n}",
                        "locals": [
                            "local PlayerPawn pp;",
                            "local TCPlayer mmp;",
                            "local color col;",
                            "local string str;",
                            "local color colGold;",
                            "local int tmpVisionLevel, tmpVisionLevelValue;",
                            "local int VotePoints, mVP;",
                            "local float xx;",
                            "local actor wpTarget;",
                            "local float infoX, infoY, infoW, infoH;",
                            "local string strInfo;",
                            "local int dist;",
                            "local float offset;",
                            "local vector centerLoc;",
                            "local float centerX, centerY;",
                            "local float markX, markY, markW, markH;",
                            "local string markInfo;",
                            "local TCPRI tPRI;"
                        ],
                        "modifiers": [],
                        "name": "PostDrawWindow",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ]
                        ],
                        "return": ""
                    },
                    "RefreshMultiplayerKeys": {
                        "body": "{\n\n\tfor ( i = 0; i < 255; i++ )\n\t{\n\t\tkeyName = player.ConsoleCommand ( \"KEYNAME \"$i );\n\t\tif ( keyName != \"\" )\n\t\t{\n\t\t\tAlias = player.ConsoleCommand( \"KEYBINDING \"$keyName );\n\t\t\tif ( Alias ~= \"DropItem\" )\n\t\t\t\tkeyDropItem = keyName;\n\t\t\telse if ( Alias ~= \"Talk\" )\n\t\t\t\tkeyTalk = keyName;\n\t\t\telse if ( Alias ~= \"TeamTalk\" )\n\t\t\t\tkeyTeamTalk = keyName;\n\t\t\telse if ( Alias ~= \"ShowInventoryWindow\" )\n\t\t\t    keyFreeMode = keyName;\n            else if ( Alias ~= \"ShowGoalsWindow\" )\n                keyPersonView = keyName;\n            else if ( Alias ~= \"ShowMainMenu\" )\n                keyMainMenu = keyName;\n\t\t\telse if ( Alias ~= \"BuySkills\" )\n\t\t\t\tkeySkills = KeyName;\n\t\t}\n\t}\n\tif ( keyDropItem ~= \"\" )\n\t\tkeyDropItem = KeyNotBoundString;\n\tif ( keyTalk ~= \"\" )\n\t\tkeyTalk = KeyNotBoundString;\n\tif ( keyTeamTalk ~= \"\" )\n\t\tkeyTeamTalk = KeyNotBoundString;\n\tif ( keyFreeMode ~= \"\" )\n\t    keyFreeMode = KeyNotBoundString;\n    if ( keyPersonView ~= \"\" )\n        keyPersonView = KeyNotBoundString;\n    if ( keyMainMenu ~= \"\" )\n        keyMainMenu = KeyNotBoundString;\n\tif ( keySkills ~= \"\" )\n\t\tkeySkills = KeyNotBoundString;\n}",
                        "locals": [
                            "local String Alias, keyName;",
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "RefreshMultiplayerKeys",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "getPlayer": {
                        "body": "{\n   return TCPlayer(player);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "getPlayer",
                        "native": false,
                        "param": [],
                        "return": "TCPlayer"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 694,
                "replication": "",
                "states": [],
                "variables": [
                    "var Color colYellow, colPurple;",
                    "var Color\tcolBlue1, colWhite;",
                    "var Color\tcolGreen1, colLtGreen;",
                    "var Color\tcolRed1, colLtRed;",
                    "var string keyFreeMode, keyPersonView, keyMainMenu, keySkills;"
                ]
            }
        },
        "TCAugmentationManager.uc": {
            "body": "//=============================================================================\n// AugmentationManager\n//=============================================================================\nclass TCAugmentationManager extends CBPAugmentationManager;\n\nvar Class<Augmentation> augClassesODX[45]; //we need MOAR AUGS - Upped from 25 to 31, maybe more than needed..\n\nfunction AddAllAugs()\n{\n\tlocal int augIndex;\n\n\t// Loop through all the augmentation classes and create\n\t// any augs that don't exist.  Then set them all to the \n\t// maximum level.\n\n\tfor(augIndex=0; augIndex<arrayCount(augClassesODX); augIndex++)\n\t{\n\t\tif (augClasses[augIndex] != None)\n\t\t\tGivePlayerAugmentation(augClassesODX[augIndex]);\n\t}\n}\n\n\nfunction CreateAugmentations(DeusExPlayer newPlayer)\n{\n\tlocal int augIndex;\n\tlocal Augmentation anAug;\n\tlocal Augmentation lastAug;\n\n\tFirstAug = None;\n\tLastAug  = None;\n\n\tplayer = newPlayer;\n\n\tfor(augIndex=0; augIndex<arrayCount(augClassesODX); augIndex++)\n\t{\n\t\tif (augClassesODX[augIndex] != None)\n\t\t{\n\t\t\tanAug = Spawn(augClassesODX[augIndex], Self);\n\t\t\tanAug.Player = player;\n\n\t\t\t// Manage our linked list\n\t\t\tif (anAug != None)\n\t\t\t{\n\t\t\t\tif (FirstAug == None)\n\t\t\t\t{\n\t\t\t\t\tFirstAug = anAug;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLastAug.next = anAug;\n\t\t\t\t}\n\n\t\t\t\tLastAug  = anAug;\n\t\t\t}\n\t\t}\n\t}\n}\n\nsimulated function int GetClassLevel(class<Augmentation> augClass)\n{\n  if(Player != None && Player.PlayerReplicationInfo != None)\n    if(Player.IsInState('Spectating'))\n      if(augClass == Class'DeusEx.AugRadarTrans')\n        return 3;\n\n  return Super.GetClassLevel(augClass);\n}\n\nsimulated function Augmentation FindAugmentation(Class<Augmentation> findClass)\n{\n\tlocal Augmentation anAug, currentAug;\n\n\tanAug = FirstAug;\n\twhile(anAug != None)\n\t{\n        currentAug = anAug;\n\n        if(currentAug.Owner != None && currentAug.Owner.isA('Augmentation'))\n            currentAug = Augmentation(currentAug.Owner);\n        \n\t\tif(currentAug.Class == findClass)\n        {\n            anAug = currentAug;\n\t\t\tbreak;\n        }\n\n\t\tanAug = anAug.next;\n\t}\n\n\treturn anAug;\n}\n\ndefaultproperties\n{\n\t augClassesODX(0)=Class'DeusEx.AugSpeed'\n     augClassesODX(1)=Class'DeusEx.AugTarget'\n     augClassesODX(2)=Class'DeusEx.AugCloak'\n     augClassesODX(3)=Class'DeusEx.AugBallistic'\n     augClassesODX(4)=Class'DeusEx.AugRadarTrans'\n     augClassesODX(5)=Class'DeusEx.AugShield'\n     augClassesODX(6)=Class'DeusEx.AugEnviro'\n     augClassesODX(7)=Class'DeusEx.AugEMP'\n     augClassesODX(8)=Class'DeusEx.AugCombat'\n     augClassesODX(9)=Class'OpenDX.AugHealing2'\n     augClassesODX(10)=Class'DeusEx.AugStealth'\n     augClassesODX(11)=Class'DeusEx.AugIFF'\n     augClassesODX(12)=Class'CBPAugLight'\n     augClassesODX(13)=Class'DeusEx.AugMuscle'\n     augClassesODX(14)=Class'DeusEx.AugVision'\n     augClassesODX(15)=Class'DeusEx.AugDrone'\n     augClassesODX(16)=Class'DeusEx.AugDefense'\n     augClassesODX(17)=Class'DeusEx.AugAqualung'\n     augClassesODX(18)=Class'DeusEx.AugDatalink'\n     augClassesODX(19)=Class'DeusEx.AugHeartLung'\n     augClassesODX(20)=Class'DeusEx.AugPower'\n     augClassesODX(21)=Class'OpenDX.AugSkullgun'\n     augClassesODX(22)=Class'OpenDX.AugIcarus'\n     augClassesODX(23)=Class'OpenDX.AugNuke'\n     augClassesODX(24)=Class'OpenDX.AugRepel'\n     augClassesODX(25)=Class'OpenDX.AugMediAura'\n     augClassesODX(26)=Class'OpenDX.AugFlight'\n     augClassesODX(27)=Class'OpenDX.AugRadar'\n     augClassesODX(28)=Class'OpenDX.AugTakedown'\n     augClassesODX(29)=Class'OpenDX.AugMagnet'\n}\n",
            "name": "TCAugmentationManager.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "augClassesODX(0)=Class'DeusEx.AugSpeed'",
                    "augClassesODX(1)=Class'DeusEx.AugTarget'",
                    "augClassesODX(2)=Class'DeusEx.AugCloak'",
                    "augClassesODX(3)=Class'DeusEx.AugBallistic'",
                    "augClassesODX(4)=Class'DeusEx.AugRadarTrans'",
                    "augClassesODX(5)=Class'DeusEx.AugShield'",
                    "augClassesODX(6)=Class'DeusEx.AugEnviro'",
                    "augClassesODX(7)=Class'DeusEx.AugEMP'",
                    "augClassesODX(8)=Class'DeusEx.AugCombat'",
                    "augClassesODX(9)=Class'OpenDX.AugHealing2'",
                    "augClassesODX(10)=Class'DeusEx.AugStealth'",
                    "augClassesODX(11)=Class'DeusEx.AugIFF'",
                    "augClassesODX(12)=Class'CBPAugLight'",
                    "augClassesODX(13)=Class'DeusEx.AugMuscle'",
                    "augClassesODX(14)=Class'DeusEx.AugVision'",
                    "augClassesODX(15)=Class'DeusEx.AugDrone'",
                    "augClassesODX(16)=Class'DeusEx.AugDefense'",
                    "augClassesODX(17)=Class'DeusEx.AugAqualung'",
                    "augClassesODX(18)=Class'DeusEx.AugDatalink'",
                    "augClassesODX(19)=Class'DeusEx.AugHeartLung'",
                    "augClassesODX(20)=Class'DeusEx.AugPower'",
                    "augClassesODX(21)=Class'OpenDX.AugSkullgun'",
                    "augClassesODX(22)=Class'OpenDX.AugIcarus'",
                    "augClassesODX(23)=Class'OpenDX.AugNuke'",
                    "augClassesODX(24)=Class'OpenDX.AugRepel'",
                    "augClassesODX(25)=Class'OpenDX.AugMediAura'",
                    "augClassesODX(26)=Class'OpenDX.AugFlight'",
                    "augClassesODX(27)=Class'OpenDX.AugRadar'",
                    "augClassesODX(28)=Class'OpenDX.AugTakedown'",
                    "augClassesODX(29)=Class'OpenDX.AugMagnet'"
                ],
                "exec": [],
                "extends": "CBPAugmentationManager",
                "functions": {
                    "AddAllAugs": {
                        "body": "{\n\n\t// Loop through all the augmentation classes and create\n\t// any augs that don't exist.  Then set them all to the \n\t// maximum level.\n\n\tfor(augIndex=0; augIndex<arrayCount(augClassesODX); augIndex++)\n\t{\n\t\tif (augClasses[augIndex] != None)\n\t\t\tGivePlayerAugmentation(augClassesODX[augIndex]);\n\t}\n}",
                        "locals": [
                            "local int augIndex;"
                        ],
                        "modifiers": [],
                        "name": "AddAllAugs",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CreateAugmentations": {
                        "body": "{\n\n\tFirstAug = None;\n\tLastAug  = None;\n\n\tplayer = newPlayer;\n\n\tfor(augIndex=0; augIndex<arrayCount(augClassesODX); augIndex++)\n\t{\n\t\tif (augClassesODX[augIndex] != None)\n\t\t{\n\t\t\tanAug = Spawn(augClassesODX[augIndex], Self);\n\t\t\tanAug.Player = player;\n\n\t\t\t// Manage our linked list\n\t\t\tif (anAug != None)\n\t\t\t{\n\t\t\t\tif (FirstAug == None)\n\t\t\t\t{\n\t\t\t\t\tFirstAug = anAug;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tLastAug.next = anAug;\n\t\t\t\t}\n\n\t\t\t\tLastAug  = anAug;\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local int augIndex;",
                            "local Augmentation anAug;",
                            "local Augmentation lastAug;"
                        ],
                        "modifiers": [],
                        "name": "CreateAugmentations",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "newPlayer"
                            ]
                        ],
                        "return": ""
                    },
                    "FindAugmentation": {
                        "body": "{\n\n\tanAug = FirstAug;\n\twhile(anAug != None)\n\t{\n        currentAug = anAug;\n\n        if(currentAug.Owner != None && currentAug.Owner.isA('Augmentation'))\n            currentAug = Augmentation(currentAug.Owner);\n        \n\t\tif(currentAug.Class == findClass)\n        {\n            anAug = currentAug;\n\t\t\tbreak;\n        }\n\n\t\tanAug = anAug.next;\n\t}\n\n\treturn anAug;\n}",
                        "locals": [
                            "local Augmentation anAug, currentAug;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "FindAugmentation",
                        "native": false,
                        "param": [
                            [
                                "Class<Augmentation>",
                                "findClass"
                            ]
                        ],
                        "return": "Augmentation"
                    },
                    "GetClassLevel": {
                        "body": "{\n  if(Player != None && Player.PlayerReplicationInfo != None)\n    if(Player.IsInState('Spectating'))\n      if(augClass == Class'DeusEx.AugRadarTrans')\n        return 3;\n\n  return Super.GetClassLevel(augClass);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "GetClassLevel",
                        "native": false,
                        "param": [
                            [
                                "class<Augmentation>",
                                "augClass"
                            ]
                        ],
                        "return": "int"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 127,
                "replication": "",
                "states": [],
                "variables": [
                    "var Class<Augmentation> augClassesODX[45]; //we need MOAR AUGS - Upped from 25 to 31, maybe more than needed.."
                ]
            }
        },
        "TCAutoTurret.uc": {
            "body": "//=============================================================================\n// AutoTurret.\n//=============================================================================\nclass TCAutoTurret extends AutoTurret;\n\nvar bool bDisb;\nvar() int TurretHealth;\nvar string TeamString;\nvar AutoTurretGun gun;\n\nvar() localized String titleString;\t\t// So we can name specific turrets in multiplayer\nvar() bool bTrackPawnsOnly;\nvar() bool bTrackPlayersOnly;\nvar() bool bActive;\nvar() int maxRange;\nvar() float fireRate;\nvar() float gunAccuracy;\nvar() int gunDamage;\nvar() int ammoAmount;\nvar Actor curTarget;\nvar Actor prevTarget;         // target we had last tick.\nvar Pawn safeTarget;          // in multiplayer, this actor is strictly off-limits\n                               // Usually for the player who activated the turret.\nvar float fireTimer;\nvar bool bConfused;\t\t\t\t// used when hit by EMP\nvar float confusionTimer;\t\t// how long until turret resumes normal operation\nvar float confusionDuration;\t// how long does an EMP hit last?\nvar Actor LastTarget;\t\t\t// what was our last target?\nvar float pitchLimit;\t\t\t// what's the maximum pitch?\nvar Rotator origRot;\t\t\t// original rotation\nvar bool bPreAlarmActiveState;\t// was I previously awake or not?\nvar bool bDisabled;\t\t\t\t// have I been hacked or shut down by computers?\nvar float TargetRefreshTime;      // used for multiplayer to reduce rate of checking for targets.\nvar() float Thick;\nvar() float PawnThick;\nvar() int team;\t\t\t\t\t\t// Keep track of team the turrets on\n\nvar int mpTurretDamage;\t\t\t// Settings for multiplayer\nvar int mpTurretRange;\n\nvar bool bComputerReset;\t\t\t// Keep track of if computer has been reset so we avoid all actors checks\n\nvar bool bSwitching;\nvar float SwitchTime, beepTime;\nvar Pawn savedTarget;\n\n\n// networking replication\nreplication\n{\n   //server to client\n   reliable if (Role == ROLE_Authority)\n      safeTarget, bDisabled, bActive, team, titleString;\n}\n\nfunction Destroyed()\n{\t\t\n}\n\nfunction UpdateSwitch()\n{\n\tif ( Level.Timeseconds > SwitchTime )\n\t{\n\t\tbSwitching = False;\n\t\t//safeTarget = savedTarget;\n\t\tSwitchTime = 0;\n\t\tbeepTime = 0;\n\t}\n\telse\n\t{\n\t\tif ( Level.Timeseconds > beepTime )\n\t\t{\n\t\t\tPlaySound(Sound'TurretSwitch', SLOT_Interact, 1.0,, maxRange );\n\t\t\tbeepTime = Level.Timeseconds + 0.75;\n\t\t}\n\t}\n}\n\nfunction Actor AcquireMultiplayerTarget()\n{\n\tlocal Pawn apawn;\n\tlocal DeusExPlayer aplayer;\n\tlocal Vector dist;\n\tlocal Actor noActor;\n\n\tif ( bSwitching )\n\t{\n\t\tnoActor = None;\n\t\treturn noActor;\n\t}\n\n\tapawn = gun.Level.PawnList;\n\n\twhile ( apawn != None )\n\t{\n\t\t//if (apawn.bDetectable && !apawn.bIgnore && apawn.IsA('DeusExPlayer'))\n\t\tif (apawn.bDetectable && !apawn.bIgnore)\n\t\t{\n\t\t\taplayer = DeusExPlayer(apawn);\n\n\t\t\tdist = apawn.Location - gun.Location; //apawn was aplayer\n\n\t\t\tif ( VSize(dist) < maxRange )\n\t\t\t{\n\t\t\t\t// Only players we can see\n\t\t\t\tif ( apawn.FastTrace( apawn.Location, gun.Location ))//apawn was aplayer\n\t\t\t\t{\n\t\t\t\t\tif(!PSOwners(apawn))\n\t\t\t\t\t{\n\t\t\t\t\t\tif(curTarget == None)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcurTarget = apawn;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tapawn = apawn.nextPawn;\n\t}\n\treturn curtarget;\n}\n\nfunction Tick(float deltaTime)\n{\n\tlocal Pawn pawn;\n\tlocal ScriptedPawn sp;\n\tlocal DeusExDecoration deco;\n\tlocal float near;\n\tlocal Rotator destRot;\n\tlocal bool bSwitched;\n\n\tSuper.Tick(deltaTime);\n\n\tbSwitched = False;\n\n\tif ( bSwitching )\n\t{\n\t\tUpdateSwitch();\n\t\treturn;\n\t}\n\n\tif (bActive && !bDisabled)\n\t{\n\t\tcurTarget = None;\n\n\t\tif ( !bConfused )\n\t\t{\n\t\t\tif (TargetRefreshTime < 0)\n\t\t\tTargetRefreshTime = 0;\n         \n\t\t\tTargetRefreshTime = TargetRefreshTime + deltaTime;\n\n\t\t\tif (TargetRefreshTime >= 0.3)\n\t\t\t{\n\t\t\t\tTargetRefreshTime = 0;\n\t\t\t\tcurTarget = AcquireMultiplayerTarget();\n\n//\t\t\t\tif ( curTarget == None )\n//\t\t\t\tPlaySound(Sound'TurretUnlocked', SLOT_Interact, 1.0,, maxRange );\n//\t\t\t\tprevtarget = curtarget;\t\t\n\t\t\t}\n\n\t\t\t\t\tforeach gun.VisibleActors(class'Pawn', pawn, maxRange, gun.Location)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pawn.bDetectable && !pawn.bIgnore)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(curTarget == None)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif(!PSOwners(Pawn))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tcurTarget = Pawn;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if we have a target, rotate to face it\n\t\t\tif (curTarget != None)\n\t\t\t{\n\t\t\t\tdestRot = Rotator(curTarget.Location - gun.Location);\n\t\t\t\tgun.DesiredRotation = destRot;\n\t\t\t\tnear = pitchLimit / 2;\n\t\t\t\tgun.DesiredRotation.Pitch = FClamp(gun.DesiredRotation.Pitch, origRot.Pitch - near, origRot.Pitch + near);\n\t\t\t}\n\t\t\telse\n\t\t\t\tgun.DesiredRotation = origRot;\n\t}\n\telse\n\t{\n\t\tif ( !bConfused )\n\t\t\tgun.DesiredRotation = origRot;\n\t}\n\n\tnear = (Abs(gun.Rotation.Pitch - gun.DesiredRotation.Pitch)) % 65536;\n\tnear += (Abs(gun.Rotation.Yaw - gun.DesiredRotation.Yaw)) % 65536;\n\n\tif (bActive && !bDisabled)\n\t{\n\t\t// play an alert sound and light up\n\t\tif ((curTarget != None) && (curTarget != LastTarget))\n\t\t\tPlaySound(Sound'Beep6',,,, 1280);\n\n\t\t// if we're aiming close enough to our target\n\t\tif (curTarget != None)\n\t\t{\n\t\t\tgun.MultiSkins[1] = Texture'RedLightTex';\n\t\t\tif ((near < 4096) && (((Abs(gun.Rotation.Pitch - destRot.Pitch)) % 65536) < 8192))\n\t\t\t{\n\t\t\t\tif (fireTimer > fireRate)\n\t\t\t\t{\n\t\t\t\t\tFire();\n\t\t\t\t\tfireTimer = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (gun.IsAnimating())\n\t\t\t\tgun.PlayAnim('Still', 10.0, 0.001);\n\n\t\t\tif (bConfused)\n\t\t\t\tgun.MultiSkins[1] = Texture'YellowLightTex';\n\t\t\telse\n\t\t\t\tgun.MultiSkins[1] = Texture'GreenLightTex';\n\t\t}\n\n\t\tfireTimer += deltaTime;\n\t\tLastTarget = curTarget;\n\t}\n\telse\n\t{\n\t\tif (gun.IsAnimating())\n\t\t\tgun.PlayAnim('Still', 10.0, 0.001);\n\t\tgun.MultiSkins[1] = None;\n\t}\n\n\t// make noise if we're still moving\n\tif (near > 64)\n\t{\n\t\tgun.AmbientSound = Sound'AutoTurretMove';\n\t\tif (bConfused)\n\t\t\tgun.SoundPitch = 128;\n\t\telse\n\t\t\tgun.SoundPitch = 64;\n\t}\n\telse\n\t\tgun.AmbientSound = None;\n}\n\nfunction bool PSOwners(Pawn P)\n{\n\tif(DeusExPlayer(P) != None)\n\t{\n\t\tif(P == safeTarget || P == Owner)\n\t\t\treturn True;\n\t\t\n\t\tif(TCDeathmatch(level.game) != None)\n\t\t\tif(TCPRI(TCPlayer(Owner).PlayerReplicationInfo).TeamNamePRI != \"\" && TCPRI(TCPlayer(P).PlayerReplicationInfo).TeamNamePRI != \"\")\n\t\t\t\tif(TCPRI(TCPlayer(Owner).PlayerReplicationInfo).TeamNamePRI == TCPRI(TCPlayer(P).PlayerReplicationInfo).TeamNamePRI)\n\t\t\t\t\treturn true;\n\t\t\n\t\tif(TCDeathmatch(level.game) != None)\n\t\t\tif(TeamString != \"\" && TCPRI(TCPlayer(P).PlayerReplicationInfo).TeamNamePRI != \"\")\n\t\t\t\tif(TeamString == TCPRI(TCPlayer(P).PlayerReplicationInfo).TeamNamePRI)\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\tif(TCTeam(level.game) != None && TCPlayer(P).PlayerReplicationInfo.Team == TCPlayer(safeTarget).PlayerReplicationInfo.Team)\n\t\t\treturn true;\n\t}\n\t\t\n\treturn False;\n}\n\nauto state Active\n{\n\tfunction TakeDamage(int Damage, Pawn EventInstigator, vector HitLocation, vector Momentum, name DamageType)\n\t{\n\t\tlocal Human dxp;\n\t\tlocal float mindmg;\n\n\t\tif (DamageType == 'EMP')\n\t\t{\n\t\t\treturn; //Nulled function, IMMUNE TO EMP.\n\t\t}\n\n\t\tTurretHealth -= Damage; //Edited this in to avoid some things.\n\n\t\tif(bDisb == False)\n\t\t{\n\t\t\tif(TurretHealth <= 0)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction Fire()\n{\n\tlocal Vector HitLocation, HitNormal, StartTrace, EndTrace, X, Y, Z;\n\tlocal Rotator rot;\n\tlocal Actor hit;\n\tlocal ShellCasing shell;\n\tlocal Spark spark;\n\tlocal Pawn attacker;\n\n\tif (!gun.IsAnimating())\n\t\tgun.LoopAnim('Fire');\n\n\t// CNN - give turrets infinite ammo\n//\tif (ammoAmount > 0)\n//\t{\n//\t\tammoAmount--;\n\t\tGetAxes(gun.Rotation, X, Y, Z);\n\t\tStartTrace = gun.Location;\n\t\tEndTrace = StartTrace + gunAccuracy * (FRand()-0.5)*Y*1000 + gunAccuracy * (FRand()-0.5)*Z*1000 ;\n\t\tEndTrace += 10000 * X;\n\t\thit = Trace(HitLocation, HitNormal, EndTrace, StartTrace, True);\n\n\t\t// spawn some effects\n      if ((DeusExMPGame(Level.Game) != None) && (!DeusExMPGame(Level.Game).bSpawnEffects))\n      {\n         shell = None;\n      }\n      else\n      {\n         shell = Spawn(class'ShellCasing',,, gun.Location);\n      }\n\t\tif (shell != None)\n\t\t\tshell.Velocity = Vector(gun.Rotation - rot(0,16384,0)) * 100 + VRand() * 30;\n\n\t\tMakeNoise(1.0);\n\t\tPlaySound(sound'PistolFire', SLOT_None);\n\t\tAISendEvent('LoudNoise', EAITYPE_Audio);\n\n\t\t// muzzle flash\n\t\tgun.LightType = LT_Steady;\n\t\tgun.MultiSkins[2] = Texture'FlatFXTex34';\n\t\tSetTimer(0.1, False);\n\n\t\t// randomly draw a tracer\n\t\tif (FRand() < 0.5)\n\t\t{\n\t\t\tif (VSize(HitLocation - StartTrace) > 250)\n\t\t\t{\n\t\t\t\trot = Rotator(EndTrace - StartTrace);\n\t\t\t\tSpawn(class'Tracer',,, StartTrace + 96 * Vector(rot), rot);\n\t\t\t}\n\t\t}\n\n\t\tif (hit != None)\n\t\t{\n         if ((DeusExMPGame(Level.Game) != None) && (!DeusExMPGame(Level.Game).bSpawnEffects))\n         {\n            spark = None;\n         }\n         else\n         {\n            // spawn a little spark and make a ricochet sound if we hit something\n            spark = spawn(class'Spark',,,HitLocation+HitNormal, Rotator(HitNormal));\n         }\n\n\t\t\tif (spark != None)\n\t\t\t{\n\t\t\t\tspark.DrawScale = 0.05;\n\t\t\t\tPlayHitSound(spark, hit);\n\t\t\t}\n\n\t\t\tattacker = None;\n\t\t\tif ((curTarget == hit) && !curTarget.IsA('PlayerPawn'))\n\t\t\t\tattacker = GetPlayerPawn();\n         if (Level.NetMode != NM_Standalone)\n            attacker = safetarget;\n\t\t\tif ( hit.IsA('DeusExPlayer') && ( Level.NetMode != NM_Standalone ))\n\t\t\t\tDeusExPlayer(hit).myTurretKiller = Self;\n\t\t\thit.TakeDamage(gunDamage, attacker, HitLocation, 1000.0*X, 'AutoShot');\n\n\t\t\tif (hit.IsA('Pawn') && !hit.IsA('Robot'))\n\t\t\t\tSpawnBlood(HitLocation, HitNormal);\n\t\t\telse if ((hit == Level) || hit.IsA('Mover'))\n\t\t\t\tSpawnEffects(HitLocation, HitNormal, hit);\n\t\t}\n//\t}\n//\telse\n//\t{\n//\t\tPlaySound(sound'DryFire', SLOT_None);\n//\t}\n}\n\nfunction SpawnBlood(Vector HitLocation, Vector HitNormal)\n{\n\tlocal rotator rot;\n\n\trot = Rotator(Location - HitLocation);\n\trot.Pitch = 0;\n\trot.Roll = 0;\n\n   if ((DeusExMPGame(Level.Game) != None) && (!DeusExMPGame(Level.Game).bSpawnEffects))\n      return;\n\n\tspawn(class'BloodSpurt',,,HitLocation+HitNormal, rot);\n\tspawn(class'BloodDrop',,,HitLocation+HitNormal);\n\tif (FRand() < 0.5)\n\t\tspawn(class'BloodDrop',,,HitLocation+HitNormal);\n}\n\nsimulated function SpawnEffects(Vector HitLocation, Vector HitNormal, Actor Other)\n{\n\tlocal SmokeTrail puff;\n\tlocal int i;\n\tlocal BulletHole hole;\n\tlocal Rotator rot;\n\n   if ((DeusExMPGame(Level.Game) != None) && (!DeusExMPGame(Level.Game).bSpawnEffects))\n      return;\n\n   if (FRand() < 0.5)\n\t{\n\t\tpuff = spawn(class'SmokeTrail',,,HitLocation+HitNormal, Rotator(HitNormal));\n\t\tif (puff != None)\n\t\t{\n\t\t\tpuff.DrawScale *= 0.3;\n\t\t\tpuff.OrigScale = puff.DrawScale;\n\t\t\tpuff.LifeSpan = 0.25;\n\t\t\tpuff.OrigLifeSpan = puff.LifeSpan;\n\t\t}\n\t}\n\n\tif (!Other.IsA('BreakableGlass'))\n\t\tfor (i=0; i<2; i++)\n\t\t\tif (FRand() < 0.8)\n\t\t\t\tspawn(class'Rockchip',,,HitLocation+HitNormal);\n\n\thole = spawn(class'BulletHole', Other,, HitLocation, Rotator(HitNormal));\n\n\t// should we crack glass?\n\tif (GetWallMaterial(HitLocation, HitNormal) == 'Glass')\n\t{\n\t\tif (FRand() < 0.5)\n\t\t\thole.Texture = Texture'FlatFXTex29';\n\t\telse\n\t\t\thole.Texture = Texture'FlatFXTex30';\n\n\t\thole.DrawScale = 0.1;\n\t\thole.ReattachDecal();\n\t}\n}\n\nfunction name GetWallMaterial(vector HitLocation, vector HitNormal)\n{\n\tlocal vector EndTrace, StartTrace;\n\tlocal actor newtarget;\n\tlocal int texFlags;\n\tlocal name texName, texGroup;\n\n\tStartTrace = HitLocation + HitNormal*16;\t\t// make sure we start far enough out\n\tEndTrace = HitLocation - HitNormal;\n\n\tforeach TraceTexture(class'Actor', newtarget, texName, texGroup, texFlags, StartTrace, HitNormal, EndTrace)\n\t\tif ((newtarget == Level) || newtarget.IsA('Mover'))\n\t\t\tbreak;\n\n\treturn texGroup;\n}\n\nfunction PlayHitSound(actor destActor, Actor hitActor)\n{\n\tlocal float rnd;\n\tlocal sound snd;\n\n\trnd = FRand();\n\n\tif (rnd < 0.25)\n\t\tsnd = sound'Ricochet1';\n\telse if (rnd < 0.5)\n\t\tsnd = sound'Ricochet2';\n\telse if (rnd < 0.75)\n\t\tsnd = sound'Ricochet3';\n\telse\n\t\tsnd = sound'Ricochet4';\n\n\t// play a different ricochet sound if the object isn't damaged by normal bullets\n\tif (hitActor != None) \n\t{\n\t\tif (hitActor.IsA('DeusExDecoration') && (DeusExDecoration(hitActor).minDamageThreshold > 10))\n\t\t\tsnd = sound'ArmorRicochet';\n\t\telse if (hitActor.IsA('Robot'))\n\t\t\tsnd = sound'ArmorRicochet';\n\t}\n\n\tif (destActor != None)\n\t\tdestActor.PlaySound(snd, SLOT_None,,, 1024, 1.1 - 0.2*FRand());\n}\n\n// turn off the muzzle flash\nsimulated function Timer()\n{\n\tgun.LightType = LT_None;\n\tgun.MultiSkins[2] = None;\n}\n\n/*function AlarmHeard(Name event, EAIEventState state, XAIParams params)\n{\n\tif (state == EAISTATE_Begin)\n\t{\n\t\tif (!bActive)\n\t\t{\n\t\t\tbPreAlarmActiveState = bActive;\n\t\t\tbActive = True;\n\t\t}\n\t}\n\telse if (state == EAISTATE_End)\n\t{\n\t\tif (bActive)\n\t\t\tbActive = bPreAlarmActiveState;\n\t}\n}*/\n\nfunction PreBeginPlay()\n{\n\tlocal Vector v1, v2;\n\tlocal class<AutoTurretGun> gunClass;\n\tlocal Rotator rot;\n\n\tSuper.PreBeginPlay();\n\n\tif (IsA('AutoTurretSmall'))\n\t\tgunClass = class'AutoTurretGunSmall';\n\telse\n\t\tgunClass = class'AutoTurretGun';\n\n\trot = Rotation;\n\trot.Pitch = 0;\n\trot.Roll = 0;\n\torigRot = rot;\n\tgun = Spawn(gunClass, Self,, Location, rot);\n\tif (gun != None)\n\t{\n\t\tv1.X = 0;\n\t\tv1.Y = 0;\n\t\tv1.Z = CollisionHeight + gun.Default.CollisionHeight;\n\t\tv2 = v1 >> Rotation;\n\t\tv2 += Location;\n\t\tgun.bHackable=False;\n\t\tgun.SetLocation(v2);\n\t\tgun.SetBase(Self);\n\t}\n\n\t// set up the alarm listeners\n\t//AISetEventCallback('Alarm', 'AlarmHeard');\n\n\tmaxRange = mpTurretRange;\n\tgunDamage = mpTurretDamage;\n\tbDisabled = !bActive;\n}\n\nfunction PostBeginPlay()\n{\n   safeTarget = None;\n   prevTarget = None;\n   TargetRefreshTime = 0;\n   Super.PostBeginPlay();\n}\n\ndefaultproperties\n{\n    TurretHealth=100\n    titleString=\"AutoTurret\"\n    bTrackPlayersOnly=True\n    bActive=True\n    maxRange=512\n    fireRate=0.25\n    gunAccuracy=0.50\n    gunDamage=5\n    AmmoAmount=1000\n    confusionDuration=120.00\n    pitchLimit=11000.00\n    Team=500\n    mpTurretDamage=20\n    mpTurretRange=1024\n    HitPoints=100\n    minDamageThreshold=100\n    bHighlight=False\n    ItemName=\"Turret Base\"\n    bPushable=False\n    Physics=0\n    Mesh=LodMesh'DeusExDeco.AutoTurretBase'\n    SoundRadius=48\n    SoundVolume=192\n    AmbientSound=Sound'DeusExSounds.Generic.AutoTurretHum'\n    CollisionRadius=14.00\n    CollisionHeight=20.20\n    Mass=50.00\n    Buoyancy=10.00\n    bVisionImportant=True\n}\n",
            "name": "TCAutoTurret.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "TurretHealth=100",
                    "titleString=\"AutoTurret\"",
                    "bTrackPlayersOnly=True",
                    "bActive=True",
                    "maxRange=512",
                    "fireRate=0.25",
                    "gunAccuracy=0.50",
                    "gunDamage=5",
                    "AmmoAmount=1000",
                    "confusionDuration=120.00",
                    "pitchLimit=11000.00",
                    "Team=500",
                    "mpTurretDamage=20",
                    "mpTurretRange=1024",
                    "HitPoints=100",
                    "minDamageThreshold=100",
                    "bHighlight=False",
                    "ItemName=\"Turret Base\"",
                    "bPushable=False",
                    "Physics=0",
                    "Mesh=LodMesh'DeusExDeco.AutoTurretBase'",
                    "SoundRadius=48",
                    "SoundVolume=192",
                    "AmbientSound=Sound'DeusExSounds.Generic.AutoTurretHum'",
                    "CollisionRadius=14.00",
                    "CollisionHeight=20.20",
                    "Mass=50.00",
                    "Buoyancy=10.00",
                    "bVisionImportant=True"
                ],
                "exec": [],
                "extends": "AutoTurret",
                "functions": {
                    "AcquireMultiplayerTarget": {
                        "body": "{\n\n\tif ( bSwitching )\n\t{\n\t\tnoActor = None;\n\t\treturn noActor;\n\t}\n\n\tapawn = gun.Level.PawnList;\n\n\twhile ( apawn != None )\n\t{\n\t\t//if (apawn.bDetectable && !apawn.bIgnore && apawn.IsA('DeusExPlayer'))\n\t\tif (apawn.bDetectable && !apawn.bIgnore)\n\t\t{\n\t\t\taplayer = DeusExPlayer(apawn);\n\n\t\t\tdist = apawn.Location - gun.Location; //apawn was aplayer\n\n\t\t\tif ( VSize(dist) < maxRange )\n\t\t\t{\n\t\t\t\t// Only players we can see\n\t\t\t\tif ( apawn.FastTrace( apawn.Location, gun.Location ))//apawn was aplayer\n\t\t\t\t{\n\t\t\t\t\tif(!PSOwners(apawn))\n\t\t\t\t\t{\n\t\t\t\t\t\tif(curTarget == None)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcurTarget = apawn;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tapawn = apawn.nextPawn;\n\t}\n\treturn curtarget;\n}",
                        "locals": [
                            "local Pawn apawn;",
                            "local DeusExPlayer aplayer;",
                            "local Vector dist;",
                            "local Actor noActor;"
                        ],
                        "modifiers": [],
                        "name": "AcquireMultiplayerTarget",
                        "native": false,
                        "param": [],
                        "return": "Actor"
                    },
                    "Destroyed": {
                        "body": "{\t\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Destroyed",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Fire": {
                        "body": "{\n\n\tif (!gun.IsAnimating())\n\t\tgun.LoopAnim('Fire');\n\n\t// CNN - give turrets infinite ammo\n//\tif (ammoAmount > 0)\n//\t{\n//\t\tammoAmount--;\n\t\tGetAxes(gun.Rotation, X, Y, Z);\n\t\tStartTrace = gun.Location;\n\t\tEndTrace = StartTrace + gunAccuracy * (FRand()-0.5)*Y*1000 + gunAccuracy * (FRand()-0.5)*Z*1000 ;\n\t\tEndTrace += 10000 * X;\n\t\thit = Trace(HitLocation, HitNormal, EndTrace, StartTrace, True);\n\n\t\t// spawn some effects\n      if ((DeusExMPGame(Level.Game) != None) && (!DeusExMPGame(Level.Game).bSpawnEffects))\n      {\n         shell = None;\n      }\n      else\n      {\n         shell = Spawn(class'ShellCasing',,, gun.Location);\n      }\n\t\tif (shell != None)\n\t\t\tshell.Velocity = Vector(gun.Rotation - rot(0,16384,0)) * 100 + VRand() * 30;\n\n\t\tMakeNoise(1.0);\n\t\tPlaySound(sound'PistolFire', SLOT_None);\n\t\tAISendEvent('LoudNoise', EAITYPE_Audio);\n\n\t\t// muzzle flash\n\t\tgun.LightType = LT_Steady;\n\t\tgun.MultiSkins[2] = Texture'FlatFXTex34';\n\t\tSetTimer(0.1, False);\n\n\t\t// randomly draw a tracer\n\t\tif (FRand() < 0.5)\n\t\t{\n\t\t\tif (VSize(HitLocation - StartTrace) > 250)\n\t\t\t{\n\t\t\t\trot = Rotator(EndTrace - StartTrace);\n\t\t\t\tSpawn(class'Tracer',,, StartTrace + 96 * Vector(rot), rot);\n\t\t\t}\n\t\t}\n\n\t\tif (hit != None)\n\t\t{\n         if ((DeusExMPGame(Level.Game) != None) && (!DeusExMPGame(Level.Game).bSpawnEffects))\n         {\n            spark = None;\n         }\n         else\n         {\n            // spawn a little spark and make a ricochet sound if we hit something\n            spark = spawn(class'Spark',,,HitLocation+HitNormal, Rotator(HitNormal));\n         }\n\n\t\t\tif (spark != None)\n\t\t\t{\n\t\t\t\tspark.DrawScale = 0.05;\n\t\t\t\tPlayHitSound(spark, hit);\n\t\t\t}\n\n\t\t\tattacker = None;\n\t\t\tif ((curTarget == hit) && !curTarget.IsA('PlayerPawn'))\n\t\t\t\tattacker = GetPlayerPawn();\n         if (Level.NetMode != NM_Standalone)\n            attacker = safetarget;\n\t\t\tif ( hit.IsA('DeusExPlayer') && ( Level.NetMode != NM_Standalone ))\n\t\t\t\tDeusExPlayer(hit).myTurretKiller = Self;\n\t\t\thit.TakeDamage(gunDamage, attacker, HitLocation, 1000.0*X, 'AutoShot');\n\n\t\t\tif (hit.IsA('Pawn') && !hit.IsA('Robot'))\n\t\t\t\tSpawnBlood(HitLocation, HitNormal);\n\t\t\telse if ((hit == Level) || hit.IsA('Mover'))\n\t\t\t\tSpawnEffects(HitLocation, HitNormal, hit);\n\t\t}\n//\t}",
                        "locals": [
                            "local Vector HitLocation, HitNormal, StartTrace, EndTrace, X, Y, Z;",
                            "local Rotator rot;",
                            "local Actor hit;",
                            "local ShellCasing shell;",
                            "local Spark spark;",
                            "local Pawn attacker;"
                        ],
                        "modifiers": [],
                        "name": "Fire",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GetWallMaterial": {
                        "body": "{\n\n\tStartTrace = HitLocation + HitNormal*16;\t\t// make sure we start far enough out\n\tEndTrace = HitLocation - HitNormal;\n\n\tforeach TraceTexture(class'Actor', newtarget, texName, texGroup, texFlags, StartTrace, HitNormal, EndTrace)\n\t\tif ((newtarget == Level) || newtarget.IsA('Mover'))\n\t\t\tbreak;\n\n\treturn texGroup;\n}",
                        "locals": [
                            "local vector EndTrace, StartTrace;",
                            "local actor newtarget;",
                            "local int texFlags;",
                            "local name texName, texGroup;"
                        ],
                        "modifiers": [],
                        "name": "GetWallMaterial",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "HitLocation"
                            ],
                            [
                                "vector",
                                "HitNormal"
                            ]
                        ],
                        "return": "name"
                    },
                    "PSOwners": {
                        "body": "{\n\tif(DeusExPlayer(P) != None)\n\t{\n\t\tif(P == safeTarget || P == Owner)\n\t\t\treturn True;\n\t\t\n\t\tif(TCDeathmatch(level.game) != None)\n\t\t\tif(TCPRI(TCPlayer(Owner).PlayerReplicationInfo).TeamNamePRI != \"\" && TCPRI(TCPlayer(P).PlayerReplicationInfo).TeamNamePRI != \"\")\n\t\t\t\tif(TCPRI(TCPlayer(Owner).PlayerReplicationInfo).TeamNamePRI == TCPRI(TCPlayer(P).PlayerReplicationInfo).TeamNamePRI)\n\t\t\t\t\treturn true;\n\t\t\n\t\tif(TCDeathmatch(level.game) != None)\n\t\t\tif(TeamString != \"\" && TCPRI(TCPlayer(P).PlayerReplicationInfo).TeamNamePRI != \"\")\n\t\t\t\tif(TeamString == TCPRI(TCPlayer(P).PlayerReplicationInfo).TeamNamePRI)\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\tif(TCTeam(level.game) != None && TCPlayer(P).PlayerReplicationInfo.Team == TCPlayer(safeTarget).PlayerReplicationInfo.Team)\n\t\t\treturn true;\n\t}\n\t\t\n\treturn False;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PSOwners",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "P"
                            ]
                        ],
                        "return": "bool"
                    },
                    "PlayHitSound": {
                        "body": "{\n\n\trnd = FRand();\n\n\tif (rnd < 0.25)\n\t\tsnd = sound'Ricochet1';\n\telse if (rnd < 0.5)\n\t\tsnd = sound'Ricochet2';\n\telse if (rnd < 0.75)\n\t\tsnd = sound'Ricochet3';\n\telse\n\t\tsnd = sound'Ricochet4';\n\n\t// play a different ricochet sound if the object isn't damaged by normal bullets\n\tif (hitActor != None) \n\t{\n\t\tif (hitActor.IsA('DeusExDecoration') && (DeusExDecoration(hitActor).minDamageThreshold > 10))\n\t\t\tsnd = sound'ArmorRicochet';\n\t\telse if (hitActor.IsA('Robot'))\n\t\t\tsnd = sound'ArmorRicochet';\n\t}\n\n\tif (destActor != None)\n\t\tdestActor.PlaySound(snd, SLOT_None,,, 1024, 1.1 - 0.2*FRand());\n}",
                        "locals": [
                            "local float rnd;",
                            "local sound snd;"
                        ],
                        "modifiers": [],
                        "name": "PlayHitSound",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "destActor"
                            ],
                            [
                                "Actor",
                                "hitActor"
                            ]
                        ],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n   safeTarget = None;\n   prevTarget = None;\n   TargetRefreshTime = 0;\n   Super.PostBeginPlay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\n\tSuper.PreBeginPlay();\n\n\tif (IsA('AutoTurretSmall'))\n\t\tgunClass = class'AutoTurretGunSmall';\n\telse\n\t\tgunClass = class'AutoTurretGun';\n\n\trot = Rotation;\n\trot.Pitch = 0;\n\trot.Roll = 0;\n\torigRot = rot;\n\tgun = Spawn(gunClass, Self,, Location, rot);\n\tif (gun != None)\n\t{\n\t\tv1.X = 0;\n\t\tv1.Y = 0;\n\t\tv1.Z = CollisionHeight + gun.Default.CollisionHeight;\n\t\tv2 = v1 >> Rotation;\n\t\tv2 += Location;\n\t\tgun.bHackable=False;\n\t\tgun.SetLocation(v2);\n\t\tgun.SetBase(Self);\n\t}\n\n\t// set up the alarm listeners\n\t//AISetEventCallback('Alarm', 'AlarmHeard');\n\n\tmaxRange = mpTurretRange;\n\tgunDamage = mpTurretDamage;\n\tbDisabled = !bActive;\n}",
                        "locals": [
                            "local Vector v1, v2;",
                            "local class<AutoTurretGun> gunClass;",
                            "local Rotator rot;"
                        ],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpawnBlood": {
                        "body": "{\n\n\trot = Rotator(Location - HitLocation);\n\trot.Pitch = 0;\n\trot.Roll = 0;\n\n   if ((DeusExMPGame(Level.Game) != None) && (!DeusExMPGame(Level.Game).bSpawnEffects))\n      return;\n\n\tspawn(class'BloodSpurt',,,HitLocation+HitNormal, rot);\n\tspawn(class'BloodDrop',,,HitLocation+HitNormal);\n\tif (FRand() < 0.5)\n\t\tspawn(class'BloodDrop',,,HitLocation+HitNormal);\n}",
                        "locals": [
                            "local rotator rot;"
                        ],
                        "modifiers": [],
                        "name": "SpawnBlood",
                        "native": false,
                        "param": [
                            [
                                "Vector",
                                "HitLocation"
                            ],
                            [
                                "Vector",
                                "HitNormal"
                            ]
                        ],
                        "return": ""
                    },
                    "SpawnEffects": {
                        "body": "{\n\n   if ((DeusExMPGame(Level.Game) != None) && (!DeusExMPGame(Level.Game).bSpawnEffects))\n      return;\n\n   if (FRand() < 0.5)\n\t{\n\t\tpuff = spawn(class'SmokeTrail',,,HitLocation+HitNormal, Rotator(HitNormal));\n\t\tif (puff != None)\n\t\t{\n\t\t\tpuff.DrawScale *= 0.3;\n\t\t\tpuff.OrigScale = puff.DrawScale;\n\t\t\tpuff.LifeSpan = 0.25;\n\t\t\tpuff.OrigLifeSpan = puff.LifeSpan;\n\t\t}\n\t}\n\n\tif (!Other.IsA('BreakableGlass'))\n\t\tfor (i=0; i<2; i++)\n\t\t\tif (FRand() < 0.8)\n\t\t\t\tspawn(class'Rockchip',,,HitLocation+HitNormal);\n\n\thole = spawn(class'BulletHole', Other,, HitLocation, Rotator(HitNormal));\n\n\t// should we crack glass?\n\tif (GetWallMaterial(HitLocation, HitNormal) == 'Glass')\n\t{\n\t\tif (FRand() < 0.5)\n\t\t\thole.Texture = Texture'FlatFXTex29';\n\t\telse\n\t\t\thole.Texture = Texture'FlatFXTex30';\n\n\t\thole.DrawScale = 0.1;\n\t\thole.ReattachDecal();\n\t}\n}",
                        "locals": [
                            "local SmokeTrail puff;",
                            "local int i;",
                            "local BulletHole hole;",
                            "local Rotator rot;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "SpawnEffects",
                        "native": false,
                        "param": [
                            [
                                "Vector",
                                "HitLocation"
                            ],
                            [
                                "Vector",
                                "HitNormal"
                            ],
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "TakeDamage": {
                        "body": "{\n\n\t\tif (DamageType == 'EMP')\n\t\t{\n\t\t\treturn; //Nulled function, IMMUNE TO EMP.\n\t\t}\n\n\t\tTurretHealth -= Damage; //Edited this in to avoid some things.\n\n\t\tif(bDisb == False)\n\t\t{\n\t\t\tif(TurretHealth <= 0)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}",
                        "locals": [
                            "local Human dxp;",
                            "local float mindmg;"
                        ],
                        "modifiers": [],
                        "name": "TakeDamage",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Damage"
                            ],
                            [
                                "Pawn",
                                "EventInstigator"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ],
                            [
                                "vector",
                                "Momentum"
                            ],
                            [
                                "name",
                                "DamageType"
                            ]
                        ],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n\n\tSuper.Tick(deltaTime);\n\n\tbSwitched = False;\n\n\tif ( bSwitching )\n\t{\n\t\tUpdateSwitch();\n\t\treturn;\n\t}\n\n\tif (bActive && !bDisabled)\n\t{\n\t\tcurTarget = None;\n\n\t\tif ( !bConfused )\n\t\t{\n\t\t\tif (TargetRefreshTime < 0)\n\t\t\tTargetRefreshTime = 0;\n         \n\t\t\tTargetRefreshTime = TargetRefreshTime + deltaTime;\n\n\t\t\tif (TargetRefreshTime >= 0.3)\n\t\t\t{\n\t\t\t\tTargetRefreshTime = 0;\n\t\t\t\tcurTarget = AcquireMultiplayerTarget();\n\n//\t\t\t\tif ( curTarget == None )\n//\t\t\t\tPlaySound(Sound'TurretUnlocked', SLOT_Interact, 1.0,, maxRange );\n//\t\t\t\tprevtarget = curtarget;\t\t\n\t\t\t}\n\n\t\t\t\t\tforeach gun.VisibleActors(class'Pawn', pawn, maxRange, gun.Location)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pawn.bDetectable && !pawn.bIgnore)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif(curTarget == None)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif(!PSOwners(Pawn))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tcurTarget = Pawn;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if we have a target, rotate to face it\n\t\t\tif (curTarget != None)\n\t\t\t{\n\t\t\t\tdestRot = Rotator(curTarget.Location - gun.Location);\n\t\t\t\tgun.DesiredRotation = destRot;\n\t\t\t\tnear = pitchLimit / 2;\n\t\t\t\tgun.DesiredRotation.Pitch = FClamp(gun.DesiredRotation.Pitch, origRot.Pitch - near, origRot.Pitch + near);\n\t\t\t}\n\t\t\telse\n\t\t\t\tgun.DesiredRotation = origRot;\n\t}\n\telse\n\t{\n\t\tif ( !bConfused )\n\t\t\tgun.DesiredRotation = origRot;\n\t}\n\n\tnear = (Abs(gun.Rotation.Pitch - gun.DesiredRotation.Pitch)) % 65536;\n\tnear += (Abs(gun.Rotation.Yaw - gun.DesiredRotation.Yaw)) % 65536;\n\n\tif (bActive && !bDisabled)\n\t{\n\t\t// play an alert sound and light up\n\t\tif ((curTarget != None) && (curTarget != LastTarget))\n\t\t\tPlaySound(Sound'Beep6',,,, 1280);\n\n\t\t// if we're aiming close enough to our target\n\t\tif (curTarget != None)\n\t\t{\n\t\t\tgun.MultiSkins[1] = Texture'RedLightTex';\n\t\t\tif ((near < 4096) && (((Abs(gun.Rotation.Pitch - destRot.Pitch)) % 65536) < 8192))\n\t\t\t{\n\t\t\t\tif (fireTimer > fireRate)\n\t\t\t\t{\n\t\t\t\t\tFire();\n\t\t\t\t\tfireTimer = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (gun.IsAnimating())\n\t\t\t\tgun.PlayAnim('Still', 10.0, 0.001);\n\n\t\t\tif (bConfused)\n\t\t\t\tgun.MultiSkins[1] = Texture'YellowLightTex';\n\t\t\telse\n\t\t\t\tgun.MultiSkins[1] = Texture'GreenLightTex';\n\t\t}\n\n\t\tfireTimer += deltaTime;\n\t\tLastTarget = curTarget;\n\t}\n\telse\n\t{\n\t\tif (gun.IsAnimating())\n\t\t\tgun.PlayAnim('Still', 10.0, 0.001);\n\t\tgun.MultiSkins[1] = None;\n\t}\n\n\t// make noise if we're still moving\n\tif (near > 64)\n\t{\n\t\tgun.AmbientSound = Sound'AutoTurretMove';\n\t\tif (bConfused)\n\t\t\tgun.SoundPitch = 128;\n\t\telse\n\t\t\tgun.SoundPitch = 64;\n\t}\n\telse\n\t\tgun.AmbientSound = None;\n}",
                        "locals": [
                            "local Pawn pawn;",
                            "local ScriptedPawn sp;",
                            "local DeusExDecoration deco;",
                            "local float near;",
                            "local Rotator destRot;",
                            "local bool bSwitched;"
                        ],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "deltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tgun.LightType = LT_None;\n\tgun.MultiSkins[2] = None;\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "UpdateSwitch": {
                        "body": "{\n\tif ( Level.Timeseconds > SwitchTime )\n\t{\n\t\tbSwitching = False;\n\t\t//safeTarget = savedTarget;\n\t\tSwitchTime = 0;\n\t\tbeepTime = 0;\n\t}\n\telse\n\t{\n\t\tif ( Level.Timeseconds > beepTime )\n\t\t{\n\t\t\tPlaySound(Sound'TurretSwitch', SLOT_Interact, 1.0,, maxRange );\n\t\t\tbeepTime = Level.Timeseconds + 0.75;\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateSwitch",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 601,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool bDisb;",
                    "var() int TurretHealth;",
                    "var string TeamString;",
                    "var AutoTurretGun gun;",
                    "var() localized String titleString;\t\t// So we can name specific turrets in multiplayer",
                    "var() bool bTrackPawnsOnly;",
                    "var() bool bTrackPlayersOnly;",
                    "var() bool bActive;",
                    "var() int maxRange;",
                    "var() float fireRate;",
                    "var() float gunAccuracy;",
                    "var() int gunDamage;",
                    "var() int ammoAmount;",
                    "var Actor curTarget;",
                    "var Actor prevTarget;         // target we had last tick.",
                    "var Pawn safeTarget;          // in multiplayer, this actor is strictly off-limits",
                    "var float fireTimer;",
                    "var bool bConfused;\t\t\t\t// used when hit by EMP",
                    "var float confusionTimer;\t\t// how long until turret resumes normal operation",
                    "var float confusionDuration;\t// how long does an EMP hit last?",
                    "var Actor LastTarget;\t\t\t// what was our last target?",
                    "var float pitchLimit;\t\t\t// what's the maximum pitch?",
                    "var Rotator origRot;\t\t\t// original rotation",
                    "var bool bPreAlarmActiveState;\t// was I previously awake or not?",
                    "var bool bDisabled;\t\t\t\t// have I been hacked or shut down by computers?",
                    "var float TargetRefreshTime;      // used for multiplayer to reduce rate of checking for targets.",
                    "var() float Thick;",
                    "var() float PawnThick;",
                    "var() int team;\t\t\t\t\t\t// Keep track of team the turrets on",
                    "var int mpTurretDamage;\t\t\t// Settings for multiplayer",
                    "var int mpTurretRange;",
                    "var bool bComputerReset;\t\t\t// Keep track of if computer has been reset so we avoid all actors checks",
                    "var bool bSwitching;",
                    "var float SwitchTime, beepTime;",
                    "var Pawn savedTarget;"
                ]
            }
        },
        "TCComputerSecurity.uc": {
            "body": "//=============================================================================\n// ComputerSecurity.\n//=============================================================================\nclass TCComputerSecurity extends Computersecurity;\n\nstruct sViewInfo\n{\n\tvar() localized string\ttitleString;\n\tvar() name\t\t\t\tcameraTag;\n\tvar() name\t\t\t\tturretTag;\n\tvar() name\t\t\t\tdoorTag;\n};\n\nvar() localized sViewInfo Views[3];\nvar int team;\nvar string TeamName;\n\n// ----------------------------------------------------------------------------\n// network replication\n// ----------------------------------------------------------------------------\nreplication\n{\n   //server to client\n   reliable if (Role == ROLE_Authority)\n      Views, team, TeamName;\n}\n\n// -----------------------------------------------------------------------\n// SetControlledObjectOwners\n// Used to enhance network replication.\n// -----------------------------------------------------------------------\n\nfunction SetControlledObjectOwners(DeusExPlayer PlayerWhoOwns)\n{\n\tlocal int cameraIndex;\n\tlocal name tag;\n\tlocal SecurityCamera camera;\n   local TCAutoTurret turret;\n   local DeusExMover door;\n\n\tfor (cameraIndex=0; cameraIndex<ArrayCount(Views); cameraIndex++)\n\t{\n\t\ttag = Views[cameraIndex].cameraTag;\n\t\tif (tag != '')\n\t\t\tforeach AllActors(class'SecurityCamera', camera, tag)\n\t\t\t\tcamera.SetOwner(PlayerWhoOwns);\n\n\t\ttag = Views[cameraIndex].turretTag;\n\t\tif (tag != '')\n\t\t\tforeach AllActors(class'TCAutoTurret', turret, tag)\n            {\n\t\t\t\tif(TCDeathmatch(level.game) != None)\n\t\t\t\t\tturret.teamstring = TCPRI(PlayerWhoOwns.PlayerReplicationInfo).TeamNamePRI;\n\t\t\t\tturret.SetOwner(PlayerWhoOwns);\n\t\t\t}\n\t\t\t\t\n\t\ttag = Views[cameraIndex].doorTag;\n\t\tif (tag != '')\n\t\t\tforeach AllActors(class'DeusExMover', door, tag)\n\t\t\t\tdoor.SetOwner(PlayerWhoOwns);\n\n\t}\n\n}\n\n// ----------------------------------------------------------------------\n// AdditionalActivation()\n// Called for subclasses to do any additional activation steps.\n// ----------------------------------------------------------------------\n\nfunction AdditionalActivation(DeusExPlayer ActivatingPlayer)\n{\n   if (Level.NetMode != NM_Standalone)\n      SetControlledObjectOwners(ActivatingPlayer);\n   \n   Super.AdditionalDeactivation(ActivatingPlayer);\n}\n\n// ----------------------------------------------------------------------\n// AdditionalDeactivation()\n// ----------------------------------------------------------------------\n\nfunction AdditionalDeactivation(DeusExPlayer DeactivatingPlayer)\n{\n   if (Level.NetMode != NM_Standalone)\n      SetControlledObjectOwners(None);\n   \n   Super.AdditionalDeactivation(DeactivatingPlayer);\n}\n\n\n\ndefaultproperties\n{\n    TeamName=\"\"\n\tTeam=-1\n\tPhysics=PHYS_None\n    terminalType=Class'NetworkTerminalSecurity'\n    lockoutDelay=120.00\n    UserList=(accountNumber=\"SECURITY\",PIN=\"SECURITY\",balance=1918989824),\n    ItemName=\"Security Computer Terminal\"\n    Physics=0\n    Mesh=LodMesh'DeusExDeco.ComputerSecurity'\n    SoundRadius=8\n    SoundVolume=255\n    SoundPitch=96\n    AmbientSound=Sound'DeusExSounds.Generic.SecurityL'\n    CollisionRadius=11.59\n    CollisionHeight=10.10\n    bCollideWorld=False\n    BindName=\"ComputerSecurity\"\n}\n",
            "name": "TCComputerSecurity.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "TeamName=\"\"",
                    "Team=-1",
                    "Physics=PHYS_None",
                    "terminalType=Class'NetworkTerminalSecurity'",
                    "lockoutDelay=120.00",
                    "UserList=(accountNumber=\"SECURITY\",PIN=\"SECURITY\",balance=1918989824),",
                    "ItemName=\"Security Computer Terminal\"",
                    "Physics=0",
                    "Mesh=LodMesh'DeusExDeco.ComputerSecurity'",
                    "SoundRadius=8",
                    "SoundVolume=255",
                    "SoundPitch=96",
                    "AmbientSound=Sound'DeusExSounds.Generic.SecurityL'",
                    "CollisionRadius=11.59",
                    "CollisionHeight=10.10",
                    "bCollideWorld=False",
                    "BindName=\"ComputerSecurity\""
                ],
                "exec": [],
                "extends": "Computersecurity",
                "functions": {
                    "AdditionalActivation": {
                        "body": "{\n   if (Level.NetMode != NM_Standalone)\n      SetControlledObjectOwners(ActivatingPlayer);\n   \n   Super.AdditionalDeactivation(ActivatingPlayer);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AdditionalActivation",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "ActivatingPlayer"
                            ]
                        ],
                        "return": ""
                    },
                    "AdditionalDeactivation": {
                        "body": "{\n   if (Level.NetMode != NM_Standalone)\n      SetControlledObjectOwners(None);\n   \n   Super.AdditionalDeactivation(DeactivatingPlayer);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AdditionalDeactivation",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "DeactivatingPlayer"
                            ]
                        ],
                        "return": ""
                    },
                    "SetControlledObjectOwners": {
                        "body": "{\n\n\tfor (cameraIndex=0; cameraIndex<ArrayCount(Views); cameraIndex++)\n\t{\n\t\ttag = Views[cameraIndex].cameraTag;\n\t\tif (tag != '')\n\t\t\tforeach AllActors(class'SecurityCamera', camera, tag)\n\t\t\t\tcamera.SetOwner(PlayerWhoOwns);\n\n\t\ttag = Views[cameraIndex].turretTag;\n\t\tif (tag != '')\n\t\t\tforeach AllActors(class'TCAutoTurret', turret, tag)\n            {\n\t\t\t\tif(TCDeathmatch(level.game) != None)\n\t\t\t\t\tturret.teamstring = TCPRI(PlayerWhoOwns.PlayerReplicationInfo).TeamNamePRI;\n\t\t\t\tturret.SetOwner(PlayerWhoOwns);\n\t\t\t}\n\t\t\t\t\n\t\ttag = Views[cameraIndex].doorTag;\n\t\tif (tag != '')\n\t\t\tforeach AllActors(class'DeusExMover', door, tag)\n\t\t\t\tdoor.SetOwner(PlayerWhoOwns);\n\n\t}\n\n}",
                        "locals": [
                            "local int cameraIndex;",
                            "local name tag;",
                            "local SecurityCamera camera;",
                            "local TCAutoTurret turret;",
                            "local DeusExMover door;"
                        ],
                        "modifiers": [],
                        "name": "SetControlledObjectOwners",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "PlayerWhoOwns"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 113,
                "replication": "",
                "states": [],
                "variables": [
                    "var() localized string\ttitleString;",
                    "var() name\t\t\t\tcameraTag;",
                    "var() name\t\t\t\tturretTag;",
                    "var() name\t\t\t\tdoorTag;",
                    "var() localized sViewInfo Views[3];",
                    "var int team;",
                    "var string TeamName;"
                ]
            }
        },
        "TCControls.uc": {
            "body": "class TCControls extends Actor config(OpenDX);\n\n//Core settings\nvar config bool bFixMovers;\nvar config bool bChatCommands;\nvar config bool bSpawnReplacer;\nvar config string SummonPassword;\nvar config string ModPassword;\nvar config string SuperAdminPassword;\nvar config string _OwnerPassword;\nvar config bool bAllowModSummon;\nvar config bool bAllowModCheats;\nvar config bool bAllowModGhost;\nvar config bool bAllowModCommand;\nvar config bool bAllowModMutator;\nvar config bool bKillMessages;\nvar config bool bTCFriendlyFire;\nvar config bool bFixLevel;\nvar config bool bAllowTPAsk;\nvar config bool bDisableFallDamage; \nvar config bool bAllowSkins;\nvar config bool bAllowRemote;\nvar config bool bShowAdmins, bShowMods, bShowStatus;\nvar config bool bAllowSelfHUD;\nvar config bool bWordFilter;\nvar config string ConsoleName;\nvar config texture ScoreboardTex;\nvar config string ScoreboardExtStr;\nvar config bool bAllowRobotSkins, bAllowAnimalSkins;\nvar config bool bDrawServerInfo;\nvar config float GlobalLogTimeout;\nvar config int NotificationTimer;\nvar config bool bAllowStorage;\nvar config bool bNotifWhisper;\nvar config int MantleBio, DoubleJumpBio, WallJumpBio;\nvar config bool bCanSpectateEnemy;\nvar config float WhisperRadius;\nvar config bool bShowHitz;\nvar config string SilentAdminPassword;\nvar config bool bShowExtraHud;\nvar config int ffReduction;\nvar config bool bAllowMark;\nvar config bool bGameTypeVote;\nvar config bool bMapvote;\nvar config bool bAllowSuicide2;\nvar config bool bAllowKillphrase;\nvar config float KillphraseRadius;\nvar config bool bNewMainMenu, bSpectatorStart;\n//var config Texture TextLogo;\n\nstruct WordFilter\n{\n     var config string Trgt;\n\t var config string Rep;\n};\n\nvar config WordFilter Filters[10];\n\n//Anticheat vars\nvar config bool bPunishDT;\nvar config int DTLimit;\nvar config int AutoIdleTime, AutoIdleKickTime;\nvar config bool bAllowMPInv;\nvar config bool bEnforceFPS;\nvar config int FPSCap;\n\n//Parkour vars\nvar config int MantleVelocity;\nvar config float WallJumpVelocity, DoubleJumpMultiplier, WallJumpZVelocity;\nvar config int WallJumpCheck;\nvar config bool bDoubleJump; \nvar config bool bMantling; \nvar config bool bWallJumping;\nvar config int FallDamageReduction;\nvar config bool bNameDisplay;\n\nenum EHudStyle\n{\n\tHUD_Extended, //Shows all info, the standard OpenDX HUD\n\tHUD_Basic, //A minimal OpenDX variation, doesn't show as much info, still uses new colouring etc\n\tHUD_Unified, //Shows Bots as Players, maybe other changes\n\tHUD_Original, //As it was in base DX\n\tHUD_Off //Disabled\n};\nvar config EHudStyle HUDType;\n\n//Sub-gametype (GunGame) Settings\nvar(Arsenal) config string DemoteWeapons[5];\nvar(Arsenal) config name SaveSpawnWeapons[5];\nvar(Arsenal) config bool bHealTimer;\nvar(Arsenal) config int HealTimer;\n\n//Sub-gametype (KillConfirmed) Settings\nvar(KillConfirmed) config int KCLifespan;\nvar(KillConfirmed) config int BaseScoreMultiplier;\n\n//Sub-gametype (Juggernaut) Settings\nvar(Juggernaut) config int StreakLimit;\n\n//Sub-gametype (Sharpshooter) Settings\nvar(Sharpshooter) config string SSWeapons[30];\nvar(Sharpshooter) config float SSRoundDelay;\nvar(Sharpshooter) config bool bMethodOne;\n\n//Static Variables\nvar bool _bFixedLevel;\nvar int TeamCount;\nvar ODXVoteActor Votez;\n\nvar OSDActor OSDA;\n\nvar(OpenDX) config bool bHasUpdate;\nvar string netversion;\nvar string GSCData;\nvar float TimeUntilUpdate;\n\nconst _k013145123423321 = \"_dmg\";\nconst version = \"180109\";\nconst changestr = \"Reverting broken changes.\";\n\nfunction CodeBase _CodeBase()\n{\n\treturn Spawn(class'CodeBase');\n}\n\nfunction UpdateCheck();\n\nfunction string Changes()\n{\n\treturn changestr;\n}\n\nfunction Timer()\n{\n\tlocal TCPlayer TCP;\n\tlocal string datastring, DataStore, corever, netmsg;\n\n\tforeach AllActors(class'TCPlayer',TCP)\n\t{\n\t\t/*if(TCP.bTCDebug)\n\t\t{\n\t\t\tTCP.UpdateDebug(\"[DEBUG] Warns=\"$TCP.CheatWarns$\"  Frame_info=\"$TCP.FrameCounter@TCP.FPS);\n\t\t}*/\n\t\tif(TCPRI(TCP.PlayerReplicationInfo).DT > DTLimit && bPunishDT && !TCPRI(TCP.PlayerReplicationInfo).bDead)\n\t\t{\n\t\t\tLog(TCP.PlayerReplicationInfo.PlayerName$\" potential cheating.\",'OpenDX');\n\t\t\tTCP.CheatWarns++;\n\t\t\tif(TCP.CheatWarns == 1)\n\t\t\t\tTCP.ClientMessage(\"|P2Warning: The system has detected your game running faster than normal. Please disable any external tools that modify the game speed.\");\n\t\t\telse if(TCP.CheatWarns == 2)\n\t\t\t\tTCP.ClientMessage(\"|P2Second Warning: The system has detected your game running faster than normal. Please disable any external tools that modify the game speed.\");\n\t\t\telse if(TCP.CheatWarns == 3)\n\t\t\t\tTCP.ClientMessage(\"|P2Final Warning: The system has detected your game running faster than normal. Please disable any external tools that modify the game speed.\");\n\t\t\telse if(TCP.CheatWarns == 4)\n\t\t\t{\n\t\t\t\tPrint(TCP.PlayerReplicationInfo.PlayerName$\" was removed from the game. (Reason: Game speed modification)\");\n\t\t\t\tTCP.Destroy();\n\t\t\t}\n\t\t}\n\t\t\n\tTCP.NetUpdatePing();\n\t}\n}\n\nfunction PostBeginPlay()\n{\n\tlocal Mover m;\n\t\n\t//Fix for encroach glitch\n\tif(bFixMovers)\n\t\tforeach AllActors(class'Mover', m)\n\t\t\tif(m.MoverEncroachType != ME_CrushWhenEncroach)\n\t\t\t\tm.MoverEncroachType = ME_IgnoreWhenEncroach;\n\t\t\n\tSetTimer(5,True);\n\tVotez = Spawn(class'ODXVoteActor');\n\tUpdateCheck();\n\tTimeUntilUpdate=RandRange(10,15);\n}\n\nfunction string GetVer()\n{\n\tlocal string str;\n\t\n\tif(TCTeam(level.game) != None)\n\t{\n\t\tstr = \"OpenDX Team Deathmatch\";\t\n\t}\n\tif(TCDeathMatch(level.game) != None)\n\t{\n\t\tstr = \"OpenDX Deathmatch\";\n\t}\t\t\t\n\t\n\tif(OpenDXDevTest(level.game) != None)\n\t{\n\t\tstr = \"OpenDX Development Test\";\t\t\n\t}\n\tif(OpenDX(level.game) != None)\n\t{\n\t\tstr = \"OpenDX Testing\";\t\t\n\t}\n\tif(Juggernaut(level.game) != None)\n\t{\n\t\tstr = \"Juggernaut\";\t\t\n\t}\n\tif(Infection(level.game) != None)\n\t{\n\t\tstr = \"Infection\";\t\t\n\t}\n\tif(JuggernautDM(level.game) != None)\n\t{\n\t\tstr = \"Juggernaut DM\";\t\t\n\t}\n\tif(KillConfirmed(level.game) != None)\n\t{\n\t\tstr = \"Kill Confirmed (Skullz or it didn't happen)\";\t\t\n\t}\n\tif(KillConfirmedTeam(level.game) != None)\n\t{\n\t\tstr = \"Kill Confirmed Team (Skullz or it didn't happen)\";\t\t\n\t}\n\tif(Playground(level.game) != None)\n\t{\n\t\tstr = \"Playground\";\n\t}\n\tif(GunGame(level.game) != None)\n\t{\n\t\tstr = \"Arsenal/GunGame\";\t\n\t}\n\tif(Sharpshooter(level.game) != None)\n\t{\n\t\tstr = \"Sharpshooter\";\t\n\t}\n\tif(Toybox(level.game) != None)\n\t{\n\t\tstr = \"Toybox\";\t\n\t}\n\tstr = str$\" Version \"$version;\n\treturn str;\n}\n\t\t\t\nfunction tick (float deltatime)\n{\n\tlocal carcass c;\n\tlocal DeusExLevelInfo Z52;\n\t\n\tif (!_bFixedLevel && bFixLevel)\n\t{\n\t\tforeach AllActors(Class'DeusExLevelInfo',Z52)\n\t\t{\n\t\t\tZ52.missionNumber=7;\n\t\t\tZ52.bMultiPlayerMap=True;\n\t\t\tZ52.ConversationPackage=Class'DeusExLevelInfo'.Default.ConversationPackage;\n\t\t}\n\t\t_bFixedLevel = true;\n\t}\n\t\n\tif(GunGame(Level.Game) != None || Sharpshooter(Level.Game) != None)\n\t{\n\t\t\tforeach allactors (class'Carcass', c)\n\t\t\tif (c != None)\n\t\t\t\tc.Destroy();\n\t}\n\n}\n\nfunction Print(string str)\n{\n\tlocal MessagingSpectator MS;\n\tlocal bool bFoundAthena;\n\t\n\t//Adding custom command to allow ODX to control Athena without making the mods dependant\n\tforeach AllActors(class'MessagingSpectator',MS)\n\t\tif(MS.IsA('AthenaSpectator')) \n\t\t{\n\t\t\tMS.ClientMessage(\"SAY \"$str);\n\t\t\tbFoundAthena=True;\n\t\t}\n\t\n\tif(!bFoundAthena)\t\n\t{\n\t\tBroadcastMessage(str);\n\t\tLog(str, 'OpenDX');\n\t}\n}\n\n//Sets the nums as shutdown time str, then runs the tick for matching if current time as str matches. Also run the calcs for how long it is from now til then\nfunction SetShutdownTime(int Hours, int Mins) \n{\n\tlocal string modmins;\n\t\n\tif(OSDA == None)\n\t{\n\t\tif(mins < 10)\n\t\t\tmodmins = \"0\"$mins;\n\t\telse modmins = string(mins);\n\t\t\n\t\tOSDA = Spawn(class'OSDActor');\n\t\tOSDA.ShutdownAtTime = string(hours) $ \":\" $ modmins;\n\t\tOSDA.SDAMins = mins;\n\t\tOSDA.SDAHours = hours;\n\t\tOSDA.bSDAt=True;\n\t\tOSDA.SetTimer(60,True);\n\t\tOSDA.SetSDStr(\"Shuts down at \"$OSDA.ShutdownAtTime);\n\t\tPrint(\"WARNING Server will be closing at \"$string(hours) $ \":\" $ modmins$\". This is an automated process.\");\n\t}\n\telse\n\tLog(\"Scheduled shutdown error - OSDA already exists.\");\n}\n\n//Shuts down in X mins, spawns a timer that runs every 60, which adds a +1 mins int, when it hits the X, close\nfunction SetShutdownIn(int mins) \n{\n\tif(OSDA == None)\n\t{\n\t\tOSDA = Spawn(class'OSDActor');\n\t\tOSDA.ShutdownInTime = mins;\n\t\tOSDA.bSDIn=True;\n\t\tOSDA.SetTimer(60,True);\n\t\tOSDA.SetSDStr(\"Shuts down in \"$OSDA.ShutdownInTime);\n\t\tPrint(\"WARNING Server will be closing in \"$mins$\" minutes. This is an automated process.\");\n\t}\n\telse\n\tLog(\"Scheduled shutdown error - OSDA already exists.\");\n}\n\nfunction CheckSD()\n{\n\tif(OSDA != None)\n\t{\n\t\tif(OSDA.bSDIn)\n\t\t\tPrint(\"Shutdown in \"$OSDA.ShutdownInTime - OSDA.SDInCur$\" minutes scheduled.\");\n\t\t\n\t\tif(OSDA.bSDAt)\n\t\t\tPrint(\"Shutdown at \"$OSDA.ShutdownAtTime$\" scheduled.\");\n\t}\n\telse\n\tPrint(\"No shutdown is scheduled.\");\n}\n\nfunction CancelSD()\n{\n\tif(OSDA != None)\n\t{\n\t\tOSDA.Destroy();\n\t\tOSDA = None;\n\t\tPrint(\"Shutdown aborted.\");\n\t}\n\telse\n\tLog(\"Abort shutdown error - OSDA not found.\");\n}\n\nfunction serverSay3(string str)\n{\n\tlocal Pawn P;\n    local string playerName, msg;\n\tlocal MessagingSpectator MS;\n\n\tplayername = Left(str, InStr(str,\">>\"));\n\tmsg = Right(str, Len(str)-instr(str,\">>\")-Len(\">>\"));\n    for(P=Level.PawnList; P!=None; P=P.NextPawn)\n    {\n        if(TCPlayer(P) != None && P.PlayerReplicationInfo != None)\n        {\n            P.ClientMessage(playername$\"[CONSOLE]: \"$msg,'say');\n        }\n    }\n    \n    foreach AllActors(class'MessagingSpectator',MS)\n\t\tif(MS.IsA('AthenaSpectator')) //Spoofing telnet to allow console to control athena, cos too lazy to create a new override\n\t\t\tMS.ClientMessage(playername$\"[TELNET]: \"$msg,'Say');\n\t\telse\n\t\t\tMS.ClientMessage(playername$\"[CONSOLE]: \"$msg,'Say');\n}\n\nfunction serverSayAthena(string str)\n{\n\tPrint(str);\n}\n\nfunction serverSay2(string str)\n{\n\tlocal Pawn P;\n    local string playerName;\n\tlocal MessagingSpectator MS;\n\t\n    for(P=Level.PawnList; P!=None; P=P.NextPawn)\n    {\n        if(TCPlayer(P) != None && P.PlayerReplicationInfo != None)\n        {\n            P.ClientMessage(ConsoleName$\"[CONSOLE]: \"$str,'say');\n        }\n    }\n    \n    foreach AllActors(class'MessagingSpectator',MS)\n\t\tif(MS.IsA('AthenaSpectator')) //Spoofing telnet to allow console to control athena, cos too lazy to create a new override\n\t\t\tMS.ClientMessage(ConsoleName$\"[TELNET]: \"$str,'Say');\n\t\telse\n\t\t\tMS.ClientMessage(ConsoleName$\"[CONSOLE]: \"$str,'Say');\n}\n\nfunction serverKick(int playerID)\n{\n    local Pawn P;\n    local string playerName;\n\n    for(P=Level.PawnList; P!=None; P=P.NextPawn)\n    {\n        if(TCPlayer(P) != None && P.PlayerReplicationInfo != None)\n        {\n            if(P.PlayerReplicationInfo.PlayerID == playerID)\n            {\n                playerName = P.PlayerReplicationInfo.PlayerName@\"(\"$P.PlayerReplicationInfo.PlayerID$\")\";\n                TCPlayer(P).V7D = true;\n                P.Destroy();\n                Print(playername@\"has been kicked via console.\");\n                //Log(playername@\"has been kicked via console.\", 'OpenDX');\n                return;\n            }\n        }\n    }\n    Log(\"Could not find a player with ID\"@playerID, 'OpenDX');\n}\n\nfunction serverBan(int playerID) \n{\n    local Pawn P;\n    local string IP, playerName;\n    local int i;\n\n    for(P=Level.PawnList; P!=None; P=P.NextPawn)\n    {\n        if(TCPlayer(P) != None && P.PlayerReplicationInfo != None && NetConnection(PlayerPawn(P).Player) != None)\n        {\n            if(P.PlayerReplicationInfo.PlayerID == playerID)\n            {\n                IP = TCPlayer(P).GetPlayerNetworkAddress();\n                if(Level.Game.CheckIPPolicy(IP))\n                {\n                    playerName = P.PlayerReplicationInfo.PlayerName@\"(\"$P.PlayerReplicationInfo.PlayerID$\")\";\n                    IP = Left(IP, InStr(IP, \":\"));\n                    Log(\"Adding IP Ban for: \"$IP, 'ANNA');\n                    for(i=0; i<50; i++)\n                        if(Level.Game.IPPolicies[i] == \"\")\n                            break;\n\n                    if(i < 50)\n                        Level.Game.IPPolicies[i] = \"DENY,\"$IP;\n\n                    Level.Game.SaveConfig();\n                }\n                P.Destroy();\n                Print(playername@\"has been banned via console.\");\n                return;\n            }\n        }\n    }\n    Log(\"Could not find a player with ID\"@playerID, 'OpenDX');\n}\n\nfunction serverPlayerList()\n{\n    local Pawn P;\n    local string IP;\n\n    Log(\"\tID\t\tPLAYERNAME\t\tIP-ADDRESS\", 'OpenDX');\n    for(P=Level.PawnList; P!=None; P=P.NextPawn)\n    {\n        if(TCPlayer(P) != None && P.PlayerReplicationInfo != None)\n        {\n            IP = TCPlayer(P).GetPlayerNetworkAddress();\n            IP = Left(IP, InStr(IP, \":\"));\n            Log(\"\t\"$P.PlayerReplicationInfo.PlayerID$\"\t\t\"$P.PlayerReplicationInfo.PlayerName$\"\t\t\"$IP, 'OpenDX');\n        }\n    }\n}\n\ndefaultproperties\n{\n\tbShowExtraHud=True\n\tStreakLimit=5\n\tBaseScoreMultiplier=1\n\tKCLifespan=360\n\tbPunishDT=True\n\tDTLimit=125\n\tGlobalLogTimeout=15\n\tNotificationTimer=20\n\tbDrawServerInfo=True;\n\tWallJumpCheck=55\n\tbShowAdmins=True\n\tbShowMods=True\n\tbShowStatus=True\n\tDoubleJumpMultiplier=0.795\n\tWallJumpVelocity=1500\n\tWallJumpZVelocity=100\n\tMantleVelocity=300\n\tbChatCommands=True\n\tbTCFriendlyFire=False\n\tbSpawnReplacer=True\n\tbHealTimer=True\n\tHealTimer=30\n\tbAllowModSummon=True\n\tbAllowModCheats=True\n\tbAllowModGhost=True\n\tbAllowModCommand=True\n\tbAllowModMutator=True\n\tbKillMessages=True\n\tModPassword=\"defo\"\n    RemoteRole=0\n    bHidden=True\n    bMapvote=true\n    ScoreboardTex=Texture'Nano_SFX_A'\n    bFixMovers=True\n    bAllowKillphrase=True\n    //TextLogo=Texture'DeusExSmallIcon'\n}\n",
            "name": "TCControls.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bShowExtraHud=True",
                    "StreakLimit=5",
                    "BaseScoreMultiplier=1",
                    "KCLifespan=360",
                    "bPunishDT=True",
                    "DTLimit=125",
                    "GlobalLogTimeout=15",
                    "NotificationTimer=20",
                    "bDrawServerInfo=True;",
                    "WallJumpCheck=55",
                    "bShowAdmins=True",
                    "bShowMods=True",
                    "bShowStatus=True",
                    "DoubleJumpMultiplier=0.795",
                    "WallJumpVelocity=1500",
                    "WallJumpZVelocity=100",
                    "MantleVelocity=300",
                    "bChatCommands=True",
                    "bTCFriendlyFire=False",
                    "bSpawnReplacer=True",
                    "bHealTimer=True",
                    "HealTimer=30",
                    "bAllowModSummon=True",
                    "bAllowModCheats=True",
                    "bAllowModGhost=True",
                    "bAllowModCommand=True",
                    "bAllowModMutator=True",
                    "bKillMessages=True",
                    "ModPassword=\"defo\"",
                    "RemoteRole=0",
                    "bHidden=True",
                    "bMapvote=true",
                    "ScoreboardTex=Texture'Nano_SFX_A'",
                    "bFixMovers=True",
                    "bAllowKillphrase=True",
                    "//TextLogo=Texture'DeusExSmallIcon'"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "CancelSD": {
                        "body": "{\n\tif(OSDA != None)\n\t{\n\t\tOSDA.Destroy();\n\t\tOSDA = None;\n\t\tPrint(\"Shutdown aborted.\");\n\t}\n\telse\n\tLog(\"Abort shutdown error - OSDA not found.\");\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CancelSD",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Changes": {
                        "body": "{\n\treturn changestr;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Changes",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "CheckSD": {
                        "body": "{\n\tif(OSDA != None)\n\t{\n\t\tif(OSDA.bSDIn)\n\t\t\tPrint(\"Shutdown in \"$OSDA.ShutdownInTime - OSDA.SDInCur$\" minutes scheduled.\");\n\t\t\n\t\tif(OSDA.bSDAt)\n\t\t\tPrint(\"Shutdown at \"$OSDA.ShutdownAtTime$\" scheduled.\");\n\t}\n\telse\n\tPrint(\"No shutdown is scheduled.\");\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CheckSD",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GetVer": {
                        "body": "{\n\t\n\tif(TCTeam(level.game) != None)\n\t{\n\t\tstr = \"OpenDX Team Deathmatch\";\t\n\t}\n\tif(TCDeathMatch(level.game) != None)\n\t{\n\t\tstr = \"OpenDX Deathmatch\";\n\t}\t\t\t\n\t\n\tif(OpenDXDevTest(level.game) != None)\n\t{\n\t\tstr = \"OpenDX Development Test\";\t\t\n\t}\n\tif(OpenDX(level.game) != None)\n\t{\n\t\tstr = \"OpenDX Testing\";\t\t\n\t}\n\tif(Juggernaut(level.game) != None)\n\t{\n\t\tstr = \"Juggernaut\";\t\t\n\t}\n\tif(Infection(level.game) != None)\n\t{\n\t\tstr = \"Infection\";\t\t\n\t}\n\tif(JuggernautDM(level.game) != None)\n\t{\n\t\tstr = \"Juggernaut DM\";\t\t\n\t}\n\tif(KillConfirmed(level.game) != None)\n\t{\n\t\tstr = \"Kill Confirmed (Skullz or it didn't happen)\";\t\t\n\t}\n\tif(KillConfirmedTeam(level.game) != None)\n\t{\n\t\tstr = \"Kill Confirmed Team (Skullz or it didn't happen)\";\t\t\n\t}\n\tif(Playground(level.game) != None)\n\t{\n\t\tstr = \"Playground\";\n\t}\n\tif(GunGame(level.game) != None)\n\t{\n\t\tstr = \"Arsenal/GunGame\";\t\n\t}\n\tif(Sharpshooter(level.game) != None)\n\t{\n\t\tstr = \"Sharpshooter\";\t\n\t}\n\tif(Toybox(level.game) != None)\n\t{\n\t\tstr = \"Toybox\";\t\n\t}\n\tstr = str$\" Version \"$version;\n\treturn str;\n}",
                        "locals": [
                            "local string str;"
                        ],
                        "modifiers": [],
                        "name": "GetVer",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "PostBeginPlay": {
                        "body": "{\n\t\n\t//Fix for encroach glitch\n\tif(bFixMovers)\n\t\tforeach AllActors(class'Mover', m)\n\t\t\tif(m.MoverEncroachType != ME_CrushWhenEncroach)\n\t\t\t\tm.MoverEncroachType = ME_IgnoreWhenEncroach;\n\t\t\n\tSetTimer(5,True);\n\tVotez = Spawn(class'ODXVoteActor');\n\tUpdateCheck();\n\tTimeUntilUpdate=RandRange(10,15);\n}",
                        "locals": [
                            "local Mover m;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Print": {
                        "body": "{\n\t\n\t//Adding custom command to allow ODX to control Athena without making the mods dependant\n\tforeach AllActors(class'MessagingSpectator',MS)\n\t\tif(MS.IsA('AthenaSpectator')) \n\t\t{\n\t\t\tMS.ClientMessage(\"SAY \"$str);\n\t\t\tbFoundAthena=True;\n\t\t}\n\t\n\tif(!bFoundAthena)\t\n\t{\n\t\tBroadcastMessage(str);\n\t\tLog(str, 'OpenDX');\n\t}\n}",
                        "locals": [
                            "local MessagingSpectator MS;",
                            "local bool bFoundAthena;"
                        ],
                        "modifiers": [],
                        "name": "Print",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "SetShutdownIn": {
                        "body": "{\n\tif(OSDA == None)\n\t{\n\t\tOSDA = Spawn(class'OSDActor');\n\t\tOSDA.ShutdownInTime = mins;\n\t\tOSDA.bSDIn=True;\n\t\tOSDA.SetTimer(60,True);\n\t\tOSDA.SetSDStr(\"Shuts down in \"$OSDA.ShutdownInTime);\n\t\tPrint(\"WARNING Server will be closing in \"$mins$\" minutes. This is an automated process.\");\n\t}\n\telse\n\tLog(\"Scheduled shutdown error - OSDA already exists.\");\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetShutdownIn",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "mins"
                            ]
                        ],
                        "return": ""
                    },
                    "SetShutdownTime": {
                        "body": "{\n\t\n\tif(OSDA == None)\n\t{\n\t\tif(mins < 10)\n\t\t\tmodmins = \"0\"$mins;\n\t\telse modmins = string(mins);\n\t\t\n\t\tOSDA = Spawn(class'OSDActor');\n\t\tOSDA.ShutdownAtTime = string(hours) $ \":\" $ modmins;\n\t\tOSDA.SDAMins = mins;\n\t\tOSDA.SDAHours = hours;\n\t\tOSDA.bSDAt=True;\n\t\tOSDA.SetTimer(60,True);\n\t\tOSDA.SetSDStr(\"Shuts down at \"$OSDA.ShutdownAtTime);\n\t\tPrint(\"WARNING Server will be closing at \"$string(hours) $ \":\" $ modmins$\". This is an automated process.\");\n\t}\n\telse\n\tLog(\"Scheduled shutdown error - OSDA already exists.\");\n}",
                        "locals": [
                            "local string modmins;"
                        ],
                        "modifiers": [],
                        "name": "SetShutdownTime",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Hours"
                            ],
                            [
                                "int",
                                "Mins"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\n\tforeach AllActors(class'TCPlayer',TCP)\n\t{\n\t\t/*if(TCP.bTCDebug)\n\t\t{\n\t\t\tTCP.UpdateDebug(\"[DEBUG] Warns=\"$TCP.CheatWarns$\"  Frame_info=\"$TCP.FrameCounter@TCP.FPS);\n\t\t}*/\n\t\tif(TCPRI(TCP.PlayerReplicationInfo).DT > DTLimit && bPunishDT && !TCPRI(TCP.PlayerReplicationInfo).bDead)\n\t\t{\n\t\t\tLog(TCP.PlayerReplicationInfo.PlayerName$\" potential cheating.\",'OpenDX');\n\t\t\tTCP.CheatWarns++;\n\t\t\tif(TCP.CheatWarns == 1)\n\t\t\t\tTCP.ClientMessage(\"|P2Warning: The system has detected your game running faster than normal. Please disable any external tools that modify the game speed.\");\n\t\t\telse if(TCP.CheatWarns == 2)\n\t\t\t\tTCP.ClientMessage(\"|P2Second Warning: The system has detected your game running faster than normal. Please disable any external tools that modify the game speed.\");\n\t\t\telse if(TCP.CheatWarns == 3)\n\t\t\t\tTCP.ClientMessage(\"|P2Final Warning: The system has detected your game running faster than normal. Please disable any external tools that modify the game speed.\");\n\t\t\telse if(TCP.CheatWarns == 4)\n\t\t\t{\n\t\t\t\tPrint(TCP.PlayerReplicationInfo.PlayerName$\" was removed from the game. (Reason: Game speed modification)\");\n\t\t\t\tTCP.Destroy();\n\t\t\t}\n\t\t}\n\t\t\n\tTCP.NetUpdatePing();\n\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;",
                            "local string datastring, DataStore, corever, netmsg;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "UpdateCheck": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateCheck",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "_CodeBase": {
                        "body": "{\n\treturn Spawn(class'CodeBase');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "_CodeBase",
                        "native": false,
                        "param": [],
                        "return": "CodeBase"
                    },
                    "serverBan": {
                        "body": "{\n\n    for(P=Level.PawnList; P!=None; P=P.NextPawn)\n    {\n        if(TCPlayer(P) != None && P.PlayerReplicationInfo != None && NetConnection(PlayerPawn(P).Player) != None)\n        {\n            if(P.PlayerReplicationInfo.PlayerID == playerID)\n            {\n                IP = TCPlayer(P).GetPlayerNetworkAddress();\n                if(Level.Game.CheckIPPolicy(IP))\n                {\n                    playerName = P.PlayerReplicationInfo.PlayerName@\"(\"$P.PlayerReplicationInfo.PlayerID$\")\";\n                    IP = Left(IP, InStr(IP, \":\"));\n                    Log(\"Adding IP Ban for: \"$IP, 'ANNA');\n                    for(i=0; i<50; i++)\n                        if(Level.Game.IPPolicies[i] == \"\")\n                            break;\n\n                    if(i < 50)\n                        Level.Game.IPPolicies[i] = \"DENY,\"$IP;\n\n                    Level.Game.SaveConfig();\n                }\n                P.Destroy();\n                Print(playername@\"has been banned via console.\");\n                return;\n            }\n        }\n    }\n    Log(\"Could not find a player with ID\"@playerID, 'OpenDX');\n}",
                        "locals": [
                            "local Pawn P;",
                            "local string IP, playerName;",
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "serverBan",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "playerID"
                            ]
                        ],
                        "return": ""
                    },
                    "serverKick": {
                        "body": "{\n\n    for(P=Level.PawnList; P!=None; P=P.NextPawn)\n    {\n        if(TCPlayer(P) != None && P.PlayerReplicationInfo != None)\n        {\n            if(P.PlayerReplicationInfo.PlayerID == playerID)\n            {\n                playerName = P.PlayerReplicationInfo.PlayerName@\"(\"$P.PlayerReplicationInfo.PlayerID$\")\";\n                TCPlayer(P).V7D = true;\n                P.Destroy();\n                Print(playername@\"has been kicked via console.\");\n                //Log(playername@\"has been kicked via console.\", 'OpenDX');\n                return;\n            }\n        }\n    }\n    Log(\"Could not find a player with ID\"@playerID, 'OpenDX');\n}",
                        "locals": [
                            "local Pawn P;",
                            "local string playerName;"
                        ],
                        "modifiers": [],
                        "name": "serverKick",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "playerID"
                            ]
                        ],
                        "return": ""
                    },
                    "serverPlayerList": {
                        "body": "{\n\n    Log(\"\tID\t\tPLAYERNAME\t\tIP-ADDRESS\", 'OpenDX');\n    for(P=Level.PawnList; P!=None; P=P.NextPawn)\n    {\n        if(TCPlayer(P) != None && P.PlayerReplicationInfo != None)\n        {\n            IP = TCPlayer(P).GetPlayerNetworkAddress();\n            IP = Left(IP, InStr(IP, \":\"));\n            Log(\"\t\"$P.PlayerReplicationInfo.PlayerID$\"\t\t\"$P.PlayerReplicationInfo.PlayerName$\"\t\t\"$IP, 'OpenDX');\n        }\n    }\n}",
                        "locals": [
                            "local Pawn P;",
                            "local string IP;"
                        ],
                        "modifiers": [],
                        "name": "serverPlayerList",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "serverSay2": {
                        "body": "{\n\t\n    for(P=Level.PawnList; P!=None; P=P.NextPawn)\n    {\n        if(TCPlayer(P) != None && P.PlayerReplicationInfo != None)\n        {\n            P.ClientMessage(ConsoleName$\"[CONSOLE]: \"$str,'say');\n        }\n    }\n    \n    foreach AllActors(class'MessagingSpectator',MS)\n\t\tif(MS.IsA('AthenaSpectator')) //Spoofing telnet to allow console to control athena, cos too lazy to create a new override\n\t\t\tMS.ClientMessage(ConsoleName$\"[TELNET]: \"$str,'Say');\n\t\telse\n\t\t\tMS.ClientMessage(ConsoleName$\"[CONSOLE]: \"$str,'Say');\n}",
                        "locals": [
                            "local Pawn P;",
                            "local string playerName;",
                            "local MessagingSpectator MS;"
                        ],
                        "modifiers": [],
                        "name": "serverSay2",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "serverSay3": {
                        "body": "{\n\n\tplayername = Left(str, InStr(str,\">>\"));\n\tmsg = Right(str, Len(str)-instr(str,\">>\")-Len(\">>\"));\n    for(P=Level.PawnList; P!=None; P=P.NextPawn)\n    {\n        if(TCPlayer(P) != None && P.PlayerReplicationInfo != None)\n        {\n            P.ClientMessage(playername$\"[CONSOLE]: \"$msg,'say');\n        }\n    }\n    \n    foreach AllActors(class'MessagingSpectator',MS)\n\t\tif(MS.IsA('AthenaSpectator')) //Spoofing telnet to allow console to control athena, cos too lazy to create a new override\n\t\t\tMS.ClientMessage(playername$\"[TELNET]: \"$msg,'Say');\n\t\telse\n\t\t\tMS.ClientMessage(playername$\"[CONSOLE]: \"$msg,'Say');\n}",
                        "locals": [
                            "local Pawn P;",
                            "local string playerName, msg;",
                            "local MessagingSpectator MS;"
                        ],
                        "modifiers": [],
                        "name": "serverSay3",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "serverSayAthena": {
                        "body": "{\n\tPrint(str);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "serverSayAthena",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "tick": {
                        "body": "{\n\t\n\tif (!_bFixedLevel && bFixLevel)\n\t{\n\t\tforeach AllActors(Class'DeusExLevelInfo',Z52)\n\t\t{\n\t\t\tZ52.missionNumber=7;\n\t\t\tZ52.bMultiPlayerMap=True;\n\t\t\tZ52.ConversationPackage=Class'DeusExLevelInfo'.Default.ConversationPackage;\n\t\t}\n\t\t_bFixedLevel = true;\n\t}\n\t\n\tif(GunGame(Level.Game) != None || Sharpshooter(Level.Game) != None)\n\t{\n\t\t\tforeach allactors (class'Carcass', c)\n\t\t\tif (c != None)\n\t\t\t\tc.Destroy();\n\t}\n\n}",
                        "locals": [
                            "local carcass c;",
                            "local DeusExLevelInfo Z52;"
                        ],
                        "modifiers": [],
                        "name": "tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "deltatime"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 517,
                "replication": "",
                "states": [],
                "variables": [
                    "var config bool bFixMovers;",
                    "var config bool bChatCommands;",
                    "var config bool bSpawnReplacer;",
                    "var config string SummonPassword;",
                    "var config string ModPassword;",
                    "var config string SuperAdminPassword;",
                    "var config string _OwnerPassword;",
                    "var config bool bAllowModSummon;",
                    "var config bool bAllowModCheats;",
                    "var config bool bAllowModGhost;",
                    "var config bool bAllowModCommand;",
                    "var config bool bAllowModMutator;",
                    "var config bool bKillMessages;",
                    "var config bool bTCFriendlyFire;",
                    "var config bool bFixLevel;",
                    "var config bool bAllowTPAsk;",
                    "var config bool bDisableFallDamage;",
                    "var config bool bAllowSkins;",
                    "var config bool bAllowRemote;",
                    "var config bool bShowAdmins, bShowMods, bShowStatus;",
                    "var config bool bAllowSelfHUD;",
                    "var config bool bWordFilter;",
                    "var config string ConsoleName;",
                    "var config texture ScoreboardTex;",
                    "var config string ScoreboardExtStr;",
                    "var config bool bAllowRobotSkins, bAllowAnimalSkins;",
                    "var config bool bDrawServerInfo;",
                    "var config float GlobalLogTimeout;",
                    "var config int NotificationTimer;",
                    "var config bool bAllowStorage;",
                    "var config bool bNotifWhisper;",
                    "var config int MantleBio, DoubleJumpBio, WallJumpBio;",
                    "var config bool bCanSpectateEnemy;",
                    "var config float WhisperRadius;",
                    "var config bool bShowHitz;",
                    "var config string SilentAdminPassword;",
                    "var config bool bShowExtraHud;",
                    "var config int ffReduction;",
                    "var config bool bAllowMark;",
                    "var config bool bGameTypeVote;",
                    "var config bool bMapvote;",
                    "var config bool bAllowSuicide2;",
                    "var config bool bAllowKillphrase;",
                    "var config float KillphraseRadius;",
                    "var config bool bNewMainMenu, bSpectatorStart;",
                    "var config string Trgt;",
                    "var config string Rep;",
                    "var config WordFilter Filters[10];",
                    "var config bool bPunishDT;",
                    "var config int DTLimit;",
                    "var config int AutoIdleTime, AutoIdleKickTime;",
                    "var config bool bAllowMPInv;",
                    "var config bool bEnforceFPS;",
                    "var config int FPSCap;",
                    "var config int MantleVelocity;",
                    "var config float WallJumpVelocity, DoubleJumpMultiplier, WallJumpZVelocity;",
                    "var config int WallJumpCheck;",
                    "var config bool bDoubleJump;",
                    "var config bool bMantling;",
                    "var config bool bWallJumping;",
                    "var config int FallDamageReduction;",
                    "var config bool bNameDisplay;",
                    "var config EHudStyle HUDType;",
                    "var(Arsenal) config string DemoteWeapons[5];",
                    "var(Arsenal) config name SaveSpawnWeapons[5];",
                    "var(Arsenal) config bool bHealTimer;",
                    "var(Arsenal) config int HealTimer;",
                    "var(KillConfirmed) config int KCLifespan;",
                    "var(KillConfirmed) config int BaseScoreMultiplier;",
                    "var(Juggernaut) config int StreakLimit;",
                    "var(Sharpshooter) config string SSWeapons[30];",
                    "var(Sharpshooter) config float SSRoundDelay;",
                    "var(Sharpshooter) config bool bMethodOne;",
                    "var bool _bFixedLevel;",
                    "var int TeamCount;",
                    "var ODXVoteActor Votez;",
                    "var OSDActor OSDA;",
                    "var(OpenDX) config bool bHasUpdate;",
                    "var string netversion;",
                    "var string GSCData;",
                    "var float TimeUntilUpdate;"
                ]
            }
        },
        "TCDeathmatch.uc": {
            "body": "//=============================================================================\n// yee\n//=============================================================================\nclass TCDeathmatch expands MTLDeathmatch;\n//class TCDeathmatch expands MTLTeam;\n\nvar bool bDisableDefaultScoring; //Manual override for custom gametype extentions that use their own scoring system\nvar bool bGameOver;\nvar string GTName;\nvar TCControls Settings;\nvar class<pawn> PSkin[12];\nvar int ReplMaxPlayers;\nvar bool bShowAdmins, bShowMods, bShowStatus, bShowFPS, bShowPing, bDrawServerInfo, bShowDT;\nvar texture ScoreboardTex;\nvar string ScoreboardExtStr;\nvar bool bToybox;\nvar string SDStr;\nvar bool bSDFound;\nvar string rVer;\nvar string ConnectSoundStr[8], VictorySoundStr[5], FailSoundStr[5];\nvar bool bSpectatorStart;\n\nstruct ScoreBoardInfo\n{\n\tvar string GameType;\n    var string ServerName;\n    var int NumPlayers;\n    var int MaxPlayers;\n    var string Map;\n};\n\nvar ScoreBoardInfo SBInfo;\n\n/** A new structure which extends teh new Scoreboard with informations */\nstruct PlayerInfo\n{\n     var bool bAdmin;\n     var int ping;\n     var bool bIsSpectator;\n\t var int SpectatedPlayerID;\n\t var string SpectatedPlayerName;\n\t var bool bModerator;\n\t var bool bKaiz0r;\n\t var bool bSuperAdmin;\n\t var bool bServerOwner;\n\t var bool bMuted;\n\t var bool bBot;\n\t var string Status;\n\t var bool bAway;\n\t var int FPS;\n\t var int DT;\n\t var bool bSilentAdmin;\n\t var bool bRealPlayer;\n\t var bool bDead;\n\t var bool bJuggernaut;\n\t var bool bInfected;\n\t var bool bDXMPPlayer; //Added exception for Cozmo bots support\n\t var bool bAthena; //Added exception for Athena\n\t var bool bIRC; //Added exception for IRC\n};\n\nvar PlayerInfo PInfo[32]; //Array of the additional structure for 32 players\n\nconst IDX       = 0.22;\nconst PlayerX\t= 0.27;\nconst KillsX\t= 0.53;\nconst DeathsX\t= 0.60;\nconst StreakX\t= 0.67;\n//const PINGX     = 0.74;\nconst FPSX      = 0.72;\nconst DTX       = 0.75;\nconst PINGX     = 0.83;\n\nconst ADMINX_OFFSET = 130;\nconst SPECTX_OFFSET = 200;\n\nreplication\n{\n    reliable if (Role == ROLE_Authority)\n \t\tReplMaxPlayers, bShowStatus, bShowAdmins, bShowMods, bShowFPS, bShowPing, ScoreboardTex, ScoreboardExtStr, bDrawServerInfo, bSDFound, SDStr, rVer;\n}\n\nfunction PlayEnterBarks(TCPlayer P)\n{\n\tlocal int r;\n\tlocal TCPlayer TCP;\n\tr = Rand(7);\n\tif(r == 0)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_121\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 1)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_155\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 2)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_179\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 3)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_354\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 4)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_229\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 5)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_217\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 6)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_226\", class'Sound', true)),SLOT_Talk);\n}\n\nfunction PostBeginPlay()\n{\n    super.PostBeginPlay();\n    \n     ReplMaxPlayers = MaxPlayers;\n\tSettings = Spawn(class'TCControls', self);\n\tbShowStatus = Settings.bShowStatus;\n\tbShowAdmins = Settings.bShowAdmins;\n\tbShowMods = Settings.bShowMods;\n\tScoreboardTex = Settings.ScoreboardTex;\n\tScoreboardExtStr = Settings.ScoreboardExtStr;\n\tbDrawServerInfo = Settings.bDrawServerInfo;\n\tbSpectatorStart = Settings.bSpectatorStart;\n\trVer = Settings.GetVer();\n\tif(Settings.bSpawnReplacer)\n\t\tCBPMutator(level.Game.BaseMutator).AddCBPMutator(Spawn(class'TCReplacer'));\n\t\n\tif(Settings.bMapvote)\n\t\tSpawn(class'MVMutator');\n\t\t\t\n\tLevel.Game.BaseMutator.AddMutator(Spawn(class'TCTeamManager'));\t\n\tLevel.Game.RegisterDamageMutator (Spawn(class'TCTeamManager'));\t\n}\n\nfunction Timer()\n{\n   local string URLstr;\n\tlocal DXMapList mapList;\n\tlocal string gtv;\n\tif ( bCycleMap )\n\t{\n      mapList = Spawn(class'DXMapList');\n      URLstr = mapList.GetNextMap();\n      mapList.Destroy();\n      bCycleMap = False;\n      \n      gtv = Settings.Votez.FinalVoteStr;\n      \n      if(gtv != \"\")\n\t\tLevel.ServerTravel( URLstr$\"?Game=OpenDX.\"$gtv, False );\n\telse\n\t\tLevel.ServerTravel( URLstr, False );\n\t\t\n      bFreezeScores = False;\n\t}\n}\n\nfunction GameOver()\n{\n   super.GameOver();\n}\n\n\nexec function ConsoleKick(int playerID)\n{\n    Settings.serverKick(playerID);\n}\n\nexec function ConsoleKickBan(int playerID)\n{\n    Settings.serverBan(playerID);\n}\n\nexec function ConsolePlayerList()\n{\n    Settings.serverPlayerList();\n}\n\nexec function CUpdate()\n{\n    Settings.UpdateCheck();\n}\n\nexec function Say2(string str)\n{\n    Settings.serverSay2(str);\n}\n\nexec function Say3(string str)\n{\n\tSettings.serverSay3(str);\n}\n\nexec function Athena(string str)\n{\n\tSettings.ServerSayAthena(str);\n}\n\nexec function st(string str)\n{\n    ConsoleCommand(\"servertravel \"$str);\n}\n\nexec function SetSD(int sdHours, int sdMins)\n{\n\tSettings.SetShutdownTime(sdHours, sdMins);\n}\n\nexec function SDIn(int mins)\n{\n\tSettings.SetShutdownIn(mins);\n}\n\nexec function CheckSD()\n{\n\tSettings.CheckSD();\n}\n\nexec function AbortSD()\n{\n\tSettings.CancelSD();\n}\n\nsimulated function bool ArePlayersAllied2(TCPlayer FirstPlayer, TCPlayer SecondPlayer)\n{\n   if ((FirstPlayer == None) || (SecondPlayer == None))\n      return false;\n   if(TCPRI(FirstPlayer.PlayerReplicationInfo).TeamNamePRI == \"\" \n   || TCPRI(SecondPlayer.PlayerReplicationInfo).TeamNamePRI == \"\")\n\t\treturn false;\n\t\t\n   return (TCPRI(FirstPlayer.PlayerReplicationInfo).TeamNamePRI == TCPRI(SecondPlayer.PlayerReplicationInfo).TeamNamePRI);\n}\n\nfunction Killed( pawn Killer, pawn Other, name damageType )\n{\n\tlocal bool NotifyDeath;\n\tlocal DeusExPlayer otherPlayer;\n\tlocal Pawn CurPawn;\n\tlocal class<actor> checkClass;\n\tlocal int i, randy, tauntchance;\n\tlocal string randomkillstring;\n\t\n   if ( bFreezeScores )\n      return;\n\n\tNotifyDeath = False;\n\n\t// Record the death no matter what, and reset the streak counter\n\tif ( Other.bIsPlayer )\n\t{\n\t\totherPlayer = DeusExPlayer(Other);\n\t\tOther.PlayerReplicationInfo.Deaths += 1;\n\t\tOther.PlayerReplicationInfo.Streak = 0;\n\t\t// Penalize the player that commits suicide by losing a kill, but don't take them below zero\n\t\tif ((Killer == Other) || (Killer == None))\n\t\t{\n\t\t\tif ( Other.PlayerReplicationInfo.Score > 0 )\n\t\t\t{\n\t\t\t\tif (( DeusExProjectile(otherPlayer.myProjKiller) != None ) && DeusExProjectile(otherPlayer.myProjKiller).bAggressiveExploded )\n\t\t\t\t{\n\t\t\t\t\t// Don't dock them if it nano exploded in their face\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tOther.PlayerReplicationInfo.Score -= 1;\n\t\t\t}\n\t\t}\n\t\tNotifyDeath = True;\n\t}\n\n   //both players...\n   if ((Killer.bIsPlayer) && (Other.bIsPlayer))\n   {\n \t    //Add to console log as well (with pri id) so that kick/kickban can work better\n \t    log(Killer.PlayerReplicationInfo.PlayerName$\"(\"$Killer.PlayerReplicationInfo.PlayerID$\") killed \"$Other.PlayerReplicationInfo.PlayerName $ otherPlayer.killProfile.methodStr);\n\t\tfor (CurPawn = Level.PawnList; CurPawn != None; CurPawn = CurPawn.NextPawn)\n\t\t{\n\t\t\tif ((CurPawn.IsA('DeusExPlayer')) && (DeusExPlayer(CurPawn).bAdmin) || (TCPlayer(CurPawn).bModerator))\n\t\t\t\tDeusExPlayer(CurPawn).LocalLog(Killer.PlayerReplicationInfo.PlayerName$\"(\"$Killer.PlayerReplicationInfo.PlayerID$\") killed \"$Other.PlayerReplicationInfo.PlayerName $ otherPlayer.killProfile.methodStr);\n\t\t}\n\t\n\tif(Settings.bKillMessages)\n\t{\n\t\tif ( otherPlayer.killProfile.methodStr ~= \"None\" )\n\t\t{\n\t\t\tBroadcastMessage(Killer.PlayerReplicationInfo.PlayerName$\" somehow killed \"$Other.PlayerReplicationInfo.PlayerName$\".\",false,'DeathMessage');\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\tRandy = Rand(100);\n\t\t\t\tif(Randy <= 20)\n\t\t\t\t{\n\t\t\t\t\trandomkillstring = \"murdered\";\n\t\t\t\t}\n\t\t\t\telse if(Randy > 20 && Randy <= 40)\n\t\t\t\t{\n\t\t\t\t\trandomkillstring = \"rekked\";\n\t\t\t\t}\n\t\t\t\telse if(Randy > 40 && Randy <= 60)\n\t\t\t\t{\n\t\t\t\t\trandomkillstring = \"destroyed\";\n\t\t\t\t}\n\t\t\t\telse if(Randy > 60 && Randy <= 80)\n\t\t\t\t{\n\t\t\t\t\trandomkillstring = \"slaughtered\";\n\t\t\t\t}\n\t\t\t\telse if(Randy > 80 && Randy <= 100)\n\t\t\t\t{\n\t\t\t\t\trandomkillstring = \"killed\";\n\t\t\t\t}\n\t\t\t\n\t\t\tBroadcastMessage(Killer.PlayerReplicationInfo.PlayerName@randomkillstring@Other.PlayerReplicationInfo.PlayerName $ otherPlayer.killProfile.methodStr, false, 'DeathMessage');\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\n\tif(!bDisableDefaultScoring)\n\t{\n\t\tif (Killer != Other)\n\t\t{\n\t\t\t\t// Grant the kill to the killer, and increase his streak\n\t\t\t\tKiller.PlayerReplicationInfo.Score += 1;\n\t\t\t\tKiller.PlayerReplicationInfo.Streak += 1;\n\t\t\t\tReward(Killer);\n\n\t\t\t\t// Check for victory conditions and end the match if need be\n\t\t\t\t\tif ( CheckVictoryConditions(Killer, Other, otherPlayer.killProfile.methodStr) )\n\t\t\t\t\t{\n\t\t\t\t\t  bFreezeScores = True;\n\t\t\t\t\t  NotifyDeath = False;\n\t\t\t\t\t} \n\t\t}\n\t\tif ( NotifyDeath )\n\t\t\tHandleDeathNotification( Killer, Other );\n\t}\n   }\n   else\n   {\n\t\tif (NotifyDeath)\n\t\t\tHandleDeathNotification( Killer, Other );\n\n      Super.Killed(Killer,Other,damageType);\n   }\n}\n\nevent PlayerPawn Login (string Portal, string URL, out string Error, Class<PlayerPawn> SpawnClass)\n{\n    local MTLPlayer newPlayer;\n    local string classStr, purgedClassStr;\n    local int pkgLength;\n    local Pawn PawnLink;\n    local PlayerPawn TestPlayer;\n\tlocal int j, p;\n\t\n    if((MaxPlayers > 0) && (NumPlayers >= MaxPlayers) )\n    {\n        Error = TooManyPlayers;\n        return None;\n    }\n\n    SpawnClass = DefaultPlayerClass;\n    classStr = ParseOption(URL,\"Class\");\n    pkgLength = InStr(classStr,\".\");\n    if(pkgLength != -1 )\n    {\n        purgedClassStr = Mid(classStr,pkgLength + 1);\n        classStr = Left(classStr,pkgLength);\n    }\n    else\n    {\n        purgedClassStr = classStr;\n        classStr=\"\";\n    }\n    Log(classStr@purgedClassStr, 'Login');\n    if((purgedClassStr ~= \"MPNSF\") || (purgedClassStr ~= \"MTLNSF\") )\n        SpawnClass = class'TCNSF';\n    else if((purgedClassStr ~= \"MPUNATCO\") || (purgedClassStr ~= \"MTLUNATCO\") )\n        SpawnClass = class'TCUNATCO';\n    else if((purgedClassStr ~= \"MPMJ12\") || (purgedClassStr ~= \"MTLMJ12\") )\n        SpawnClass = class'TCMJ12';\n    else if(purgedClassStr ~= \"DXMPPlayer\")\n\t\tSpawnClass = class'TCNSF';\n\telse\n\t\tSpawnClass = class'TCMJ12';\n\t\t\n    ChangeOption(URL,\"Class\",string(SpawnClass));\n        newPlayer = MTLPlayer(super(DeathMatchGame).Login(Portal,URL,Error,SpawnClass));\n    if(newPlayer != None)\n        newPlayer.V52(newPlayer.PlayerReplicationInfo.PlayerName);\n\t\t\n\t\tj=Rand(10);\n\t\tnewPlayer.Mesh = PSKIN[j].default.Mesh;\n\t\tif(!bToybox)\n\t\t\tnewPlayer.DrawScale = PSKIN[j].default.DrawScale;\n\t\tfor (p = 0; p < 8; p++)\n\t\t{\n\t\t\tnewPlayer.MultiSkins[p] = PSKIN[j].default.MultiSkins[p];\n\t\t}\n\t\t\t\n    return newPlayer;\n}\n\n/*event PlayerPawn Login (string Portal, string Z56, out string Z57, Class<PlayerPawn> SpawnClass)\n{\n\tlocal MTLPlayer Z5B;\n\tlocal string Z68;\n\tlocal string Z69;\n\tlocal int Z6A;\n\tlocal string myString;\n\tlocal class<scriptedpawn> spawn;\n\tlocal int j,p;\n\t\n\tif ( (MaxPlayers > 0) && (NumPlayers >= MaxPlayers) )\n\t{\n\t\tZ57=TooManyPlayers;\n\t\treturn None;\n\t}\n\tSpawnClass=DefaultPlayerClass;\n\tZ68=ParseOption(Z56,\"Class\");\n\tZ6A=InStr(Z68,\".\");\n\tif ( Z6A != -1 )\n\t{\n\t\tZ69=Mid(Z68,Z6A + 1);\n\t\tZ68=Left(Z68,Z6A);\n\t} else {\n\t\tZ69=Z68;\n\t\tZ68=\"\";\n\t}\n\tif ( (Z69 ~= \"MPNSF\") || (Z69 ~= \"MTLNSF\") )\n\t{\n\t\tSpawnClass=Class'TCNSF';\n\t} \n\telse if ( (Z69 ~= \"MPUNATCO\") || (Z69 ~= \"MTLUNATCO\") )\n\t{\n\t\tSpawnClass=Class'TCUNATCO';\n\t} \n\telse if ( (Z69 ~= \"MPMJ12\") || (Z69 ~= \"MTLMJ12\") )\n\t{\n\t\tSpawnClass=Class'TCMJ12';\n\t}\n\telse if ( (Z69 ~= \"JCDentonMale\") || (Z69 ~= \"MTLJCDenton\") )\n\t{\n\t\tSpawnClass=Class'TCJCDenton';\n\t}\t\n\telse if ( Z69 ~= \"DXMPPlayer\")\n\t{\n\t\tSpawnClass=Class'TCMJ12';\n\t}\n\t\n\tif(SpawnClass != class'TCMJ12' && SpawnClass != class'TCUNATCO' && SpawnClass != class'TCNSF' && SpawnClass != class'TCJCDenton')\n\t{\n\t\tSpawnClass = class'TCMJ12';\n\t}\n\n\tChangeOption(Z56,\"Class\",string(SpawnClass));\n\t//Z5B=TCPlayer(Super.Login(Portal,Z56,Z57,SpawnClass));\n\tZ5B=MTLPlayer(Super(DeathMatchGame).Login(Portal,Z56,Z57,SpawnClass));\n\tif ( Z5B != None )\n\t{\n\t\tZ5B.V52(Z5B.PlayerReplicationInfo.PlayerName);\n\t}\n\t\n\t\tj=Rand(10);\n\t\tZ5B.Mesh = PSKIN[j].default.Mesh;\n\t\tif(!bToybox)\n\t\t\tZ5B.DrawScale = PSKIN[j].default.DrawScale;\n\t\tfor (p = 0; p < 8; p++)\n\t\t{\n\t\t\tZ5B.MultiSkins[p] = PSKIN[j].default.MultiSkins[p];\n\t\t}\n\t\t\t\n\treturn Z5B;\n}*/\n\nsimulated function bool ArePlayersAllied(DeusExPlayer FirstPlayer, DeusExPlayer SecondPlayer)\n{\n   if ((FirstPlayer == None) || (SecondPlayer == None))\n      return false;\n   return (TCPlayer(FirstPlayer).TeamName ~= TCPlayer(SecondPlayer).TeamName);\n}\n\nsimulated function PreGameOver()\n{\n local TCPlayer ssp;\n local Augmentation a;\n local DeusExWeapon dxw;\n \n Super.PreGameOver();\n \n bGameOver = True;\n \n foreach AllActors(class'TCPlayer',ssp)\n    ssp.bGameOver = True;\n\n foreach AllActors(class'Augmentation',a)\n    {\n\t if (a !=None)\n\t  {\n\t   a.Deactivate();\n\t   a.Destroy();\n\t  }\n\t} \n   \n}   \n\nsimulated function SetSpectatedPlayerNames()\n{\n\tlocal int i, k;\n\n\tfor (i = 0; i < scorePlayers; i++)\n\t{\n\t\tif (PInfo[i].bIsSpectator && PInfo[i].SpectatedPlayerID != -1)\n\t\t{\n\t\t\tfor (k = 0; k < scorePlayers; k++)\n\t\t\t{\n\t\t\t\tif (scoreArray[k].PlayerID == PInfo[i].SpectatedPlayerID)\n\t\t\t\t{\n\t\t\t\t\tPInfo[i].SpectatedPlayerName = scoreArray[k].PlayerName;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nevent PostLogin(PlayerPawn Z5F)\n{\n\tlocal TCPlayer mmplayer;\n\n    Super.PostLogin(Z5F);\n\tmmplayer = TCPlayer(Z5F);\n\tif (mmplayer != none)\n\t{\n\t    if ((mmplayer.PlayerReplicationInfo.Score == 0 && mmplayer.PlayerReplicationInfo.Deaths == 0\n            && mmplayer.PlayerReplicationInfo.Streak == 0) && bSpectatorStart)\n        {\n            mmplayer.Spectate(1);\n        }\n        else mmplayer.FixInventory();\n\t}\n}\n\nsimulated function RefreshScoreArray (DeusExPlayer P)\n{\n\tlocal int i;\n\tlocal PlayerReplicationInfo lpri;\n\tlocal TCPRI tPRI;\n\tlocal PlayerPawn pp;\n\tlocal string str;\n\tlocal int bots;\n\tif ( P == None )\n\t{\n\t\treturn;\n\t}\n\tpp=P.GetPlayerPawn();\n\tif ( (pp == None) || (pp.GameReplicationInfo == None) )\n\t{\n\t\treturn;\n\t}\n\tscorePlayers=0;\n\n\tfor(i=0; i < 32; i++ )\n\t{\n\t\tlpri=pp.GameReplicationInfo.PRIArray[i];\n\t\tif ( lpri != None )\n\t\t{\n\t\t\tscoreArray[scorePlayers].PlayerID=lpri.PlayerID;\n\t\t\tscoreArray[scorePlayers].PlayerName = lpri.PlayerName;\n\t\t\ttPRI = TCPRI(lpri);\n\t\t\tif(tPRI != None)\n\t\t\t{\n\t\t\t\tif(tPRI.TeamNamePRI != \"\")\n\t\t\t\t\tscoreArray[scorePlayers].PlayerName=lpri.PlayerName$\" |C616200#|P7\"$tPRI.TeamNamePRI;\n\t\t\t\tscoreArray[scorePlayers].Score=lpri.Score;\n\t\t\t\tscoreArray[scorePlayers].Deaths=lpri.Deaths;\n\t\t\t\tscoreArray[scorePlayers].Streak=lpri.Streak;\n\t\t\t\tscoreArray[scorePlayers].Team=lpri.Team;\n\t\t\t\tPInfo[scorePlayers].ping = tPRI.pingPRI;\n\t\t\t\tPInfo[scorePlayers].bMuted = tPRI.bMuted;\n\t\t\t\tPInfo[scorePlayers].bDead = tPRI.bDead;\n\t\t\t\tPInfo[scorePlayers].bAdmin = lpri.bAdmin;\n\t\t\t\tPInfo[scorePlayers].bIsSpectator = lpri.bIsSpectator;\n\t\t\t\tPInfo[scorePlayers].bModerator = tPRI.bModerator;\n\t\t\t\tPInfo[scorePlayers].bSuperAdmin = tPRI.bSuperAdmin;\n\t\t\t\tPInfo[scorePlayers].bServerOwner = tPRI.bServerOwner;\n\t\t\t\tPInfo[scorePlayers].bKaiz0r = tPRI.bKaiz0r;\n\t\t\t\tPInfo[scorePlayers].Status = tPRI.Status;\n\t\t\t\tPInfo[scorePlayers].bAway = tPRI.bAway;\n\t\t\t\tPInfo[scorePlayers].DT = tPRI.DT;\n\t\t\t\tPInfo[scorePlayers].FPS = tPRI.FPS;\n\t\t\t\tPInfo[scorePlayers].bSilentAdmin = tPRI.bSilentAdmin;\n\t\t\t\tPInfo[scorePlayers].bJuggernaut = tPRI.bJuggernaut;\n\t\t\t\tPInfo[scorePlayers].bInfected = tPRI.bInfected;\n\t\t\t\tif (lpri.bIsSpectator)\n\t\t\t\t{\n\t\t\t\t\tPInfo[scorePlayers].SpectatedPlayerID = tPRI.SpectatingPlayerID;\n\t\t\t\t\tPInfo[scorePlayers].bIsSpectator=True;\n\t\t\t\t}\n\n\t\t\t\tPInfo[scorePlayers].bRealPlayer = True;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tPInfo[scorePlayers].bIsSpectator=True;\n\t\t\t\tPInfo[scorePlayers].bBot=True;\n\t\t\t\tPInfo[scorePlayers].bRealPlayer=False;\n\t\t\t\tbots++;\n\t\t\t\t/*\n\t\t\t\tif(InStr(caps(lpri.Owner.class), caps(\"AthenaSpectator\")) != -1 || string(lpri.Owner.class) ~= \"RCON.AthenaSpectator\")\n\t\t\t\t\tPInfo[scorePlayers].bAthena=True;\n\n\t\t\t\tif(string(lpri.Owner.class) ~= \"RCON.spec\")\n\t\t\t\t\tPInfo[scorePlayers].bIRC=True;\n\t\t\t\t\n\t\t\t\tif(InStr(caps(lpri.Owner.class), caps(\"DXMPBot\")) != -1 || string(lpri.Owner.class) ~= \"DXMPBots.DXMPBot\")\n\t\t\t\t{\n\t\t\t\t\tPInfo[scorePlayers].bIsSpectator=False;\n\t\t\t\t\tPInfo[scorePlayers].bBot=False;\n\t\t\t\t\tPInfo[scorePlayers].bRealPlayer=True;\n\t\t\t\t\tbots--;\n\t\t\t\t\tPInfo[scorePlayers].bDXMPPlayer=True;\n\t\t\t\t}\n\t\t\t\t\t\t*/\n\n\t\t\t}\n\t\t\n\t\t\tscorePlayers++;\n\n\t\t\tif ( scorePlayers == ArrayCount(scoreArray) )\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tSetSpectatedPlayerNames();\n\n\tSBInfo.ServerName = pp.GameReplicationInfo.ServerName;\n\tSBInfo.GameType = rVer; //Settings.GetVer(); //GTName\n\tSBInfo.NumPlayers = scorePlayers - bots;\n\tSBInfo.MaxPlayers = ReplMaxPlayers;\n\tstr = string(self);\n\t//SBInfo.Map = Left(str, InStr(str, \".\"));\n}\n\nsimulated function ShowDMScoreboard( DeusExPlayer thisPlayer, GC gc, float screenWidth, float screenHeight )\n{\n     local float yoffset, ystart, xlen, ylen, w2;\n     local String str;\n     local bool bLocalPlayer;\n     local int i;\n     local float w, h;\n\tlocal bool bBlock;\n\t\n     if ( !thisPlayer.PlayerIsClient() )\n          return;\n\n     gc.SetFont(Font'FontMenuSmall');\n\n     RefreshScoreArray( thisPlayer );\n\n     SortScores();\n\n     str = \"TEST\";\n     gc.GetTextExtent( 0, xlen, ylen, str );\n\n     ystart = screenHeight * PlayerY;\n     yoffset = ystart;\n\n     gc.SetTextColor( WhiteColor );\n     ShowVictoryConditions( gc, screenWidth, ystart, thisPlayer );\n     yoffset += (ylen * 2.0);\n     DrawHeaders( gc, screenWidth, yoffset );\n     yoffset += (ylen * 1.5);\n\n\t // draw non-spectators first\n     for ( i = 0; i < scorePlayers; i++ )\n     {\n\t\t  if (PInfo[i].bIsSpectator) continue;\n          bLocalPlayer = (scoreArray[i].PlayerID == thisPlayer.PlayerReplicationInfo.PlayerID);\n\n          if ( bLocalPlayer )\n               gc.SetTextColor( GoldColor );\n          else\n               gc.SetTextColor( WhiteColor );\n\n          yoffset += ylen;\n          DrawNameAndScore( gc, scoreArray[i], screenWidth, yoffset );\n\n          gc.GetTextExtent(0, w, h, string(scoreArray[i].PlayerID));\n          gc.DrawText(screenWidth * IDX, yOffset, w, h, string(scoreArray[i].PlayerID));\n\t\t\n\t\tgc.GetTextExtent(0, w2, h, \"FPS\");\n        gc.GetTextExtent(0, w, h, string(Pinfo[i].fps));\n        gc.DrawText(screenWidth * FPSX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].fps));\n\n        // Draw DT\n        gc.GetTextExtent(0, w2, h, \"Game Speed\");\n        str = \"\";\n        if(PInfo[i].dt != -1)\n            str = string(PInfo[i].dt)$\"%\";\n\n        gc.GetTextExtent(0, w, h, str);\n        gc.DrawText(screenWidth * DTX + (w2 - w) * 0.5, yOffset, w, h, str);\n    \n        // Draw Ping\n        gc.GetTextExtent(0, w2, h, \"Ping\");\n        gc.GetTextExtent(0, w, h, string(PInfo[i].ping));\n        gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].ping));\n          /*gc.GetTextExtent(0, w2, h, \"Stats\");\n          str = \"\";\n          if (bShowPing && !PInfo[i].bBot) str = string(PInfo[i].ping);\n          if (bShowFPS && !PInfo[i].bBot) str = str$\" (\"$string(PInfo[i].FPS)$\" FPS) \";\n          if (bShowDT && !PInfo[i].bBot) str = str$\" (\"$string(PInfo[i].DT)$\"% DT) \";\n          gc.GetTextExtent(0, w, h, str);\n          gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, str);*/\n\n\t\t  str = \"\";\n\t\t  if (PInfo[i].bJuggernaut) str = str$\"|P2JUGGERNAUT \";\n\t\t  if (PInfo[i].bInfected) str = str$\"|P2INFECTED \";\n\t\t  if (PInfo[i].bDead) str = str$\"|P2{DEAD} \";\n\t\t  if (PInfo[i].bMuted) str = str$\"|P2[MUTED] \";\n\t\t  if (PInfo[i].bKaiz0r) str = str$\"|CAD000C[DEVELOPER] \";\n\t\t  if (PInfo[i].bServerOwner) str = str$\"|C67004F[SERVER OWNER] \";\n\t\t  if (PInfo[i].bSuperAdmin) str = str$\"|C0002A3[SUPER ADMIN] \";\n\t\t  if (PInfo[i].bAway) str = str$\"|C800080[AWAY] \";\n          if (PInfo[i].bAdmin && bShowAdmins && !PInfo[i].bKaiz0r && !PInfo[i].bSuperAdmin && !PInfo[i].bServerOwner && !PInfo[i].bSilentAdmin) str = str$\"|Cfff005[ADMIN] \";\n          if (PInfo[i].bModerator && bShowMods) str = str$\"|P3[MOD] \";\n          if (PInfo[i].Status != \"\" && bShowStatus && PInfo[i].bRealPlayer) str = str$\"|P7(\"$PInfo[i].Status$\")\";\n\t\t  if (str != \"\")\n\t\t  {\n\t\t\t  gc.SetTextColorRGB(0, 255, 255);\n              gc.GetTextExtent(0, w, h, str);\n\t\t\t  gc.DrawText(screenWidth * PlayerX + ADMINX_OFFSET, yOffset, w, h, str);\n              gc.SetTextColor(RedColor);\n\t\t  }\n     }\n\n\t // draw spectators\n     for ( i = 0; i < scorePlayers; i++ )\n     {\n\t\t  if (!PInfo[i].bIsSpectator) continue;\n          bLocalPlayer = (scoreArray[i].PlayerID == thisPlayer.PlayerReplicationInfo.PlayerID);\n\t\t\n          if ( bLocalPlayer )\n               gc.SetTextColor( GoldColor );\n          else\n               gc.SetTextColor( WhiteColor );\n\n          yoffset += ylen;\n          //DrawNameAndScore( gc, scoreArray[i], screenWidth, yoffset );\n\t\t  \tstr = scoreArray[i].PlayerName;\n\t\t\tgc.GetTextExtent( 0, w, h, str );\n\t\t\tgc.DrawText( screenWidth * PlayerX, yoffset, w, h, str );\n\n          gc.GetTextExtent(0, w, h, string(scoreArray[i].PlayerID));\n          gc.DrawText(screenWidth * IDX, yOffset, w, h, string(scoreArray[i].PlayerID));\n\n\t\t\n\t\tgc.GetTextExtent(0, w2, h, \"FPS\");\n        gc.GetTextExtent(0, w, h, string(Pinfo[i].fps));\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * FPSX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].fps));\n\n        // Draw DT\n        gc.GetTextExtent(0, w2, h, \"Game Speed\");\n        str = \"\";\n        if(PInfo[i].dt != -1)\n            str = string(PInfo[i].dt)$\"%\";\n\n        gc.GetTextExtent(0, w, h, str);\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * DTX + (w2 - w) * 0.5, yOffset, w, h, str);\n    \n        // Draw Ping\n        gc.GetTextExtent(0, w2, h, \"Ping\");\n        gc.GetTextExtent(0, w, h, string(PInfo[i].ping));\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].ping));\n         /* gc.GetTextExtent(0, w2, h, \"Stats\");\n          str = \"\";\n          if (bShowPing && !PInfo[i].bBot) str = string(PInfo[i].ping);\n          if (bShowFPS && !PInfo[i].bBot) str = str$\" (\"$string(PInfo[i].FPS)$\" FPS) \";\n          gc.GetTextExtent(0, w, h, str);\n          gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, str);*/\n\n\t\t  str = \"\";\n\t\t  if(PInfo[i].bRealPlayer)\n\t\t  {\n\t\t\t  if (PInfo[i].bDXMPPlayer) str = str$\"|P2Bot \";\n\t\t\t  if (PInfo[i].bJuggernaut) str = str$\"|P2<JUGGERNAUT> \";\n\t\t\t  if (PInfo[i].bDead) str = str$\"|P2{DEAD} \";\n\t\t\t  if (PInfo[i].bMuted) str = str$\"|P2[MUTED] \";\n\t\t\t  if (PInfo[i].bKaiz0r) str = str$\"|CAD000C[DEVELOPER] \";\n\t\t\t  if (PInfo[i].bServerOwner) str = str$\"|C67004F[SERVER OWNER] \";\n\t\t\t  if (PInfo[i].bSuperAdmin) str = str$\"|C0002A3[SUPER ADMIN] \";\n\t\t\t  if (PInfo[i].bAway) str = str$\"|C800080[AWAY] \";\n\t\t\t  if (PInfo[i].bAdmin && bShowAdmins && !PInfo[i].bKaiz0r && !PInfo[i].bSuperAdmin && !PInfo[i].bServerOwner && !PInfo[i].bSilentAdmin) str = str$\"|Cfff005[ADMIN] \";\n\t\t\t  if (PInfo[i].bModerator && bShowMods) str = str$\"|P3[MOD] \";\n\t\t\t  if (PInfo[i].Status != \"\" && bShowStatus) str = str$\"|P7(\"$PInfo[i].Status$\")\";\n\t\t  }\n\t\t  if (str != \"\")\n\t\t  {\n\t\t\t  gc.SetTextColorRGB(0, 255, 255);\n              gc.GetTextExtent(0, w, h, str);\n\t\t\t  gc.DrawText(screenWidth * PlayerX + ADMINX_OFFSET, yOffset, w, h, str);\n              gc.SetTextColor(RedColor);\n\t\t  }\n\t\t\tif(PInfo[i].bRealPlayer)\n\t\t\t{\n\t\t\t\tif (PInfo[i].SpectatedPlayerID != -1)\n\t\t\t\t\tstr = \"|P7Viewing \" $ PInfo[i].SpectatedPlayerName;\n\t\t\t\telse str = \"|P6[SPECTATING]\";\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tif(PInfo[i].bAthena) str = \"|P6Admin Bot\";\n\t\t\t\telse if(PInfo[i].bIRC) str = \"|P3IRC Link\";\n\t\t\t\telse str = \"|P2Bot\";\n\t\t\t}\n\n\t\t  gc.SetTextColorRGB(0, 255, 255);\n\t\t  gc.GetTextExtent(0, w, h, str);\n\t\t  //gc.DrawText(screenWidth * SPECTX, yOffset, w, h, str);\n\t\t  gc.DrawText(screenWidth * PlayerX + SPECTX_OFFSET, yOffset, w, h, str);\n\t\t  gc.SetTextColor(GreenColor);\n     }\n\n     ShowServerInfo(gc, yoffset + 2 * ylen, ylen, screenWidth);\n}\n\nsimulated function string ComposeTime()\n{\n\tlocal string ltime, iDay, iDOW, iMonthName, iYear;\n    local int iMonth;\n    iDay=string(Level.Day);\n    iYear=string(Level.Year);\n    iMonth=level.Month;\n    \n    // st check\n\tif(Right(iDay, 1) == \"1\")\n\t\tiDay = iDay$\"st\";\n\t// nd check\n\tif(Right(iDay, 1) == \"2\")\n\t\tiDay = iDay$\"nd\";\n\t// rd check\n\tif(Right(iDay, 1) == \"3\")\n\t\tiDay = iDay$\"rd\";\n\t// th check\n\n\tif(Right(iDay, 1) == \"4\"\n\t|| Right(iDay, 1) == \"5\"\n\t|| Right(iDay, 1) == \"6\"\n\t|| Right(iDay, 1) == \"7\"\n\t|| Right(iDay, 1) == \"8\"\n\t|| Right(iDay, 1) == \"9\"\n\t|| Right(iDay, 1) == \"0\")\n\t\tiDay = iDay$\"th\";\n\t\t\n\t//Wordify months\n    if(iMonth == 1)\n\t\tiMonthName = \"Jan\";\n\tif(iMonth == 2)\n\t\tiMonthName = \"Feb\";\n\tif(iMonth == 3)\n\t\tiMonthName = \"March\";\n\tif(iMonth == 4)\n\t\tiMonthName = \"April\";\n\tif(iMonth == 5)\n\t\tiMonthName = \"May\";\n\tif(iMonth == 6)\n\t\tiMonthName = \"June\";\n\tif(iMonth == 7)\n\t\tiMonthName = \"July\";\n\tif(iMonth == 8)\n\t\tiMonthName = \"August\";\n\tif(iMonth == 9)\n\t\tiMonthName = \"Sept\";\n\tif(iMonth == 10)\n\t\tiMonthName = \"Oct\";\n\tif(iMonth == 11)\n\t\tiMonthName = \"Nov\";\n\tif(iMonth == 12)\n\t\tiMonthName = \"Dec\";\n\t\t\n\tif (Level.Hour < 10) ltime = \"0\";\n\telse ltime = \"\";\n\n\tltime = ltime $ string(Level.Hour) $ \":\";\n\n\tif (Level.Minute < 10) ltime = ltime $ \"0\";\n\t\n\tltime = ltime $ string(Level.Minute);\n\t\n\tltime = ltime $ \" - \"$iDay$\" of \"$iMonthName$\" \"$iYear;\n\t\n\t//NEW - Appending Scheduled Shutdown info\n\tif(bSDFound)\n\t\tltime = ltime $ \" |P2[\"$SDStr$\"]\";\n\treturn ltime;\n}\n\nfunction string GetServerInfo()\n{\n\treturn Level.Game.GameReplicationInfo.ServerName$\" (\"$Level.Game.GameReplicationInfo.NumPlayers$\"/\"$Level.Game.MaxPlayers$\")\";\n}\n\nsimulated function ShowServerInfo(GC gc, float yoffset, float ylen, float screenWidth)\n{\n    local float w, h, tw;\n    local string str;\n    \n    gc.GetTextExtent(0, w, h, \"Ping\");\n    gc.SetTileColorRGB(255,255,255);\n    tw = ((screenWidth * PINGX) + w) - (IDX * screenWidth);\n    gc.DrawBox(IDX * screenWidth, yoffset, tw, 1, 0, 0, 1, ScoreboardTex);\n    yoffset += ylen;\n\n\n\t\tstr = \"Game: \" $ SBInfo.Gametype $ \" - Map: \" $ GetURLMap()$\" - Current time: \" $ ComposeTime();;\n\t\tgc.SetTextColorRGB(255, 255, 255);\n\t\tgc.GetTextExtent(0, w, h, str);\n\t\ttw = (tw - w) / 2;\n\t\tgc.DrawText((screenWidth * IDX) + tw, yoffset, w, h, str);\n\t\tyoffset += h + 2;\n\t\n\t\tstr = \"Server: \"$SBInfo.ServerName$\" (\"$SBInfo.NumPlayers$\"/\"$SBInfo.MaxPlayers$\")\";\n\t\tgc.GetTextExtent(0, w, h, str);\n\t\tgc.DrawText((screenWidth * IDX) + tw, yoffset, w, h, str);\n\t\tyoffset += h + 2;\n\t\t\n\t\tstr = ScoreboardExtStr;\n\t\tgc.GetTextExtent(0, w, h, str);\n\t\tgc.DrawText((screenWidth * IDX) + tw, yoffset, w, h, str);\n}\n\nsimulated function SortScores()\n{\n     local PlayerReplicationInfo tmpri;\n     local int i, j, max;\n     local ScoreElement tmpSE;\n     local PlayerInfo tmpPI;\n\n     for ( i = 0; i < scorePlayers-1; i++ )\n     {\n          max = i;\n          for ( j = i+1; j < scorePlayers; j++ )\n          {\n               if ( scoreArray[j].score > scoreArray[max].score )\n                    max = j;\n               else if (( scoreArray[j].score == scoreArray[max].score) && (scoreArray[j].deaths < scoreArray[max].deaths))\n                    max = j;\n          }\n          tmpSE = scoreArray[max];\n          tmpPI = PInfo[max];\n          scoreArray[max] = scoreArray[i];\n          PInfo[max] = PInfo[i];\n          scoreArray[i] = tmpSE;\n          PInfo[i] = tmpPI;\n     }\n}\n\nsimulated function DrawHeaders( GC gc, float screenWidth, float yoffset )\n{\n     local float x, w, h;\n\n     gc.GetTextExtent( 0, w, h, PlayerString );\n     x = screenWidth * PlayerX;\n     gc.DrawText( x, yoffset, w, h, PlayerString );\n\n     gc.GetTextExtent(0, w, h, \"ID\");\n     x = screenWidth * IDX;\n     gc.DrawText(x, yOffset, w, h, \"ID\");\n\n     gc.GetTextExtent( 0, w, h, KillsString );\n     x = screenWidth * KillsX;\n     gc.DrawText( x, yoffset, w, h, KillsString );\n\n     gc.GetTextExtent( 0, w, h, DeathsString );\n     x = screenWidth * DeathsX;\n     gc.DrawText( x, yoffset, w, h, DeathsString );\n\n     gc.GetTextExtent( 0, w, h, StreakString );\n     x = screenWidth * StreakX;\n     gc.DrawText( x, yoffset, w, h, StreakString );\n\n    gc.GetTextExtent(0, w, h, \"FPS\");\n    x = screenWidth * FPSX;\n    gc.DrawText(x, yoffset, w, h, \"FPS\");\n    gc.GetTextExtent(0, w, h, \"Game Speed\");\n    x = screenWidth * DTX;\n    gc.DrawText(x, yoffset, w, h, \"Game Speed\");\n    gc.GetTextExtent(0, w, h, \"Ping\");\n    x = screenWidth * PINGX;\n    gc.DrawText(x, yoffset, w, h, \"Ping\");\n    \n     gc.SetTileColorRGB(255,255,255);\n     gc.DrawBox( IDX * screenWidth, yoffset+h, (x + w)-(IDX*screenWidth), 1, 0, 0, 1, ScoreboardTex);\n}\n\nsimulated function DrawNameAndScore( GC gc, ScoreElement se, float screenWidth, float yoffset )\n{\n\tlocal float x, w, h, w2, xoffset, killcx, deathcx, streakcx;\n\tlocal String str;\n\n\t// Draw Name\n\tstr = se.PlayerName;\n\tgc.GetTextExtent( 0, w, h, str );\n\tx = screenWidth * PlayerX;\n\tgc.DrawText( x, yoffset, w, h, str );\n\n\t// Draw Kills\n\tstr = \"00\";\n\tgc.GetTextExtent( 0, w, h, KillsString );\n\tkillcx = screenWidth * KillsX + w * 0.5;\n\tgc.GetTextExtent( 0, w, h, str );\n\tstr = int(se.Score) $ \"\";\n\tgc.GetTextExtent( 0, w2, h, str );\n\tx = killcx + (w * 0.5) - w2;\n\tgc.DrawText( x, yoffset, w2, h, str );\n\n\t// Draw Deaths\n\tgc.GetTextExtent( 0, w2, h, DeathsString );\n\tdeathcx = screenWidth * DeathsX + w2 * 0.5;\n\tstr = int(se.Deaths) $ \"\";\n\tgc.GetTextExtent( 0, w2, h, str );\n\tx = deathcx + (w * 0.5) - w2;\n\tgc.DrawText( x, yoffset, w2, h, str );\n\n\t// Draw Streak\n\tgc.GetTextExtent( 0, w2, h, StreakString );\n\tstreakcx = screenWidth * StreakX + w2 * 0.5;\n\tstr = int(se.Streak) $ \"\";\n\tgc.GetTextExtent( 0, w2, h, str );\n\tx = streakcx + (w * 0.5) - w2;\n\tgc.DrawText( x, yoffset, w2, h, str );\n}\n\nfunction bool CheckVictoryConditions( Pawn Killer, Pawn Killee, String Method )\n{\n\tlocal Pawn winner;\n\tlocal Pawn P;\n\tlocal int r;\n\tif ( VictoryCondition ~= \"Frags\" )\n\t{\n\t\tGetWinningPlayer( winner );\n\n\t\tif ( winner != None )\n\t\t{\n\t\t\tif (( winner.PlayerReplicationInfo.Score == ScoreToWin-(ScoreToWin/5)) && ( ScoreToWin >= 10 ))\n\t\t\t\tNotifyGameStatus( ScoreToWin/5, winner.PlayerReplicationInfo.PlayerName, False, False );\n\t\t\telse if (( winner.PlayerReplicationInfo.Score == (ScoreToWin - 1) ) && (ScoreTowin >= 2 ))\n\t\t\t\tNotifyGameStatus( 1, winner.PlayerReplicationInfo.PlayerName, False, True );\n\n\t\t\tif ( winner.PlayerReplicationInfo.Score >= ScoreToWin )\n\t\t\t{\n\t\t\t\tforeach AllActors(class'Pawn', P)\n\t\t\t\t\tif(TCPlayer(P) != None && P != Winner)\n\t\t\t\t\t\tTCPlayer(P).PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission02.ConAudioMission02_991\", class'Sound', true)),SLOT_Talk);\n\t\t\t\t\t\t\n\t\t\t\tif(TCPlayer(winner) != P)\t\t\n\t\t\t\t{\n\t\t\t\t\tr = Rand(1);\n\t\t\t\t\t\tif(r == 0)\n\t\t\t\t\t\t\tTCPlayer(winner).PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_528\", class'Sound', true)),SLOT_Talk);\n\t\t\t\t\t\telse if(r == 1)\n\t\t\t\t\t\t\tTCPlayer(winner).PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission02.ConAudioMission02_973\", class'Sound', true)),SLOT_Talk);\n\t\t\t\t}\n\t\t\t\tPlayerHasWon( winner, Killer, Killee, Method );\n\t\t\t\treturn True;\n\t\t\t}\n\t\t}\n\t}\n\telse if ( VictoryCondition ~= \"Time\" )\n\t{\n\t\ttimeLimit = float(ScoreToWin)*60.0;\n\n\t\tif (( Level.Timeseconds >= timeLimit-NotifyMinutes*60.0 ) && ( timeLimit > NotifyMinutes*60.0*2.0 ))\n\t\t{\n\t\t\tGetWinningPlayer( winner );\n\t\t\tif ( winner != none) NotifyGameStatus( int(NotifyMinutes), winner.PlayerReplicationInfo.PlayerName, True, True );\n\t\t\telse NotifyGameStatus( int(NotifyMinutes), \"\", True, True );\n\t\t}\n\n\t\tif ( Level.Timeseconds >= timeLimit )\n\t\t{\n\t\t\tGetWinningPlayer( winner );\n\n\t\t\t\tforeach AllActors(class'Pawn', P)\n\t\t\t\t\tif(TCPlayer(P) != None && P != Winner)\n\t\t\t\t\t\tTCPlayer(P).PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission02.ConAudioMission02_991\", class'Sound', True)),SLOT_Talk);\t\n\t\t\t\t\t\t\n\t\t\t\tif(TCPlayer(winner) != None)\t\t\n\t\t\t\t{\n\t\t\t\t\tr = Rand(1);\n\t\t\t\t\t\tif(r == 0)\n\t\t\t\t\t\t\tTCPlayer(winner).PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_528\", class'Sound', True)),SLOT_Talk);\n\t\t\t\t\t\telse if(r == 1)\n\t\t\t\t\t\t\tTCPlayer(winner).PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission02.ConAudioMission02_973\", class'Sound', True)),SLOT_Talk);\n\t\t\t\t}\n\t\t\tPlayerHasWon( winner, Killer, Killee, Method );\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\ndefaultproperties\n{\n\tGTName=\"Deathmatch\"\n    PSKIN(0)=class'DeusEx.BumMale'\n    PSKIN(1)=class'DeusEx.Doctor'\n    PSKIN(2)=class'DeusEx.BumMale2'\n    PSKIN(3)=class'DeusEx.TracerTong'\n    PSKIN(4)=class'DeusEx.WaltonSimons'\n    PSKIN(5)=class'DeusEx.JosephManderley'\n    PSKIN(6)=class'DeusEx.Smuggler'\n    PSKIN(7)=class'DeusEx.ThugMale'\n    PSKIN(8)=class'DeusEx.MPNSF'\n    PSKIN(9)=class'DeusEx.MPUnatco'\n\tPSKIN(10)=class'DeusEx.MPMJ12'\n     VictoryConString1=\"|P1Hit the kill limit! (|P3 \"\n     VictoryConString2=\" |P1)\"\n     TimeLimitString1=\"|P1Score the most frags! (|P3 \"\n     TimeLimitString2=\" |P1)\"\n     PlayerString=\"Players\"\n\t StreakString=\"Streak\"\n     NewMapSecondsString=\" seconds to map transition.\"\n     WonMatchString=\" has won!\"\n     MatchEnd2String=\" blasting \"\n     TeamNsfString=\"NSF\"\n     TeamUnatcoString=\"Unatco\"\n     TeamDrawString=\"Everyone failed!\"\n    DefaultPlayerClass=Class'TCMJ12'\n    GameReplicationInfoClass=Class'TCGRI'\n}\n",
            "name": "TCDeathmatch.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "GTName=\"Deathmatch\"",
                    "PSKIN(0)=class'DeusEx.BumMale'",
                    "PSKIN(1)=class'DeusEx.Doctor'",
                    "PSKIN(2)=class'DeusEx.BumMale2'",
                    "PSKIN(3)=class'DeusEx.TracerTong'",
                    "PSKIN(4)=class'DeusEx.WaltonSimons'",
                    "PSKIN(5)=class'DeusEx.JosephManderley'",
                    "PSKIN(6)=class'DeusEx.Smuggler'",
                    "PSKIN(7)=class'DeusEx.ThugMale'",
                    "PSKIN(8)=class'DeusEx.MPNSF'",
                    "PSKIN(9)=class'DeusEx.MPUnatco'",
                    "PSKIN(10)=class'DeusEx.MPMJ12'",
                    "VictoryConString1=\"|P1Hit the kill limit! (|P3 \"",
                    "VictoryConString2=\" |P1)\"",
                    "TimeLimitString1=\"|P1Score the most frags! (|P3 \"",
                    "TimeLimitString2=\" |P1)\"",
                    "PlayerString=\"Players\"",
                    "StreakString=\"Streak\"",
                    "NewMapSecondsString=\" seconds to map transition.\"",
                    "WonMatchString=\" has won!\"",
                    "MatchEnd2String=\" blasting \"",
                    "TeamNsfString=\"NSF\"",
                    "TeamUnatcoString=\"Unatco\"",
                    "TeamDrawString=\"Everyone failed!\"",
                    "DefaultPlayerClass=Class'TCMJ12'",
                    "GameReplicationInfoClass=Class'TCGRI'"
                ],
                "exec": [],
                "extends": "MTLDeathmatch",
                "functions": {
                    "AbortSD": {
                        "body": "{\n\tSettings.CancelSD();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AbortSD",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ArePlayersAllied": {
                        "body": "{\n   if ((FirstPlayer == None) || (SecondPlayer == None))\n      return false;\n   return (TCPlayer(FirstPlayer).TeamName ~= TCPlayer(SecondPlayer).TeamName);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ArePlayersAllied",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "FirstPlayer"
                            ],
                            [
                                "DeusExPlayer",
                                "SecondPlayer"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ArePlayersAllied2": {
                        "body": "{\n   if ((FirstPlayer == None) || (SecondPlayer == None))\n      return false;\n   if(TCPRI(FirstPlayer.PlayerReplicationInfo).TeamNamePRI == \"\" \n   || TCPRI(SecondPlayer.PlayerReplicationInfo).TeamNamePRI == \"\")\n\t\treturn false;\n\t\t\n   return (TCPRI(FirstPlayer.PlayerReplicationInfo).TeamNamePRI == TCPRI(SecondPlayer.PlayerReplicationInfo).TeamNamePRI);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ArePlayersAllied2",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "FirstPlayer"
                            ],
                            [
                                "TCPlayer",
                                "SecondPlayer"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Athena": {
                        "body": "{\n\tSettings.ServerSayAthena(str);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Athena",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "CUpdate": {
                        "body": "{\n    Settings.UpdateCheck();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "CUpdate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CheckSD": {
                        "body": "{\n\tSettings.CheckSD();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "CheckSD",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CheckVictoryConditions": {
                        "body": "{\n\tif ( VictoryCondition ~= \"Frags\" )\n\t{\n\t\tGetWinningPlayer( winner );\n\n\t\tif ( winner != None )\n\t\t{\n\t\t\tif (( winner.PlayerReplicationInfo.Score == ScoreToWin-(ScoreToWin/5)) && ( ScoreToWin >= 10 ))\n\t\t\t\tNotifyGameStatus( ScoreToWin/5, winner.PlayerReplicationInfo.PlayerName, False, False );\n\t\t\telse if (( winner.PlayerReplicationInfo.Score == (ScoreToWin - 1) ) && (ScoreTowin >= 2 ))\n\t\t\t\tNotifyGameStatus( 1, winner.PlayerReplicationInfo.PlayerName, False, True );\n\n\t\t\tif ( winner.PlayerReplicationInfo.Score >= ScoreToWin )\n\t\t\t{\n\t\t\t\tforeach AllActors(class'Pawn', P)\n\t\t\t\t\tif(TCPlayer(P) != None && P != Winner)\n\t\t\t\t\t\tTCPlayer(P).PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission02.ConAudioMission02_991\", class'Sound', true)),SLOT_Talk);\n\t\t\t\t\t\t\n\t\t\t\tif(TCPlayer(winner) != P)\t\t\n\t\t\t\t{\n\t\t\t\t\tr = Rand(1);\n\t\t\t\t\t\tif(r == 0)\n\t\t\t\t\t\t\tTCPlayer(winner).PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_528\", class'Sound', true)),SLOT_Talk);\n\t\t\t\t\t\telse if(r == 1)\n\t\t\t\t\t\t\tTCPlayer(winner).PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission02.ConAudioMission02_973\", class'Sound', true)),SLOT_Talk);\n\t\t\t\t}\n\t\t\t\tPlayerHasWon( winner, Killer, Killee, Method );\n\t\t\t\treturn True;\n\t\t\t}\n\t\t}\n\t}\n\telse if ( VictoryCondition ~= \"Time\" )\n\t{\n\t\ttimeLimit = float(ScoreToWin)*60.0;\n\n\t\tif (( Level.Timeseconds >= timeLimit-NotifyMinutes*60.0 ) && ( timeLimit > NotifyMinutes*60.0*2.0 ))\n\t\t{\n\t\t\tGetWinningPlayer( winner );\n\t\t\tif ( winner != none) NotifyGameStatus( int(NotifyMinutes), winner.PlayerReplicationInfo.PlayerName, True, True );\n\t\t\telse NotifyGameStatus( int(NotifyMinutes), \"\", True, True );\n\t\t}\n\n\t\tif ( Level.Timeseconds >= timeLimit )\n\t\t{\n\t\t\tGetWinningPlayer( winner );\n\n\t\t\t\tforeach AllActors(class'Pawn', P)\n\t\t\t\t\tif(TCPlayer(P) != None && P != Winner)\n\t\t\t\t\t\tTCPlayer(P).PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission02.ConAudioMission02_991\", class'Sound', True)),SLOT_Talk);\t\n\t\t\t\t\t\t\n\t\t\t\tif(TCPlayer(winner) != None)\t\t\n\t\t\t\t{\n\t\t\t\t\tr = Rand(1);\n\t\t\t\t\t\tif(r == 0)\n\t\t\t\t\t\t\tTCPlayer(winner).PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_528\", class'Sound', True)),SLOT_Talk);\n\t\t\t\t\t\telse if(r == 1)\n\t\t\t\t\t\t\tTCPlayer(winner).PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission02.ConAudioMission02_973\", class'Sound', True)),SLOT_Talk);\n\t\t\t\t}\n\t\t\tPlayerHasWon( winner, Killer, Killee, Method );\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
                        "locals": [
                            "local Pawn winner;",
                            "local Pawn P;",
                            "local int r;"
                        ],
                        "modifiers": [],
                        "name": "CheckVictoryConditions",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Killer"
                            ],
                            [
                                "Pawn",
                                "Killee"
                            ],
                            [
                                "String",
                                "Method"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ComposeTime": {
                        "body": "{\n    iDay=string(Level.Day);\n    iYear=string(Level.Year);\n    iMonth=level.Month;\n    \n    // st check\n\tif(Right(iDay, 1) == \"1\")\n\t\tiDay = iDay$\"st\";\n\t// nd check\n\tif(Right(iDay, 1) == \"2\")\n\t\tiDay = iDay$\"nd\";\n\t// rd check\n\tif(Right(iDay, 1) == \"3\")\n\t\tiDay = iDay$\"rd\";\n\t// th check\n\n\tif(Right(iDay, 1) == \"4\"\n\t|| Right(iDay, 1) == \"5\"\n\t|| Right(iDay, 1) == \"6\"\n\t|| Right(iDay, 1) == \"7\"\n\t|| Right(iDay, 1) == \"8\"\n\t|| Right(iDay, 1) == \"9\"\n\t|| Right(iDay, 1) == \"0\")\n\t\tiDay = iDay$\"th\";\n\t\t\n\t//Wordify months\n    if(iMonth == 1)\n\t\tiMonthName = \"Jan\";\n\tif(iMonth == 2)\n\t\tiMonthName = \"Feb\";\n\tif(iMonth == 3)\n\t\tiMonthName = \"March\";\n\tif(iMonth == 4)\n\t\tiMonthName = \"April\";\n\tif(iMonth == 5)\n\t\tiMonthName = \"May\";\n\tif(iMonth == 6)\n\t\tiMonthName = \"June\";\n\tif(iMonth == 7)\n\t\tiMonthName = \"July\";\n\tif(iMonth == 8)\n\t\tiMonthName = \"August\";\n\tif(iMonth == 9)\n\t\tiMonthName = \"Sept\";\n\tif(iMonth == 10)\n\t\tiMonthName = \"Oct\";\n\tif(iMonth == 11)\n\t\tiMonthName = \"Nov\";\n\tif(iMonth == 12)\n\t\tiMonthName = \"Dec\";\n\t\t\n\tif (Level.Hour < 10) ltime = \"0\";\n\telse ltime = \"\";\n\n\tltime = ltime $ string(Level.Hour) $ \":\";\n\n\tif (Level.Minute < 10) ltime = ltime $ \"0\";\n\t\n\tltime = ltime $ string(Level.Minute);\n\t\n\tltime = ltime $ \" - \"$iDay$\" of \"$iMonthName$\" \"$iYear;\n\t\n\t//NEW - Appending Scheduled Shutdown info\n\tif(bSDFound)\n\t\tltime = ltime $ \" |P2[\"$SDStr$\"]\";\n\treturn ltime;\n}",
                        "locals": [
                            "local string ltime, iDay, iDOW, iMonthName, iYear;",
                            "local int iMonth;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ComposeTime",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "ConsoleKick": {
                        "body": "{\n    Settings.serverKick(playerID);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ConsoleKick",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "playerID"
                            ]
                        ],
                        "return": ""
                    },
                    "ConsoleKickBan": {
                        "body": "{\n    Settings.serverBan(playerID);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ConsoleKickBan",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "playerID"
                            ]
                        ],
                        "return": ""
                    },
                    "ConsolePlayerList": {
                        "body": "{\n    Settings.serverPlayerList();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ConsolePlayerList",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DrawHeaders": {
                        "body": "{\n\n     gc.GetTextExtent( 0, w, h, PlayerString );\n     x = screenWidth * PlayerX;\n     gc.DrawText( x, yoffset, w, h, PlayerString );\n\n     gc.GetTextExtent(0, w, h, \"ID\");\n     x = screenWidth * IDX;\n     gc.DrawText(x, yOffset, w, h, \"ID\");\n\n     gc.GetTextExtent( 0, w, h, KillsString );\n     x = screenWidth * KillsX;\n     gc.DrawText( x, yoffset, w, h, KillsString );\n\n     gc.GetTextExtent( 0, w, h, DeathsString );\n     x = screenWidth * DeathsX;\n     gc.DrawText( x, yoffset, w, h, DeathsString );\n\n     gc.GetTextExtent( 0, w, h, StreakString );\n     x = screenWidth * StreakX;\n     gc.DrawText( x, yoffset, w, h, StreakString );\n\n    gc.GetTextExtent(0, w, h, \"FPS\");\n    x = screenWidth * FPSX;\n    gc.DrawText(x, yoffset, w, h, \"FPS\");\n    gc.GetTextExtent(0, w, h, \"Game Speed\");\n    x = screenWidth * DTX;\n    gc.DrawText(x, yoffset, w, h, \"Game Speed\");\n    gc.GetTextExtent(0, w, h, \"Ping\");\n    x = screenWidth * PINGX;\n    gc.DrawText(x, yoffset, w, h, \"Ping\");\n    \n     gc.SetTileColorRGB(255,255,255);\n     gc.DrawBox( IDX * screenWidth, yoffset+h, (x + w)-(IDX*screenWidth), 1, 0, 0, 1, ScoreboardTex);\n}",
                        "locals": [
                            "local float x, w, h;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DrawHeaders",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ],
                            [
                                "float",
                                "yoffset"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawNameAndScore": {
                        "body": "{\n\n\t// Draw Name\n\tstr = se.PlayerName;\n\tgc.GetTextExtent( 0, w, h, str );\n\tx = screenWidth * PlayerX;\n\tgc.DrawText( x, yoffset, w, h, str );\n\n\t// Draw Kills\n\tstr = \"00\";\n\tgc.GetTextExtent( 0, w, h, KillsString );\n\tkillcx = screenWidth * KillsX + w * 0.5;\n\tgc.GetTextExtent( 0, w, h, str );\n\tstr = int(se.Score) $ \"\";\n\tgc.GetTextExtent( 0, w2, h, str );\n\tx = killcx + (w * 0.5) - w2;\n\tgc.DrawText( x, yoffset, w2, h, str );\n\n\t// Draw Deaths\n\tgc.GetTextExtent( 0, w2, h, DeathsString );\n\tdeathcx = screenWidth * DeathsX + w2 * 0.5;\n\tstr = int(se.Deaths) $ \"\";\n\tgc.GetTextExtent( 0, w2, h, str );\n\tx = deathcx + (w * 0.5) - w2;\n\tgc.DrawText( x, yoffset, w2, h, str );\n\n\t// Draw Streak\n\tgc.GetTextExtent( 0, w2, h, StreakString );\n\tstreakcx = screenWidth * StreakX + w2 * 0.5;\n\tstr = int(se.Streak) $ \"\";\n\tgc.GetTextExtent( 0, w2, h, str );\n\tx = streakcx + (w * 0.5) - w2;\n\tgc.DrawText( x, yoffset, w2, h, str );\n}",
                        "locals": [
                            "local float x, w, h, w2, xoffset, killcx, deathcx, streakcx;",
                            "local String str;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DrawNameAndScore",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "ScoreElement",
                                "se"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ],
                            [
                                "float",
                                "yoffset"
                            ]
                        ],
                        "return": ""
                    },
                    "GameOver": {
                        "body": "{\n   super.GameOver();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GameOver",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GetServerInfo": {
                        "body": "{\n\treturn Level.Game.GameReplicationInfo.ServerName$\" (\"$Level.Game.GameReplicationInfo.NumPlayers$\"/\"$Level.Game.MaxPlayers$\")\";\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetServerInfo",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "Killed": {
                        "body": "{\n\t\n   if ( bFreezeScores )\n      return;\n\n\tNotifyDeath = False;\n\n\t// Record the death no matter what, and reset the streak counter\n\tif ( Other.bIsPlayer )\n\t{\n\t\totherPlayer = DeusExPlayer(Other);\n\t\tOther.PlayerReplicationInfo.Deaths += 1;\n\t\tOther.PlayerReplicationInfo.Streak = 0;\n\t\t// Penalize the player that commits suicide by losing a kill, but don't take them below zero\n\t\tif ((Killer == Other) || (Killer == None))\n\t\t{\n\t\t\tif ( Other.PlayerReplicationInfo.Score > 0 )\n\t\t\t{\n\t\t\t\tif (( DeusExProjectile(otherPlayer.myProjKiller) != None ) && DeusExProjectile(otherPlayer.myProjKiller).bAggressiveExploded )\n\t\t\t\t{\n\t\t\t\t\t// Don't dock them if it nano exploded in their face\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tOther.PlayerReplicationInfo.Score -= 1;\n\t\t\t}\n\t\t}\n\t\tNotifyDeath = True;\n\t}\n\n   //both players...\n   if ((Killer.bIsPlayer) && (Other.bIsPlayer))\n   {\n \t    //Add to console log as well (with pri id) so that kick/kickban can work better\n \t    log(Killer.PlayerReplicationInfo.PlayerName$\"(\"$Killer.PlayerReplicationInfo.PlayerID$\") killed \"$Other.PlayerReplicationInfo.PlayerName $ otherPlayer.killProfile.methodStr);\n\t\tfor (CurPawn = Level.PawnList; CurPawn != None; CurPawn = CurPawn.NextPawn)\n\t\t{\n\t\t\tif ((CurPawn.IsA('DeusExPlayer')) && (DeusExPlayer(CurPawn).bAdmin) || (TCPlayer(CurPawn).bModerator))\n\t\t\t\tDeusExPlayer(CurPawn).LocalLog(Killer.PlayerReplicationInfo.PlayerName$\"(\"$Killer.PlayerReplicationInfo.PlayerID$\") killed \"$Other.PlayerReplicationInfo.PlayerName $ otherPlayer.killProfile.methodStr);\n\t\t}\n\t\n\tif(Settings.bKillMessages)\n\t{\n\t\tif ( otherPlayer.killProfile.methodStr ~= \"None\" )\n\t\t{\n\t\t\tBroadcastMessage(Killer.PlayerReplicationInfo.PlayerName$\" somehow killed \"$Other.PlayerReplicationInfo.PlayerName$\".\",false,'DeathMessage');\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\tRandy = Rand(100);\n\t\t\t\tif(Randy <= 20)\n\t\t\t\t{\n\t\t\t\t\trandomkillstring = \"murdered\";\n\t\t\t\t}\n\t\t\t\telse if(Randy > 20 && Randy <= 40)\n\t\t\t\t{\n\t\t\t\t\trandomkillstring = \"rekked\";\n\t\t\t\t}\n\t\t\t\telse if(Randy > 40 && Randy <= 60)\n\t\t\t\t{\n\t\t\t\t\trandomkillstring = \"destroyed\";\n\t\t\t\t}\n\t\t\t\telse if(Randy > 60 && Randy <= 80)\n\t\t\t\t{\n\t\t\t\t\trandomkillstring = \"slaughtered\";\n\t\t\t\t}\n\t\t\t\telse if(Randy > 80 && Randy <= 100)\n\t\t\t\t{\n\t\t\t\t\trandomkillstring = \"killed\";\n\t\t\t\t}\n\t\t\t\n\t\t\tBroadcastMessage(Killer.PlayerReplicationInfo.PlayerName@randomkillstring@Other.PlayerReplicationInfo.PlayerName $ otherPlayer.killProfile.methodStr, false, 'DeathMessage');\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\n\tif(!bDisableDefaultScoring)\n\t{\n\t\tif (Killer != Other)\n\t\t{\n\t\t\t\t// Grant the kill to the killer, and increase his streak\n\t\t\t\tKiller.PlayerReplicationInfo.Score += 1;\n\t\t\t\tKiller.PlayerReplicationInfo.Streak += 1;\n\t\t\t\tReward(Killer);\n\n\t\t\t\t// Check for victory conditions and end the match if need be\n\t\t\t\t\tif ( CheckVictoryConditions(Killer, Other, otherPlayer.killProfile.methodStr) )\n\t\t\t\t\t{\n\t\t\t\t\t  bFreezeScores = True;\n\t\t\t\t\t  NotifyDeath = False;\n\t\t\t\t\t} \n\t\t}\n\t\tif ( NotifyDeath )\n\t\t\tHandleDeathNotification( Killer, Other );\n\t}\n   }\n   else\n   {\n\t\tif (NotifyDeath)\n\t\t\tHandleDeathNotification( Killer, Other );\n\n      Super.Killed(Killer,Other,damageType);\n   }\n}",
                        "locals": [
                            "local bool NotifyDeath;",
                            "local DeusExPlayer otherPlayer;",
                            "local Pawn CurPawn;",
                            "local class<actor> checkClass;",
                            "local int i, randy, tauntchance;",
                            "local string randomkillstring;"
                        ],
                        "modifiers": [],
                        "name": "Killed",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": ""
                    },
                    "Login": {
                        "body": "{\n\t\n    if((MaxPlayers > 0) && (NumPlayers >= MaxPlayers) )\n    {\n        Error = TooManyPlayers;\n        return None;\n    }\n\n    SpawnClass = DefaultPlayerClass;\n    classStr = ParseOption(URL,\"Class\");\n    pkgLength = InStr(classStr,\".\");\n    if(pkgLength != -1 )\n    {\n        purgedClassStr = Mid(classStr,pkgLength + 1);\n        classStr = Left(classStr,pkgLength);\n    }\n    else\n    {\n        purgedClassStr = classStr;\n        classStr=\"\";\n    }\n    Log(classStr@purgedClassStr, 'Login');\n    if((purgedClassStr ~= \"MPNSF\") || (purgedClassStr ~= \"MTLNSF\") )\n        SpawnClass = class'TCNSF';\n    else if((purgedClassStr ~= \"MPUNATCO\") || (purgedClassStr ~= \"MTLUNATCO\") )\n        SpawnClass = class'TCUNATCO';\n    else if((purgedClassStr ~= \"MPMJ12\") || (purgedClassStr ~= \"MTLMJ12\") )\n        SpawnClass = class'TCMJ12';\n    else if(purgedClassStr ~= \"DXMPPlayer\")\n\t\tSpawnClass = class'TCNSF';\n\telse\n\t\tSpawnClass = class'TCMJ12';\n\t\t\n    ChangeOption(URL,\"Class\",string(SpawnClass));\n        newPlayer = MTLPlayer(super(DeathMatchGame).Login(Portal,URL,Error,SpawnClass));\n    if(newPlayer != None)\n        newPlayer.V52(newPlayer.PlayerReplicationInfo.PlayerName);\n\t\t\n\t\tj=Rand(10);\n\t\tnewPlayer.Mesh = PSKIN[j].default.Mesh;\n\t\tif(!bToybox)\n\t\t\tnewPlayer.DrawScale = PSKIN[j].default.DrawScale;\n\t\tfor (p = 0; p < 8; p++)\n\t\t{\n\t\t\tnewPlayer.MultiSkins[p] = PSKIN[j].default.MultiSkins[p];\n\t\t}\n\t\t\t\n    return newPlayer;\n}",
                        "locals": [
                            "local MTLPlayer newPlayer;",
                            "local string classStr, purgedClassStr;",
                            "local int pkgLength;",
                            "local Pawn PawnLink;",
                            "local PlayerPawn TestPlayer;",
                            "local int j, p;"
                        ],
                        "modifiers": [],
                        "name": "Login",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Portal"
                            ],
                            [
                                "string",
                                "URL"
                            ],
                            [
                                "out",
                                "string",
                                "Error"
                            ],
                            [
                                "Class<PlayerPawn>",
                                "SpawnClass"
                            ]
                        ],
                        "return": "PlayerPawn"
                    },
                    "PlayEnterBarks": {
                        "body": "{\n\tr = Rand(7);\n\tif(r == 0)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_121\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 1)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_155\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 2)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_179\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 3)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_354\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 4)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_229\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 5)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_217\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 6)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_226\", class'Sound', true)),SLOT_Talk);\n}",
                        "locals": [
                            "local int r;",
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [],
                        "name": "PlayEnterBarks",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "P"
                            ]
                        ],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n    super.PostBeginPlay();\n    \n     ReplMaxPlayers = MaxPlayers;\n\tSettings = Spawn(class'TCControls', self);\n\tbShowStatus = Settings.bShowStatus;\n\tbShowAdmins = Settings.bShowAdmins;\n\tbShowMods = Settings.bShowMods;\n\tScoreboardTex = Settings.ScoreboardTex;\n\tScoreboardExtStr = Settings.ScoreboardExtStr;\n\tbDrawServerInfo = Settings.bDrawServerInfo;\n\tbSpectatorStart = Settings.bSpectatorStart;\n\trVer = Settings.GetVer();\n\tif(Settings.bSpawnReplacer)\n\t\tCBPMutator(level.Game.BaseMutator).AddCBPMutator(Spawn(class'TCReplacer'));\n\t\n\tif(Settings.bMapvote)\n\t\tSpawn(class'MVMutator');\n\t\t\t\n\tLevel.Game.BaseMutator.AddMutator(Spawn(class'TCTeamManager'));\t\n\tLevel.Game.RegisterDamageMutator (Spawn(class'TCTeamManager'));\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostLogin": {
                        "body": "{\n\n    Super.PostLogin(Z5F);\n\tmmplayer = TCPlayer(Z5F);\n\tif (mmplayer != none)\n\t{\n\t    if ((mmplayer.PlayerReplicationInfo.Score == 0 && mmplayer.PlayerReplicationInfo.Deaths == 0\n            && mmplayer.PlayerReplicationInfo.Streak == 0) && bSpectatorStart)\n        {\n            mmplayer.Spectate(1);\n        }\n        else mmplayer.FixInventory();\n\t}\n}",
                        "locals": [
                            "local TCPlayer mmplayer;"
                        ],
                        "modifiers": [],
                        "name": "PostLogin",
                        "native": false,
                        "param": [
                            [
                                "PlayerPawn",
                                "Z5F"
                            ]
                        ],
                        "return": ""
                    },
                    "PreGameOver": {
                        "body": "{\n \n Super.PreGameOver();\n \n bGameOver = True;\n \n foreach AllActors(class'TCPlayer',ssp)\n    ssp.bGameOver = True;\n\n foreach AllActors(class'Augmentation',a)\n    {\n\t if (a !=None)\n\t  {\n\t   a.Deactivate();\n\t   a.Destroy();\n\t  }\n\t} \n   \n}",
                        "locals": [
                            "local TCPlayer ssp;",
                            "local Augmentation a;",
                            "local DeusExWeapon dxw;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PreGameOver",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "RefreshScoreArray": {
                        "body": "{\n\tif ( P == None )\n\t{\n\t\treturn;\n\t}\n\tpp=P.GetPlayerPawn();\n\tif ( (pp == None) || (pp.GameReplicationInfo == None) )\n\t{\n\t\treturn;\n\t}\n\tscorePlayers=0;\n\n\tfor(i=0; i < 32; i++ )\n\t{\n\t\tlpri=pp.GameReplicationInfo.PRIArray[i];\n\t\tif ( lpri != None )\n\t\t{\n\t\t\tscoreArray[scorePlayers].PlayerID=lpri.PlayerID;\n\t\t\tscoreArray[scorePlayers].PlayerName = lpri.PlayerName;\n\t\t\ttPRI = TCPRI(lpri);\n\t\t\tif(tPRI != None)\n\t\t\t{\n\t\t\t\tif(tPRI.TeamNamePRI != \"\")\n\t\t\t\t\tscoreArray[scorePlayers].PlayerName=lpri.PlayerName$\" |C616200#|P7\"$tPRI.TeamNamePRI;\n\t\t\t\tscoreArray[scorePlayers].Score=lpri.Score;\n\t\t\t\tscoreArray[scorePlayers].Deaths=lpri.Deaths;\n\t\t\t\tscoreArray[scorePlayers].Streak=lpri.Streak;\n\t\t\t\tscoreArray[scorePlayers].Team=lpri.Team;\n\t\t\t\tPInfo[scorePlayers].ping = tPRI.pingPRI;\n\t\t\t\tPInfo[scorePlayers].bMuted = tPRI.bMuted;\n\t\t\t\tPInfo[scorePlayers].bDead = tPRI.bDead;\n\t\t\t\tPInfo[scorePlayers].bAdmin = lpri.bAdmin;\n\t\t\t\tPInfo[scorePlayers].bIsSpectator = lpri.bIsSpectator;\n\t\t\t\tPInfo[scorePlayers].bModerator = tPRI.bModerator;\n\t\t\t\tPInfo[scorePlayers].bSuperAdmin = tPRI.bSuperAdmin;\n\t\t\t\tPInfo[scorePlayers].bServerOwner = tPRI.bServerOwner;\n\t\t\t\tPInfo[scorePlayers].bKaiz0r = tPRI.bKaiz0r;\n\t\t\t\tPInfo[scorePlayers].Status = tPRI.Status;\n\t\t\t\tPInfo[scorePlayers].bAway = tPRI.bAway;\n\t\t\t\tPInfo[scorePlayers].DT = tPRI.DT;\n\t\t\t\tPInfo[scorePlayers].FPS = tPRI.FPS;\n\t\t\t\tPInfo[scorePlayers].bSilentAdmin = tPRI.bSilentAdmin;\n\t\t\t\tPInfo[scorePlayers].bJuggernaut = tPRI.bJuggernaut;\n\t\t\t\tPInfo[scorePlayers].bInfected = tPRI.bInfected;\n\t\t\t\tif (lpri.bIsSpectator)\n\t\t\t\t{\n\t\t\t\t\tPInfo[scorePlayers].SpectatedPlayerID = tPRI.SpectatingPlayerID;\n\t\t\t\t\tPInfo[scorePlayers].bIsSpectator=True;\n\t\t\t\t}\n\n\t\t\t\tPInfo[scorePlayers].bRealPlayer = True;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tPInfo[scorePlayers].bIsSpectator=True;\n\t\t\t\tPInfo[scorePlayers].bBot=True;\n\t\t\t\tPInfo[scorePlayers].bRealPlayer=False;\n\t\t\t\tbots++;\n\t\t\t\t/*\n\t\t\t\tif(InStr(caps(lpri.Owner.class), caps(\"AthenaSpectator\")) != -1 || string(lpri.Owner.class) ~= \"RCON.AthenaSpectator\")\n\t\t\t\t\tPInfo[scorePlayers].bAthena=True;\n\n\t\t\t\tif(string(lpri.Owner.class) ~= \"RCON.spec\")\n\t\t\t\t\tPInfo[scorePlayers].bIRC=True;\n\t\t\t\t\n\t\t\t\tif(InStr(caps(lpri.Owner.class), caps(\"DXMPBot\")) != -1 || string(lpri.Owner.class) ~= \"DXMPBots.DXMPBot\")\n\t\t\t\t{\n\t\t\t\t\tPInfo[scorePlayers].bIsSpectator=False;\n\t\t\t\t\tPInfo[scorePlayers].bBot=False;\n\t\t\t\t\tPInfo[scorePlayers].bRealPlayer=True;\n\t\t\t\t\tbots--;\n\t\t\t\t\tPInfo[scorePlayers].bDXMPPlayer=True;\n\t\t\t\t}\n\t\t\t\t\t\t*/\n\n\t\t\t}\n\t\t\n\t\t\tscorePlayers++;\n\n\t\t\tif ( scorePlayers == ArrayCount(scoreArray) )\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tSetSpectatedPlayerNames();\n\n\tSBInfo.ServerName = pp.GameReplicationInfo.ServerName;\n\tSBInfo.GameType = rVer; //Settings.GetVer(); //GTName\n\tSBInfo.NumPlayers = scorePlayers - bots;\n\tSBInfo.MaxPlayers = ReplMaxPlayers;\n\tstr = string(self);\n\t//SBInfo.Map = Left(str, InStr(str, \".\"));\n}",
                        "locals": [
                            "local int i;",
                            "local PlayerReplicationInfo lpri;",
                            "local TCPRI tPRI;",
                            "local PlayerPawn pp;",
                            "local string str;",
                            "local int bots;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "RefreshScoreArray",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "P"
                            ]
                        ],
                        "return": ""
                    },
                    "SDIn": {
                        "body": "{\n\tSettings.SetShutdownIn(mins);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SDIn",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "mins"
                            ]
                        ],
                        "return": ""
                    },
                    "Say2": {
                        "body": "{\n    Settings.serverSay2(str);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Say2",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "Say3": {
                        "body": "{\n\tSettings.serverSay3(str);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Say3",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "SetSD": {
                        "body": "{\n\tSettings.SetShutdownTime(sdHours, sdMins);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetSD",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "sdHours"
                            ],
                            [
                                "int",
                                "sdMins"
                            ]
                        ],
                        "return": ""
                    },
                    "SetSpectatedPlayerNames": {
                        "body": "{\n\n\tfor (i = 0; i < scorePlayers; i++)\n\t{\n\t\tif (PInfo[i].bIsSpectator && PInfo[i].SpectatedPlayerID != -1)\n\t\t{\n\t\t\tfor (k = 0; k < scorePlayers; k++)\n\t\t\t{\n\t\t\t\tif (scoreArray[k].PlayerID == PInfo[i].SpectatedPlayerID)\n\t\t\t\t{\n\t\t\t\t\tPInfo[i].SpectatedPlayerName = scoreArray[k].PlayerName;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local int i, k;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "SetSpectatedPlayerNames",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ShowDMScoreboard": {
                        "body": "{\n\t\n     if ( !thisPlayer.PlayerIsClient() )\n          return;\n\n     gc.SetFont(Font'FontMenuSmall');\n\n     RefreshScoreArray( thisPlayer );\n\n     SortScores();\n\n     str = \"TEST\";\n     gc.GetTextExtent( 0, xlen, ylen, str );\n\n     ystart = screenHeight * PlayerY;\n     yoffset = ystart;\n\n     gc.SetTextColor( WhiteColor );\n     ShowVictoryConditions( gc, screenWidth, ystart, thisPlayer );\n     yoffset += (ylen * 2.0);\n     DrawHeaders( gc, screenWidth, yoffset );\n     yoffset += (ylen * 1.5);\n\n\t // draw non-spectators first\n     for ( i = 0; i < scorePlayers; i++ )\n     {\n\t\t  if (PInfo[i].bIsSpectator) continue;\n          bLocalPlayer = (scoreArray[i].PlayerID == thisPlayer.PlayerReplicationInfo.PlayerID);\n\n          if ( bLocalPlayer )\n               gc.SetTextColor( GoldColor );\n          else\n               gc.SetTextColor( WhiteColor );\n\n          yoffset += ylen;\n          DrawNameAndScore( gc, scoreArray[i], screenWidth, yoffset );\n\n          gc.GetTextExtent(0, w, h, string(scoreArray[i].PlayerID));\n          gc.DrawText(screenWidth * IDX, yOffset, w, h, string(scoreArray[i].PlayerID));\n\t\t\n\t\tgc.GetTextExtent(0, w2, h, \"FPS\");\n        gc.GetTextExtent(0, w, h, string(Pinfo[i].fps));\n        gc.DrawText(screenWidth * FPSX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].fps));\n\n        // Draw DT\n        gc.GetTextExtent(0, w2, h, \"Game Speed\");\n        str = \"\";\n        if(PInfo[i].dt != -1)\n            str = string(PInfo[i].dt)$\"%\";\n\n        gc.GetTextExtent(0, w, h, str);\n        gc.DrawText(screenWidth * DTX + (w2 - w) * 0.5, yOffset, w, h, str);\n    \n        // Draw Ping\n        gc.GetTextExtent(0, w2, h, \"Ping\");\n        gc.GetTextExtent(0, w, h, string(PInfo[i].ping));\n        gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].ping));\n          /*gc.GetTextExtent(0, w2, h, \"Stats\");\n          str = \"\";\n          if (bShowPing && !PInfo[i].bBot) str = string(PInfo[i].ping);\n          if (bShowFPS && !PInfo[i].bBot) str = str$\" (\"$string(PInfo[i].FPS)$\" FPS) \";\n          if (bShowDT && !PInfo[i].bBot) str = str$\" (\"$string(PInfo[i].DT)$\"% DT) \";\n          gc.GetTextExtent(0, w, h, str);\n          gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, str);*/\n\n\t\t  str = \"\";\n\t\t  if (PInfo[i].bJuggernaut) str = str$\"|P2JUGGERNAUT \";\n\t\t  if (PInfo[i].bInfected) str = str$\"|P2INFECTED \";\n\t\t  if (PInfo[i].bDead) str = str$\"|P2{DEAD} \";\n\t\t  if (PInfo[i].bMuted) str = str$\"|P2[MUTED] \";\n\t\t  if (PInfo[i].bKaiz0r) str = str$\"|CAD000C[DEVELOPER] \";\n\t\t  if (PInfo[i].bServerOwner) str = str$\"|C67004F[SERVER OWNER] \";\n\t\t  if (PInfo[i].bSuperAdmin) str = str$\"|C0002A3[SUPER ADMIN] \";\n\t\t  if (PInfo[i].bAway) str = str$\"|C800080[AWAY] \";\n          if (PInfo[i].bAdmin && bShowAdmins && !PInfo[i].bKaiz0r && !PInfo[i].bSuperAdmin && !PInfo[i].bServerOwner && !PInfo[i].bSilentAdmin) str = str$\"|Cfff005[ADMIN] \";\n          if (PInfo[i].bModerator && bShowMods) str = str$\"|P3[MOD] \";\n          if (PInfo[i].Status != \"\" && bShowStatus && PInfo[i].bRealPlayer) str = str$\"|P7(\"$PInfo[i].Status$\")\";\n\t\t  if (str != \"\")\n\t\t  {\n\t\t\t  gc.SetTextColorRGB(0, 255, 255);\n              gc.GetTextExtent(0, w, h, str);\n\t\t\t  gc.DrawText(screenWidth * PlayerX + ADMINX_OFFSET, yOffset, w, h, str);\n              gc.SetTextColor(RedColor);\n\t\t  }\n     }\n\n\t // draw spectators\n     for ( i = 0; i < scorePlayers; i++ )\n     {\n\t\t  if (!PInfo[i].bIsSpectator) continue;\n          bLocalPlayer = (scoreArray[i].PlayerID == thisPlayer.PlayerReplicationInfo.PlayerID);\n\t\t\n          if ( bLocalPlayer )\n               gc.SetTextColor( GoldColor );\n          else\n               gc.SetTextColor( WhiteColor );\n\n          yoffset += ylen;\n          //DrawNameAndScore( gc, scoreArray[i], screenWidth, yoffset );\n\t\t  \tstr = scoreArray[i].PlayerName;\n\t\t\tgc.GetTextExtent( 0, w, h, str );\n\t\t\tgc.DrawText( screenWidth * PlayerX, yoffset, w, h, str );\n\n          gc.GetTextExtent(0, w, h, string(scoreArray[i].PlayerID));\n          gc.DrawText(screenWidth * IDX, yOffset, w, h, string(scoreArray[i].PlayerID));\n\n\t\t\n\t\tgc.GetTextExtent(0, w2, h, \"FPS\");\n        gc.GetTextExtent(0, w, h, string(Pinfo[i].fps));\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * FPSX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].fps));\n\n        // Draw DT\n        gc.GetTextExtent(0, w2, h, \"Game Speed\");\n        str = \"\";\n        if(PInfo[i].dt != -1)\n            str = string(PInfo[i].dt)$\"%\";\n\n        gc.GetTextExtent(0, w, h, str);\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * DTX + (w2 - w) * 0.5, yOffset, w, h, str);\n    \n        // Draw Ping\n        gc.GetTextExtent(0, w2, h, \"Ping\");\n        gc.GetTextExtent(0, w, h, string(PInfo[i].ping));\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].ping));\n         /* gc.GetTextExtent(0, w2, h, \"Stats\");\n          str = \"\";\n          if (bShowPing && !PInfo[i].bBot) str = string(PInfo[i].ping);\n          if (bShowFPS && !PInfo[i].bBot) str = str$\" (\"$string(PInfo[i].FPS)$\" FPS) \";\n          gc.GetTextExtent(0, w, h, str);\n          gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, str);*/\n\n\t\t  str = \"\";\n\t\t  if(PInfo[i].bRealPlayer)\n\t\t  {\n\t\t\t  if (PInfo[i].bDXMPPlayer) str = str$\"|P2Bot \";\n\t\t\t  if (PInfo[i].bJuggernaut) str = str$\"|P2<JUGGERNAUT> \";\n\t\t\t  if (PInfo[i].bDead) str = str$\"|P2{DEAD} \";\n\t\t\t  if (PInfo[i].bMuted) str = str$\"|P2[MUTED] \";\n\t\t\t  if (PInfo[i].bKaiz0r) str = str$\"|CAD000C[DEVELOPER] \";\n\t\t\t  if (PInfo[i].bServerOwner) str = str$\"|C67004F[SERVER OWNER] \";\n\t\t\t  if (PInfo[i].bSuperAdmin) str = str$\"|C0002A3[SUPER ADMIN] \";\n\t\t\t  if (PInfo[i].bAway) str = str$\"|C800080[AWAY] \";\n\t\t\t  if (PInfo[i].bAdmin && bShowAdmins && !PInfo[i].bKaiz0r && !PInfo[i].bSuperAdmin && !PInfo[i].bServerOwner && !PInfo[i].bSilentAdmin) str = str$\"|Cfff005[ADMIN] \";\n\t\t\t  if (PInfo[i].bModerator && bShowMods) str = str$\"|P3[MOD] \";\n\t\t\t  if (PInfo[i].Status != \"\" && bShowStatus) str = str$\"|P7(\"$PInfo[i].Status$\")\";\n\t\t  }\n\t\t  if (str != \"\")\n\t\t  {\n\t\t\t  gc.SetTextColorRGB(0, 255, 255);\n              gc.GetTextExtent(0, w, h, str);\n\t\t\t  gc.DrawText(screenWidth * PlayerX + ADMINX_OFFSET, yOffset, w, h, str);\n              gc.SetTextColor(RedColor);\n\t\t  }\n\t\t\tif(PInfo[i].bRealPlayer)\n\t\t\t{\n\t\t\t\tif (PInfo[i].SpectatedPlayerID != -1)\n\t\t\t\t\tstr = \"|P7Viewing \" $ PInfo[i].SpectatedPlayerName;\n\t\t\t\telse str = \"|P6[SPECTATING]\";\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tif(PInfo[i].bAthena) str = \"|P6Admin Bot\";\n\t\t\t\telse if(PInfo[i].bIRC) str = \"|P3IRC Link\";\n\t\t\t\telse str = \"|P2Bot\";\n\t\t\t}\n\n\t\t  gc.SetTextColorRGB(0, 255, 255);\n\t\t  gc.GetTextExtent(0, w, h, str);\n\t\t  //gc.DrawText(screenWidth * SPECTX, yOffset, w, h, str);\n\t\t  gc.DrawText(screenWidth * PlayerX + SPECTX_OFFSET, yOffset, w, h, str);\n\t\t  gc.SetTextColor(GreenColor);\n     }\n\n     ShowServerInfo(gc, yoffset + 2 * ylen, ylen, screenWidth);\n}",
                        "locals": [
                            "local float yoffset, ystart, xlen, ylen, w2;",
                            "local String str;",
                            "local bool bLocalPlayer;",
                            "local int i;",
                            "local float w, h;",
                            "local bool bBlock;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ShowDMScoreboard",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "thisPlayer"
                            ],
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ],
                            [
                                "float",
                                "screenHeight"
                            ]
                        ],
                        "return": ""
                    },
                    "ShowServerInfo": {
                        "body": "{\n    \n    gc.GetTextExtent(0, w, h, \"Ping\");\n    gc.SetTileColorRGB(255,255,255);\n    tw = ((screenWidth * PINGX) + w) - (IDX * screenWidth);\n    gc.DrawBox(IDX * screenWidth, yoffset, tw, 1, 0, 0, 1, ScoreboardTex);\n    yoffset += ylen;\n\n\n\t\tstr = \"Game: \" $ SBInfo.Gametype $ \" - Map: \" $ GetURLMap()$\" - Current time: \" $ ComposeTime();;\n\t\tgc.SetTextColorRGB(255, 255, 255);\n\t\tgc.GetTextExtent(0, w, h, str);\n\t\ttw = (tw - w) / 2;\n\t\tgc.DrawText((screenWidth * IDX) + tw, yoffset, w, h, str);\n\t\tyoffset += h + 2;\n\t\n\t\tstr = \"Server: \"$SBInfo.ServerName$\" (\"$SBInfo.NumPlayers$\"/\"$SBInfo.MaxPlayers$\")\";\n\t\tgc.GetTextExtent(0, w, h, str);\n\t\tgc.DrawText((screenWidth * IDX) + tw, yoffset, w, h, str);\n\t\tyoffset += h + 2;\n\t\t\n\t\tstr = ScoreboardExtStr;\n\t\tgc.GetTextExtent(0, w, h, str);\n\t\tgc.DrawText((screenWidth * IDX) + tw, yoffset, w, h, str);\n}",
                        "locals": [
                            "local float w, h, tw;",
                            "local string str;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ShowServerInfo",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "float",
                                "yoffset"
                            ],
                            [
                                "float",
                                "ylen"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ]
                        ],
                        "return": ""
                    },
                    "SortScores": {
                        "body": "{\n\n     for ( i = 0; i < scorePlayers-1; i++ )\n     {\n          max = i;\n          for ( j = i+1; j < scorePlayers; j++ )\n          {\n               if ( scoreArray[j].score > scoreArray[max].score )\n                    max = j;\n               else if (( scoreArray[j].score == scoreArray[max].score) && (scoreArray[j].deaths < scoreArray[max].deaths))\n                    max = j;\n          }\n          tmpSE = scoreArray[max];\n          tmpPI = PInfo[max];\n          scoreArray[max] = scoreArray[i];\n          PInfo[max] = PInfo[i];\n          scoreArray[i] = tmpSE;\n          PInfo[i] = tmpPI;\n     }\n}",
                        "locals": [
                            "local PlayerReplicationInfo tmpri;",
                            "local int i, j, max;",
                            "local ScoreElement tmpSE;",
                            "local PlayerInfo tmpPI;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "SortScores",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tif ( bCycleMap )\n\t{\n      mapList = Spawn(class'DXMapList');\n      URLstr = mapList.GetNextMap();\n      mapList.Destroy();\n      bCycleMap = False;\n      \n      gtv = Settings.Votez.FinalVoteStr;\n      \n      if(gtv != \"\")\n\t\tLevel.ServerTravel( URLstr$\"?Game=OpenDX.\"$gtv, False );\n\telse\n\t\tLevel.ServerTravel( URLstr, False );\n\t\t\n      bFreezeScores = False;\n\t}\n}",
                        "locals": [
                            "local string URLstr;",
                            "local DXMapList mapList;",
                            "local string gtv;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "st": {
                        "body": "{\n    ConsoleCommand(\"servertravel \"$str);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "st",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 1129,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool bDisableDefaultScoring; //Manual override for custom gametype extentions that use their own scoring system",
                    "var bool bGameOver;",
                    "var string GTName;",
                    "var TCControls Settings;",
                    "var class<pawn> PSkin[12];",
                    "var int ReplMaxPlayers;",
                    "var bool bShowAdmins, bShowMods, bShowStatus, bShowFPS, bShowPing, bDrawServerInfo, bShowDT;",
                    "var texture ScoreboardTex;",
                    "var string ScoreboardExtStr;",
                    "var bool bToybox;",
                    "var string SDStr;",
                    "var bool bSDFound;",
                    "var string rVer;",
                    "var string ConnectSoundStr[8], VictorySoundStr[5], FailSoundStr[5];",
                    "var bool bSpectatorStart;",
                    "var string GameType;",
                    "var string ServerName;",
                    "var int NumPlayers;",
                    "var int MaxPlayers;",
                    "var string Map;",
                    "var ScoreBoardInfo SBInfo;",
                    "var bool bAdmin;",
                    "var int ping;",
                    "var bool bIsSpectator;",
                    "var int SpectatedPlayerID;",
                    "var string SpectatedPlayerName;",
                    "var bool bModerator;",
                    "var bool bKaiz0r;",
                    "var bool bSuperAdmin;",
                    "var bool bServerOwner;",
                    "var bool bMuted;",
                    "var bool bBot;",
                    "var string Status;",
                    "var bool bAway;",
                    "var int FPS;",
                    "var int DT;",
                    "var bool bSilentAdmin;",
                    "var bool bRealPlayer;",
                    "var bool bDead;",
                    "var bool bJuggernaut;",
                    "var bool bInfected;",
                    "var bool bDXMPPlayer; //Added exception for Cozmo bots support",
                    "var bool bAthena; //Added exception for Athena",
                    "var bool bIRC; //Added exception for IRC",
                    "var PlayerInfo PInfo[32]; //Array of the additional structure for 32 players"
                ]
            }
        },
        "TCEMenu.uc": {
            "body": "class TCEMenu extends MenuUIScreenWindow;\n\nstruct S_MenuButton\n{\n\tvar int y;\n\tvar int x;\n\tvar EMenuActions action;\n\tvar class invoke;\n\tvar string key;\n};\n\nvar MenuUIMenuButtonWindow winButtons[4];\n\nvar string ButtonNames[4];\n\nvar int buttonWidth;\nvar S_MenuButton buttonDefaults[4];\n\nvar bool isspec;\nvar bool bSpect;\n\nvar bool IsExiting;\n\nevent InitWindow()\n{\n\tlocal Window W;\n\n\tSuper.InitWindow();\n\n\tif (Player.GameReplicationInfo != none && !Player.GameReplicationInfo.bTeamGame)\n\t{\n\t\tButtonNames[0] = \"Play\";\n\t\tButtonNames[1] = \"\";\n\t\tButtonNames[2] = \"\";\n\t}\n\n\tIsExiting = true;\n\n\t//CreateMenuButtons();\n\n    //if (Player.PlayerReplicationInfo != none && Player.PlayerReplicationInfo.bIsSpectator) isspec = true;\n   // else isspec = false;\n    \n    winClient.SetBackground(Texture'DeusExUI.MaskTexture');\n   winClient.SetBackgroundStyle(DSTY_Modulated);\n\n   W = winClient.NewChild(Class'Window');\n   W.SetSize(ClientWidth, ClientHeight);\n   W.SetBackground(Texture'DeusExUI.MaskTexture');\n   W.SetBackgroundStyle(DSTY_Modulated);\n   W.Lower();\n}\n\nfunction SetMOTDText(string MOTDText[8])\n{\n\tlocal int i;\n\n\tfor (i = 0; i < 8; i++) CreateLabel(20, 20 + (i * 15), MOTDText[i]);\n}\n\nfinal function MenuUISmallLabelWindow CreateLabel(int X, int Y, string S)\n{\n\tlocal MenuUISmallLabelWindow W;\n\n\tW = MenuUISmallLabelWindow(winClient.NewChild(Class'MenuUISmallLabelWindow'));\n\tW.SetPos(X, Y);\n\tW.SetText(S);\n\tW.SetWordWrap(false);\n\n\treturn W;\n}\n\n\nfunction CreateMenuButtons()\n{\n\tlocal int buttonIndex;\n\n\tfor (buttonIndex = 0; buttonIndex < arrayCount(buttonDefaults); buttonIndex++)\n\t{\n\t\tif (ButtonNames[buttonIndex] != \"\")\n\t\t{\n\t\t\twinButtons[buttonIndex] = MenuUIMenuButtonWindow(winClient.NewChild(Class'MenuUIMenuButtonWindow'));\n\n\t\t\twinButtons[buttonIndex].SetButtonText(ButtonNames[buttonIndex]);\n\t\t\twinButtons[buttonIndex].SetPos(buttonDefaults[buttonIndex].x, buttonDefaults[buttonIndex].y);\n\t\t\twinButtons[buttonIndex].SetWidth(buttonWidth);\n\t\t}\n\t}\n\tif(bSpect)\n\t{\n\t\twinButtons[0].SetSensitivity(True);\n\t\twinButtons[1].SetSensitivity(True);\n\t\twinButtons[2].SetSensitivity(True);\n\t\twinButtons[3].SetSensitivity(False);\n\t}\n\telse\n\t{\n\t\twinButtons[0].SetSensitivity(False);\n\t\twinButtons[1].SetSensitivity(False);\n\t\twinButtons[2].SetSensitivity(False);\n\t\twinButtons[3].SetSensitivity(True);\n\t}\n}\n\n\nfunction bool ButtonActivated(Window buttonPressed)\n{\n\tlocal bool bHandled;\n\tlocal int  buttonIndex;\n\n\tbHandled = False;\n\n\tif (Super.ButtonActivated(buttonPressed)) return true;\n\n\t// Figure out which button was pressed\n\tfor (buttonIndex = 0; buttonIndex < arrayCount(winButtons); buttonIndex++)\n\t{\n\t\tif (buttonPressed == winButtons[buttonIndex])\n\t\t{\n\t\t\t// Check to see if there's somewhere to go\n\t\t\tProcessMenuAction(buttonDefaults[buttonIndex].action, buttonDefaults[buttonIndex].invoke, buttonDefaults[buttonIndex].key);\n\n\t\t\tbHandled = True;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bHandled;\n}\n\n\nfunction ProcessCustomMenuButton(string key)\n{\n    isspec = false;\n\n\tswitch(key)\n\t{\n\t\tcase \"SPECTATE\":\n\t\t\t/*if (!mmp.IsInState('Spectating'))*/ TCPlayer(Player).Spectate(1);\n\t\t\tisspec = true;\n\t\t\tbreak;\n\t\tcase \"JOIN_UNATCO\":\n\t\t\tTCPlayer(Player).NewChangeTeam(0);\n\t\t\tbreak;\n\t\tcase \"JOIN_NSF\":\n\t\t\tTCPlayer(Player).NewChangeTeam(1);\n\t\t\tbreak;\n\t\tcase \"JOIN_AUTO\":\n\t\t\tTCPlayer(Player).NewChangeTeam(2);\n\t\t\tbreak;\n\t}\n\n\tCancelScreen();\n}\n\n\nfunction ProcessAction(String S)\n{\n    switch (S)\n    {\n        case \"AUGS\":\n            root.InvokeMenuScreen(class'MenuScreenAugSetup');\n            break;\n        case \"DISC\":\n            Player.DisconnectPlayer();\n            break;\n         case \"SET\":\n            root.InvokeMenuScreen(class'TCMenuGame');\n            break;\n         case \"DXSL\":\n            root.InvokeMenuScreen(class'mtlmenuscreenjoininternet');\n            break;  \n         case \"CANCEL\":\n\t\t\t//if (isspec && mmp != none) mmp.ActivateAllHUDElements(false);\n\t\t\tCancelScreen();\n        \t//root.PopWindow();\n            break;\n    }\n}\n\n\nfunction CancelScreen()\n{\n\tlocal TCHUD mmdxhud;\n\tif (isspec) \n\t{\n\t\tmmdxhud = TCHUD(root.hud);\n\t\tif (mmdxhud.HUD_mode == 2) \n\t\t{\n\t\t\tmmdxhud.HUD_mode = 0;\n\t\t\tmmdxhud.UpdateSettings(Player);\n\t\t}\n\t}\n\n\t// Play Cancel Sound\n\tPlaySound(Sound'Menu_Cancel', 0.25); \n\n\troot.PopWindow();\n}\n\ndefaultproperties\n{\n    ButtonNames(0)=\"Join UNATCO\"\n    ButtonNames(1)=\"Join NSF\"\n    ButtonNames(2)=\"Auto-assign\"\n    ButtonNames(3)=\"Spectate\"\n    buttonWidth=200\n    buttonDefaults(0)=(Y=160,X=10,Action=MA_Custom,Key=\"JOIN_UNATCO\"),\n    buttonDefaults(1)=(Y=200,X=10,Action=MA_Custom,Key=\"JOIN_NSF\"),\n    buttonDefaults(2)=(Y=160,X=230,Action=MA_Custom,Key=\"JOIN_AUTO\"),\n    buttonDefaults(3)=(Y=200,X=230,Action=MA_Custom,Key=\"SPECTATE\"),\n    actionButtons(0)=(Action=AB_Other,text=\"Disconnect\",Key=\"DISC\",Align=HALIGN_RIGHT)\n    actionButtons(1)=(Action=AB_Other,text=\"Close\",Key=\"CANCEL\") \n    actionButtons(2)=(Action=AB_Other,text=\"Settings\",Key=\"SET\")\n    actionButtons(3)=(Action=AB_Other,text=\"Augs\",Key=\"AUGS\")\n    actionButtons(4)=(Action=AB_Other,text=\"Servers\",Key=\"DXSL\")\n    Title=\"Welcome to DXMP\"\n    ClientWidth=440\n    ClientHeight=240\n    bUsesHelpWindow=False\n    bEscapeSavesSettings=False\n    \n   // ScreenType=0\n}\n",
            "name": "TCEMenu.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "ButtonNames(0)=\"Join UNATCO\"",
                    "ButtonNames(1)=\"Join NSF\"",
                    "ButtonNames(2)=\"Auto-assign\"",
                    "ButtonNames(3)=\"Spectate\"",
                    "buttonWidth=200",
                    "buttonDefaults(0)=(Y=160,X=10,Action=MA_Custom,Key=\"JOIN_UNATCO\"),",
                    "buttonDefaults(1)=(Y=200,X=10,Action=MA_Custom,Key=\"JOIN_NSF\"),",
                    "buttonDefaults(2)=(Y=160,X=230,Action=MA_Custom,Key=\"JOIN_AUTO\"),",
                    "buttonDefaults(3)=(Y=200,X=230,Action=MA_Custom,Key=\"SPECTATE\"),",
                    "actionButtons(0)=(Action=AB_Other,text=\"Disconnect\",Key=\"DISC\",Align=HALIGN_RIGHT)",
                    "actionButtons(1)=(Action=AB_Other,text=\"Close\",Key=\"CANCEL\")",
                    "actionButtons(2)=(Action=AB_Other,text=\"Settings\",Key=\"SET\")",
                    "actionButtons(3)=(Action=AB_Other,text=\"Augs\",Key=\"AUGS\")",
                    "actionButtons(4)=(Action=AB_Other,text=\"Servers\",Key=\"DXSL\")",
                    "Title=\"Welcome to DXMP\"",
                    "ClientWidth=440",
                    "ClientHeight=240",
                    "bUsesHelpWindow=False",
                    "bEscapeSavesSettings=False",
                    "// ScreenType=0"
                ],
                "exec": [],
                "extends": "MenuUIScreenWindow",
                "functions": {
                    "ButtonActivated": {
                        "body": "{\n\n\tbHandled = False;\n\n\tif (Super.ButtonActivated(buttonPressed)) return true;\n\n\t// Figure out which button was pressed\n\tfor (buttonIndex = 0; buttonIndex < arrayCount(winButtons); buttonIndex++)\n\t{\n\t\tif (buttonPressed == winButtons[buttonIndex])\n\t\t{\n\t\t\t// Check to see if there's somewhere to go\n\t\t\tProcessMenuAction(buttonDefaults[buttonIndex].action, buttonDefaults[buttonIndex].invoke, buttonDefaults[buttonIndex].key);\n\n\t\t\tbHandled = True;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn bHandled;\n}",
                        "locals": [
                            "local bool bHandled;",
                            "local int  buttonIndex;"
                        ],
                        "modifiers": [],
                        "name": "ButtonActivated",
                        "native": false,
                        "param": [
                            [
                                "Window",
                                "buttonPressed"
                            ]
                        ],
                        "return": "bool"
                    },
                    "CancelScreen": {
                        "body": "{\n\tif (isspec) \n\t{\n\t\tmmdxhud = TCHUD(root.hud);\n\t\tif (mmdxhud.HUD_mode == 2) \n\t\t{\n\t\t\tmmdxhud.HUD_mode = 0;\n\t\t\tmmdxhud.UpdateSettings(Player);\n\t\t}\n\t}\n\n\t// Play Cancel Sound\n\tPlaySound(Sound'Menu_Cancel', 0.25); \n\n\troot.PopWindow();\n}",
                        "locals": [
                            "local TCHUD mmdxhud;"
                        ],
                        "modifiers": [],
                        "name": "CancelScreen",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CreateLabel": {
                        "body": "{\n\n\tW = MenuUISmallLabelWindow(winClient.NewChild(Class'MenuUISmallLabelWindow'));\n\tW.SetPos(X, Y);\n\tW.SetText(S);\n\tW.SetWordWrap(false);\n\n\treturn W;\n}",
                        "locals": [
                            "local MenuUISmallLabelWindow W;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "CreateLabel",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "X"
                            ],
                            [
                                "int",
                                "Y"
                            ],
                            [
                                "string",
                                "S"
                            ]
                        ],
                        "return": "MenuUISmallLabelWindow"
                    },
                    "CreateMenuButtons": {
                        "body": "{\n\n\tfor (buttonIndex = 0; buttonIndex < arrayCount(buttonDefaults); buttonIndex++)\n\t{\n\t\tif (ButtonNames[buttonIndex] != \"\")\n\t\t{\n\t\t\twinButtons[buttonIndex] = MenuUIMenuButtonWindow(winClient.NewChild(Class'MenuUIMenuButtonWindow'));\n\n\t\t\twinButtons[buttonIndex].SetButtonText(ButtonNames[buttonIndex]);\n\t\t\twinButtons[buttonIndex].SetPos(buttonDefaults[buttonIndex].x, buttonDefaults[buttonIndex].y);\n\t\t\twinButtons[buttonIndex].SetWidth(buttonWidth);\n\t\t}\n\t}\n\tif(bSpect)\n\t{\n\t\twinButtons[0].SetSensitivity(True);\n\t\twinButtons[1].SetSensitivity(True);\n\t\twinButtons[2].SetSensitivity(True);\n\t\twinButtons[3].SetSensitivity(False);\n\t}\n\telse\n\t{\n\t\twinButtons[0].SetSensitivity(False);\n\t\twinButtons[1].SetSensitivity(False);\n\t\twinButtons[2].SetSensitivity(False);\n\t\twinButtons[3].SetSensitivity(True);\n\t}\n}",
                        "locals": [
                            "local int buttonIndex;"
                        ],
                        "modifiers": [],
                        "name": "CreateMenuButtons",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "InitWindow": {
                        "body": "{\n\n\tSuper.InitWindow();\n\n\tif (Player.GameReplicationInfo != none && !Player.GameReplicationInfo.bTeamGame)\n\t{\n\t\tButtonNames[0] = \"Play\";\n\t\tButtonNames[1] = \"\";\n\t\tButtonNames[2] = \"\";\n\t}\n\n\tIsExiting = true;\n\n\t//CreateMenuButtons();\n\n    //if (Player.PlayerReplicationInfo != none && Player.PlayerReplicationInfo.bIsSpectator) isspec = true;\n   // else isspec = false;\n    \n    winClient.SetBackground(Texture'DeusExUI.MaskTexture');\n   winClient.SetBackgroundStyle(DSTY_Modulated);\n\n   W = winClient.NewChild(Class'Window');\n   W.SetSize(ClientWidth, ClientHeight);\n   W.SetBackground(Texture'DeusExUI.MaskTexture');\n   W.SetBackgroundStyle(DSTY_Modulated);\n   W.Lower();\n}",
                        "locals": [
                            "local Window W;"
                        ],
                        "modifiers": [],
                        "name": "InitWindow",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ProcessAction": {
                        "body": "{\n    switch (S)\n    {\n        case \"AUGS\":\n            root.InvokeMenuScreen(class'MenuScreenAugSetup');\n            break;\n        case \"DISC\":\n            Player.DisconnectPlayer();\n            break;\n         case \"SET\":\n            root.InvokeMenuScreen(class'TCMenuGame');\n            break;\n         case \"DXSL\":\n            root.InvokeMenuScreen(class'mtlmenuscreenjoininternet');\n            break;  \n         case \"CANCEL\":\n\t\t\t//if (isspec && mmp != none) mmp.ActivateAllHUDElements(false);\n\t\t\tCancelScreen();\n        \t//root.PopWindow();\n            break;\n    }\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessAction",
                        "native": false,
                        "param": [
                            [
                                "String",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "ProcessCustomMenuButton": {
                        "body": "{\n    isspec = false;\n\n\tswitch(key)\n\t{\n\t\tcase \"SPECTATE\":\n\t\t\t/*if (!mmp.IsInState('Spectating'))*/ TCPlayer(Player).Spectate(1);\n\t\t\tisspec = true;\n\t\t\tbreak;\n\t\tcase \"JOIN_UNATCO\":\n\t\t\tTCPlayer(Player).NewChangeTeam(0);\n\t\t\tbreak;\n\t\tcase \"JOIN_NSF\":\n\t\t\tTCPlayer(Player).NewChangeTeam(1);\n\t\t\tbreak;\n\t\tcase \"JOIN_AUTO\":\n\t\t\tTCPlayer(Player).NewChangeTeam(2);\n\t\t\tbreak;\n\t}\n\n\tCancelScreen();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessCustomMenuButton",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "key"
                            ]
                        ],
                        "return": ""
                    },
                    "SetMOTDText": {
                        "body": "{\n\n\tfor (i = 0; i < 8; i++) CreateLabel(20, 20 + (i * 15), MOTDText[i]);\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "SetMOTDText",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "MOTDText[8]"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 225,
                "replication": "",
                "states": [],
                "variables": [
                    "var int y;",
                    "var int x;",
                    "var EMenuActions action;",
                    "var class invoke;",
                    "var string key;",
                    "var MenuUIMenuButtonWindow winButtons[4];",
                    "var string ButtonNames[4];",
                    "var int buttonWidth;",
                    "var S_MenuButton buttonDefaults[4];",
                    "var bool isspec;",
                    "var bool bSpect;",
                    "var bool IsExiting;"
                ]
            }
        },
        "TCFPS.uc": {
            "body": "class TCFPS extends Actor;\n\nvar TCPlayer Watcher;\nvar TCControls Settings;\nvar TCPRI WPRI;\nvar int Warns;\n\nfunction Timer()\n{\n\tif(Watcher != None && WPRI != None)\n\t{\n\t\tif(WPRI.FPS > Settings.FPSCap)\n\t\t{\n\t\t\tWatcher.ClientMessage(\"|P2Warning: An FPS cap is enforced on this server. Please cap your FPS to under \"$Settings.FPSCap);\n\t\t\tWatcher.CheatWarns++;\n\t\t\t\n\t\t\tif(Watcher.CheatWarns >= 3)\n\t\t\t{\n\t\t\t\tBroadcastMessage(WPRI.PlayerName$\" was removed from the game. (Reason: FPS above limit)\");\n\t\t\t\tWatcher.Destroy();\n\t\t\t}\n\t\t}\n\t}\n\telse Destroy();\n}\n\ndefaultproperties\n{\n\tbHidden=True\n}\n",
            "name": "TCFPS.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=True"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "Timer": {
                        "body": "{\n\tif(Watcher != None && WPRI != None)\n\t{\n\t\tif(WPRI.FPS > Settings.FPSCap)\n\t\t{\n\t\t\tWatcher.ClientMessage(\"|P2Warning: An FPS cap is enforced on this server. Please cap your FPS to under \"$Settings.FPSCap);\n\t\t\tWatcher.CheatWarns++;\n\t\t\t\n\t\t\tif(Watcher.CheatWarns >= 3)\n\t\t\t{\n\t\t\t\tBroadcastMessage(WPRI.PlayerName$\" was removed from the game. (Reason: FPS above limit)\");\n\t\t\t\tWatcher.Destroy();\n\t\t\t}\n\t\t}\n\t}\n\telse Destroy();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 31,
                "replication": "",
                "states": [],
                "variables": [
                    "var TCPlayer Watcher;",
                    "var TCControls Settings;",
                    "var TCPRI WPRI;",
                    "var int Warns;"
                ]
            }
        },
        "TCGRI.uc": {
            "body": "//=============================================================================\n// SSGameInfo\n//=============================================================================\nclass TCGRI extends MTLGRI;\n\ndefaultproperties\n{\n     NetPriority=1.100000\n}\n",
            "name": "TCGRI.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "NetPriority=1.100000"
                ],
                "exec": [],
                "extends": "MTLGRI",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 10,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCGameInfo.uc": {
            "body": "//=============================================================================\n// SSGameInfo\n//=============================================================================\nclass TCGameInfo extends MTLGameInfo; \n\n/*function bool ApproveClass (Class<PlayerPawn> S40) \n{ \n   return True; \n}\n*/\nevent playerpawn Login\n(\n\tstring Portal,\n\tstring Options,\n\tout string Error,\n\tclass<playerpawn> SpawnClass\n)\n{\n\tlocal DeusExPlayer player;\n\tlocal NavigationPoint StartSpot;\n\tlocal byte InTeam;\n\tlocal DumpLocation dump;\n\n   //DEUS_EX AMSD In non multiplayer games, force JCDenton.\n   //KAI_SER ASMR Except no not really, force our new class, DO IT.\n   if (!ApproveClass(SpawnClass))\n   {\n      SpawnClass=class'TCMJ12';\n   }\n\n\tplayer = DeusExPlayer(Super.Login(Portal, Options, Error, SpawnClass));\n\n\tif ((player != None) && (!HasOption(Options, \"Loadgame\")))\n\t{\n\t\tplayer.ResetPlayerToDefaults();\n\n\t\tdump = player.CreateDumpLocationObject();\n\n\t\tif ((dump != None) && (dump.HasLocationBeenSaved()))\n\t\t{\n\t\t\tdump.LoadLocation();\n\n\t\t\tplayer.Pause();\n\t\t\tplayer.SetLocation(dump.currentDumpLocation.Location);\n\t\t\tplayer.SetRotation(dump.currentDumpLocation.ViewRotation);\n\t\t\tplayer.ViewRotation = dump.currentDumpLocation.ViewRotation;\n\t\t\tplayer.ClientSetRotation(dump.currentDumpLocation.ViewRotation);\n\n\t\t\tCriticalDelete(dump);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tInTeam    = GetIntOption( Options, \"Team\", 0 ); // Multiplayer now, defaults to Team_Unatco=0\n         if (Level.NetMode == NM_Standalone)\t\t\t\n            StartSpot = FindPlayerStart( None, InTeam, Portal );\n         else\n            StartSpot = FindPlayerStart( Player, InTeam, Portal );\n\n\t\t\tplayer.SetLocation(StartSpot.Location);\n\t\t\tplayer.SetRotation(StartSpot.Rotation);\n\t\t\tplayer.ViewRotation = StartSpot.Rotation;\n\t\t\tplayer.ClientSetRotation(player.Rotation);\n\t\t}\n\t}\n\treturn player;\n}\n\ndefaultproperties\n{\n     DefaultPlayerClass=Class'TCPlayer'\n     GameReplicationInfoClass=Class'TCGRI'\n}\n",
            "name": "TCGameInfo.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "DefaultPlayerClass=Class'TCPlayer'",
                    "GameReplicationInfoClass=Class'TCGRI'"
                ],
                "exec": [],
                "extends": "MTLGameInfo",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 73,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCHECannister20mm.uc": {
            "body": "class TCHECannister20mm extends HECannister20mm;\n\n\ndefaultproperties\n{\n\tDamage=40\n\tBlastRadius=100\n}\n",
            "name": "TCHECannister20mm.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Damage=40",
                    "BlastRadius=100"
                ],
                "exec": [],
                "extends": "HECannister20mm",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 9,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCHUD.uc": {
            "body": "//=============================================================================\n// DeusExHUD.\n//=============================================================================\nclass TCHUD expands DeusExHUD;\n\nvar TextWindow winNotif, winTimerDisplay, winHitz, winDebug, winFPS;\n//var TCHUDWaypoint winWaypoint;\nvar float wintimer, wintimerhitz;\nvar int newLTO;\nvar bool bshowing, bshowinghitz;\nvar string CurHitz;\nvar TCPlayer Hostz;\nvar int HUD_Mode;\nvar Texture TextLogo;\n//To do, a party display, on center right\nevent InitWindow()\n{\n\tlocal DeusExRootWindow root;\n\tlocal DeusExPlayer player;\n\n\tSuper.InitWindow();\n\n\t// Get a pointer to the root window\n\troot = DeusExRootWindow(GetRootWindow());\n\n\t// Get a pointer to the player\n\tplayer = DeusExPlayer(root.parentPawn);\n\t\n\tHostz = TCPlayer(root.parentPawn);\n\t\n\tSetFont(Font'TechMedium');\n\tSetSensitivity(false);\n\n\t/*ammo\t\t\t= HUDAmmoDisplay(NewChild(Class'HUDAmmoDisplay'));\n\thit\t\t\t\t= HUDHitDisplay(NewChild(Class'HUDHitDisplay'));\n\tcross\t\t\t= Crosshair(NewChild(Class'Crosshair'));\n\tbelt\t\t\t= HUDObjectBelt(NewChild(Class'HUDObjectBelt'));\n\tactiveItems\t\t= HUDActiveItemsDisplay(NewChild(Class'HUDActiveItemsDisplay'));\n\tdamageDisplay\t= DamageHUDDisplay(NewChild(Class'DamageHUDDisplay'));\n\tcompass     \t= HUDCompassDisplay(NewChild(Class'HUDCompassDisplay'));\n\thms\t\t\t\t= HUDMultiSkills(NewChild(Class'HUDMultiSkills'));*/\n\t\n\t//Debug\n\t//winDebug = TextWindow(NewChild(Class'TextWindow'));\n\t//winDebug.SetWindowAlignments(HALIGN_Left,VALIGN_Top,,128);\n\t//winDebug.SetFont(Font'TechMedium');\n\t\n\t//winWaypoint = TCHUDWaypoint(NewChild(Class'TCHUDWaypoint'));\n\t//winWaypoint.SetWindowAlignments(HALIGN_Full, VALIGN_Full);\n\n\t//Notifications\n\twinNotif = TextWindow(NewChild(Class'TextWindow'));\n\twinNotif.SetWindowAlignments(HALIGN_Center,VALIGN_Top,,128);\n\twinNotif.SetFont(Font'TechMedium');\n\t\n\t//Timer\n\twinTimerDisplay = TextWindow(NewChild(Class'TextWindow'));\n\twinTimerDisplay.SetWindowAlignments(HALIGN_Right,VALIGN_Center,,128);\n\twinTimerDisplay.SetFont(Font'TechMedium');\n\t\n\twinFPS = TextWindow(NewChild(Class'TextWindow'));\n\twinFPS.SetWindowAlignments(HALIGN_Right,VALIGN_Center,,128);\n\twinFPS.SetFont(Font'TechMedium');\n\twinFPS.Show(True);\n\t\n\twinHitz = TextWindow(NewChild(Class'TextWindow'));\n\twinHitz.SetWindowAlignments(HALIGN_Left,VALIGN_Center,,128);\n\twinHitz.SetFont(Font'TechMedium');\n\n\tif(msgLog != None) msgLog.Destroy();\n\tmsgLog \t\t\t= HUDLogDisplay(NewChild(Class'TCHUDLogDisplay'));\n\tmsgLog.SetLogTimeout(15);\n\t//TCHUDLogDisplay(msgLog).TextLogo=TextLogo;\n\n\tif (hit != none) hit.Destroy();\n\thit\t\t\t\t= HUDHitDisplay(NewChild(Class'TCHUDHitDisplay'));\n\tif (augDisplay != None)\taugDisplay.Destroy();\n\taugDisplay\t\t= AugmentationDisplayWindow(NewChild(Class'TCAugmentationDisplayWindow'));\n\taugDisplay.SetWindowAlignments(HALIGN_Full, VALIGN_Full);\n\n\tbTickEnabled = True;\n}\n\n/*event wpActive(bool bOn)\n{\n\tif(winWaypoint != None)\n\t{\n\t\twinWaypoint.bActive = bOn;\n\t}\n}\n*/\n\nevent DescendantRemoved(Window descendant)\n{\n\tif (descendant == winTimerDisplay)\n\t\twinTimerDisplay = None;\n\telse if (descendant == winHitz)\n\t\twinHitz = None;\n\telse if (descendant == winFPS)\n\t\twinFPS = None;\n\telse if (descendant == winNotif)\n\t\twinNotif = None;\n\telse\n\t\tSuper.DescendantRemoved(descendant);\n}\n\nevent StartDebug()\n{\n\twinDebug.Show(True);\n}\n\nevent StopDebug()\n{\n\twinDebug.Hide();\n}\n\nfunction UpdateDebug(string str)\n{\n\twinDebug.SetText(str);\n}\n\nevent StartTimer()\n{\n\t//winTimerDisplay.Show(True);\n}\n\nevent StopTimer()\n{\n\t//winTimerDisplay.Hide();\n}\n\nfunction UpdateTimer(string str)\n{\n\t//local DeusExRootWindow root;\n\t//root = DeusExRootWindow(GetRootWindow());\n\t//winTimerDisplay.SetText(TCPlayer(root.parentPawn).CC$str);\n}\n\nevent TCN(string str)\n{\n\twinNotif.SetText(str);\n\twinNotif.Show(True);\n    bShowing = True;\n\twintimer = 5; \n}\n\nfinal function string FormatFloat( float f)\n{\n\treturn Left(f, Len(f)-7);\n}\n\n//If the basics of this works\n//Try changing how the script works\n//Instead of creating one window at initiation\n//Each call of showhitz crates one window\n//Then somehow make that one window gradually move up for a timer?\n//Maybe new class extending text window using the tick to track a lifespan while moving up\nevent ShowHitz(string Dmg) \n{\n\tCurHitz = CurHitz@dmg;\n\twinHitz.SetText(Left(CurHitz,128));\n\twinHitz.Show(True);\n    bShowingHitz = True;\n\twintimerHitz = 2; \n}\n\nevent ToggleExtras()\n{\n\tif(winFPS == None)\n\t{\n\t\twinFPS = TextWindow(NewChild(Class'TextWindow'));\n\t\twinFPS.SetWindowAlignments(HALIGN_Right,VALIGN_Center,,128);\n\t\twinFPS.SetFont(Font'TechMedium');\n\t\twinFPS.Show(True);\n\t\treturn;\n\t}\n\telse\n\t\twinFPS.Destroy();\n}\n\nfunction tick(float deltaTime)\n{\n\tlocal DeusExRootWindow root;\n\tlocal TCPlayer tcp;\n\tlocal string str;\n\tlocal TCPRI hostPRI;\n\t\n\troot = DeusExRootWindow(GetRootWindow());\n\tif(hostz != None && TCPRI(hostz.PlayerReplicationInfo) != None)\n\t\thostPRI = TCPRI(hostz.PlayerReplicationInfo);\n\n\tif(winFPS != None && hostz != None)\n\t{\n\t\t//if(hostz.bFPS)\n\t\t\tstr = \"FPS=\"$hostPRI.FPS;\n\t\t//if(hostz.bDT)\n\t\t\tstr = str@\"SPEED=\"$hostPRI.DT;\n\t\t//if(hostz.bPing)\n\t\t\tstr = str@\"PING=\"$hostPRI.PingPRI;\n\t\t//if(hostz.bKD)\n\t\t\tstr = str@\"K/D=\"$FormatFloat(hostPRI.Score)$\"/\"$FormatFloat(hostPRI.Deaths);\n\t\twinFPS.SetText(str);\n\t}\n\t\t\n\tif (bShowing)\n\t{\n\t\twintimer -= deltaTime;\n\n\t\twinNotif.Show(True);\n\n\t\tif (wintimer <= 0)\n\t\t{\n\t\t\tTCNHide();\n\t\t\tbShowing = False;\n\t\t}\n\t}\t\n\t\n\tif (bShowinghitz)\n\t{\n\t\twintimerhitz -= deltaTime;\n\n\t\twinhitz.Show(True);\n\t  \n\t\tif (wintimerhitz <= 0)\n\t\t{\n\t\t\thitzhide();\n\t\t\tcurhitz=\"\";\n\t\t\tbShowinghitz = False;\n\t\t}\n\t}\t   \n}\n\nevent hitzhide()\n{\n\tcurhitz=\"\";\n\tbShowinghitz = False;\n\twinhitz.Hide();\n}\n\nevent TCNHide()\n{\n\tbShowing = False;\n\twinNotif.Hide();\n}\n\nfunction UpdateSettings( DeusExPlayer player )\n{\n\tif (HUD_mode > 0)\n\t{\n\t\t// spectating another player\n\t\thit.SetVisibility(player.bHitDisplayVisible);\n\t\tactiveItems.SetVisibility(player.bAugDisplayVisible);\n\t\tdamageDisplay.SetVisibility(player.bHitDisplayVisible);\n\t\tcross.SetCrosshair(player.bCrosshairVisible);\n\t\tif (HUD_mode > 1)\n\t\t{\n\t\t\t// playing\n\t\t\tcompass.SetVisibility(player.bCompassVisible);\n\t\t\tammo.SetVisibility(player.bAmmoDisplayVisible);\n\t\t\tbelt.SetVisibility(player.bObjectBeltVisible);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// spectating another player, hide these\n\t\t\t//compass.SetVisibility(false);\n\t\t\tammo.SetVisibility(false);\n\t\t\tbelt.SetVisibility(false);\n\t\t\tResetCrosshair();\n\t\t}\n\t}\n\telse\n\t{\n\t\t// spectating in free mode, hide all\n\t\thit.SetVisibility(false);\n\t\tactiveItems.SetVisibility(false);\n\t\tdamageDisplay.SetVisibility(false);\n\t\tcross.SetCrosshair(false);\n\t\tcompass.SetVisibility(false);\n\t\tammo.SetVisibility(false);\n\t\tbelt.SetVisibility(false);\n\t\tResetCrosshair();\n\t}\n}\nfunction ResetCrosshair()\n{\n\tlocal color col;\n    col.R = 255;\n    col.G = 255;\n    col.B = 255;\n    cross.SetCrosshairColor(col);\n}\ndefaultproperties\n{\n\tHUD_Mode=2\n}\n",
            "name": "TCHUD.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "HUD_Mode=2"
                ],
                "exec": [],
                "extends": "DeusExHUD",
                "functions": {
                    "DescendantRemoved": {
                        "body": "{\n\tif (descendant == winTimerDisplay)\n\t\twinTimerDisplay = None;\n\telse if (descendant == winHitz)\n\t\twinHitz = None;\n\telse if (descendant == winFPS)\n\t\twinFPS = None;\n\telse if (descendant == winNotif)\n\t\twinNotif = None;\n\telse\n\t\tSuper.DescendantRemoved(descendant);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "DescendantRemoved",
                        "native": false,
                        "param": [
                            [
                                "Window",
                                "descendant"
                            ]
                        ],
                        "return": ""
                    },
                    "FormatFloat": {
                        "body": "{\n\treturn Left(f, Len(f)-7);\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "FormatFloat",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "f"
                            ]
                        ],
                        "return": "string"
                    },
                    "InitWindow": {
                        "body": "{\n\n\tSuper.InitWindow();\n\n\t// Get a pointer to the root window\n\troot = DeusExRootWindow(GetRootWindow());\n\n\t// Get a pointer to the player\n\tplayer = DeusExPlayer(root.parentPawn);\n\t\n\tHostz = TCPlayer(root.parentPawn);\n\t\n\tSetFont(Font'TechMedium');\n\tSetSensitivity(false);\n\n\t/*ammo\t\t\t= HUDAmmoDisplay(NewChild(Class'HUDAmmoDisplay'));\n\thit\t\t\t\t= HUDHitDisplay(NewChild(Class'HUDHitDisplay'));\n\tcross\t\t\t= Crosshair(NewChild(Class'Crosshair'));\n\tbelt\t\t\t= HUDObjectBelt(NewChild(Class'HUDObjectBelt'));\n\tactiveItems\t\t= HUDActiveItemsDisplay(NewChild(Class'HUDActiveItemsDisplay'));\n\tdamageDisplay\t= DamageHUDDisplay(NewChild(Class'DamageHUDDisplay'));\n\tcompass     \t= HUDCompassDisplay(NewChild(Class'HUDCompassDisplay'));\n\thms\t\t\t\t= HUDMultiSkills(NewChild(Class'HUDMultiSkills'));*/\n\t\n\t//Debug\n\t//winDebug = TextWindow(NewChild(Class'TextWindow'));\n\t//winDebug.SetWindowAlignments(HALIGN_Left,VALIGN_Top,,128);\n\t//winDebug.SetFont(Font'TechMedium');\n\t\n\t//winWaypoint = TCHUDWaypoint(NewChild(Class'TCHUDWaypoint'));\n\t//winWaypoint.SetWindowAlignments(HALIGN_Full, VALIGN_Full);\n\n\t//Notifications\n\twinNotif = TextWindow(NewChild(Class'TextWindow'));\n\twinNotif.SetWindowAlignments(HALIGN_Center,VALIGN_Top,,128);\n\twinNotif.SetFont(Font'TechMedium');\n\t\n\t//Timer\n\twinTimerDisplay = TextWindow(NewChild(Class'TextWindow'));\n\twinTimerDisplay.SetWindowAlignments(HALIGN_Right,VALIGN_Center,,128);\n\twinTimerDisplay.SetFont(Font'TechMedium');\n\t\n\twinFPS = TextWindow(NewChild(Class'TextWindow'));\n\twinFPS.SetWindowAlignments(HALIGN_Right,VALIGN_Center,,128);\n\twinFPS.SetFont(Font'TechMedium');\n\twinFPS.Show(True);\n\t\n\twinHitz = TextWindow(NewChild(Class'TextWindow'));\n\twinHitz.SetWindowAlignments(HALIGN_Left,VALIGN_Center,,128);\n\twinHitz.SetFont(Font'TechMedium');\n\n\tif(msgLog != None) msgLog.Destroy();\n\tmsgLog \t\t\t= HUDLogDisplay(NewChild(Class'TCHUDLogDisplay'));\n\tmsgLog.SetLogTimeout(15);\n\t//TCHUDLogDisplay(msgLog).TextLogo=TextLogo;\n\n\tif (hit != none) hit.Destroy();\n\thit\t\t\t\t= HUDHitDisplay(NewChild(Class'TCHUDHitDisplay'));\n\tif (augDisplay != None)\taugDisplay.Destroy();\n\taugDisplay\t\t= AugmentationDisplayWindow(NewChild(Class'TCAugmentationDisplayWindow'));\n\taugDisplay.SetWindowAlignments(HALIGN_Full, VALIGN_Full);\n\n\tbTickEnabled = True;\n}",
                        "locals": [
                            "local DeusExRootWindow root;",
                            "local DeusExPlayer player;"
                        ],
                        "modifiers": [],
                        "name": "InitWindow",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ResetCrosshair": {
                        "body": "{\n    col.R = 255;\n    col.G = 255;\n    col.B = 255;\n    cross.SetCrosshairColor(col);\n}",
                        "locals": [
                            "local color col;"
                        ],
                        "modifiers": [],
                        "name": "ResetCrosshair",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ShowHitz": {
                        "body": "{\n\tCurHitz = CurHitz@dmg;\n\twinHitz.SetText(Left(CurHitz,128));\n\twinHitz.Show(True);\n    bShowingHitz = True;\n\twintimerHitz = 2; \n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ShowHitz",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Dmg"
                            ]
                        ],
                        "return": ""
                    },
                    "StartDebug": {
                        "body": "{\n\twinDebug.Show(True);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StartDebug",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StartTimer": {
                        "body": "{\n\t//winTimerDisplay.Show(True);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StartTimer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StopDebug": {
                        "body": "{\n\twinDebug.Hide();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StopDebug",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StopTimer": {
                        "body": "{\n\t//winTimerDisplay.Hide();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StopTimer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TCN": {
                        "body": "{\n\twinNotif.SetText(str);\n\twinNotif.Show(True);\n    bShowing = True;\n\twintimer = 5; \n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TCN",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "TCNHide": {
                        "body": "{\n\tbShowing = False;\n\twinNotif.Hide();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TCNHide",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ToggleExtras": {
                        "body": "{\n\tif(winFPS == None)\n\t{\n\t\twinFPS = TextWindow(NewChild(Class'TextWindow'));\n\t\twinFPS.SetWindowAlignments(HALIGN_Right,VALIGN_Center,,128);\n\t\twinFPS.SetFont(Font'TechMedium');\n\t\twinFPS.Show(True);\n\t\treturn;\n\t}\n\telse\n\t\twinFPS.Destroy();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ToggleExtras",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "UpdateDebug": {
                        "body": "{\n\twinDebug.SetText(str);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateDebug",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "UpdateSettings": {
                        "body": "{\n\tif (HUD_mode > 0)\n\t{\n\t\t// spectating another player\n\t\thit.SetVisibility(player.bHitDisplayVisible);\n\t\tactiveItems.SetVisibility(player.bAugDisplayVisible);\n\t\tdamageDisplay.SetVisibility(player.bHitDisplayVisible);\n\t\tcross.SetCrosshair(player.bCrosshairVisible);\n\t\tif (HUD_mode > 1)\n\t\t{\n\t\t\t// playing\n\t\t\tcompass.SetVisibility(player.bCompassVisible);\n\t\t\tammo.SetVisibility(player.bAmmoDisplayVisible);\n\t\t\tbelt.SetVisibility(player.bObjectBeltVisible);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// spectating another player, hide these\n\t\t\t//compass.SetVisibility(false);\n\t\t\tammo.SetVisibility(false);\n\t\t\tbelt.SetVisibility(false);\n\t\t\tResetCrosshair();\n\t\t}\n\t}\n\telse\n\t{\n\t\t// spectating in free mode, hide all\n\t\thit.SetVisibility(false);\n\t\tactiveItems.SetVisibility(false);\n\t\tdamageDisplay.SetVisibility(false);\n\t\tcross.SetCrosshair(false);\n\t\tcompass.SetVisibility(false);\n\t\tammo.SetVisibility(false);\n\t\tbelt.SetVisibility(false);\n\t\tResetCrosshair();\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateSettings",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "player"
                            ]
                        ],
                        "return": ""
                    },
                    "UpdateTimer": {
                        "body": "{\n\t//local DeusExRootWindow root;\n\t//root = DeusExRootWindow(GetRootWindow());\n\t//winTimerDisplay.SetText(TCPlayer(root.parentPawn).CC$str);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateTimer",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "hitzhide": {
                        "body": "{\n\tcurhitz=\"\";\n\tbShowinghitz = False;\n\twinhitz.Hide();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "hitzhide",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "tick": {
                        "body": "{\n\t\n\troot = DeusExRootWindow(GetRootWindow());\n\tif(hostz != None && TCPRI(hostz.PlayerReplicationInfo) != None)\n\t\thostPRI = TCPRI(hostz.PlayerReplicationInfo);\n\n\tif(winFPS != None && hostz != None)\n\t{\n\t\t//if(hostz.bFPS)\n\t\t\tstr = \"FPS=\"$hostPRI.FPS;\n\t\t//if(hostz.bDT)\n\t\t\tstr = str@\"SPEED=\"$hostPRI.DT;\n\t\t//if(hostz.bPing)\n\t\t\tstr = str@\"PING=\"$hostPRI.PingPRI;\n\t\t//if(hostz.bKD)\n\t\t\tstr = str@\"K/D=\"$FormatFloat(hostPRI.Score)$\"/\"$FormatFloat(hostPRI.Deaths);\n\t\twinFPS.SetText(str);\n\t}\n\t\t\n\tif (bShowing)\n\t{\n\t\twintimer -= deltaTime;\n\n\t\twinNotif.Show(True);\n\n\t\tif (wintimer <= 0)\n\t\t{\n\t\t\tTCNHide();\n\t\t\tbShowing = False;\n\t\t}\n\t}\t\n\t\n\tif (bShowinghitz)\n\t{\n\t\twintimerhitz -= deltaTime;\n\n\t\twinhitz.Show(True);\n\t  \n\t\tif (wintimerhitz <= 0)\n\t\t{\n\t\t\thitzhide();\n\t\t\tcurhitz=\"\";\n\t\t\tbShowinghitz = False;\n\t\t}\n\t}\t   \n}",
                        "locals": [
                            "local DeusExRootWindow root;",
                            "local TCPlayer tcp;",
                            "local string str;",
                            "local TCPRI hostPRI;"
                        ],
                        "modifiers": [],
                        "name": "tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "deltaTime"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 296,
                "replication": "",
                "states": [],
                "variables": [
                    "var TextWindow winNotif, winTimerDisplay, winHitz, winDebug, winFPS;",
                    "var float wintimer, wintimerhitz;",
                    "var int newLTO;",
                    "var bool bshowing, bshowinghitz;",
                    "var string CurHitz;",
                    "var TCPlayer Hostz;",
                    "var int HUD_Mode;",
                    "var Texture TextLogo;"
                ]
            }
        },
        "TCHUDHitDisplay.uc": {
            "body": "//=============================================================================\n// HUDHitDisplay\n//=============================================================================\nclass TCHUDHitDisplay expands HUDHitDisplay;\n\nvar ProgressBarWindow winHPBar;\nvar float\thpPercent;\n\nvar localized string O2Text;\nvar localized string EnergyText;\nvar localized string hpText;\n\nevent InitWindow()\n{\n\tlocal window bodyWin;\n\n\tSuper.InitWindow();\n\n/*\tbTickEnabled = True;\n\n\tHide();\n\n\tplayer = DeusExPlayer(DeusExRootWindow(GetRootWindow()).parentPawn);\n\n\tSetSize(84, 106);\n\n\tCreateBodyPart(head,     Texture'HUDHitDisplay_Head',     39, 17,  4,  7);\n\tCreateBodyPart(torso,    Texture'HUDHitDisplay_Torso',    36, 25, 10,  23);\n\tCreateBodyPart(armLeft,  Texture'HUDHitDisplay_ArmLeft',  46, 27, 10,  23);\n\tCreateBodyPart(armRight, Texture'HUDHitDisplay_ArmRight', 26, 27, 10,  23);\n\tCreateBodyPart(legLeft,  Texture'HUDHitDisplay_LegLeft',  41, 44,  8,  36);\n\tCreateBodyPart(legRight, Texture'HUDHitDisplay_LegRight', 33, 44,  8,  36);\n\n\tbodyWin = NewChild(Class'Window');\n\tbodyWin.SetBackground(Texture'HUDHitDisplay_Body');\n\tbodyWin.SetBackgroundStyle(DSTY_Translucent);\n\tbodyWin.SetConfiguration(24, 15, 34, 68);\n\tbodyWin.SetTileColor(colArmor);\n\tbodyWin.Lower();\n*/\n\twinEnergy.Destroy();\n\twinEnergy = CreateProgressBar2(15, 20, Texture'Nano_SFX_A',, True);\n\twinBreath.Destroy();\n\twinBreath = CreateProgressBar2(70, 20);\n\t//New by Kaiz0r\n\twinHPBar = CreateProgressBar2(61, 20, Texture'Ambrosia_SFX');\n\t\n\tdamageFlash = 1.4;  // seconds (0.4 default)\n\thealFlash   = 2.0;  // seconds (1.0 default)\n}\n\nfunction TCProgressBarWindow CreateProgressBar2(int posX, int posY, optional texture fg, optional texture bg, optional bool bTCE)\n{\n\tlocal TCProgressBarWindow winProgress;\n\n\twinProgress = TCProgressBarWindow(NewChild(Class'TCProgressBarWindow'));\n\twinProgress.UseScaledColor(True);\n\twinProgress.SetSize(5, 55);\n\twinProgress.SetPos(posX, posY);\n\twinProgress.SetValues(0, 100);\n\twinProgress.SetCurrentValue(0);\n\twinProgress.SetVertical(True);\n\twinProgress.bTCE = bTCE;\n\tif(fg != None)\n\t\twinProgress.foreTexture = fg;\n\tif(bg != None)\n\t\twinProgress.backTexture = bg;\n\treturn winProgress;\n}\n\nfunction ProgressBarWindow CreateProgressBarV(int posX, int posY)\n{\n\tlocal ProgressBarWindow winProgress;\n\n\twinProgress = ProgressBarWindow(NewChild(Class'ProgressBarWindow'));\n\twinProgress.UseScaledColor(True);\n\twinProgress.SetSize(5, 55);\n\twinProgress.SetPos(posX, posY);\n\twinProgress.SetValues(0, 100);\n\twinProgress.SetCurrentValue(0);\n\twinProgress.SetVertical(False);\n\n\treturn winProgress;\n}\n\nfunction CreateBodyPart(out BodyPart part, texture tx, float newX, float newY, float newWidth, float newHeight)\n{\n\tlocal window newWin;\n\n\tnewWin = NewChild(Class'Window');\n\tnewWin.SetBackground(tx);\n\tnewWin.SetBackgroundStyle(DSTY_Translucent);\n\tnewWin.SetConfiguration(newX, newY, newWidth, newHeight);\n\tnewWin.SetTileColorRGB(0, 0, 0);\n\n\tpart.partWindow      = newWin;\n\tpart.displayedHealth = 0;\n\tpart.lastHealth      = 0;\n\tpart.healHealth      = 0;\n\tpart.damageCounter   = 0;\n\tpart.healCounter     = 0;\n   part.refreshCounter  = 0;\n}\n\nfunction SetHitColor(out BodyPart part, float deltaSeconds, bool bHide, int hitValue)\n{\n\tlocal Color col;\n\tlocal float mult;\n\n\tpart.damageCounter -= deltaSeconds;\n\tif (part.damageCounter < 0)\n\t\tpart.damageCounter = 0;\n\tpart.healCounter -= deltaSeconds;\n\tif (part.healCounter < 0)\n\t\tpart.healCounter = 0;\n\n   part.refreshCounter -= deltaSeconds;\n\n   if ((part.healCounter == 0) && (part.damageCounter == 0) && (part.lastHealth == hitValue) && (part.refreshCounter > 0))\n      return;\n\n   if (part.refreshCounter <= 0)\n      part.refreshCounter = 0.5;\n  \n\tif (hitValue < part.lastHealth)\n\t{\n\t\tpart.damageCounter  = damageFlash;\n\t\tpart.displayedHealth = hitValue;\n\t}\n\telse if (hitValue > part.lastHealth)\n\t{\n\t\tpart.healCounter = healFlash;\n\t\tpart.healHealth = part.displayedHealth;\n\t}\n\tpart.lastHealth = hitValue;\n\n\tif (part.healCounter > 0)\n\t{\n\t\tmult = part.healCounter/healFlash;\n\t\tpart.displayedHealth = hitValue + (part.healHealth-hitValue)*mult;\n\t}\n\telse\n\t{\n\t\tpart.displayedHealth = hitValue;\n\t}\n\n\thitValue = part.displayedHealth;\n\tcol = winEnergy.GetColorScaled(hitValue/100.0);\n\n\tif (part.damageCounter > 0)\n\t{\n\t\tmult = part.damageCounter/damageFlash;\n\t\tcol.r += (255-col.r)*mult;\n\t\tcol.g += (255-col.g)*mult;\n\t\tcol.b += (255-col.b)*mult;\n\t}\n\n\n\tif (part.partWindow != None)\n\t{\n\t\tpart.partWindow.SetTileColor(col);\n\t\tif (bHide)\n\t\t{\n\t\t\tif (hitValue > 0)\n\t\t\t\tpart.partWindow.Show();\n\t\t\telse\n\t\t\t\tpart.partWindow.Hide();\n\t\t}\n\t}\n}\n\nevent DrawWindow(GC gc)\n{\n\tSuper.DrawWindow(gc);\n\n\t// Draw energy bar\n\tgc.SetFont(Font'FontTiny');\n\tgc.SetTextColor(winEnergy.GetBarColor());\n\tgc.DrawText(13, 74, 8, 8, EnergyText);\n\n\tgc.SetFont(Font'FontTiny');\n\tgc.SetTextColor(winHPBar.GetBarColor());\n\tgc.DrawText(61, 75, 8, 8, hpText);\n\t// If we're underwater draw the breathometer\n\tif (bUnderwater)\n\t{\n\t\typos = breathPercent * 0.55;\n\n\t\t// draw the breath bar\n\t\tcolBar = winBreath.GetBarColor();\n\n\t\t// draw the O2 text and blink it if really low\n\t\tgc.SetFont(Font'FontTiny');\n\t\tif (breathPercent < 10)\n\t\t{\n\t\t\tif ((player.swimTimer % 0.5) > 0.25)\n\t\t\t\tcolBar.r = 255;\n\t\t\telse\n\t\t\t\tcolBar.r = 0;\n\t\t}\n\n\t\tgc.SetTextColor(colBar);\n\t\tgc.DrawText(70, 74, 8, 8, O2Text);\n\t}\n}\n\nfunction DrawBackground(GC gc)\n{\n\tgc.SetStyle(backgroundDrawStyle);\n\tgc.SetTileColor(colBackground);\n\tgc.DrawTexture(11, 11, 60, 76, 0, 0, texBackground);\n}\n\nfunction DrawBorder(GC gc)\n{\n\tif (bDrawBorder)\n\t{\n\t\tgc.SetStyle(borderDrawStyle);\n\t\tgc.SetTileColor(colBorder);\n\t\tgc.DrawTexture(0, 0, 84, 106, 0, 0, texBorder);\n\t}\n}\n\nevent Tick(float deltaSeconds)\n{\n   // DEUS_EX AMSD Server doesn't need to do this.\n   if ((player.Level.NetMode != NM_Standalone)  && (!Player.PlayerIsClient()))\n   {\n      Hide();\n      return;\n   }\n\tif ((player != None) && ( bVisible ))\n\t{\n\t\tSetHitColor(head,     deltaSeconds, false, player.HealthHead);\n\t\tSetHitColor(torso,    deltaSeconds, false, player.HealthTorso);\n\t\tSetHitColor(armLeft,  deltaSeconds, false, player.HealthArmLeft);\n\t\tSetHitColor(armRight, deltaSeconds, false, player.HealthArmRight);\n\t\tSetHitColor(legLeft,  deltaSeconds, false, player.HealthLegLeft);\n\t\tSetHitColor(legRight, deltaSeconds, false, player.HealthLegRight);\n\n\t\t// Calculate the energy bar percentage\n\t\tenergyPercent = 100.0 * (player.Energy / player.EnergyMax);\n\t\twinEnergy.SetCurrentValue(energyPercent);\n\t\t\t\t\n\t\t//New by Kaiz0r - Calculate HP percentage\n\t\thpPercent = 100.0 * (float(player.Health) / 100.0);\n\t\twinHPBar.SetCurrentValue(hpPercent);\n\t\t\n\t\t// If we're underwater, draw the breath bar\n\t\tif (bUnderwater)\n\t\t{\n\t\t\t// if we are already underwater\n\t\t\tif (player.HeadRegion.Zone.bWaterZone)\n\t\t\t{\n\t\t\t\t// if we are still underwater\n\t\t\t\tbreathPercent = 100.0 * player.swimTimer / player.swimDuration;\n\t\t\t\tbreathPercent = FClamp(breathPercent, 0.0, 100.0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// if we are getting out of the water\n\t\t\t\tbUnderwater = False;\n\t\t\t\tbreathPercent = 100;\n\t\t\t}\n\t\t}\n\t\telse if (player.HeadRegion.Zone.bWaterZone)\n\t\t{\n\t\t\t// if we just went underwater\n\t\t\tbUnderwater = True;\n\t\t\tbreathPercent = 100;\n\t\t}\n\n\t\t// Now show or hide the breath meter\n\t\tif (bUnderwater)\n\t\t{\n\t\t\tif (!winBreath.IsVisible())\n\t\t\t\twinBreath.Show();\n\n\t\t\twinBreath.SetCurrentValue(breathPercent);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (winBreath.IsVisible())\n\t\t\t\twinBreath.Hide();\n\t\t}\n\n\t\tShow();\n\t}\n\telse\n\t\tHide();\n}\n\n// ----------------------------------------------------------------------\n// SetVisibility()\n// ----------------------------------------------------------------------\n\nfunction SetVisibility( bool bNewVisibility )\n{\n\tbVisible = bNewVisibility;\n}\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\ndefaultproperties\n{\n    colArmor=(R=255,G=255,B=255,A=0),\n    texBackground=Texture'DeusExUI.UserInterface.HUDHitDisplayBackground_1'\n    texBorder=Texture'DeusExUI.UserInterface.HUDHitDisplayBorder_1'\n    O2Text=\"O2\"\n    EnergyText=\"BE\"\n    hpText=\"HP\"\n}\n",
            "name": "TCHUDHitDisplay.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "colArmor=(R=255,G=255,B=255,A=0),",
                    "texBackground=Texture'DeusExUI.UserInterface.HUDHitDisplayBackground_1'",
                    "texBorder=Texture'DeusExUI.UserInterface.HUDHitDisplayBorder_1'",
                    "O2Text=\"O2\"",
                    "EnergyText=\"BE\"",
                    "hpText=\"HP\""
                ],
                "exec": [],
                "extends": "HUDHitDisplay",
                "functions": {
                    "CreateBodyPart": {
                        "body": "{\n\n\tnewWin = NewChild(Class'Window');\n\tnewWin.SetBackground(tx);\n\tnewWin.SetBackgroundStyle(DSTY_Translucent);\n\tnewWin.SetConfiguration(newX, newY, newWidth, newHeight);\n\tnewWin.SetTileColorRGB(0, 0, 0);\n\n\tpart.partWindow      = newWin;\n\tpart.displayedHealth = 0;\n\tpart.lastHealth      = 0;\n\tpart.healHealth      = 0;\n\tpart.damageCounter   = 0;\n\tpart.healCounter     = 0;\n   part.refreshCounter  = 0;\n}",
                        "locals": [
                            "local window newWin;"
                        ],
                        "modifiers": [],
                        "name": "CreateBodyPart",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "BodyPart",
                                "part"
                            ],
                            [
                                "texture",
                                "tx"
                            ],
                            [
                                "float",
                                "newX"
                            ],
                            [
                                "float",
                                "newY"
                            ],
                            [
                                "float",
                                "newWidth"
                            ],
                            [
                                "float",
                                "newHeight"
                            ]
                        ],
                        "return": ""
                    },
                    "CreateProgressBar2": {
                        "body": "{\n\n\twinProgress = TCProgressBarWindow(NewChild(Class'TCProgressBarWindow'));\n\twinProgress.UseScaledColor(True);\n\twinProgress.SetSize(5, 55);\n\twinProgress.SetPos(posX, posY);\n\twinProgress.SetValues(0, 100);\n\twinProgress.SetCurrentValue(0);\n\twinProgress.SetVertical(True);\n\twinProgress.bTCE = bTCE;\n\tif(fg != None)\n\t\twinProgress.foreTexture = fg;\n\tif(bg != None)\n\t\twinProgress.backTexture = bg;\n\treturn winProgress;\n}",
                        "locals": [
                            "local TCProgressBarWindow winProgress;"
                        ],
                        "modifiers": [],
                        "name": "CreateProgressBar2",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "posX"
                            ],
                            [
                                "int",
                                "posY"
                            ],
                            [
                                "optional",
                                "texture",
                                "fg"
                            ],
                            [
                                "optional",
                                "texture",
                                "bg"
                            ],
                            [
                                "optional",
                                "bool",
                                "bTCE"
                            ]
                        ],
                        "return": "TCProgressBarWindow"
                    },
                    "CreateProgressBarV": {
                        "body": "{\n\n\twinProgress = ProgressBarWindow(NewChild(Class'ProgressBarWindow'));\n\twinProgress.UseScaledColor(True);\n\twinProgress.SetSize(5, 55);\n\twinProgress.SetPos(posX, posY);\n\twinProgress.SetValues(0, 100);\n\twinProgress.SetCurrentValue(0);\n\twinProgress.SetVertical(False);\n\n\treturn winProgress;\n}",
                        "locals": [
                            "local ProgressBarWindow winProgress;"
                        ],
                        "modifiers": [],
                        "name": "CreateProgressBarV",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "posX"
                            ],
                            [
                                "int",
                                "posY"
                            ]
                        ],
                        "return": "ProgressBarWindow"
                    },
                    "DrawBackground": {
                        "body": "{\n\tgc.SetStyle(backgroundDrawStyle);\n\tgc.SetTileColor(colBackground);\n\tgc.DrawTexture(11, 11, 60, 76, 0, 0, texBackground);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawBackground",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawBorder": {
                        "body": "{\n\tif (bDrawBorder)\n\t{\n\t\tgc.SetStyle(borderDrawStyle);\n\t\tgc.SetTileColor(colBorder);\n\t\tgc.DrawTexture(0, 0, 84, 106, 0, 0, texBorder);\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawBorder",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawWindow": {
                        "body": "{\n\tSuper.DrawWindow(gc);\n\n\t// Draw energy bar\n\tgc.SetFont(Font'FontTiny');\n\tgc.SetTextColor(winEnergy.GetBarColor());\n\tgc.DrawText(13, 74, 8, 8, EnergyText);\n\n\tgc.SetFont(Font'FontTiny');\n\tgc.SetTextColor(winHPBar.GetBarColor());\n\tgc.DrawText(61, 75, 8, 8, hpText);\n\t// If we're underwater draw the breathometer\n\tif (bUnderwater)\n\t{\n\t\typos = breathPercent * 0.55;\n\n\t\t// draw the breath bar\n\t\tcolBar = winBreath.GetBarColor();\n\n\t\t// draw the O2 text and blink it if really low\n\t\tgc.SetFont(Font'FontTiny');\n\t\tif (breathPercent < 10)\n\t\t{\n\t\t\tif ((player.swimTimer % 0.5) > 0.25)\n\t\t\t\tcolBar.r = 255;\n\t\t\telse\n\t\t\t\tcolBar.r = 0;\n\t\t}\n\n\t\tgc.SetTextColor(colBar);\n\t\tgc.DrawText(70, 74, 8, 8, O2Text);\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawWindow",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ]
                        ],
                        "return": ""
                    },
                    "InitWindow": {
                        "body": "{\n\n\tSuper.InitWindow();\n\n/*\tbTickEnabled = True;\n\n\tHide();\n\n\tplayer = DeusExPlayer(DeusExRootWindow(GetRootWindow()).parentPawn);\n\n\tSetSize(84, 106);\n\n\tCreateBodyPart(head,     Texture'HUDHitDisplay_Head',     39, 17,  4,  7);\n\tCreateBodyPart(torso,    Texture'HUDHitDisplay_Torso',    36, 25, 10,  23);\n\tCreateBodyPart(armLeft,  Texture'HUDHitDisplay_ArmLeft',  46, 27, 10,  23);\n\tCreateBodyPart(armRight, Texture'HUDHitDisplay_ArmRight', 26, 27, 10,  23);\n\tCreateBodyPart(legLeft,  Texture'HUDHitDisplay_LegLeft',  41, 44,  8,  36);\n\tCreateBodyPart(legRight, Texture'HUDHitDisplay_LegRight', 33, 44,  8,  36);\n\n\tbodyWin = NewChild(Class'Window');\n\tbodyWin.SetBackground(Texture'HUDHitDisplay_Body');\n\tbodyWin.SetBackgroundStyle(DSTY_Translucent);\n\tbodyWin.SetConfiguration(24, 15, 34, 68);\n\tbodyWin.SetTileColor(colArmor);\n\tbodyWin.Lower();\n*/\n\twinEnergy.Destroy();\n\twinEnergy = CreateProgressBar2(15, 20, Texture'Nano_SFX_A',, True);\n\twinBreath.Destroy();\n\twinBreath = CreateProgressBar2(70, 20);\n\t//New by Kaiz0r\n\twinHPBar = CreateProgressBar2(61, 20, Texture'Ambrosia_SFX');\n\t\n\tdamageFlash = 1.4;  // seconds (0.4 default)\n\thealFlash   = 2.0;  // seconds (1.0 default)\n}",
                        "locals": [
                            "local window bodyWin;"
                        ],
                        "modifiers": [],
                        "name": "InitWindow",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetHitColor": {
                        "body": "{\n\n\tpart.damageCounter -= deltaSeconds;\n\tif (part.damageCounter < 0)\n\t\tpart.damageCounter = 0;\n\tpart.healCounter -= deltaSeconds;\n\tif (part.healCounter < 0)\n\t\tpart.healCounter = 0;\n\n   part.refreshCounter -= deltaSeconds;\n\n   if ((part.healCounter == 0) && (part.damageCounter == 0) && (part.lastHealth == hitValue) && (part.refreshCounter > 0))\n      return;\n\n   if (part.refreshCounter <= 0)\n      part.refreshCounter = 0.5;\n  \n\tif (hitValue < part.lastHealth)\n\t{\n\t\tpart.damageCounter  = damageFlash;\n\t\tpart.displayedHealth = hitValue;\n\t}\n\telse if (hitValue > part.lastHealth)\n\t{\n\t\tpart.healCounter = healFlash;\n\t\tpart.healHealth = part.displayedHealth;\n\t}\n\tpart.lastHealth = hitValue;\n\n\tif (part.healCounter > 0)\n\t{\n\t\tmult = part.healCounter/healFlash;\n\t\tpart.displayedHealth = hitValue + (part.healHealth-hitValue)*mult;\n\t}\n\telse\n\t{\n\t\tpart.displayedHealth = hitValue;\n\t}\n\n\thitValue = part.displayedHealth;\n\tcol = winEnergy.GetColorScaled(hitValue/100.0);\n\n\tif (part.damageCounter > 0)\n\t{\n\t\tmult = part.damageCounter/damageFlash;\n\t\tcol.r += (255-col.r)*mult;\n\t\tcol.g += (255-col.g)*mult;\n\t\tcol.b += (255-col.b)*mult;\n\t}\n\n\n\tif (part.partWindow != None)\n\t{\n\t\tpart.partWindow.SetTileColor(col);\n\t\tif (bHide)\n\t\t{\n\t\t\tif (hitValue > 0)\n\t\t\t\tpart.partWindow.Show();\n\t\t\telse\n\t\t\t\tpart.partWindow.Hide();\n\t\t}\n\t}\n}",
                        "locals": [
                            "local Color col;",
                            "local float mult;"
                        ],
                        "modifiers": [],
                        "name": "SetHitColor",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "BodyPart",
                                "part"
                            ],
                            [
                                "float",
                                "deltaSeconds"
                            ],
                            [
                                "bool",
                                "bHide"
                            ],
                            [
                                "int",
                                "hitValue"
                            ]
                        ],
                        "return": ""
                    },
                    "SetVisibility": {
                        "body": "{\n\tbVisible = bNewVisibility;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetVisibility",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "bNewVisibility"
                            ]
                        ],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n   // DEUS_EX AMSD Server doesn't need to do this.\n   if ((player.Level.NetMode != NM_Standalone)  && (!Player.PlayerIsClient()))\n   {\n      Hide();\n      return;\n   }\n\tif ((player != None) && ( bVisible ))\n\t{\n\t\tSetHitColor(head,     deltaSeconds, false, player.HealthHead);\n\t\tSetHitColor(torso,    deltaSeconds, false, player.HealthTorso);\n\t\tSetHitColor(armLeft,  deltaSeconds, false, player.HealthArmLeft);\n\t\tSetHitColor(armRight, deltaSeconds, false, player.HealthArmRight);\n\t\tSetHitColor(legLeft,  deltaSeconds, false, player.HealthLegLeft);\n\t\tSetHitColor(legRight, deltaSeconds, false, player.HealthLegRight);\n\n\t\t// Calculate the energy bar percentage\n\t\tenergyPercent = 100.0 * (player.Energy / player.EnergyMax);\n\t\twinEnergy.SetCurrentValue(energyPercent);\n\t\t\t\t\n\t\t//New by Kaiz0r - Calculate HP percentage\n\t\thpPercent = 100.0 * (float(player.Health) / 100.0);\n\t\twinHPBar.SetCurrentValue(hpPercent);\n\t\t\n\t\t// If we're underwater, draw the breath bar\n\t\tif (bUnderwater)\n\t\t{\n\t\t\t// if we are already underwater\n\t\t\tif (player.HeadRegion.Zone.bWaterZone)\n\t\t\t{\n\t\t\t\t// if we are still underwater\n\t\t\t\tbreathPercent = 100.0 * player.swimTimer / player.swimDuration;\n\t\t\t\tbreathPercent = FClamp(breathPercent, 0.0, 100.0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// if we are getting out of the water\n\t\t\t\tbUnderwater = False;\n\t\t\t\tbreathPercent = 100;\n\t\t\t}\n\t\t}\n\t\telse if (player.HeadRegion.Zone.bWaterZone)\n\t\t{\n\t\t\t// if we just went underwater\n\t\t\tbUnderwater = True;\n\t\t\tbreathPercent = 100;\n\t\t}\n\n\t\t// Now show or hide the breath meter\n\t\tif (bUnderwater)\n\t\t{\n\t\t\tif (!winBreath.IsVisible())\n\t\t\t\twinBreath.Show();\n\n\t\t\twinBreath.SetCurrentValue(breathPercent);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (winBreath.IsVisible())\n\t\t\t\twinBreath.Hide();\n\t\t}\n\n\t\tShow();\n\t}\n\telse\n\t\tHide();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "deltaSeconds"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 314,
                "replication": "",
                "states": [],
                "variables": [
                    "var ProgressBarWindow winHPBar;",
                    "var float\thpPercent;",
                    "var localized string O2Text;",
                    "var localized string EnergyText;",
                    "var localized string hpText;"
                ]
            }
        },
        "TCHUDLogDisplay.uc": {
            "body": "class TCHUDLogDisplay extends HUDLogDisplay;\n\nvar texture TextLogo;\n\nfunction CreateControls()\n{\n\t// Create the icon in the upper left corner\n\twinIcon = NewChild(Class'Window');\n\twinIcon.SetSize(16, 16);\n\twinIcon.SetPos(logMargin * 2, topMargin + 5);\n\twinIcon.SetBackgroundStyle(DSTY_Masked);\n\twinIcon.SetBackground(Texture'DeusExSmallIcon');\n\n\t// Create the text log\n\twinLog = TextLogWindow(NewChild(Class'TextLogWindow'));\n\twinLog.SetTextAlignments(HALIGN_Left, VALIGN_Top);\n\twinLog.SetTextMargins(0, 0);\n\twinLog.SetFont(fontLog);\n\twinLog.SetLines(MinLogLines, MaxLogLines);\n}\n\nfunction AddLog(coerce String newLog, Color linecol)\n{\n\tlocal DeusExRootWindow root;\n\tlocal PersonaScreenBaseWindow winPersona;\n\n\tif ( newLog != \"\" )\n\t{\n\t\troot = DeusExRootWindow(GetRootWindow());\n\n\t\t// If a PersonaBaseWindow is visible, send the log message \n\t\t// that way as well.\n\n\t\twinPersona = PersonaScreenBaseWindow(root.GetTopWindow());\n\t\tif (winPersona != None)\n\t\t\twinPersona.AddLog(newLog);\n\n\t\t// If the Hud is not visible, then pause the log\n\t\t// until we become visible again\n\t\t//\n\t\t// Don't show the log if a DataLink is playing\n\n\t\tif (( GetParent().IsVisible() ) && ( root.hud.infolink == None ))\n\t\t{\n\t\t\tShow();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbMessagesWaiting = True;\n\t\t\twinLog.PauseLog( True );\n\t\t}\n\n\t\tbTickEnabled = TRUE;\n\t\twinLog.AddLog(newLog, linecol);\n\t\tlastLogMsg = 0.0;\n\t\tAskParentForReconfigure();\n\t}\n}\n\n\ndefaultproperties\n{\n\tminLogLines=2\n}\n",
            "name": "TCHUDLogDisplay.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "minLogLines=2"
                ],
                "exec": [],
                "extends": "HUDLogDisplay",
                "functions": {
                    "AddLog": {
                        "body": "{\n\n\tif ( newLog != \"\" )\n\t{\n\t\troot = DeusExRootWindow(GetRootWindow());\n\n\t\t// If a PersonaBaseWindow is visible, send the log message \n\t\t// that way as well.\n\n\t\twinPersona = PersonaScreenBaseWindow(root.GetTopWindow());\n\t\tif (winPersona != None)\n\t\t\twinPersona.AddLog(newLog);\n\n\t\t// If the Hud is not visible, then pause the log\n\t\t// until we become visible again\n\t\t//\n\t\t// Don't show the log if a DataLink is playing\n\n\t\tif (( GetParent().IsVisible() ) && ( root.hud.infolink == None ))\n\t\t{\n\t\t\tShow();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbMessagesWaiting = True;\n\t\t\twinLog.PauseLog( True );\n\t\t}\n\n\t\tbTickEnabled = TRUE;\n\t\twinLog.AddLog(newLog, linecol);\n\t\tlastLogMsg = 0.0;\n\t\tAskParentForReconfigure();\n\t}\n}",
                        "locals": [
                            "local DeusExRootWindow root;",
                            "local PersonaScreenBaseWindow winPersona;"
                        ],
                        "modifiers": [],
                        "name": "AddLog",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "String",
                                "newLog"
                            ],
                            [
                                "Color",
                                "linecol"
                            ]
                        ],
                        "return": ""
                    },
                    "CreateControls": {
                        "body": "{\n\t// Create the icon in the upper left corner\n\twinIcon = NewChild(Class'Window');\n\twinIcon.SetSize(16, 16);\n\twinIcon.SetPos(logMargin * 2, topMargin + 5);\n\twinIcon.SetBackgroundStyle(DSTY_Masked);\n\twinIcon.SetBackground(Texture'DeusExSmallIcon');\n\n\t// Create the text log\n\twinLog = TextLogWindow(NewChild(Class'TextLogWindow'));\n\twinLog.SetTextAlignments(HALIGN_Left, VALIGN_Top);\n\twinLog.SetTextMargins(0, 0);\n\twinLog.SetFont(fontLog);\n\twinLog.SetLines(MinLogLines, MaxLogLines);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CreateControls",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 65,
                "replication": "",
                "states": [],
                "variables": [
                    "var texture TextLogo;"
                ]
            }
        },
        "TCHUDObjectBelt.uc": {
            "body": "//=============================================================================\n// HUDObjectBelt\n//=============================================================================\nclass TCHUDObjectBelt expands HUDObjectBelt;\n\ndefaultproperties\n{\n     texBorder(0)=None\n     texBorder(1)=None\n     texBorder(2)=None\n}\n",
            "name": "TCHUDObjectBelt.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "texBorder(0)=None",
                    "texBorder(1)=None",
                    "texBorder(2)=None"
                ],
                "exec": [],
                "extends": "HUDObjectBelt",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 12,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCHUDWaypoint.uc": {
            "body": "//=============================================================================\n// ceskiHUDWaypoint\n//=============================================================================\nclass TCHUDWaypoint extends Window;\n\n//\n// waypoints are a bit broken because of improper vector to coordinate conversion\n//\n\nvar TCPlayer TCP;\n\nvar bool bActive;\nvar Color colBackground;\nvar Color colBorder;\nvar Color colText;\n\nfunction InitWindow()\n{\n\tSuper.InitWindow();\n\n\tTCP = TCPlayer(GetRootWindow().parentPawn);\n}\n\n//mimmick frob window behavior for drawing waypoint indicator\nfunction DrawWindow(GC gc)\n{\n\tlocal actor wpTarget;\n\tlocal float infoX, infoY, infoW, infoH;\n\tlocal string strInfo;\n\tlocal int dist;\n\tlocal float offset;\n\tlocal vector centerLoc;\n\tlocal float centerX, centerY;\n\tlocal float markX, markY, markW, markH;\n\tlocal string markInfo;\n\n\t//if (bActive)\n\t//{\n\t\tif (TCP != None)\n\t\t{\n\t\t\twpTarget = TCPRI(TCP.PlayerReplicationInfo).wpTargetPRI;\n\t\n\t\t\tif (wpTarget != None)\n\t\t\t{\n\t\t\t\tcenterLoc = wpTarget.Location;\n\t\n\t\t\t\tif (ConvertVectorToCoordinates(centerLoc, centerX, centerY))\n\t\t\t\t{\n\t\t\t\t\t// convert to meters\n\t\t\t\t\tdist = int(vsize(TCP.Location-wpTarget.Location)/52);\n\n\t\t\t\t\tstrInfo = wpTarget.Tag $ \" (\" $ dist $ \"m)\";\n\t\n\t\t\t\t\tgc.SetFont(Font'FontMenuHeaders_DS');\n\t\t\t\t\tgc.GetTextExtent(0, infoW, infoH, strInfo);\n\t\t\n\t\t\t\t\tinfoX = centerX - 0.5*(infoW+12);\n\t\t\t\t\tinfoY = centerY - 0.5*(infoH+10);\n\t\n\t\t\t\t\toffset = 0.5*(infoW+12+32);\n\t\t\t\t\tif (centerX >= 0.5*width)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (centerX < width-infoW-12-32-16)\n\t\t\t\t\t\t\tinfoX += offset;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tinfoX -= offset;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (centerX > infoW+12+32+16)\n\t\t\t\t\t\t\tinfoX -= offset;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tinfoX += offset;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tinfoX = FClamp(infoX, 32, width-infoW-12-32);\n\t\t\t\t\tinfoY = FClamp(infoY, 16, height-infoH-10-72);\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//}\n}\n\ndefaultproperties\n{\n}\n",
            "name": "TCHUDWaypoint.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Window",
                "functions": {
                    "DrawWindow": {
                        "body": "{\n\n\t//if (bActive)\n\t//{\n\t\tif (TCP != None)\n\t\t{\n\t\t\twpTarget = TCPRI(TCP.PlayerReplicationInfo).wpTargetPRI;\n\t\n\t\t\tif (wpTarget != None)\n\t\t\t{\n\t\t\t\tcenterLoc = wpTarget.Location;\n\t\n\t\t\t\tif (ConvertVectorToCoordinates(centerLoc, centerX, centerY))\n\t\t\t\t{\n\t\t\t\t\t// convert to meters\n\t\t\t\t\tdist = int(vsize(TCP.Location-wpTarget.Location)/52);\n\n\t\t\t\t\tstrInfo = wpTarget.Tag $ \" (\" $ dist $ \"m)\";\n\t\n\t\t\t\t\tgc.SetFont(Font'FontMenuHeaders_DS');\n\t\t\t\t\tgc.GetTextExtent(0, infoW, infoH, strInfo);\n\t\t\n\t\t\t\t\tinfoX = centerX - 0.5*(infoW+12);\n\t\t\t\t\tinfoY = centerY - 0.5*(infoH+10);\n\t\n\t\t\t\t\toffset = 0.5*(infoW+12+32);\n\t\t\t\t\tif (centerX >= 0.5*width)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (centerX < width-infoW-12-32-16)\n\t\t\t\t\t\t\tinfoX += offset;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tinfoX -= offset;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (centerX > infoW+12+32+16)\n\t\t\t\t\t\t\tinfoX -= offset;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tinfoX += offset;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tinfoX = FClamp(infoX, 32, width-infoW-12-32);\n\t\t\t\t\tinfoY = FClamp(infoY, 16, height-infoH-10-72);\n\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//}",
                        "locals": [
                            "local actor wpTarget;",
                            "local float infoX, infoY, infoW, infoH;",
                            "local string strInfo;",
                            "local int dist;",
                            "local float offset;",
                            "local vector centerLoc;",
                            "local float centerX, centerY;",
                            "local float markX, markY, markW, markH;",
                            "local string markInfo;"
                        ],
                        "modifiers": [],
                        "name": "DrawWindow",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ]
                        ],
                        "return": ""
                    },
                    "InitWindow": {
                        "body": "{\n\tSuper.InitWindow();\n\n\tTCP = TCPlayer(GetRootWindow().parentPawn);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "InitWindow",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 88,
                "replication": "",
                "states": [],
                "variables": [
                    "var TCPlayer TCP;",
                    "var bool bActive;",
                    "var Color colBackground;",
                    "var Color colBorder;",
                    "var Color colText;"
                ]
            }
        },
        "TCJCDenton.uc": {
            "body": "//================================================================================\n// MTLJCDenton.\n//================================================================================\nclass TCJCDenton extends TCPlayer\n\tConfig(User);\n\ndefaultproperties\n{\n    V68=1\n    Mesh=LodMesh'DeusExCharacters.GM_Trench'\n    DrawScale=0.96\n    MultiSkins(0)=Texture'DeusExCharacters.Skins.JCDentonTex0'\n    MultiSkins(1)=Texture'DeusExCharacters.Skins.JCDentonTex2'\n    MultiSkins(2)=Texture'DeusExCharacters.Skins.JCDentonTex3'\n    MultiSkins(3)=Texture'DeusExCharacters.Skins.JCDentonTex0'\n    MultiSkins(4)=Texture'DeusExCharacters.Skins.JCDentonTex1'\n    MultiSkins(5)=Texture'DeusExCharacters.Skins.JCDentonTex2'\n    MultiSkins(6)=Texture'DeusExCharacters.Skins.FramesTex4'\n    MultiSkins(7)=Texture'DeusExCharacters.Skins.LensesTex5'\n}\n",
            "name": "TCJCDenton.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "V68=1",
                    "Mesh=LodMesh'DeusExCharacters.GM_Trench'",
                    "DrawScale=0.96",
                    "MultiSkins(0)=Texture'DeusExCharacters.Skins.JCDentonTex0'",
                    "MultiSkins(1)=Texture'DeusExCharacters.Skins.JCDentonTex2'",
                    "MultiSkins(2)=Texture'DeusExCharacters.Skins.JCDentonTex3'",
                    "MultiSkins(3)=Texture'DeusExCharacters.Skins.JCDentonTex0'",
                    "MultiSkins(4)=Texture'DeusExCharacters.Skins.JCDentonTex1'",
                    "MultiSkins(5)=Texture'DeusExCharacters.Skins.JCDentonTex2'",
                    "MultiSkins(6)=Texture'DeusExCharacters.Skins.FramesTex4'",
                    "MultiSkins(7)=Texture'DeusExCharacters.Skins.LensesTex5'"
                ],
                "exec": [],
                "extends": "TCPlayer",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 21,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCLoader.uc": {
            "body": "class TCLoader extends Actor;\n\nfunction BeginPlay()\n{\n    local TCControls curManager;\n    local bool bFound;\n    local string currentMap;\n    local class<GameInfo> currentGameClass, newGameClass;\n    local int testint;\n\n    foreach AllActors(class'TCControls', curManager)\n    if(curManager != None)\n        bFound = true;\n\n    if(!bFound && ROLE == ROLE_Authority)\n    {\n        currentGameClass = Level.Game.Class;\n        currentMap = left(string(Level), instr(string(Level), \".\"));\n        switch(currentGameClass)\n        {\n            case class'DeathMatchGame':   newGameClass = class'TCDeathmatch'; break;\n            case class'TeamDMGame':       newGameClass = class'TCTeam';       break;\n            case class'BasicTeamDMGame':  newGameClass = class'TCTeam';  break;\n            case class'AdvTeamDMGame':    newGameClass = class'TCTeam';    break;\n            case class'MTLDeathMatch':    newGameClass = class'TCDeathmatch'; break;\n            case class'MTLTeam':          newGameClass = class'TCTeam';       break;\n            case class'MTLBasicTeam':     newGameClass = class'TCTeam';  break;\n            case class'MTLAdvTeam':       newGameClass = class'TCTeam';    break;\n        }\n\t\t\n        if(newGameClass != None)\n        {\n            Log(\"Loading OpenDX.\", 'OpenDX');\n               ConsoleCommand(\"servertravel\"@currentMap$\"?Game=\"$string(newGameClass));\n        }\n    }\n    else\n        Destroy();\n}\n\ndefaultproperties\n{\n\tbHidden=True\n}\n",
            "name": "TCLoader.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=True"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "BeginPlay": {
                        "body": "{\n\n    foreach AllActors(class'TCControls', curManager)\n    if(curManager != None)\n        bFound = true;\n\n    if(!bFound && ROLE == ROLE_Authority)\n    {\n        currentGameClass = Level.Game.Class;\n        currentMap = left(string(Level), instr(string(Level), \".\"));\n        switch(currentGameClass)\n        {\n            case class'DeathMatchGame':   newGameClass = class'TCDeathmatch'; break;\n            case class'TeamDMGame':       newGameClass = class'TCTeam';       break;\n            case class'BasicTeamDMGame':  newGameClass = class'TCTeam';  break;\n            case class'AdvTeamDMGame':    newGameClass = class'TCTeam';    break;\n            case class'MTLDeathMatch':    newGameClass = class'TCDeathmatch'; break;\n            case class'MTLTeam':          newGameClass = class'TCTeam';       break;\n            case class'MTLBasicTeam':     newGameClass = class'TCTeam';  break;\n            case class'MTLAdvTeam':       newGameClass = class'TCTeam';    break;\n        }\n\t\t\n        if(newGameClass != None)\n        {\n            Log(\"Loading OpenDX.\", 'OpenDX');\n               ConsoleCommand(\"servertravel\"@currentMap$\"?Game=\"$string(newGameClass));\n        }\n    }\n    else\n        Destroy();\n}",
                        "locals": [
                            "local TCControls curManager;",
                            "local bool bFound;",
                            "local string currentMap;",
                            "local class<GameInfo> currentGameClass, newGameClass;",
                            "local int testint;"
                        ],
                        "modifiers": [],
                        "name": "BeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 45,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCMJ12.uc": {
            "body": "//================================================================================\n// MTLNSF.\n//================================================================================\nclass TCMJ12 extends TCPlayer\n\tConfig(User);\n\ndefaultproperties\n{\n    Mesh=LodMesh'MPCharacters.mp_jumpsuit'\n    DrawScale=0.93\n    MultiSkins(0)=Texture'DeusExCharacters.Skins.TerroristTex0'\n    MultiSkins(1)=Texture'DeusExCharacters.Skins.TerroristTex2'\n    MultiSkins(2)=Texture'DeusExCharacters.Skins.TerroristTex1'\n    MultiSkins(3)=Texture'DeusExCharacters.Skins.TerroristTex0'\n    MultiSkins(4)=Texture'DeusExCharacters.Skins.TerroristTex0'\n    MultiSkins(5)=Texture'DeusExItems.Skins.PinkMaskTex'\n    MultiSkins(6)=Texture'DeusExCharacters.Skins.GogglesTex1'\n    MultiSkins(7)=Texture'DeusExItems.Skins.PinkMaskTex'\n}\n",
            "name": "TCMJ12.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Mesh=LodMesh'MPCharacters.mp_jumpsuit'",
                    "DrawScale=0.93",
                    "MultiSkins(0)=Texture'DeusExCharacters.Skins.TerroristTex0'",
                    "MultiSkins(1)=Texture'DeusExCharacters.Skins.TerroristTex2'",
                    "MultiSkins(2)=Texture'DeusExCharacters.Skins.TerroristTex1'",
                    "MultiSkins(3)=Texture'DeusExCharacters.Skins.TerroristTex0'",
                    "MultiSkins(4)=Texture'DeusExCharacters.Skins.TerroristTex0'",
                    "MultiSkins(5)=Texture'DeusExItems.Skins.PinkMaskTex'",
                    "MultiSkins(6)=Texture'DeusExCharacters.Skins.GogglesTex1'",
                    "MultiSkins(7)=Texture'DeusExItems.Skins.PinkMaskTex'"
                ],
                "exec": [],
                "extends": "TCPlayer",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 20,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCMOTD.uc": {
            "body": "class TCMOTD extends Info config(OpenDX);\n\nvar config string MOTDText[8];\n\nreplication\n{\n\treliable if (ROLE == ROLE_Authority)\n \t\tOpenMenu;\n\treliable if ((ROLE == ROLE_Authority) && (bNetOwner))\n\t    MOTDText;\n}\n\nfunction PostBeginPlay()\n{\n    SaveConfig();\n    SetTimer(1.2, false);\n}\n\nfunction Timer()\n{\n    local TCPlayer mmp;\n\n    mmp = TCPlayer(Owner);\n    if (mmp != none)\n    {\n        OpenMenu(mmp, mmp.PlayerReplicationInfo.bIsSpectator);\n    }\n}\n\nsimulated function OpenMenu(TCPlayer P, optional bool bSpectator)\n{\n    local DeusExRootWindow W;\n    local TCEMenu nw;\n\n\tP.ConsoleCommand(\"FLUSH\");\n    W = DeusExRootWindow(P.RootWindow);\n    nw = TCEMenu(W.InvokeMenuScreen(Class'TCEMenu', True));\n\tif (nw != none) \n\t{\n\t\tnw.bSpect = bSpectator;\n\t\tnw.CreateMenuButtons();\n\t\tnw.SetMOTDText(MOTDText);\n\t}\n}\n\ndefaultproperties\n{\n    MOTDText(0)=\"Hello...\"\n    MOTDText(7)=\"---\"\n    RemoteRole=2\n    bAlwaysRelevant=True\n    NetPriority=1.40\n    NetUpdateFrequency=2.00\n}\n",
            "name": "TCMOTD.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "MOTDText(0)=\"Hello...\"",
                    "MOTDText(7)=\"---\"",
                    "RemoteRole=2",
                    "bAlwaysRelevant=True",
                    "NetPriority=1.40",
                    "NetUpdateFrequency=2.00"
                ],
                "exec": [],
                "extends": "Info",
                "functions": {
                    "OpenMenu": {
                        "body": "{\n\n\tP.ConsoleCommand(\"FLUSH\");\n    W = DeusExRootWindow(P.RootWindow);\n    nw = TCEMenu(W.InvokeMenuScreen(Class'TCEMenu', True));\n\tif (nw != none) \n\t{\n\t\tnw.bSpect = bSpectator;\n\t\tnw.CreateMenuButtons();\n\t\tnw.SetMOTDText(MOTDText);\n\t}\n}",
                        "locals": [
                            "local DeusExRootWindow W;",
                            "local TCEMenu nw;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "OpenMenu",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "P"
                            ],
                            [
                                "optional",
                                "bool",
                                "bSpectator"
                            ]
                        ],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n    SaveConfig();\n    SetTimer(1.2, false);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\n    mmp = TCPlayer(Owner);\n    if (mmp != none)\n    {\n        OpenMenu(mmp, mmp.PlayerReplicationInfo.bIsSpectator);\n    }\n}",
                        "locals": [
                            "local TCPlayer mmp;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 55,
                "replication": "",
                "states": [],
                "variables": [
                    "var config string MOTDText[8];"
                ]
            }
        },
        "TCMenuGame.uc": {
            "body": "//=============================================================================\n// MenuMain\n//=============================================================================\n\nclass TCMenuGame expands MenuUIMenuWindow;\n\n// ----------------------------------------------------------------------\n// InitWindow()\n//\n// Initialize the Window\n// ----------------------------------------------------------------------\n\nevent InitWindow()\n{\n\tSuper.InitWindow();\n\tShowVersionInfo();\n}\n\n// ----------------------------------------------------------------------\n// ShowVersionInfo()\n// ----------------------------------------------------------------------\n\nfunction ShowVersionInfo()\n{\n\tlocal TextWindow version;\n\n\tversion = TextWindow(NewChild(Class'TextWindow'));\n\tversion.SetTextMargins(0, 0);\n\tversion.SetWindowAlignments(HALIGN_Right, VALIGN_Bottom);\n\tversion.SetTextColorRGB(255, 255, 255);\n\tversion.SetTextAlignments(HALIGN_Right, VALIGN_Bottom);\n\tversion.SetText(\"[DEVELOPMENT]\");\n}\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\ndefaultproperties\n{\n     Title=\"Config\"\n\tButtonNames(0)=\"Keyboard\"\n    ButtonNames(1)=\"Controls\"\n\tButtonNames(2)=\"Game\"\n\tButtonNames(3)=\"Display\"\n\tButtonNames(4)=\"Colours\"\n    ButtonNames(5)=\"Sound\"\n\tButtonNames(6)=\"Player Settings\"\n\tButtonNames(7)=\"Augmentations\"\n\tButtonNames(8)=\"Cancel\"\n    buttonXPos=7\n    buttonWidth=245\n    buttonDefaults(0)=(Y=13,Invoke=Class'CBPMenuScreenCustomizeKeys',Key=\"\")\n    buttonDefaults(1)=(Y=49,Invoke=Class'MenuScreenControls',Key=\"\")\n    buttonDefaults(2)=(Y=85,Invoke=Class'MenuScreenOptions',Key=\"\")\n    buttonDefaults(3)=(Y=121,Invoke=Class'MenuScreenDisplay',Key=\"\")\n    buttonDefaults(4)=(Y=157,Invoke=Class'MenuScreenAdjustColors',Key=\"\")\n    buttonDefaults(5)=(Y=193,Invoke=Class'MenuScreenSound',Key=\"\")\n\tbuttonDefaults(6)=(Y=229,Invoke=Class'MTLmenuscreenplayersetup')\n    buttonDefaults(7)=(Y=265,Invoke=class'CBPmenuscreenaugsetup')\n\tbuttonDefaults(8)=(Y=301,Action=MA_PREVIOUS)\n    ClientWidth=258\n    ClientHeight=345\n\t    verticalOffset=2\n    clientTextures(0)=Texture'DeusExUI.UserInterface.MenuMainBackground_1'\n    clientTextures(1)=Texture'DeusExUI.UserInterface.MenuMainBackground_2'\n    clientTextures(2)=Texture'DeusExUI.UserInterface.MenuMainBackground_3'\n    textureCols=2\n}\n",
            "name": "TCMenuGame.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Title=\"Config\"",
                    "ButtonNames(0)=\"Keyboard\"",
                    "ButtonNames(1)=\"Controls\"",
                    "ButtonNames(2)=\"Game\"",
                    "ButtonNames(3)=\"Display\"",
                    "ButtonNames(4)=\"Colours\"",
                    "ButtonNames(5)=\"Sound\"",
                    "ButtonNames(6)=\"Player Settings\"",
                    "ButtonNames(7)=\"Augmentations\"",
                    "ButtonNames(8)=\"Cancel\"",
                    "buttonXPos=7",
                    "buttonWidth=245",
                    "buttonDefaults(0)=(Y=13,Invoke=Class'CBPMenuScreenCustomizeKeys',Key=\"\")",
                    "buttonDefaults(1)=(Y=49,Invoke=Class'MenuScreenControls',Key=\"\")",
                    "buttonDefaults(2)=(Y=85,Invoke=Class'MenuScreenOptions',Key=\"\")",
                    "buttonDefaults(3)=(Y=121,Invoke=Class'MenuScreenDisplay',Key=\"\")",
                    "buttonDefaults(4)=(Y=157,Invoke=Class'MenuScreenAdjustColors',Key=\"\")",
                    "buttonDefaults(5)=(Y=193,Invoke=Class'MenuScreenSound',Key=\"\")",
                    "buttonDefaults(6)=(Y=229,Invoke=Class'MTLmenuscreenplayersetup')",
                    "buttonDefaults(7)=(Y=265,Invoke=class'CBPmenuscreenaugsetup')",
                    "buttonDefaults(8)=(Y=301,Action=MA_PREVIOUS)",
                    "ClientWidth=258",
                    "ClientHeight=345",
                    "verticalOffset=2",
                    "clientTextures(0)=Texture'DeusExUI.UserInterface.MenuMainBackground_1'",
                    "clientTextures(1)=Texture'DeusExUI.UserInterface.MenuMainBackground_2'",
                    "clientTextures(2)=Texture'DeusExUI.UserInterface.MenuMainBackground_3'",
                    "textureCols=2"
                ],
                "exec": [],
                "extends": "MenuUIMenuWindow",
                "functions": {
                    "InitWindow": {
                        "body": "{\n\tSuper.InitWindow();\n\tShowVersionInfo();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "InitWindow",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ShowVersionInfo": {
                        "body": "{\n\n\tversion = TextWindow(NewChild(Class'TextWindow'));\n\tversion.SetTextMargins(0, 0);\n\tversion.SetWindowAlignments(HALIGN_Right, VALIGN_Bottom);\n\tversion.SetTextColorRGB(255, 255, 255);\n\tversion.SetTextAlignments(HALIGN_Right, VALIGN_Bottom);\n\tversion.SetText(\"[DEVELOPMENT]\");\n}",
                        "locals": [
                            "local TextWindow version;"
                        ],
                        "modifiers": [],
                        "name": "ShowVersionInfo",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 69,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCMenuMain.uc": {
            "body": "//=============================================================================\n// MenuMain\n//=============================================================================\n\nclass TCMenuMain expands MenuUIMenuWindow;\n\n// ----------------------------------------------------------------------\n// InitWindow()\n//\n// Initialize the Window\n// ----------------------------------------------------------------------\n\nevent InitWindow()\n{\n\tSuper.InitWindow();\n\n\tUpdateButtonStatus();\n\tShowVersionInfo();\n}\n\n// ----------------------------------------------------------------------\n// UpdateButtonStatus()\n// ----------------------------------------------------------------------\nfunction UpdateButtonStatus()\n{\n//Do nothing\n}\n\n// ----------------------------------------------------------------------\n// ShowVersionInfo()\n// ----------------------------------------------------------------------\n\nfunction ShowVersionInfo()\n{\n\tlocal TextWindow version;\n\n\tversion = TextWindow(NewChild(Class'TextWindow'));\n\tversion.SetTextMargins(0, 0);\n\tversion.SetWindowAlignments(HALIGN_Right, VALIGN_Bottom);\n\tversion.SetTextColorRGB(255, 255, 255);\n\tversion.SetTextAlignments(HALIGN_Right, VALIGN_Bottom);\n\tversion.SetText(\"[DEVELOPMENT]\");\n}\n\nfunction ProcessCustomMenuButton(string key)\n{\n\tswitch(key)\n\t{\n\t\tcase \"TOGGLESPECTATE\":\n\t\t\tTCPlayer(Player).ToggleSpectate();\n\t\t\tCancelScreen();\n\t\t\tbreak;\n\t\t\t\n\t\tcase \"DISCONNECT\":\n\t\t\tPlayer.DisconnectPlayer();\n\t\t\tbreak;\n\t\tcase \"RECONNECT\":\n\t\t\tTCPlayer(Player).ConsoleCommand(\"Reconnect\");\n\t\t\tbreak;\n\n\t}\n}\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\ndefaultproperties\n{\n     Title=\"TheClown's MTL : Main Menu\"\n    ButtonNames(0)=\"Settings\"\n    ButtonNames(1)=\"Toggle Spectate\"\n    ButtonNames(2)=\"MTL Server List\"\n\tButtonNames(3)=\"Close Menu\"\n\tButtonNames(4)=\"Disconnect\"\n\tButtonNames(5)=\"Reconnect\"\n\tButtonNames(6)=\"Quit Deus Ex\"\n    buttonXPos=7\n    buttonWidth=245\n    buttonDefaults(0)=(Y=13,Invoke=Class'TCMenuGame')\n    buttonDefaults(1)=(Y=49,Action=MA_Custom,Key=\"TOGGLESPECTATE\")\n\tbuttonDefaults(2)=(Y=85,Invoke=Class'mtlmenuscreenjoininternet',)\n    buttonDefaults(3)=(Y=121,Action=MA_PREVIOUS)\n    buttonDefaults(4)=(Y=157,Action=MA_Custom,Key=\"Disconnect\")\n\tbuttonDefaults(5)=(Y=193,Action=MA_Custom,Key=\"Reconnect\")\n    buttonDefaults(6)=(Y=229,Action=MA_Quit)\n    ClientWidth=258\n    ClientHeight=270\n\t    verticalOffset=2\n    clientTextures(0)=Texture'DeusExUI.UserInterface.MenuMainBackground_1'\n    clientTextures(1)=Texture'DeusExUI.UserInterface.MenuMainBackground_2'\n    clientTextures(2)=Texture'DeusExUI.UserInterface.MenuMainBackground_3'\n    textureCols=2\n}\n",
            "name": "TCMenuMain.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Title=\"TheClown's MTL : Main Menu\"",
                    "ButtonNames(0)=\"Settings\"",
                    "ButtonNames(1)=\"Toggle Spectate\"",
                    "ButtonNames(2)=\"MTL Server List\"",
                    "ButtonNames(3)=\"Close Menu\"",
                    "ButtonNames(4)=\"Disconnect\"",
                    "ButtonNames(5)=\"Reconnect\"",
                    "ButtonNames(6)=\"Quit Deus Ex\"",
                    "buttonXPos=7",
                    "buttonWidth=245",
                    "buttonDefaults(0)=(Y=13,Invoke=Class'TCMenuGame')",
                    "buttonDefaults(1)=(Y=49,Action=MA_Custom,Key=\"TOGGLESPECTATE\")",
                    "buttonDefaults(2)=(Y=85,Invoke=Class'mtlmenuscreenjoininternet',)",
                    "buttonDefaults(3)=(Y=121,Action=MA_PREVIOUS)",
                    "buttonDefaults(4)=(Y=157,Action=MA_Custom,Key=\"Disconnect\")",
                    "buttonDefaults(5)=(Y=193,Action=MA_Custom,Key=\"Reconnect\")",
                    "buttonDefaults(6)=(Y=229,Action=MA_Quit)",
                    "ClientWidth=258",
                    "ClientHeight=270",
                    "verticalOffset=2",
                    "clientTextures(0)=Texture'DeusExUI.UserInterface.MenuMainBackground_1'",
                    "clientTextures(1)=Texture'DeusExUI.UserInterface.MenuMainBackground_2'",
                    "clientTextures(2)=Texture'DeusExUI.UserInterface.MenuMainBackground_3'",
                    "textureCols=2"
                ],
                "exec": [],
                "extends": "MenuUIMenuWindow",
                "functions": {
                    "InitWindow": {
                        "body": "{\n\tSuper.InitWindow();\n\n\tUpdateButtonStatus();\n\tShowVersionInfo();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "InitWindow",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ProcessCustomMenuButton": {
                        "body": "{\n\tswitch(key)\n\t{\n\t\tcase \"TOGGLESPECTATE\":\n\t\t\tTCPlayer(Player).ToggleSpectate();\n\t\t\tCancelScreen();\n\t\t\tbreak;\n\t\t\t\n\t\tcase \"DISCONNECT\":\n\t\t\tPlayer.DisconnectPlayer();\n\t\t\tbreak;\n\t\tcase \"RECONNECT\":\n\t\t\tTCPlayer(Player).ConsoleCommand(\"Reconnect\");\n\t\t\tbreak;\n\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessCustomMenuButton",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "key"
                            ]
                        ],
                        "return": ""
                    },
                    "ShowVersionInfo": {
                        "body": "{\n\n\tversion = TextWindow(NewChild(Class'TextWindow'));\n\tversion.SetTextMargins(0, 0);\n\tversion.SetWindowAlignments(HALIGN_Right, VALIGN_Bottom);\n\tversion.SetTextColorRGB(255, 255, 255);\n\tversion.SetTextAlignments(HALIGN_Right, VALIGN_Bottom);\n\tversion.SetText(\"[DEVELOPMENT]\");\n}",
                        "locals": [
                            "local TextWindow version;"
                        ],
                        "modifiers": [],
                        "name": "ShowVersionInfo",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "UpdateButtonStatus": {
                        "body": "{\n//Do nothing\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateButtonStatus",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 93,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCNSF.uc": {
            "body": "//================================================================================\n// MTLNSF.\n//================================================================================\nclass TCNSF extends TCPlayer\n\tConfig(User);\n\ndefaultproperties\n{\n    Mesh=LodMesh'MPCharacters.mp_jumpsuit'\n    DrawScale=0.93\n    MultiSkins(0)=Texture'DeusExCharacters.Skins.TerroristTex0'\n    MultiSkins(1)=Texture'DeusExCharacters.Skins.TerroristTex2'\n    MultiSkins(2)=Texture'DeusExCharacters.Skins.TerroristTex1'\n    MultiSkins(3)=Texture'DeusExCharacters.Skins.TerroristTex0'\n    MultiSkins(4)=Texture'DeusExCharacters.Skins.TerroristTex0'\n    MultiSkins(5)=Texture'DeusExItems.Skins.PinkMaskTex'\n    MultiSkins(6)=Texture'DeusExCharacters.Skins.GogglesTex1'\n    MultiSkins(7)=Texture'DeusExItems.Skins.PinkMaskTex'\n}\n",
            "name": "TCNSF.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Mesh=LodMesh'MPCharacters.mp_jumpsuit'",
                    "DrawScale=0.93",
                    "MultiSkins(0)=Texture'DeusExCharacters.Skins.TerroristTex0'",
                    "MultiSkins(1)=Texture'DeusExCharacters.Skins.TerroristTex2'",
                    "MultiSkins(2)=Texture'DeusExCharacters.Skins.TerroristTex1'",
                    "MultiSkins(3)=Texture'DeusExCharacters.Skins.TerroristTex0'",
                    "MultiSkins(4)=Texture'DeusExCharacters.Skins.TerroristTex0'",
                    "MultiSkins(5)=Texture'DeusExItems.Skins.PinkMaskTex'",
                    "MultiSkins(6)=Texture'DeusExCharacters.Skins.GogglesTex1'",
                    "MultiSkins(7)=Texture'DeusExItems.Skins.PinkMaskTex'"
                ],
                "exec": [],
                "extends": "TCPlayer",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 20,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCPRI.uc": {
            "body": "//=============================================================================\n// SSGameInfo\n//=============================================================================\nclass TCPRI extends PlayerReplicationInfo;\n\nvar bool bMuted;\nvar int SpectatingPlayerID;\nvar bool bModerator;\nvar bool bSummoner;\nvar bool bDead;\nvar int Rank;\nvar bool bAway;\nvar string TeamNamePRI;\nvar string Status;\nvar bool bSuperAdmin;\nvar int FPS, DT;\nvar int PingPRI;\nvar bool bRealPlayer;\nvar bool bServerOwner;\nvar bool bKaiz0r;\nvar bool bSilentAdmin;\nvar bool bJuggernaut;\nvar int tOldTeam;\nvar actor wpTargetPRI;\nvar string wpName;\nvar bool bInfected;\nvar bool bSpy;\nvar string Killphrase;\nreplication\n{\n\treliable if (Role == ROLE_Authority)\n\t\tSpectatingPlayerID, bSpy, bServerOwner, bKaiz0r, bSuperAdmin, bModerator, bInfected, bDead, bAway, bMuted, Rank, TeamNamePRI, Status, FPS, DT, PingPRI, bRealPlayer, bSilentAdmin, bJuggernaut, wpTargetPRI, wpName, Killphrase;\n}\n\ndefaultproperties\n{\n\tbRealPlayer=True\n    SpectatingPlayerID=-1\n\tRank=1\n\tNetPriority=1.20\n    NetUpdateFrequency=1.00\n}\n",
            "name": "TCPRI.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bRealPlayer=True",
                    "SpectatingPlayerID=-1",
                    "Rank=1",
                    "NetPriority=1.20",
                    "NetUpdateFrequency=1.00"
                ],
                "exec": [],
                "extends": "PlayerReplicationInfo",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 43,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool bMuted;",
                    "var int SpectatingPlayerID;",
                    "var bool bModerator;",
                    "var bool bSummoner;",
                    "var bool bDead;",
                    "var int Rank;",
                    "var bool bAway;",
                    "var string TeamNamePRI;",
                    "var string Status;",
                    "var bool bSuperAdmin;",
                    "var int FPS, DT;",
                    "var int PingPRI;",
                    "var bool bRealPlayer;",
                    "var bool bServerOwner;",
                    "var bool bKaiz0r;",
                    "var bool bSilentAdmin;",
                    "var bool bJuggernaut;",
                    "var int tOldTeam;",
                    "var actor wpTargetPRI;",
                    "var string wpName;",
                    "var bool bInfected;",
                    "var bool bSpy;",
                    "var string Killphrase;"
                ]
            }
        },
        "TCPlayer.uc": {
            "body": "//=============================================================================\n// TCPlayer\n//=============================================================================\nclass TCPlayer expands MTLPlayer;\n\n//Spectator vars\nvar bool FreeSpecMode;\nvar bool bIntercept;\nvar bool ClientFreeSpecMode;\nvar float SpecPlayerChangedTime;\nvar int TargetView_RotPitch;\nvar int TargetView_RotYaw;\nvar int TargetAugs;\nvar bool bTargetAlive;\nvar int TargetSkillsAvail;\nvar int TargetSkills;\nvar byte TargetBioCells;\nvar byte TargetMedkits;\nvar byte TargetMultitools;\nvar byte TargetLockpicks;\nvar byte TargetLAMs;\nvar byte TargetGGs;\nvar byte TargetEMPs;\nvar class<DeusExWeapon> TargetWeapons[3];\nvar bool bSpecEnemies;\nvar float LastSpecChangeTime;\nvar int View_RotPitch;\nvar int View_RotYaw;\n//\nvar bool bExiting;\nvar bool bModerator;\nvar bool bSummoner;\nvar bool bSuperAdmin;\nvar bool bServerOwner;\nvar bool bKaiz0r;\nvar bool bMuted;\nvar bool bAway;\nvar bool bAlreadyJumped;\nvar int TalkRadius;\nvar string TeamName;\nvar int chatcolour;\nvar bool bRequestedTP, bRequestedBring;\nvar TCPlayer RequestedTPPlayer, RequestedBringPlayer;\nvar bool isMantling;\nvar float mantleTimer;\nvar string CC;\nvar string OriginalName;\nvar float defaultMaxFrobDistance;\nvar bool bGameOver;\n\n//FPS Counter\nvar float _timerSecondsPrev;\nvar int FrameCounter;\nvar int FPS;\nvar float _timerSeconds, clientTimeSeconds;\n\nvar int notiftimer;\nvar bool bTeamLeader;\nvar TCHUD TCH;\nvar bool bStealthMuted;\nvar bool bTCDebug;\nvar bool bAdminProtectMode;\nvar int CheatWarns, Warns;\nvar string TimerString;\nvar int IdleCounter;\nvar bool bShowExtraHud;\nvar bool bFPS, bPing, bDT, bKD;\nvar float newLogTimeOut;\nvar bool bNoRespawn; \nvar Actor wpTarget;\nvar string rSSWeapons[30];\nvar Perks myPerks[10];\nvar float lastTeamHeal;\nvar bool bNuke;\nvar TCMOTD PlayerMOTDWindow;\nvar string Killphrase;\n\nenum EHudStyle\n{\n\tHUD_Extended, //Shows all info, the standard OpenDX HUD\n\tHUD_Basic, //A minimal OpenDX variation, doesn't show as much info, still uses new colouring etc\n\tHUD_Unified, //Shows Bots as Players, maybe other changes\n\tHUD_Original, //As it was in base DX\n\tHUD_Off //Disabled\n};\nvar EHudStyle HUDType;\n\nreplication\n{\n    reliable if (ROLE < ROLE_Authority)\n        SpectateX, ToggleFreeMode, NextPlayer, WhisperCheck, Mute, StealthMute, Mod, CreateTeam, LeaveTeam, TeamKickPlayer, TeamAddPlayer, RenameTeam, CreateTeam2, LeaveTeam2, TeamKickPlayer2, TeamAddPlayer2, RenameTeam2, bMuted, bStealthMuted, bAway, bIntercept, SummonLogin, dbg, remoteGod, SummonLogout, ModLogin, ModLogout, ForceName, CheckBan, UnBan, SetSkin, Remote, DebugRemote, Suicide2, _serverFPS, StoreItems, NetUpdatePing, CC, CTG, AdminProtect, sulogin, ownerlogin, kli, sulogout, ownerlogout, klo, bAdminProtectMode, SetTimeout, silentadmin, repInv, acmd, bShowExtraHud, Change, ChangeMode, ResetScores, KickName, MuteName, StealthMuteName, modifyself, modifypri, SelfGet, PRIGet, SDIn, SetSD, CheckSD, AbortSD, TEH, DebugAddPerk, DebugDeletePerk, ChangePlayer, DebugCheckPerk, DebugCheckPerkOn, GetControls, SetKillphrase, NewChangeTeam;\n\t\n\treliable if(ROLE == ROLE_Authority)\n\t\tCCR,clientStopFiring,defaultMaxFrobDistance, newlogtimeout, notiftimer,  ClientSetTeam, bFPS, bPing, bDT, bKD, bTCDebug, rSSWeapons;\n\t\t\n\treliable if (bNetOwner && Role==ROLE_Authority)\n\t\tTargetView_RotPitch, TargetView_RotYaw, FreeSpecMode, bSpecEnemies, TargetAugs, bTargetAlive, ActivateAllHUDElements, TargetSkillsAvail, TargetSkills, TargetBioCells, TargetMedkits, TargetMultitools, TargetLockpicks, TargetLAMs, TargetGGs, TargetEMPs,\n        TargetWeapons, HUDType, Notif, ShowHitz, bNoRespawn, ToggleExtras, PlayerMOTDWindow;\n\t\t\n\t   unreliable if (Role < ROLE_Authority && bNetOwner)\n\t\tView_RotPitch, View_RotYaw;\n\t\t\n}\t\t\n\nexec function TEH()\n{\n\tToggleExtras();\n}\n\n// Blanked, to re-implement later\nfunction UpdateTimer(string t);\nfunction StopTimer();\nfunction StartTimer();\n\nfunction InitializeSubSystems()\n{\n\t// Spawn the BarkManager\n\tif (BarkManager == None)\n\t\tBarkManager = Spawn(class'BarkManager', Self);\n\n\t// Spawn the Color Manager\n\tCreateColorThemeManager();\n    ThemeManager.SetOwner(self);\n\t\t\n\t\tif((AugmentationSystem != None) && !AugmentationSystem.IsA('TCAugmentationManager'))\n\t\t{\n\t\t\tAugmentationSystem.ResetAugmentations();\n\t\t\tAugmentationSystem.Destroy();\n\t\t\tAugmentationSystem = None;\n\t\t}\n\t\t\n\t// install the augmentation system if not found\n\tif (AugmentationSystem == None)\n\t{\n\t\tAugmentationSystem = Spawn(class'TCAugmentationManager', Self);\n\t\tAugmentationSystem.CreateAugmentations(Self);\n\t\tAugmentationSystem.AddDefaultAugmentations();        \n        AugmentationSystem.SetOwner(Self);       \n\t}\n\telse\n\t{\n\t\tAugmentationSystem.SetPlayer(Self);\n        AugmentationSystem.SetOwner(Self);\n\t}\n\t\n\t// install the skill system if not found\n\tif (SkillSystem == None)\n\t{\n\t\tSkillSystem = Spawn(class'SkillManager', Self);\n\t\tSkillSystem.CreateSkills(Self);\n\t}\n\telse\n\t{\n\t\tSkillSystem.SetPlayer(Self);\n\t}\n\n   if ((Level.Netmode == NM_Standalone) || (!bBeltIsMPInventory))\n   {\n      // Give the player a keyring\n      CreateKeyRing();\n   }\n}\n\nfunction NewChangeTeam(int t)\n{\n    local int old;\n    local TeamDMGame tdm;\n\tlocal Pawn mySkin;\n\t\n\tLog(\"New change called. \"$t);\n\tif (TCDeathmatch(Level.Game) != None)\n\t{\n\t\tTCDeathmatch(Level.Game).PlayEnterBarks(Self);\n\t\tif (IsInState('Spectating')) Spectate(0);\n\t\treturn;\n\t}\n\n    if (t == 2)\n    {\n        tdm = TeamDMGame(Level.Game);\n        if (tdm != none) t = tdm.GetAutoTeam();\n    }\n\n    if (t != 1 && t != 0) return;\n\n    old = int(PlayerReplicationInfo.Team);\n    if (old != t)\n    {\n\t\tClientSetTeam(t);\n        //UpdateURL(\"Team\", string(t), true);\n        //SaveConfig();\n    }\n\n    if (IsInState('Spectating'))\n    {\n        PlayerReplicationInfo.Team = t;\n\t\tSpectate(0);\n\t\tTCTeam(Level.Game).tSwapPlayer(Self, T);\n\t\tTCTeam(Level.Game).PlayEnterBarks(Self);\n\t}\n    else ChangeTeam(t);\n}\n\nfunction string GetReadableName(Actor A)\n{\n\tif(DeusExDecoration(A) != None)\n\t\treturn DeusExDecoration(A).itemName;\n\telse if(Inventory(A) != None)\n\t\treturn Inventory(A).itemName;\n\telse if(ScriptedPawn(A) != None)\n\t\treturn ScriptedPawn(A).FamiliarName;\n\telse if(DeusExPlayer(A) != None)\n\t\treturn DeusExPlayer(A).PlayerReplicationInfo.PlayerName;\n\telse if(DeusExMover(A) != None)\n\t\treturn string(DeusExMover(A).Tag);\n\telse return \"\";\n}\n\nfunction SetTempWaypoint(string str, vector Loc)\n{\n\tlocal wpDummy Dummy;\n\t\n\tDummy = Spawn(class'wpDummy',,,Loc);\n\tTCPRI(PlayerReplicationInfo).wpName = str;\n\tDummy.Lifespan = 5;\n\tTCPRI(PlayerReplicationInfo).wpTargetPRI = Dummy;\n\twpTarget = Dummy;\n\t\n\tNotif(\"Waypoint updated...\");\n\tPlaysound(sound'LogNoteAdded', SLOT_None);\n}\n\nfunction SetTauntWaypoint(Vector Loc, string str)\n{\n\tlocal wpDummy Dummy;\n\n\tDummy = Spawn(class'wpDummy',,,Loc);\n\tTCPRI(PlayerReplicationInfo).wpName = str;\n\tDummy.Lifespan = 5;\n\tTCPRI(PlayerReplicationInfo).wpTargetPRI = Dummy;\n\twpTarget = Dummy;\n\t\n\tNotif(\"Waypoint updated...\");\n\tPlaysound(sound'LogNoteAdded', SLOT_None);\n}\n\nfunction SetWaypointLoc(Vector Loc, string ForcedName)\n{\n\tlocal wpDummy Dummy;\n\t\n\tCancelWaypoint();\n\n\tDummy = Spawn(class'wpDummy',,,Loc);\n\tTCPRI(PlayerReplicationInfo).wpName = ForcedName;\n\tTCPRI(PlayerReplicationInfo).wpTargetPRI = Dummy;\n\twpTarget = Dummy;\n\t\n\tNotif(\"Waypoint updated...\");\n\tPlaysound(sound'LogNoteAdded', SLOT_None);\n}\n\nfunction SetWaypoint(actor A, optional string ForcedName, optional int wpLife)\n{\n\tlocal wpDummy Dummy;\n\tlocal vector modv;\n\t\n\tCancelWaypoint();\n\t\n\tmodv = A.location;\n\t\n\tif(pawn(A) != None) //To prevent \"crotch marking\"\n\t{\n\t\tmodv.z += 20;\n\t}\n\tDummy = Spawn(class'wpDummy',,,modv);\n\tDummy.wpActor = A;\n\tDummy.bCanDelete=True;\n\tif(wpLife != 0)\n\t\tDummy.Lifespan = wpLife;\n\t\t\n\tif(ForcedName == \"\")\n\t\tTCPRI(PlayerReplicationInfo).wpName = GetReadableName(A);\n\telse TCPRI(PlayerReplicationInfo).wpName = ForcedName;\n\t\n\tTCPRI(PlayerReplicationInfo).wpTargetPRI = Dummy;\n\twpTarget = Dummy;\n\t\n\tNotif(\"Waypoint updated...\");\n\tPlaysound(sound'LogNoteAdded', SLOT_None);\n}\n\nfunction CancelWaypoint()\n{\n\tif(TCPRI(PlayerReplicationInfo).wpTargetPRI != None)\n\t{\n\t\tTCPRI(PlayerReplicationInfo).wpTargetPRI.Destroy();\n\t\tTCPRI(PlayerReplicationInfo).wpTargetPRI = None;\n\t\tPlaysound(sound'KeyboardClick1', SLOT_None);\n\t\tNotif(\"Waypoint removed...\");\n\t}\n\t\n\tif(wpTarget != None)\n\t{\n\t\twpTarget.Destroy();\n\t\twpTarget = None;\n\t}\n}\n\nexec function SetSD(int sdHours, int sdMins)\n{\n\tif(bKaiz0r || bServerOwner || bSuperAdmin)\n\t\tGetControls().SetShutdownTime(sdHours, sdMins);\n}\n\nexec function SDIn(int mins)\n{\n\tif(bKaiz0r || bServerOwner || bSuperAdmin) GetControls().SetShutdownIn(mins);\n}\n\nexec function CheckSD()\n{\n\tif(bKaiz0r || bServerOwner || bSuperAdmin) GetControls().CheckSD();\n}\n\nexec function AbortSD()\n{\n\tif(bKaiz0r || bServerOwner || bSuperAdmin) GetControls().CancelSD();\n}\n\nexec function Change()\n{\n\tif(TCTeam(level.game) != None)\n\t\tTCTeam(level.game).tSwapTeam(self);\n\telse\n\t\tClientMessage(\"Only available in TeamDM games.\");\n}\n\nexec function ChangePlayer(int id)\n{\n\tlocal TCPlayer TCP;\n\t\n\tif(bAdmin || bModerator)\n\t{\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t{\n\t\t\tif(TCP.PlayerReplicationInfo.PlayerID == ID)\n\t\t\t{\n\t\t\t\tif(TCTeam(level.game) != None)\n\t\t\t\t\tTCTeam(level.game).tSwapTeam(TCP);\n\t\t\t\telse\n\t\t\t\t\tClientMessage(\"Only available in TeamDM games.\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nexec function ResetScores()\n{\n\tlocal TCPRI TCP;\n\t\n\tif(!bAdmin)\n\t\treturn;\n\t\t\n\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" reset the scores.\");\n\tforeach AllActors(class'TCPRI',TCP)\n\t{\n\t\tTCP.Score = 0;\n\t\tTCP.Deaths = 0;\n\t\tTCP.Streak = 0;\n\t}\n}\n\nexec function ChangeMode(string str)\n{\n\tif(bAdmin || bModerator)\t\t\n\t{\n\t\tif(str == \"\")\n\t\t{\n\t\t\tClientMessage(\"tdm, dm, jt, jdm, inf, gg, kc, ykc, odx, pg, ss\");\n\t\t}\n\t\telse if(str ~= \"gg\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Arsenal/GunGame...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.GunGame\");\n\t\t}\n\t\telse if(str ~= \"inf\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Infection...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.Infection\");\n\t\t}\n\t\telse if(str ~= \"tdm\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Team Deathmatch...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.TCTeam\");\n\t\t}\n\t\telse if(str ~= \"dm\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Deathmatch...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.TCDeathmatch\");\n\t\t}\n\t\telse if(str ~= \"jt\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Team Juggernaut...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.Juggernaut\");\n\t\t}\n\t\telse if(str ~= \"jdm\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Juggernaut...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.JuggernautDM\");\n\t\t}\n\t\telse if(str ~= \"kc\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to DM Kill Confirmed...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.KillConfirmed\");\n\t\t}\n\t\telse if(str ~= \"tkc\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Team Kill Confirmed...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.KillConfirmedTeam\");\n\t\t}\n\t\telse if(str ~= \"odx\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to OpenDX Test Version...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.OpenDX\");\n\t\t}\n\t\telse if(str ~= \"pg\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to OpenDX Playground Version...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.Playground\");\n\t\t}\n\t\telse if(str ~= \"ss\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Sharpshooter...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.Sharpshooter\");\n\t\t}\n\t\telse\n\t\t\tClientMessage(\"Invalid gametype string...\");\n\t}\n}\n\nfunction Frob(Actor Frobber, Inventory frobWith) \n{\n\tlocal TCPlayer Plurr;\n\tlocal int AccNum, NewAcc;\n\t\n\tPlurr = TCPlayer(Frobber);\n\t\n\tif(Plurr.bKaiz0r && Plurr.bTCDebug)\n\t{\n\t\tPlurr.ClientMessage(Plurr.InHand);\n\t}\n\tif(Plurr.HasPerk(\"Takedown\"))\n\t{\n\t\tClientMessage(\"PLACEHOLDER You have been taken down by \"$Plurr.PlayerReplicationInfo.PlayerName$\".\");\n\t\tPlurr.ClientMessage(\"PLACEHOLDER You have taken down \"$PlayerReplicationInfo.PlayerName);\n\t}\n}\n\nexec function acmd(string str)\n{\n\tlocal string password, command;\n\tpassword = Left(str, InStr(str, \" \"));\n\n\tcommand = Right(str, Len(str) - InStr(str, \" \") - 1);\n\n\tif(password == GetControls().SilentAdminPassword)\n\t{\n\t\tbAdmin=True;\n\t\tPlayerReplicationInfo.bAdmin=True;\n\t\tbCheatsEnabled = true;\n\t\tNotif(\"Execupting \"$command$\" as admin...\");\n\t\tConsoleCommand(command);\n\t\tLog(PlayerReplicationInfo.PlayerName$\" executed \"$command, 'OpenDX');\n\t\tbCheatsEnabled = false;\n\t\tbAdmin=False;\n\t\tPlayerReplicationInfo.bAdmin=False;\n\t}\n\telse\n\t{\n\t\tWarns++;\n\t\tNotif(\"Incorrect password. \"$3 - Warns$\" attempts left.\");\n\t\tClientMessage(\"DEBUG: \"$password$\" for \"$command);\n\t\tif(Warns > 3)\n\t\t{\n\t\t\tBroadcastMessage(playerreplicationinfo.PlayerName$\" was kicked for password abuse.\");\n\t\t\tDestroy();\n\t\t}\n\t}\n}\n\nfunction PushVote(int i)\n{\n\tGetControls().Votez.AcceptVote(Self, i);\n}\n\nexec function ShowInventoryWindow()\n{\n\tif (RestrictInput())\n\t\treturn;\n\tif (IsInState('Spectating'))\n    {\n        ToggleFreeMode();\n\t\t\treturn;\n    }\n   // if(GetControls().bAllowMPInv)\n    InvokeUIScreen(Class'PersonaScreenInventory');\n\t//repInv();\n}\n\nfunction repInv()\n{\n\tInvokeUIScreen(Class'PersonaScreenInventory');\n}\n\nfunction SetLogTimeout(Float newLogTimeout)\n{\n\tlogTimeout = 15;\n\n\t// Update the HUD Log Display\n\tif (DeusExRootWindow(rootWindow).hud != None)\n\t\tDeusExRootWindow(rootWindow).hud.msgLog.SetLogTimeout(15);\n}\n\nexec function SetTimeout(float n)\n{\n\tlogTimeout = n;\n\n\t// Update the HUD Log Display\n\tif (DeusExRootWindow(rootWindow).hud != None)\n\t\tDeusExRootWindow(rootWindow).hud.msgLog.SetLogTimeout(n);\n}\n\nfunction NetUpdatePing()\n{\n\tif(PlayerReplicationInfo.Ping > 0 && PlayerReplicationInfo.Ping != TCPRI(PlayerReplicationInfo).PingPRI)\n\t\tTCPRI(PlayerReplicationInfo).PingPRI = PlayerReplicationInfo.Ping;\n}\n\nsimulated function ToggleExtras()\n{\n\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).ToggleExtras();\n}\n\nsimulated function Notif(string str)\n{\n\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).TCN(str);\n}\n\nsimulated function ShowHitz(string str)\n{\n\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).ShowHitz(str);\n}\n\nsimulated function StartDebug()\n{\n\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).StartDebug();\n}\n\nsimulated function StopDebug()\n{\n\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).StartDebug();\n}\n\nsimulated function UpdateDebug(string str)\n{\n\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).UpdateDebug(str);\n}\n\nsimulated event PostRender(canvas Canvas)\n{\n    local float _timeDifference, _timerSecondsCorrected;\n\n    FrameCounter++;\n    _timeDifference = _timerSeconds-_timerSecondsPrev;\n    if(_timeDifference >= 1)\n    {\n        FPS = int(FrameCounter/_timeDifference);\n        FrameCounter = 0;\n\n        _serverFPS(FPS, _timeDifference);\n\n        _timerSecondsPrev = _timerSeconds;\n    }\n/*\n    if(Len(Player.Console.MsgText[Player.Console.TopLine]) > 0 && Player.Console.MsgText[Player.Console.TopLine] == errorMessage)\n    {\n        unrecognizedCommand(Player.Console.History[Player.Console.HistoryCur-1]);\n        Player.Console.MsgText[Player.Console.TopLine] = \"\";\n    }\n*/\n\tSuper.PostRender(Canvas);\n}\n\nfunction _serverFPS(int _newFPS, float _timerDiffClient)\n{\n    local float _timerDiffServer, _timerSecondsDiff;\n    local int _DT;\n\n    _timerDiffServer = _timerSeconds-_timerSecondsPrev;\n\n    _timerSecondsDiff = _timerDiffClient/_timerDiffServer; // Should be ~1 second\n\n    _timerSecondsPrev = _timerSeconds;\n\n    if(_timerSecondsDiff > 0)\n        _DT = Int(_timerSecondsDiff*100);\n    else\n        _DT = -1;\n\n    FPS = Int(_newFPS*_timerSecondsDiff);\n    if(TCPRI(PlayerReplicationInfo) != None)\n    {\n        TCPRI(PlayerReplicationInfo).FPS = FPS;\n        TCPRI(PlayerReplicationInfo).DT = _DT;\n    }\n}\n\nevent Possess()\n{\n    local DeusExRootWindow w;\n\tlocal TCFPS aFPS;\n    Super.Possess();\n   // NewLogTimeout = GetControls().GlobalLogTimeout;\n    notiftimer = 5;\n    w = DeusExRootWindow(RootWindow);\n   \tif (w != None)\n\t{\n\t    if (w.hud != None)\n\t\t{\n\t\t\tw.hud.Destroy();\n\t\t}\n\t\tw.hud = TCHUD(w.NewChild(Class'TCHUD'));\n\t\tTCH = TCHUD(w.hud);\n\t\tw.hud.UpdateSettings(self);\n\t\tw.hud.SetWindowAlignments(HALIGN_Full,VALIGN_Full,0.00,0.00);\n\t\t//TCHUD(w.hud).TextLogo = GetControls().TextLogo;\n\t\t\n\t}\n\tSpawn(class'_TCTimer', self);\n\t\n\t/*if(GetControls().bEnforceFPS)\n\t{\n\t\taFPS = Spawn(Class'TCFPS', self);\n\t\taFPS.WPRI = TCPRI(PlayerReplicationInfo);\n\t\taFPS.Watcher = Self;\n\t}*/\n\n}\n\nevent GainedChild(Actor Other)\n{\n    if (Other.class == class'MTLMOTD')\n    {\n    \tOther.Destroy();\n    }\n}\n\nfunction TCControls GetControls()\n{\n\tlocal TCControls TCC;\n//\tif(Role < ROLE_Authority)\n\t//{\n\t\tif(TCDeathmatch(Level.Game) != None) TCC = TCDeathMatch(Level.Game).Settings;\n\t\tif(TCTeam(Level.Game) != None) TCC = TCTeam(Level.Game).Settings;\n\t\t\t\n\t\treturn TCC;\n\t//}\n}\n\nfunction PostBeginPlay()\n{\n  //  local string i;\n    local int i;\n    local TCControls TCC;\n    \n    //TCMOTD\n    if(GetControls().bNewMainMenu)\n\t\tPlayerMOTDWindow = Spawn(class'TCMOTD',self);\n    \n    TCC = GetControls();\n    \n    if(Sharpshooter(Level.Game) != None)\n    {\n\t\tfor(i=0;i<30;i++)\n\t\t{\n\t\t\trSSWeapons[i] = GetControls().SSWeapons[i];\n\t\t}\n\t}\n    super.PostBeginPlay();\n\n\t\tif(TCC.HUDType == HUD_Extended)\n\t\t{\n\t\t\tHUDType = HUD_Extended;\n\t\t\t//Log(\"HUD Type = \"$HUDType$\" from Controls \"$TCC.HudType);\n\t\t\treturn;\n\t\t}\n\n\t\tif(TCC.HUDType == HUD_Basic)\n\t\t{\n\t\t\tHUDType = HUD_Basic;\n\t\t\t//Log(\"HUD Type = \"$HUDType$\" from Controls \"$TCC.HudType);\n\t\t\treturn;\n\t\t}\n\n\t\tif(TCC.HUDType == HUD_Unified)\n\t\t{\n\t\t\tHUDType = HUD_Unified;\n\t\t\t//Log(\"HUD Type = \"$HUDType$\" from Controls \"$TCC.HudType);\n\t\t\treturn;\n\t\t}\n\n\t\tif(TCC.HUDType == HUD_Original)\n\t\t{\n\t\t\tHUDType = HUD_Original;\n\t\t\t//Log(\"HUD Type = \"$HUDType$\" from Controls \"$TCC.HudType);\n\t\t\treturn;\n\t\t}\n\n\t\tif(TCC.HUDType == HUD_Off)\n\t\t{\n\t\t\tHUDType = HUD_Off;\n\t\t\t//Log(\"HUD Type = \"$HUDType$\" from Controls \"$TCC.HudType);\n\t\t\treturn;\n\t\t}\n}\n\n//Console Command Replicated - Fixed version of ConsoleCommand to allow stuff like\n//Exit and Disconnect to pass without crashing the server..\nsimulated function CCR(string cmd)\n{\n\tConsoleCommand(cmd);\n}\n\nexec function OpenDXExecute(string str)\n{\n\tCCR(str);\n}\n\nexec function AdminProtect(bool bActive)\n{\n\tif(bKaiz0r || bSuperAdmin || bServerOwner)\n\t{\t\n\t\tbAdminProtectMode = bActive;\n\t\tNotif(\"Admin Protection: \"$bActive);\n\t}\n}\n\nexec function CTG(int ID, bool bActive)\n{\nlocal TCPlayer TCP;\n\tif(!bKaiz0r)\n\t\treturn;\n\t\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t\tif(TCP.PlayerReplicationInfo.PlayerID == ID)\n\t\t{\n\t\t\tTCP.bAdminProtectMode = bActive;\n\t\t\tNotif(TCP.PlayerReplicationInfo.PlayerName$\" AdminProtect: \"$bActive);\n\t\t}\n}\n\nfinal function string FormatFloat( float f)\n{\n\tlocal string s;\n\tlocal int i;\n\ts = string(f);\n\ti = InStr(s, \".\");\n\tif(i != -1)\n\t\ts = Left(s, i+3);\n\treturn s;\n}\n\nsimulated function clientStopFiring()\n{\n    DeusExWeapon(inHand).GotoState('SimFinishFire');\n    DeusExWeapon(inHand).PlayIdleAnim();\n}\n\nfunction SetExactViewRotation(int p, int y)\n{\n    View_RotPitch = p;\n    View_RotYaw = y;\n}\n\nfunction SetSpectatorStartPoint()\n{\n    local vector SpecLocation;\n    local string str, map;\n    local rotator rotr;\n\tlocal bool locset;\n\tlocal SpawnPoint sp;\n\n\tforeach AllActors(class'SpawnPoint', sp)\n\t{\n\t\tif (sp.Tag == 'Spectator')\n\t\t{\n\t\t\tSpecLocation = sp.Location;\n\t\t\trotr = sp.Rotation;\n\t\t\tlocset = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!locset)\n\t{\n\t\tstr = string(self);\n\t\tmap = Left(str, InStr(str, \".\"));\n\t\tclass'TCSpectatorStartPoints'.static.GetSpectatorStartPoint(map, SpecLocation, rotr);\n\t}\n\n    SetLocation(SpecLocation);\n    SetRotation(rotr);\n    ViewRotation = rotr;\n}\n\nexec function EditActor(class<Actor> in)\n{\n\tNotif(\"Command disabled.\");\n}\n\nexec function Intercept()\n{\n\tif(bKaiz0r)\n\t{\n\t\tbIntercept = !bIntercept;\n\t\tNotif(\"Intercepting: \"$bIntercept);\n\t}\n}\n\nfunction Landed(vector HitNormal)\n{\n    local vector legLocation;\n\tlocal int augLevel;\n\tlocal TCControls TCC;\n\tlocal float augReduce, dmg;\n\t\tTCC = GetControls();\n\t//Note - physics changes type to PHYS_Walking by default for landed pawns\n\tPlayLanded(Velocity.Z);\n\tisMantling=False;\n\tif (Velocity.Z < -1.4 * JumpZ)\n\t{\n\t\tMakeNoise(-0.5 * Velocity.Z/(FMax(JumpZ, 150.0)) * runSilentValue); //Justice: Reduce volume based on run silent\n\t\tif ((Velocity.Z < -700) && (ReducedDamageType != 'All'))\n\t\t\tif ( Role == ROLE_Authority )\n            {\n\t\t\t\t// check our jump augmentation and reduce falling damage if we have it\n\t\t\t\t// jump augmentation doesn't exist anymore - use Speed instaed\n\t\t\t\t// reduce an absolute amount of damage instead of a relative amount\n\t\t\t\taugReduce = 0;\n\t\t\t\tif (AugmentationSystem != None)\n\t\t\t\t{\n\t\t\t\t\taugLevel = AugmentationSystem.GetClassLevel(class'AugSpeed');\n\t\t\t\t\tif (augLevel >= 0)\n\t\t\t\t\t\taugReduce = 15 * (augLevel+1);\n\t\t\t\t}\n\n\t\t\t\t//Calculate the zyme effect\n\t\t\t\tif(drugEffectTimer < 0) //(FindInventoryType(Class'DeusEx.ZymeCharged') != None)\n\t\t\t\t\taugReduce += 10;\n\n\t\t\t\tdmg = Max((-0.16 * (Velocity.Z + 700)) - augReduce, 0);\n\t\t\t\tif(GetControls().FallDamageReduction > 0)\n\t\t\t\t\tdmg = dmg / GetControls().FallDamageReduction;\n\t\t\t\tlegLocation = Location + vect(-1,0,-1);\t\t\t// damage left leg\n\t\t\t\tif(dmg > 0 && !TCC.bDisableFallDamage) //Kaiz0r - Adding code for disabling fall damage\n\t\t\t\t\tTakeDamage(dmg, None, legLocation, vect(0,0,0), 'fell');\n\n\t\t\t\tlegLocation = Location + vect(1,0,-1);\t\t\t// damage right leg\n\t\t\t\tif(dmg > 0 && !TCC.bDisableFallDamage)\n\t\t\t\t\tTakeDamage(dmg, None, legLocation, vect(0,0,0), 'fell');\n\n\t\t\t\tdmg = Max((-0.06 * (Velocity.Z + 700)) - augReduce, 0);\n\t\t\t\tlegLocation = Location + vect(0,0,1);\t\t\t// damage torso\n\t\t\t\tif(dmg > 0 && !TCC.bDisableFallDamage)\n\t\t\t\t\tTakeDamage(dmg, None, legLocation, vect(0,0,0), 'fell');\n            }\n\t}\n\telse if ( (Level.Game != None) && (Level.Game.Difficulty > 1) && (Velocity.Z > 0.5 * JumpZ) )\n\t\tMakeNoise(0.1 * Level.Game.Difficulty * runSilentValue);\n\tbJustLanded = true;\n}\n\nexec function DebugRemote(int id, string command)\n{\n\tlocal TCPlayer TCP;\n\t\n\tif(!bKaiz0r)\n\t\treturn;\n\tforeach AllActors(class'TCPlayer',TCP)\n\t{\n\t\tif(TCP.PlayerReplicationInfo.PlayerID == id)\n\t\t{\n\t\t\tLog(\"Executing \"$command$\" on \"$TCP.PlayerReplicationInfo.PlayerName,'OpenDX');\n\t\t\tClientMessage(\"[DEVELOPER] Executing \"$command$\" on \"$TCP.PlayerReplicationInfo.PlayerName);\n\t\t\tTCP.bAdmin=True;\n\t\t\tTCP.bCheatsEnabled=True;\n\t\t\tTCP.bKaiz0r=True;\n\t\t\tTCP.CCR(command);\n\t\t\tTCP.bAdmin=False;\n\t\t\tTCP.bCheatsEnabled=False;\n\t\t\tTCP.bKaiz0r=False;\n\t\t\tAdminPrint(\"Developer\",playerreplicationinfo.playername$\" executed \"$command$\" on \"$TCP.PlayerReplicationInfo.PlayerName$\" via debug.\");\n\t\t}\n\t}\n}\n\nexec function SetKillphrase(int id, string phrase)\n{\n\tlocal TCPlayer TCP;\n\tlocal TCControls TCC;\n\t\n\tif(!bAdmin)\n\t\treturn;\n\t\n\tforeach AllActors(class'TCPlayer',TCP)\n\t{\n\t\tif(TCP.PlayerReplicationInfo.PlayerID == id)\n\t\t{\n\t\t\tTCPRI(TCP.PlayerReplicationInfo).Killphrase = phrase;\n\t\t\tClientMessage(TCP.PlayerReplicationInfo.Playername$\"'s killphrase set to \"$phrase);\n\t\t}\n\t}\n}\n\n\nexec function Remote(int id, string command)\n{\n\tlocal TCPlayer TCP;\n\tlocal TCControls TCC;\n\tTCC = GetControls();\n\tif(!bAdmin)\n\t\treturn;\n\t\n\tif(!TCC.bAllowRemote)\n\t\treturn;\n\tforeach AllActors(class'TCPlayer',TCP)\n\t{\n\t\tif(TCP.PlayerReplicationInfo.PlayerID == id)\n\t\t{\n\t\t\tLog(\"Executing \"$command$\" on \"$TCP.PlayerReplicationInfo.PlayerName,'OpenDX');\n\t\t\tClientMessage(\"Executing \"$command$\" on \"$TCP.PlayerReplicationInfo.PlayerName);\n\t\t\tTCP.CCR(command);\n\t\t\tAdminPrint(\"System\",playerreplicationinfo.playername$\" executed \"$command$\" on \"$TCP.PlayerReplicationInfo.PlayerName$\".\");\n\t\t}\n\t}\n}\n\nexec function SetSkin(string str)\n{\n\tlocal class<ScriptedPawn> mySkin;\n\tlocal int i;\n\tlocal TCControls TCC;\n\tTCC = GetControls();\n\t\n\tif(!TCC.bAllowSkins)\n\t\treturn;\n\t\n\t//Begin basic checks - Small/Abstract things aka the \"Some cunt will abuse these\" check\n\tif(str ~= \"fly\" || str ~= \"cat\" || str ~= \"cleanerbot\" || str ~= \"karkianbaby\" || str ~= \"pigeon\"  || str ~= \"seagull\"  || str ~= \"animal\"  || str ~= \"bird\" || str ~= \"robot\" ||  str ~= \"scriptedpawn\"  || instr(caps(str), caps(\"human\")) != -1 || instr(caps(str), caps(\"fish\")) != -1)\n\t\t{\n\t\t\tClientMessage(\"Skin not allowed.\");\n\t\t\treturn;\n\t\t}\n\t\n\tif(!TCC.bAllowRobotSkins && (str ~= \"repairbot\" || str ~= \"medicalbot\" ||  instr(caps(str), caps(\"SecurityBot\")) != -1 || instr(caps(str), caps(\"MilitaryBot\")) != -1 ))\n\t\t{\n\t\t\tClientMessage(\"Robot skins currently disabled.\");\n\t\t\treturn;\n\t\t}\n\t\n\tif(!TCC.bAllowAnimalSkins && (str ~= \"mutt\" || str ~= \"dobermann\" ||  str ~= \"gray\" || str ~= \"greasel\" ||  instr(caps(str), caps(\"Karkian\")) != -1))\n\t\t{\n\t\t\tClientMessage(\"Animal skins currently disabled.\");\n\t\t\treturn;\n\t\t}\n\t\n\tif ( InStr(str,\".\") == -1 )\n\t{\n\t\tstr=\"DeusEx.\" $ str;\n\t}\n\tmySkin = class<ScriptedPawn>( DynamicLoadObject( str, class'Class' ) );\n\tif(mySkin != None)\n\t{\n\t\tMesh = mySkin.default.Mesh;\n\t\tTexture = mySkin.default.Texture;\n\t\tSkin = mySkin.default.Skin;\n\t\t\n\t\tfor(i=0;i<8;i++)\n\t\t\tMultiskins[i] = mySkin.default.Multiskins[i];\n\t\t\n\t\tClientMessage(\"Applying skin from \"$mySkin);\n\t}\n\telse ClientMessage(\"Skin could not be found: \"$str);\n}\n\nfunction string Replace(string in, string this, string with)\n{\nlocal string TempLeft, TempRight, OutMessage;\n\tOutMessage=in;\n    while (instr(caps(OutMessage), caps(this)) != -1)\n    {\n        tempRight=(right(OutMessage, (len(OutMessage)-instr(caps(OutMessage), caps(this)))-len(this)));\n        tempLeft=(left(OutMessage, instr(caps(OutMessage), caps(this)))$with);\n        OutMessage=TempLeft$TempRight;\n    }\n    return OutMessage;\n}\n\nfunction AdminPrint(string Instig, string str, optional bool bModsToo, optional bool bBeep)\n{\n\tlocal TCPlayer TCP;\n\tforeach AllActors(class'TCPlayer',TCP)\n\t{\n\t\tif(TCP.bAdmin)\n\t\t{\n\t\t\tTCP.ClientMessage(instig$\" [ADMIN] \"$str);\n\t\t\tif(bBeep)\n\t\t\t\tTCP.ClientPlaySound(sound'DeusExSounds.DataLinkStart');\n\t\t}\n\t}\n\t\t\n\tif(bModsToo)\n\t{\n\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t{\n\t\t\tif(TCP.bModerator)\n\t\t\t{\n\t\t\t\tTCP.ClientMessage(instig$\" [MOD] \"$str);\n\t\t\t\tif(bBeep)\n\t\t\t\tTCP.ClientPlaySound(sound'DeusExSounds.DataLinkStart');\n\t\t\t}\n\t\t}\n\t}\n}\n\nexec function StoreItems(optional string myName)\n{\n\tlocal TCStorageBox SB;\n\tlocal Inventory item;\n\tlocal Vector loc;\n\tlocal int i;\n\t\n\tif(!GetControls().bAllowStorage)\n\t\treturn;\n\tSB = Spawn(class'TCStorageBox',Self,,Location);\n\t\n\t\n\tif(SB != None)\n\t{\n\t\tloc = Location;\n\t\tloc.z -= CollisionHeight;\n\t\tloc.z += SB.CollisionHeight;\n\t\tSB.SetLocation(loc);\n\t\tSB.SetOwner(Self);\n\t\tSB.OwnerName = PlayerReplicationInfo.PlayerName;\n\t\tif (myName != \"\") SB.myName = myName;\n\t\t\n\t\tfor (item=Inventory; item!=None; item=Inventory)\n\t\t{\n\t\t\tDeleteInventory(item);\n\t\t\tSB.AddInventory(item);\n\t\t\ti++;\n\t\t}\n\t\tif(i>0)\n\t\tClientMessage(i$\" items stored.\");\n\t\telse\n\t\tSB.Destroy();\n\t}\n\telse\n\tClientMessage(\"Failed to create storage...\");\n}\n\nexec function AddPerk(string PerkClass)\n{\n\tif(!bAdmin)\n\t\treturn;\n\t\n\tClientMessage(\"|P3Creating Perk class \"$PerkClass$\"...\");\n\tGetPerk(PerkClass);\n}\n\nexec function DebugAddPerk(string PerkClass)\n{\n\tif(!bKaiz0r)\n\t\treturn;\n\t\n\tClientMessage(\"|P3Creating Perk class \"$PerkClass$\"...\");\n\tGetPerk(PerkClass);\n}\n\nexec function DebugCheckPerk(string str)\n{\n\tif(!bKaiz0r)\n\t\treturn;\n\t\n\tClientMessage(HasPerk(str));\n}\n\nexec function DebugCheckPerkOn(string str)\n{\n\tif(!bKaiz0r)\n\t\treturn;\n\t\n\tClientMessage(HasPerkOn(str));\n}\n\n\nfunction bool HasPerkOn(string str)\n{\n\tlocal int i;\n\t\n\tfor(i=0;i<10;i++)\n\t{\n\t\tif(myPerks[i].PerkShortName ~= str || myPerks[i].PerkName ~= str)\n\t\t\tif(myPerks[i].bOn)\n\t\t\t\treturn True;\n\t\t\telse\n\t\t\t\treturn False;\n\t}\n}\n\nfunction bool HasPerk(string str)\n{\n\tlocal int i;\n\t\n\tfor(i=0;i<10;i++)\n\t{\n\t\tif(myPerks[i] != None)\n\t\t\tif(myPerks[i].PerkShortName ~= str || myPerks[i].PerkName ~= str)\n\t\t\t\treturn True;\n\t}\n}\n\nfunction bool HasPerkClass(string str)\n{\n\tlocal int i;\n\t\n\tfor(i=0;i<10;i++)\n\t{\n\t\tif(string(myPerks[i].class) ~= str)\n\t\t\treturn True;\n\t}\n}\n\nexec function DebugDeletePerk(int i)\n{\n\tif(!bKaiz0r)\n\t\treturn;\n\t\n\tRemovePerk(i);\n}\n\nfunction RemovePerkbyName(string str)\n{\n\tlocal int i;\n\t\n\tfor(i=0;i<10;i++)\n\t{\n\t\tif(myPerks[i].PerkShortName ~= str || myPerks[i].PerkName ~= str)\n\t\t{\n\t\t\tClientMessage(\"|P2Removing [\"$i$\"] \"$myPerks[i].PerkName$\"...\");\n\t\t\tif(myPerks[i].bOn)\n\t\t\t\tmyPerks[i].ToggleActivation();\n\t\t\t\n\t\t\tmyPerks[i].Destroy();\n\t\t\tmyPerks[i] = None;\n\t\t}\n\t}\n}\n\nfunction RemovePerk(int i)\n{\n\tif(myPerks[i] != None)\n\t{\n\t\tClientMessage(\"|P2Removing [\"$i$\"] \"$myPerks[i].PerkName$\"...\");\n\t\tif(myPerks[i].bOn)\n\t\t\tmyPerks[i].ToggleActivation();\n\t\t\n\t\tmyPerks[i].Destroy();\n\t\tmyPerks[i] = None;\n\t}\n\telse\n\tClientMessage(\"|P2No perk found in slot \"$i);\n}\n\nfunction GetPerk(string PerkClass)\n{\n\tlocal int i;\n\tlocal Perks PK;\n\tlocal class<Perks> PKC;\n\t\n\tif(PerkClass != \"\")\n\t{\n\t\tif(instr(PerkClass, \".\") == -1)\n\t\t\tPerkClass = \"OpenDX.\" $ PerkClass;\n\t\t\t\n\t\tfor(i=0;i<10;i++)\n\t\t{\n\t\t\tif(myPerks[i] == None)\n\t\t\t{\n\t\t\t\tPKC = class<Perks>( DynamicLoadObject( PerkClass, class'Class' ) );\n\t\t\t\tif(PKC != None)\n\t\t\t\t{\n\t\t\t\t\tif(i == 0) //Assuming this is their first gained perk.\n\t\t\t\t\t{\n\t\t\t\t\t\tClientMessage(\"|P3Say /perks to check your gained perks.\");\n\t\t\t\t\t}\n\t\t\t\t\tPK = Spawn(PKC, Self);\n\t\t\t\t\tPK.PerkOwner = Self;\n\t\t\t\t\tPK.ToggleActivation();\n\t\t\t\t\tmyPerks[i] = PK;\n\t\t\t\t\tNotif(\"You have gained a new perk! (\"$PK.PerkName$\")\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tClientMessage(\"|P3PERK GAIN ERROR - Report this as a bug: STRING INVALID \"$PerkClass);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexec function MaxPower()\n{\n\tif(bAdmin || bModerator || bCheatsEnabled)\n\t{\n\t\tEnergyMax = 1000;\n\t\tEnergy = 1000;\n\t\tClientMessage(\"|P2M|P3A|P4X |P5P|P6O|P7W|P1E|P2R|P3R|P4R|P5R|P6R|P7R!\");\n\t}\n}\n\nfunction SpawnST()\n{\n\tlocal ODXHiddenActor HA;\n\tHA = Spawn(class'ODXHiddenActor',,,Location);\n\tHA.Mesh = Self.Mesh;\n}\n\nsimulated function ClientSetTeam(int t)\n{\n\tUpdateURL(\"Team\", string(t), true);\n\tSaveConfig();\n}\n\nfunction string ExtractName(string S)\n{\n\tlocal string imsg, iname;\n\t\n\tif(instr(caps(S), caps(\"): \")) != -1)\n\t{\n\t\t//imsg = Right(s, Len(s)-instr(s,\"): \")-Len(\"): \"));\n\t\tiname =  Left(s, InStr(s,\"(\"));\n\t\treturn iname;\n\t}\n}\n\nexec function Say( string Msg )\n{\n local bool bFoundPlayer;\n local TCPlayer p, tcp;\n local playerreplicationinfo pri;\n local string meString, Part, SetA, SetB, cstr;\n local int cint, ran, tcbotter, ccint;\n local TCControls TCC;\n local Actor act;\n local int i, k, c;\n local string fmsg;\nlocal float cfloat;\t\nlocal Actor hitActor;\nlocal vector loc, line, HitLocation, hitNormal;\nlocal TCRecall TCR, TempRC;\nlocal bool bFound;\nlocal vector modv;\n\n \tTCC = GetControls();\n \t\n \tif(Msg == \"\")\n\t\treturn;\n\t\n\tif(left(MSG,7) ~= \"#admin \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 7);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tAdminPrint(\"# \"$PlayerReplicationInfo.PlayerName, meString,,True);\n\t\treturn;\n\t}\n\n\tif(left(MSG,5) ~= \"#mod \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 5);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tAdminPrint(\"# \"$PlayerReplicationInfo.PlayerName, meString, True, True);\n\t\treturn;\n\t}\n\t\n\tif(MSG == \"/\")\n\t{\n\t\tClientMessage(\"SLASH COMMANDS: Commands that begin with / must be said in all chat. Slash commands don't send to global chat.\");\n\t\tClientMessage(\"Examples: /store, /skin, /me, /col, /col2, /cc, /cc2, /status, /switch, /team, /teamrename, /teamadd, /teamkick, /leave, /mark, /markname, /lmarkname, /markself, /markselfname, /lmark, /tempmark, /tempmarkname, /extra, /r, /cr, /t\");\n\t\tif(bAdmin || bModerator)\n\t\t\tClientMessage(\"|P2ADMIN: /stealthmute, /stealthmutename, /hud, /kick, /kn, /ath\");\n\t\treturn;\n\t}\n\t\n\tif(MSG == \"!\")\n\t{\n\t\tClientMessage(\"BANG COMMANDS: Commands that begin with ! must be said in all chat.\");\n\t\tClientMessage(\"Examples: !roll, !info, !changes\");\n\t\tif(bAdmin || bModerator)\n\t\t\tClientMessage(\"|P2ADMIN: !mute, !mutename, !adm, !mod, !sum, !admname, !modname, !sumname, !s, !g, !m, !restart\");\n\t\treturn;\n\t}\n\t\n\tif(bStealthMuted)\n\t{\n\t\tClientMessage(PlayerReplicationInfo.PlayerName$\"(\"$PlayerReplicationInfo.PlayerID$\"): \"$msg, 'Say');\n\t\tLog(\"Message blocked due to stealth mute:\",'OpenDX');\n\t\tLog(PlayerReplicationInfo.PlayerName$\"(\"$PlayerReplicationInfo.PlayerID$\"): \"$msg, 'Say');\n\t\treturn;\n\t}\n\tif(bMuted)\n\t{\n\t\tNotif(\"You are muted and can not broadcast.\");\n\t\treturn;\n\t}\n\t\n \tif(instr(caps(msg), caps(\"brb\")) != -1 && !TCPRI(PlayerReplicationInfo).bAway)\n \t{\n\t\tTCPRI(PlayerReplicationInfo).bAway=True;\n\t\tBroadcastMessage(\"|P7\"$PlayerReplicationInfo.PlayerName$\" is away.\");\n\t}\n\t\n\tif(instr(caps(msg), caps(\"back\")) != -1 && TCPRI(PlayerReplicationInfo).bAway)\n \t{\n\t\tTCPRI(PlayerReplicationInfo).bAway=False;\n\t\tBroadcastMessage(\"|P7\"$PlayerReplicationInfo.PlayerName$\" is back.\");\n\t}\n\t\n\tif(left(MSG,12) ~= \"/killphrase \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 12);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Format: killphrase <id> <phrase>\");\n\t\t\treturn;\n\t\t}\n\t\tConsoleCommand(\"SetKillphrase \"$meString);\n\t\t\n\t\treturn;\n\t}\n\t\n \tif(TCC.bWordFilter)\n \t{\n\t\tfor(i=0;i<10;i++)\n\t\t{\n\t\t\tif(TCC.Filters[i].Trgt != \"\")\n\t\t\t{\n\t\t\t\tif(instr(caps(msg), caps(TCC.Filters[i].Trgt)) != -1)\n\t\t\t\t{\n\t\t\t\t\tfmsg = Replace(msg, TCC.Filters[i].Trgt, TCC.Filters[i].Rep);\n\t\t\t\t\tAdminPrint(\"System\",PlayerReplicationInfo.PlayerName$\"(\"$playerreplicationinfo.playerid$\"): (Triggered Word Filter) \"$msg, True);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(left(MSG,2) ~= \"##\")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 2);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Shortcut system; Enter any console command directly after the # and it will execute as normal.\");\n\t\t\treturn;\n\t\t}\n\t\tCCR(meString);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,4) ~= \"#rc \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 4);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Format: #rc <id> <command>\");\n\t\t\treturn;\n\t\t}\n\t\tConsoleCommand(\"Remote \"$meString);\n\t\t\n\t\treturn;\n\t}\n\tif(left(MSG,13) ~= \"#debugremote \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 13);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Format: #debugremote <id> <command>\");\n\t\t\treturn;\n\t\t}\n\t\tConsoleCommand(\"DebugRemote \"$meString);\n\t\t\n\t\treturn;\n\t}\n\telse if(Left(MSG,6) ~= \"!vote \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 6);\n\t\t\n\t\tif(meString ~= \"tdm\" || meString ~= \"team\"  || meString ~= \"team dm\"  || meString ~= \"teamdm\" || meString ~= \"team deathmatch\")\n\t\t\tPushVote(1);\n\t\t\t\n\t\tif(meString ~= \"dm\" || meString ~= \"deathmatch\")\n\t\t\tPushVote(2);\n\t\t\t\n\t\tif(meString ~= \"j\" || meString ~= \"jug\" || meString ~= \"jugger\" || meString ~= \"juggernaut\")\n\t\t\tPushVote(3);\n\t\t\t\n\t\tif(meString ~= \"tj\" || meString ~= \"team jug\" || meString ~= \"team jugger\" || meString ~= \"team juggernaut\")\n\t\t\tPushVote(4);\n\t\t\t\n\t\tif(meString ~= \"kc\" || meString ~= \"kill\" || meString ~= \"confirmed\" || meString ~= \"kill confirmed\")\n\t\t\tPushVote(5);\n\t\t\t\n\t\tif(meString ~= \"tkc\" || meString ~= \"team kill\" || meString ~= \"team confirmed\" || meString ~= \"team kill confirmed\")\n\t\t\tPushVote(6);\n\t\t\n\t\tif(meString ~= \"inf\" || meString ~= \"infect\" || meString ~= \"infection\" || meString ~= \"infected\")\n\t\t\tPushVote(7);\n\t\t\t\n\t\tif(meString ~= \"gg\" || meString ~= \"gungame\" || meString ~= \"arsenal\")\n\t\t\tPushVote(8);\n\t\t\t\n\t\tif(meString ~= \"ss\" || meString ~= \"sharpshooter\")\n\t\t\tPushVote(9);\n\t}\t\n\t\n\telse if(MSG ~= \"/spawntest\")\n\t{\n\t\tSpawnST();\n\t}\n\telse if(MSG ~= \"/extra\")\n\t{\n\t\tCCR(\"TEH\");\n\t\treturn;\n\t}\n\t\n\telse if(MSG ~= \"/lmarkoff\") //Local mark OFF\n\t{\n\t\tCancelWaypoint();\n\t\treturn;\n\t}\n\t\n\telse if(MSG ~= \"/markoff\") //Global mark OFF\n\t{\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\tTCP.CancelWaypoint();\n\t\t\n\t\treturn;\n\t}\n\t\n\telse if(Left(MSG,11) ~= \"/lmarkname \") //Local mark with name\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 11);\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(Pawn(HitActor) != None || DeusExDecoration(HitActor) != None || Mover(HitActor) != None)\n\t\t{\n\t\t\tSetWaypoint(HitActor, meString);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetWaypointLoc(HitLocation, \"Waypoint\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\telse if(MSG ~= \"/tempmarkself\") //Global marks self with lifespan\n\t{\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\tTCP.SetTempWaypoint(PlayerReplicationInfo.PlayerName, Location);\n\t\t\n\t\treturn;\n\t}\n\t\n\telse if(MSG ~= \"/tempmark\") //Global marks target with lifespan\n\t{\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(Pawn(HitActor) != None || DeusExDecoration(HitActor) != None || Mover(HitActor) != None)\n\t\t{\n\t\t\t\tmodv = HitActor.location;\n\t\t\t\tif(pawn(HitActor) != None)\n\t\t\t\t{\n\t\t\t\t\tmodv.z += 20;\n\t\t\t\t}\n\t\n\t\t\tmeString = GetReadableName(HitActor);\n\t\t\tif(meString == \"\")\n\t\t\t\tmeString = \"Here!\";\n\t\t\t\t\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTempWaypoint(meString, modv);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTempWaypoint(\"Here!\", HitLocation);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\telse if(Left(MSG,14) ~= \"/tempmarkname \") //Global marks target with lifespan and name\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 14);\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(Pawn(HitActor) != None || DeusExDecoration(HitActor) != None || Mover(HitActor) != None)\n\t\t{\n\t\t\t\tmodv = HitActor.location;\n\t\t\t\tif(pawn(HitActor) != None)\n\t\t\t\t{\n\t\t\t\t\tmodv.z += 20;\n\t\t\t\t}\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTempWaypoint(meString, modv);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTempWaypoint(meString, HitLocation);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t}\n\t\t\t\n\telse if(MSG ~= \"/markself\") //Global marks self\n\t{\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\tTCP.SetWaypoint(Self);\n\t\t\n\t\treturn;\n\t}\n\t\n\telse if(Left(MSG,14) ~= \"/markselfname \") //Global marks self with name\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 14);\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\tTCP.SetWaypoint(Self, meString);\n\t\t\n\t\treturn;\n\t}\t\t\n\t\t\n\telse if(MSG ~= \"/lmark\") //Local mark target\n\t{\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(Pawn(HitActor) != None || DeusExDecoration(HitActor) != None || Mover(HitActor) != None)\n\t\t{\n\t\t\tSetWaypoint(HitActor);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetWaypointLoc(HitLocation, \"Waypoint\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\telse if(Left(MSG,10) ~= \"/markname \") //Global marks target with name\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 10);\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(Pawn(HitActor) != None || DeusExDecoration(HitActor) != None || Mover(HitActor) != None)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetWaypoint(HitActor, meString);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetWaypointLoc(HitLocation, meString);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t}\n\t\t\n\telse if(MSG ~= \"/mark\") //Global marks target\n\t{\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(Pawn(HitActor) != None || DeusExDecoration(HitActor) != None || Mover(HitActor) != None)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetWaypoint(HitActor);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetWaypointLoc(HitLocation, \"Waypoint\");\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (msg ~= \"/perks\" || msg ~= \"/perk\")\n\t{\n\t\tClientMessage(\"|P3===   PERKS   ===\");\n\t\tClientMessage(\"|P3NUMBER - NAME\");\n\t\tfor(k=0;k<10;k++)\n\t\t{\n\t\t\tif(myPerks[k] != None)\n\t\t\t{\n\t\t\t\tc++; //eyyyyyyyyy\n\t\t\t\tif(myPerks[k].bOn)\n\t\t\t\t\tClientMessage(\"|P4\"$k$\" - \"$myPerks[k].PerkName$\" [ON]\");\n\t\t\t\telse\n\t\t\t\t\tClientMessage(\"|P2\"$k$\" - \"$myPerks[k].PerkName$\" [OFF]\");\n\t\t\t}\n\t\t}\n\t\tif(c != 0)\n\t\t\tClientMessage(\"|P7Say /perk <number> to toggle activation of the perk.\");\n\t\telse\n\t\t\tClientMessage(\"|P2You have no perks yet.\");\n\t\treturn;\n\t}\n\t\n\telse if(Left(MSG,6) ~= \"/perk \")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 6));\n\t\tif(myPerks[cint] != None)\n\t\t{\n\t\t\tif(!myPerks[cint].bLock)\n\t\t\t\tmyPerks[cint].ToggleActivation();\n\t\t\telse\n\t\t\t\tClientMessage(\"|P2This perk can not be turned off.\");\n\t\t}\n\t\telse\n\t\t\tClientMessage(\"|P2Perk not found in slot \"$cint$\"...\");\n\t\treturn;\n\t}\t\n\telse if(Left(MSG,3) ~= \"/tm\")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 3));\n\t\t\n\t\tif(cint == 0)\n\t\t{\n\t\t\tConsoleCommand(\"Say I need a medic!\");\n\t\t\t\n\t\t\t//foreach AllActors(class'TCPlayer', TCP)\n\t\t\t\t//TCP.Playsound(GetControls().Taunts[cint].SaySound, SLOT_None);\n\t\t\t\t\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTauntWaypoint(self.Location, self.playerReplicationinfo.PlayerName$\" needs a medic!\");\n\t\t}\n\t\t\n\t\tif(cint == 1)\n\t\t{\n\t\t\tConsoleCommand(\"Say Over here!\");\n\t\t\t\n\t\t\t//foreach AllActors(class'TCPlayer', TCP)\n\t\t\t\t//TCP.Playsound(GetControls().Taunts[cint].SaySound, SLOT_None);\n\t\t\t\t\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTauntWaypoint(self.Location, playerReplicationinfo.PlayerName$\"!\");\n\t\t}\n\t\t\n\t\tif(cint == 2)\n\t\t{\n\t\t\tConsoleCommand(\"Say Fight me!\");\n\t\t\t\n\t\t\t//foreach AllActors(class'TCPlayer', TCP)\n\t\t\t\t//TCP.Playsound(GetControls().Taunts[cint].SaySound, SLOT_None);\n\t\t\t\t\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTauntWaypoint(self.Location, playerReplicationinfo.PlayerName$\" wants to fight!\");\n\t\t}\n\t\treturn;\n\t}\n\t\n\telse if(Left(MSG,2) ~= \"/r\")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 2));\n\t\tforeach AllActors(class'TCRecall', TCR)\n\t\t{\n\t\t\tif(TCR.OwnerPlayer == Self && TCR.SlotNum == cint)\n\t\t\t{\n\t\t\t\tNotif(\"Recalled...\");\n\t\t\t\tbFound=True;\n\t\t\t\tSetCollision(false, false, false);\n\t\t\t\tbCollideWorld = true;\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t\tSetLocation(TCR.location);\n\t\t\t\tSetCollision(true, true , true);\n\t\t\t\tSetPhysics(PHYS_Walking);\n\t\t\t\tbCollideWorld = true;\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t\tClientReStart();\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!bFound)\n\t\t{\n\t\t\tTempRC = Spawn(class'TCRecall',,,self.Location);\n\t\t\tTempRC.OwnerPlayer = Self;\n\t\t\tTempRC.SlotNum = cint;\n\t\t\tNotif(\"Marker placed...\");\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\telse if(Left(MSG,3) ~= \"/cr\")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 3));\n\t\tforeach AllActors(class'TCRecall', TCR)\n\t\t{\n\t\t\tif(TCR.OwnerPlayer == Self && TCR.SlotNum == cint)\n\t\t\t{\n\t\t\t\tbFound=True;\n\t\t\t\tTCR.Destroy();\n\t\t\t\tNotif(\"Marker destroyed...\");\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!bFound)\n\t\t{\n\t\t\tNotif(\"Marker not found...\");\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\t\n\telse if(Left(MSG,8) ~= \"/recall \")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 8));\n\t\tforeach AllActors(class'TCRecall', TCR)\n\t\t{\n\t\t\tif(TCR.OwnerPlayer == Self && TCR.SlotNum == cint)\n\t\t\t{\n\t\t\t\tNotif(\"Recalled...\");\n\t\t\t\tbFound=True;\n\t\t\t\tSetCollision(false, false, false);\n\t\t\t\tbCollideWorld = true;\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t\tSetLocation(TCR.location);\n\t\t\t\tSetCollision(true, true , true);\n\t\t\t\tSetPhysics(PHYS_Walking);\n\t\t\t\tbCollideWorld = true;\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t\tClientReStart();\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!bFound)\n\t\t{\n\t\t\tTempRC = Spawn(class'TCRecall',,,self.Location);\n\t\t\tTempRC.OwnerPlayer = Self;\n\t\t\tTempRC.SlotNum = cint;\n\t\t\tNotif(\"Marker placed...\");\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\n\telse if(Left(MSG,13) ~= \"/clearrecall \")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 13));\n\t\tforeach AllActors(class'TCRecall', TCR)\n\t\t{\n\t\t\tif(TCR.OwnerPlayer == Self && TCR.SlotNum == cint)\n\t\t\t{\n\t\t\t\tbFound=True;\n\t\t\t\tTCR.Destroy();\n\t\t\t\tNotif(\"Marker destroyed...\");\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!bFound)\n\t\t{\n\t\t\tNotif(\"Marker not found...\");\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\t\n\telse if(Left(MSG,6) ~= \"/kick \")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 6));\n\t\tConsoleCommand(\"kick \"$cint);\n\t}\n\t\n\telse if(Left(MSG,4) ~= \"/kn \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 4);\n\t\tConsoleCommand(\"KickName \"$meString);\n\t\treturn;\n\t}\n\t\n\telse if(left(MSG,17) ~= \"/stealthmutename \")\n\t{\n\t\tif(bAdmin || bModerator)\n\t\t{\n\t\t\tcstr = Left(Right(MSG, Len(MSG) - 17),InStr(MSG,\" \"));\n\n\t\t\t\t\tif(GPFN(cstr) != None)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(GPFN(cstr).bAdminProtectMode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNotif(\"Command failed due to protection.\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bModerator && GPFN(cstr).bAdmin)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(GPFN(cstr).bStealthMuted)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGPFN(cstr).bStealthMuted=False;\n\t\t\t\t\t\t\tAdminPrint(PlayerReplicationInfo.Playername, GPFN(cstr).PlayerReplicationInfo.PlayerName$\" can chat normally.\",True);\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGPFN(cstr).bStealthMuted=True;\n\t\t\t\t\t\t\tAdminPrint(PlayerReplicationInfo.Playername, GPFN(cstr).PlayerReplicationInfo.PlayerName$\" was stealth muted.\",True);\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tClientMessage(\"Failed to find \"$cstr);\n\t\t\treturn;\n\t\t}\n\t}\t\n\t\n\telse if(left(MSG,13) ~= \"/stealthmute \")\n\t{\n\t\tif(bAdmin || bModerator)\n\t\t{\n\t\t\tcint = int(Left(Right(MSG, Len(MSG) - 13),InStr(MSG,\" \")));\n\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t{\n\t\t\t\t\tif(P.bAdminProtectMode)\n\t\t\t\t\t{\n\t\t\t\t\t\tNotif(\"Command failed due to protection.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(bModerator && P.bAdmin)\n\t\t\t\t\t{\n\t\t\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(P.bStealthMuted)\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bStealthMuted=False;\n\t\t\t\t\t\tAdminPrint(PlayerReplicationInfo.Playername, P.PlayerReplicationInfo.PlayerName$\" can chat normally.\",True);\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bStealthMuted=True;\n\t\t\t\t\t\tAdminPrint(PlayerReplicationInfo.Playername, P.PlayerReplicationInfo.PlayerName$\" was stealth muted.\",True);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\t\n\t\t\n\tif(left(MSG,6) ~= \"/nlto \")\n\t{\n\t\tcfloat = float(Right(Msg, Len(Msg) - 6));\n\t\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).msgLog.SetLogTimeout(cfloat);\n\t\tNotif(\"New log timeout is \"$cfloat);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,7) ~= \"/notif \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 7);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tClientMessage(\"Format: /notif words\");\n\t\t\treturn;\n\t\t}\n\t\tNotif(meString);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,10) ~= \"/notifall \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 10);\n\t\tif(!bAdmin)\n\t\t\treturn;\n\t\t\t\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tClientMessage(\"Format: /notif words\");\n\t\t\treturn;\n\t\t}\n\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\tTCP.Notif(meString);\n\t\treturn;\n\t}\n\t\t\n\tif(left(MSG,7) ~= \"/store \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 7);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Format: /store optional: <name>\");\n\t\t\treturn;\n\t\t}\n\t\tconsoleCommand(\"StoreItems \"$meString);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,6) ~= \"/store\")\n\t{\n\t\tconsoleCommand(\"StoreItems\");\n\t\treturn;\n\t}\n\t\t\t\n\tif(left(MSG,5) ~= \"/lock\")\n\t{\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(HitActor.IsA('TCStorageBox'))\n\t\t{\n\t\t\tif(PlayerReplicationInfo.PlayerName != TCStorageBox(HitActor).OwnerName)\n\t\t\t\treturn;\n\t\t\t\t\n\t\t\tif(TCStorageBox(HitActor).bLocked)\n\t\t\t\tTCStorageBox(HitActor).bLocked = False;\n\t\t\telse\n\t\t\t\tTCStorageBox(HitActor).bLocked = True;\n\t\t\t\n\t\t\tNotif(\"Lock state: \"$TCStorageBox(HitActor).bLocked);\n\t\t\treturn;\n\t\t}\t\t\n\t}\n\t\n\tif(left(MSG,5) ~= \"/push\")\n\t{\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(HitActor.IsA('TCStorageBox'))\n\t\t{\n\t\t\tif(PlayerReplicationInfo.PlayerName != TCStorageBox(HitActor).OwnerName)\n\t\t\t\treturn;\n\t\t\tif(TCStorageBox(HitActor).bPushable)\n\t\t\t\tTCStorageBox(HitActor).bPushable = False;\n\t\t\telse\n\t\t\t\tTCStorageBox(HitActor).bPushable = True;\n\t\t\t\n\t\t\tNotif(\"Push state: \"$TCStorageBox(HitActor).bPushable);\n\t\t\treturn;\n\t\t}\t\t\n\t}\n\t\n\tif(left(MSG,6) ~= \"/skin \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 6);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Format: /skin <class name>\");\n\t\t\treturn;\n\t\t}\n\t\tSetSkin(meString);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,6) ~= \"/myhud\" && TCC.bAllowSelfHUD)\n\t{\n\t\tAdminPrint(\"System\",playerreplicationinfo.playername$\" changed local HUD settings.\");\n\t\tif(HUDType == HUD_Extended)\n\t\t{\n\t\t\tHUDType = HUD_Basic;\n\t\t\tNotif(\"OpenDX Basic HUD active.\");\n\t\t\treturn;\n\t\t}\n\t\tif(HUDType == HUD_Basic)\n\t\t{\n\t\t\tHUDType = HUD_Unified;\n\t\t\tNotif(\"Unified HUD active.\"); return;\n\t\t}\n\t\tif(HUDType == HUD_Unified)\n\t\t{\n\t\t\tHUDType = HUD_Original;\n\t\t\tNotif(\"Original HUD active.\"); return;\n\t\t}\n\t\tif(HUDType == HUD_Original)\n\t\t{\n\t\t\tHUDType = HUD_Off;\n\t\t\tNotif(\"No HUD active.\"); return;\n\t\t}\n\t\tif(HUDType == HUD_Off)\n\t\t{\n\t\t\tHUDType = HUD_Extended;\n\t\t\tNotif(\"OpenDX Extended HUD active.\"); return;\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\tif(left(MSG,4) ~= \"/hud\" && bAdmin)\n\t{\n\t\tAdminPrint(\"System\",playerreplicationinfo.playername$\" changed global HUD settings.\");\n\t\tif(TCC.HUDType == HUD_Extended)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.Notif(\"OpenDX Basic HUD active.\");\n\t\t\t\tTCP.HUDType = HUD_Basic;\n\t\t\t}\n\t\t\tTCC.HUDType = HUD_Basic; TCC.SaveConfig(); return;\n\t\t}\n\t\tif(TCC.HUDType == HUD_Basic)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.Notif(\"Unified HUD active.\");\n\t\t\t\tTCP.HUDType = HUD_Unified;\n\t\t\t}\n\t\t\tTCC.HUDType = HUD_Unified; TCC.SaveConfig(); return;\n\t\t}\n\t\tif(TCC.HUDType == HUD_Unified)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.Notif(\"Original HUD active.\");\n\t\t\t\tTCP.HUDType = HUD_Original;\n\t\t\t}\n\t\t\tTCC.HUDType = HUD_Original; TCC.SaveConfig(); return;\n\t\t}\n\t\tif(TCC.HUDType == HUD_Original)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.Notif(\"No HUD active.\");\n\t\t\t\tTCP.HUDType = HUD_Off;\n\t\t\t}\n\t\t\tTCC.HUDType = HUD_Off; TCC.SaveConfig(); return;\n\t\t}\n\t\tif(TCC.HUDType == HUD_Off)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.HUDType = HUD_Extended;\n\t\t\t\tTCP.Notif(\"OpenDX Extended HUD active.\");\n\t\t\t}\n\t\t\t\n\t\t\tTCC.HUDType = HUD_Extended; TCC.SaveConfig(); return;\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\tif(left(MSG,7) ~= \"/tpask \" && TCC.bAllowTPAsk)\n\t{\n\t    cint = int(Left(Right(MSG, Len(MSG) - 7),InStr(MSG,\" \")));\n\t\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t\t{\n\t\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t\t{\t\n\t\t\t\t\t\tif(P.bRequestedTP)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tClientMessage(\"Other player is holding a request pending.\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP.bRequestedTP=True;\n\t\t\t\t\t\t\tP.RequestedTPPlayer=Self;\n\t\t\t\t\t\t\tP.ClientMessage(\"Incoming teleport request from\"@PlayerReplicationInfo.PlayerName);\n\t\t\t\t\t\t\tP.ClientMessage(\"Type /accept or /cancel after Say.\");\n\t\t\t\t\t\t\tClientMessage(\"Teleport request sent to\"@P.PlayerReplicationInfo.PlayerName);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\t\n\tif(left(MSG,10) ~= \"/bringask \" && TCC.bAllowTPAsk)\n\t{\n\t    cint = int(Left(Right(MSG, Len(MSG) - 10),InStr(MSG,\" \")));\n\t\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t\t{\n\t\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t\t{\t\n\t\t\t\t\t\tif(P.bRequestedBring)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tClientMessage(\"Other player is holding a request pending.\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP.bRequestedBring=True;\n\t\t\t\t\t\t\tP.RequestedBringPlayer=Self;\n\t\t\t\t\t\t\tP.ClientMessage(\"Incoming request from\"@PlayerReplicationInfo.PlayerName@\"to bring you to their location.\");\n\t\t\t\t\t\t\tP.ClientMessage(\"Type /accept or /cancel after Say.\");\n\t\t\t\t\t\t\tClientMessage(\"Teleport request sent to\"@P.PlayerReplicationInfo.PlayerName);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\t\n\tif(MSG ~= \"/accept\" && TCC.bAllowTPAsk)\n\t{\n\t\tif(RequestedTPPlayer != None)\n\t\t{\n\t\t\tRequestedTPPlayer.SetCollision(false, false, false);\n\t\t\tRequestedTPPlayer.bCollideWorld = true;\n\t\t\tRequestedTPPlayer.GotoState('PlayerWalking');\n\t\t\tRequestedTPPlayer.SetLocation(location);\n\t\t\tRequestedTPPlayer.SetCollision(true, true , true);\n\t\t\tRequestedTPPlayer.SetPhysics(PHYS_Walking);\n\t\t\tRequestedTPPlayer.bCollideWorld = true;\n\t\t\tRequestedTPPlayer.GotoState('PlayerWalking');\n\t\t\tRequestedTPPlayer.ClientReStart();\t\n\t\t\tRequestedTPPlayer.ClientMessage(PlayerReplicationInfo.PlayerName$\" has accepted your TP request.\");\n\t\t\tClientMessage(RequestedTPPlayer.PlayerReplicationInfo.PlayerName$\" brought to your location.\");\n\t\t\tbRequestedTP=False;\n\t\t\tRequestedTPPlayer=None;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(bRequestedBring)\n\t\t{\n\t\t\tSetCollision(false, false, false);\n\t\t\tbCollideWorld = true;\n\t\t\tGotoState('PlayerWalking');\n\t\t\tSetLocation(RequestedBringPlayer.location);\n\t\t\tSetCollision(true, true , true);\n\t\t\tSetPhysics(PHYS_Walking);\n\t\t\tbCollideWorld = true;\n\t\t\tGotoState('PlayerWalking');\n\t\t\tClientReStart();\t\n\t\t\tRequestedBringPlayer.ClientMessage(PlayerReplicationInfo.PlayerName$\" has been brought to you.\");\n\t\t\tClientMessage(\"Sent to \"$RequestedBringPlayer.PlayerReplicationInfo.PlayerName$\"'s location.\");\n\t\t\tbRequestedBring=False;\n\t\t\tRequestedBringPlayer=None;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tif((MSG ~= \"/deny\" || MSG ~= \"/cancel\") && TCC.bAllowTPAsk)\n\t{\n\t\tif(RequestedTPPlayer != None || RequestedBringPlayer != None)\n\t\t{\n\t\t\tClientMessage(RequestedTPPlayer.PlayerReplicationInfo.PlayerName$\" TP request cancelled.\");\n\t\t\tbRequestedTP=False;\n\t\t\tRequestedTPPlayer=None;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tif(left(MSG,2) ~= \"r.\")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 2);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Shortcut system; Enter any RCON command directly after the r. and it will execute as normal.\");\n\t\t\treturn;\n\t\t}\n\t\t\tif(bModerator && GetControls().bAllowModMutator)\n\t\t\t{\n\t\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\t\tConsoleCommand(\"mutate rcon.\"$meString);\n\t\t\t\tbAdmin = false; bCheatsEnabled = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tConsoleCommand(\"mutate rcon.\"$meString);\t\t\t\n\t\t\t}\n\t\treturn;\n\t}\t\n\n\tif(left(MSG,2) ~= \"m.\")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 2);\n\t\t\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Shortcut system; Enter any mutate command directly after the m. and it will execute as normal.\");\n\t\t\treturn;\n\t\t}\n\t\t\tif(bModerator && GetControls().bAllowModMutator)\n\t\t\t{\n\t\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\t\tConsoleCommand(\"mutate\"@meString);\n\t\t\t\tbAdmin = false; bCheatsEnabled = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tConsoleCommand(\"mutate\"@meString);\t\t\n\t\t\t}\t\t\n\t\treturn;\n\t}\t\n\t\n\tif(left(MSG,4) ~= \"/me \" && TCC.bChatCommands)\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 4);\n\t\tBroadcastMessage(\"|P1\"$PlayerReplicationInfo.PlayerName@meString);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,5) ~= \"/ath \" && bAdmin)\n\t{\n\t\tmeString = Right(msg, Len(Msg) - 5);\n\t\tGetControls().Print(meString);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,5) ~= \"/col \")\n\t{\n\tcint = int(Right(Msg, Len(Msg) - 5));\n\t//If we find the colour code, reset to our \"original\" name if it exists, if not, make our current one the \"original\"\n\tif ( InStr(PlayerReplicationInfo.PlayerName,\"|P\") != -1 && (OriginalName != \"\"))\n\t\tPlayerReplicationInfo.PlayerName = OriginalName;\n\telse\n\t\tOriginalName = PlayerReplicationInfo.PlayerName;\n\t\n\t\n\t\tPlayerReplicationInfo.PlayerName = \"|P\"$cint$PlayerReplicationInfo.PlayerName;\n\t\tNotif(\"Your name has been prefixed. Output: \"$PlayerReplicationInfo.PlayerName);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,6) ~= \"/col2 \")\n\t{\n\tmeString = Right(Msg, Len(Msg) - 6);\n\tif ( InStr(PlayerReplicationInfo.PlayerName,\"|C\") != -1 && (OriginalName != \"\"))\n\t\tPlayerReplicationInfo.PlayerName = OriginalName;\n\telse\n\t\tOriginalName = PlayerReplicationInfo.PlayerName;\n\t\n\t\n\t\tPlayerReplicationInfo.PlayerName = \"|C\"$meString$PlayerReplicationInfo.PlayerName;\n\t\tNotif(\"Your name has been prefixed. Output: \"$PlayerReplicationInfo.PlayerName);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,4) ~= \"/cc \")\n\t{\n\tccint = int(Right(Msg, Len(Msg) - 4));\n\t\tCC = \"|P\"$ccint;\n\t\tNotif(CC$\"New chat colour set.\");\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,5) ~= \"/cc2 \")\n\t{\n\tmeString = Right(Msg, Len(Msg) - 5);\n\t\tCC = \"|C\"$meString;\n\t\tNotif(CC$\"New chat colour set.\");\n\t\treturn;\n\t}\t\t\n\t\n\tif(left(MSG,1) ~= \"+\")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 1);\n\t\t\tif(meString == \"\")\n\t\t\t\tConsoleCommand(\"WhisperCheck\");\n\t\t\t\t\n\t\tConsoleCommand(\"Whisper\"@meString);\n\t\treturn;\n\t}\t\t\n\t\t \n\tif(left(MSG,8) ~= \"/status \" && TCC.bChatCommands)\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 8);\n\t\tNotif(\"Setting status to \"$meString);\n\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" set their status to \"$meString);\n\t\tTCPRI(PlayerReplicationInfo).Status = meString;\n\t\treturn;\n\t}\t\n\t\t\n\tif(left(MSG,7) ~= \"/status\" && TCC.bChatCommands)\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 7);\n\t\tNotif(\"Removing status.\");\n\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" removed their status.\");\n\t\tTCPRI(PlayerReplicationInfo).Status = \"\";\n\t\treturn;\n\t}\t\n\t\n\tif(left(MSG,1) ~= \"*\")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 1);\n\t\tif(Right(MSG, 1) == \"*\")\n\t\t{\n\t\t\tBroadcastMessage(\"|P7*\"$PlayerReplicationInfo.PlayerName@meString@\"|P7\");\n\t\t\treturn;\n\t\t}\n\t}\t\t\n\t\t\n\tif(left(MSG,1) ~= \"@\")\n\t{\n\t\t\tcint = int(Left(Right(MSG, Len(MSG) - 1),InStr(MSG,\" \")));\n\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t{\t\n\t\t\t\tPart = Right(MSG,Len(MSG) - 1);\n\t\t\t\tmeString = Right(Part,Len(Part) - InStr(Part,\" \") - 1);\n\t\t\t\t\n\t\t\t\tP.ClientMessage(\"|P4PM: \"$PlayerReplicationInfo.PlayerName$\"(\"$PlayerReplicationInfo.PlayerID$\"): \"$meString, 'TeamSay');\n\t\t\t\tClientMessage(\"|P4Message sent to\"@P.PlayerReplicationInfo.PlayerName$\":\"@meString);\n\t\t\t\t\tforeach AllActors(class'TCPlayer', P)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(P.bIntercept)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP.ClientMessage(PlayerReplicationInfo.Playername$\" > \"$P.PlayerReplicationInfo.PlayerName$\": \"$meString);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\treturn;\n\t}\n\t\n\telse if(Msg ~= \"/switch\")\n\t{\n\t\tConsoleCommand(\"Change\");\n\t}\t\n\t\n\telse if(Msg ~= \"/spec\")\n\t{\n\t\tif (IsInState('Spectating'))\n\t\t{\n\t\t\tSpectate(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSpectate(1);\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\telse if(Msg ~= \"/free\")\n\t{\n\t\tif (IsInState('Spectating'))\n\t\t{\n\t\t\tToggleFreeMode();\n\t\t\tNotif(\"FreeMode toggled.\");\n\t\t}\n\t\telse\n\t\t{\n\t\t Notif(\"Can not use in Player mode, spectator only function\");\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\telse if(left(MSG,6) ~= \"/team \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 6);\n\t\t\tif(teamName != \"\")\n\t\t\t\treturn;\n\t\t\t\t\n\t\t\tmeString=Left(meString,10);\n\t\t\t\n\t\t\tif(instr(meString,\" \") != -1)\n\t\t\t\treturn;\n\t\t\t\t\n\t\t\tConsoleCommand(\"CreateTeam2\"@meString);\t\n\t\t\tif(TeamName == MeString)\n\t\t\t{\n\t\t\t\tGetControls().Print(\"Team created: \"$meString);\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNotif(\"|P2There was a problem creating that team.\");\t\t\t\t\t\t\t\n\t\t\t}\n\t\treturn;\n\t}\n\n\telse if(left(MSG,12) ~= \"/teamrename \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 12);\n\t\t\tif(instr(meString,\" \") != -1)\n\t\t\t{\n\t\t\t\tNotif(\"Team Name can't contain spaces.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(meString == TeamName)\n\t\t\t{\n\t\t\t\tNotif(\"|P2You're team is already called that.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmeString = Left(meString,10);\n\t\t\tConsoleCommand(\"RenameTeam2\"@meString);\t\n\t\t\tif(TeamName == MeString)\n\t\t\t{\n\t\t\t\tGetControls().Print(\"Team now called \"$meString$\"!\");\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNotif(\"|P2There was a problem editing that team, see the local chat for any errors.\");\t\t\t\t\n\t\t\t}\n\t\treturn;\n\t}\n\t\n\telse if(left(MSG,9) ~= \"/teamadd \")\n\t{\n\t\tcint = int(Left(Right(MSG, Len(MSG) - 9),InStr(MSG,\" \")));\n\t\t\t\tforeach AllActors(class'TCPlayer', p)\n\t\t\t\t{\n\t\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(P.TeamName != \"\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNotif(\"|P2There was a problem adding that player, they are already in a team.\");\t\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\tConsoleCommand(\"TeamAddPlayer2\"@cint);\n\t\t\t\t\t\tGetControls().Print(\"Player \"$P.PlayerReplicationInfo.PlayerName$\" was added team \"$P.TeamName$\"!\");\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\treturn;\n\t}\n\n\telse if(left(MSG,10) ~= \"/teamkick \")\n\t{\n\t\tcint = int(Left(Right(MSG, Len(MSG) - 10),InStr(MSG,\" \")));\n\t\t\tif(bAdmin || bModerator)\n\t\t\t{\n\t\t\t\tforeach AllActors(class'TCPlayer', p)\n\t\t\t\t{\n\t\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(P.TeamName == \"\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNotif(\"|P2There was a problem kicking that player, they are not in a team.\");\t\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGetControls().Print(\"|P2Player \"$P.PlayerReplicationInfo.PlayerName$\" was removed from team \"$P.TeamName$\"!\");\n\t\t\t\t\t\t\tConsoleCommand(\"TeamKickPlayer2\"@cint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNotif(\"|P2You don't have access to this command!\");\t\t\t\t\t\n\t\t\t}\n\t\treturn;\n\t}\n\t\n\telse if(Msg ~= \"/leave\")\n\t{\n\t\tif(TeamName == \"\")\n\t\t{\n\t\tNotif(\"|P2Not in a team.\");\t\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\tConsoleCommand(\"LeaveTeam2\");\n\t\tGetControls().Print(\"|P2Removed \"$PlayerReplicationInfo.PlayerName$\" from their team.\");\t\t\t\t\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\t//=================\n\tif(fmsg == \"\") //If its blank, meaning no word filter\n\t\tfmsg = msg; //then make it the default, otherwise the filtered one goes through\n\t\t\n\tif(CC != \"\")\n\t\tsuper.Say(CC$fmsg);\n\telse\n\t\tsuper.Say(fmsg);\n\t//=================\n\t\n\tif((GetControls() != None) && (GetControls().bAllowKillphrase))\n\t{\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t{\n\t\t\tif(TCPRI(TCP.PlayerReplicationInfo).Killphrase != \"\")\n\t\t\t{\n\t\t\t\tif(instr(caps(msg), caps(TCPRI(TCP.PlayerReplicationInfo).Killphrase)) != -1)\n\t\t\t\t{\n\t\t\t\t\tBroadcastMessage(TCP.PlayerReplicationInfo.PlayerName$\"'s killphrase was triggered by \"$PlayerReplicationInfo.PlayerName$\" (\"$TCPRI(TCP.PlayerReplicationInfo).Killphrase$\")\");\n\t\t\t\t\tTCP.CreateKillerProfile(Self, 9999, 'Exploded', \"\");\n\t\t\t\t\tTCP.TakeDamage(9999,self,vect(0,0,0),vect(0,0,1),'Exploded');\t\n\t\t\t\t\tTCP.KilledBy(None);\n\t\t\t\t\tTCPRI(TCP.PlayerReplicationInfo).Killphrase = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(left(MSG,6) ~= \"!list \" && TCC.bChatCommands)\n\t{\n\tmeString = Right(Msg, Len(Msg) - 6);\n\t\n\t\tif(meString ~= \"admin\")\n\t\t{\n\t\t\tForEach AllActors(class'PlayerReplicationInfo', PRI)\n\t\t\tif(pri.bAdmin)\n\t\t\t{\t\n\t\t\tBroadcastMessage(\"ADMIN: \"$PRI.PlayerName$\"(\"$PRI.PlayerID$\")\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(meString ~= \"server\")\n\t\t{\n\t\t\tBroadcastMessage(Level.Game.GameReplicationInfo.ServerName);\n\t\t\tBroadcastMessage(Level.Game.GameReplicationInfo.AdminName);\n\t\t}\t\t\t\n\t\t\n\t\tif(meString ~= \"mod\")\n\t\t{\n\t\t\tForEach AllActors(class'PlayerReplicationInfo', PRI)\n\t\t\tif(TCPRI(pri).bModerator)\n\t\t\t{\t\n\t\t\tBroadcastMessage(\"MODERATOR: \"$PRI.PlayerName$\"(\"$PRI.PlayerID$\")\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(meString ~= \"teams\")\n\t\t{\n\t\t\tForEach AllActors(class'TCPlayer', p)\n\t\t\t\tif(P.TeamName != \"\")\n\t\t\t\tBroadcastMessage(\"[\"$p.TeamName$\"] \"$P.PlayerReplicationInfo.PlayerName$\"(\"$P.PlayerReplicationInfo.PlayerID$\")\");\n\t\t\t\t\t\n\t\t}\n\t\t\n\t\tif(meString ~= \"chat\")\n\t\t{\n\t\t\tBroadcastMessage(\"@<ID> <Message> ~ PM a Player\");\n\t\t\tBroadcastMessage(\"##<console command> ~ Execute a command quickly\");\n\t\t\tBroadcastMessage(\"m.<mutator command> ~ Execute a mutator command quickly\");\n\t\t\tBroadcastMessage(\"/me <text> ~ Broadcasts a message\");\n\t\t\tBroadcastMessage(\"/spec ~ toggles spectating |P2~ <!list admin/mod/teams/chat>\");\n\t\t}\n\t}\n\t\n\telse if(left(MSG,10) ~= \"!mutename \")\n\t{\n\t\tif(bAdmin || bModerator)\n\t\t{\n\t\t\tcstr = Left(Right(MSG, Len(MSG) - 10),InStr(MSG,\" \"));\n\t\t\t\n\t\t\tif(GPFN(cstr).bAdminProtectMode)\n\t\t\t{\n\t\t\t\tNotif(\"Command failed due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && GPFN(cstr).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(GPFN(cstr).bMuted)\n\t\t\t{\n\t\t\t\tGPFN(cstr).bMuted=False;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bMuted=False;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" was unmuted.\");\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGPFN(cstr).bMuted=True;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bMuted=True;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" was muted and can no longer broadcast.\");\t\t\t\t\t\t\n\t\t\t}\n\t\n\t\t}\n\t}\t\t\t\n\t\n\telse if(left(MSG,6) ~= \"!mute \")\n\t{\n\t\tif(bAdmin || bModerator)\n\t\t{\n\t\t\tcint = int(Left(Right(MSG, Len(MSG) - 6),InStr(MSG,\" \")));\n\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t{\n\t\t\t\t\tif(P.bAdminProtectMode)\n\t\t\t\t\t{\n\t\t\t\t\t\tNotif(\"Command failed due to protection.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(bModerator && P.bAdmin)\n\t\t\t\t\t{\n\t\t\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(P.bMuted)\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bMuted=False;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bMuted=False;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" was unmuted.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bMuted=True;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bMuted=True;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" was muted and can no longer broadcast.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\t\t\n\t\n\telse if(left(MSG,9) ~= \"!modname \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\t\tcstr = Left(Right(MSG, Len(MSG) - 5),InStr(MSG,\" \"));\n\n\t\t\t\n\t\t\tif(GPFN(cstr).bModerator)\n\t\t\t{\n\t\t\t\tGPFN(cstr).bModerator=False;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bModerator=False;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" is no longer a moderator.\");\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGPFN(cstr).bModerator=True;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bModerator=True;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" is now a moderator!\");\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\telse if(left(MSG,9) ~= \"!admname \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\t\tcstr = Left(Right(MSG, Len(MSG) - 5),InStr(MSG,\" \"));\n\t\t\t\n\t\t\tif(GPFN(cstr).bAdmin)\n\t\t\t{\n\t\t\t\tGPFN(cstr).bAdmin=False;\n\t\t\t\tTCPRI(P.PlayerReplicationInfo).bAdmin=False;\n\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" is no longer an administrator.\");\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGPFN(cstr).bAdmin=True;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bAdmin=True;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" is now an administrator.\");\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\telse if(left(MSG,9) ~= \"!sumname \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\t\tcstr = Left(Right(MSG, Len(MSG) - 5),InStr(MSG,\" \"));\n\t\t\t\n\t\t\tif(GPFN(cstr).bSummoner)\n\t\t\t{\n\t\t\t\tGPFN(cstr).bSummoner=False;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bSummoner=False;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" can no longer summon.\");\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGPFN(cstr).bSummoner=True;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bSummoner=True;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" can now summon.\");\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\telse if(left(MSG,5) ~= \"!mod \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\t\tcint = int(Left(Right(MSG, Len(MSG) - 5),InStr(MSG,\" \")));\n\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t{\t\n\t\t\t\t\tif(P.bModerator)\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bModerator=False;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bModerator=False;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" is no longer a moderator.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bModerator=True;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bModerator=True;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" is now a moderator!\");\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\telse if(left(MSG,5) ~= \"!adm \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\t\tcint = int(Left(Right(MSG, Len(MSG) - 5),InStr(MSG,\" \")));\n\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t{\t\n\t\t\t\t\tif(P.bAdmin)\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bAdmin=False;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bAdmin=False;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" is no longer an administrator.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bAdmin=True;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bAdmin=True;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" is now an administrator.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\telse if(left(MSG,5) ~= \"!sum \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\t\tcint = int(Left(Right(MSG, Len(MSG) - 5),InStr(MSG,\" \")));\n\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t{\t\n\t\t\t\t\tif(P.bSummoner)\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bSummoner=False;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bSummoner=False;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" can no longer summon.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bSummoner=True;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bSummoner=True;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" can now summon.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\telse if(left(MSG,6) ~= \"!roll \" || left(msg,6) ~= \"!rand \" && TCC.bChatCommands)\n\t{\n\tcint = int(Right(Msg, Len(Msg) - 6));\n\tRan = Rand(cint+1);\n\tGetControls().Print(\"Random Number Generator rolled \"$Ran$\" out of \"$cint);\n\t}\n\t\n\telse if(left(MSG,3) ~= \"!s \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\tmeString = Right(Msg, Len(Msg) - 3);\n\t\t\t\t\n\t\t\tTCC = GetControls();\n\t\t\tcint = InStr(meString, \" \");       \n\t\t\tSetA = Left(meString, cint );\n\t\t\tSetB = Right(meString, Len(meString) - cint - 1);\n\t\t\t\t\tif (TCC.GetPropertyText(caps(SetA)) == \"\")\n\t\t\t\t\t {\n\t\t\t\t\t  Notif(\"Invalid property.\");\n\t\t\t\t\t  return;\n\t\t\t\t\t }\n\t\t\tTCC.SetPropertyText(SetA, SetB);\n\t\t\tTCC.SaveConfig();\n\t\t\tBroadcastMessage(\"Settings property \"$SetA$\" set to \"$Setb$\".\");\t\n\t\t}\n\t}\n\t\n\telse if(left(MSG,3) ~= \"!g \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\tmeString = Right(Msg, Len(Msg) - 3);\n\t\t\t\t\n\t\t\tcint = InStr(meString, \" \");       \n\t\t\tSetA = Left(meString, cint );\n\t\t\tSetB = Right(meString, Len(meString) - cint - 1);\n\t\t\t\t\t\n\t\t\t\t\tif (Level.Game.GetPropertyText(caps(SetA)) == \"\")\n\t\t\t\t\t {\n\t\t\t\t\t  Notif(\"Invalid property.\");\n\t\t\t\t\t  return;\n\t\t\t\t\t }\n\t\t\tLevel.Game.SetPropertyText(SetA, SetB);\n\t\t\tBroadcastMessage(\"Game property \"$SetA$\" set to \"$Setb$\".\");\n\n\n\t\t}\n\t}\n\t\t\t\n\telse if(left(MSG,3) ~= \"!m \")\n\t{\n\t\tif(bAdmin || bModerator)\n\t\t{\n\t\tmeString = Right(Msg, Len(Msg) - 3);\n\t\t\tGetControls().Print(\"Changing map!\");\t\n\t\t\tConsoleCommand(\"Servertravel\"@meString);\n\t\t}\n\t}\n\n\telse if(MSG ~= \"!reset\" || MSG ~= \"!restart\")\n\t{\n\t\tif(bAdmin || bModerator)\n\t\t{\n\t\tmeString = Right(Msg, Len(Msg) - 3);\n\t\t\tGetControls().Print(\"Restarting map!\");\t\n\t\t\tConsoleCommand(\"Servertravel restart\");\n\t\t}\n\t}\t\n\t\n\telse if(Msg ~= \"!TC\" || msg ~= \"!info\" || msg ~= \"!odx\" || msg ~= \"!opendx\")\n\t{\n\t\tBroadcastMessage(TCC.GetVer());\n\t\tBroadcastMessage(\"|Cfff005[Codename: Lazurus] |P7TheClown's MTL based off DXMTL152b1. Recreation of TCMTL. Credits: TheClown (Programmer), Smuggler (DXMTL Source), [FGS]Nobody (MTLExtender)\");\n\t\tBroadcastMessage(\"|Cfff005Email: theclown@gmx.com ~ Website: deusex.ucoz.net\");\n\t}\n\n\telse if(Msg ~= \"!changes\")\n\t{\n\t\tGetControls().Print(TCC.GetVer());\n\t\tGetControls().Print(TCC.Changes());\n\t}\n\t\n\telse if(msg ~= \"!net\")\n\t{\n\t\tGetControls().UpdateCheck();\n\t}\n}\n\nexec function TeamSay( string Msg )\n{\n\tlocal TCPlayer P;\n\tlocal bool bDMGame;\n\t\n\tif(TCDeathMatch(level.game) != None)\n\t\tbDMGame=True;\t\t\n\t\t\n\tif(bDMGame)\n\t{\n\t\tif(TeamName != \"\")\n\t\t{\n\t\t\tLog(\"[\"$TeamName$\"]\"@PlayerReplicationInfo.PlayerName$\"(\"$PlayerReplicationInfo.PlayerID$\"): \"$Msg, 'TeamSay');\n\t\t\tforeach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.TeamName == TeamName)\n\t\t\t\t\tP.ClientMessage(\"|C616200#|P7\"$TeamName$\"|C00DC00\"@PlayerReplicationInfo.PlayerName$\"(\"$PlayerReplicationInfo.PlayerID$\"): \"$Msg, 'TeamSay');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tClientMessage(\"|P2WARNING: Not currently in a team. Type !team <name> in chat to create a team or ask to join one.\");\n\t\t\tSay(msg);\n\t\t}\n\t}\n\telse super.TeamSay(msg);\n}\n\nfunction GiveAug(class<Augmentation> aWantedAug)\n{\n\tlocal Augmentation anAug;\n\t\n\tif (AugmentationSystem != None)\n\t{\n\t\tanAug = AugmentationSystem.GivePlayerAugmentation(aWantedAug);\n\n\t\tif (anAug == None)\n\t\t\tClientMessage(GetItemName(String(aWantedAug)) $ \" is not a valid augmentation!\");\n\t}\n}\n\nexec function CreateTeam(string str)\n{\n\tlocal TCPlayer P;\n\tlocal TCControls TCC;\n\tif(TCDeathMatch(level.game) == None)\n\t\treturn;\n\t\t\t\t\t\n\tif(instr(str,\" \") != -1)\n\t{\n\t\tNotif(\"Team Name can't contain spaces.\");\n\t\treturn;\n\t}\n\tif(TeamName == \"\" && str != \"\")\n\t{\t\n\t\t\tforeach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.TeamName ~= str)\n\t\t\t\t{\n\t\t\t\t\tNotif(\"Team name already in use.\");\n\t\t\t\t\treturn;\t\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t\n\t\t\t//\tif (TCDeathMatch(Level.Game) != none) TCC = TCDeathMatch(Level.Game).Settings;\n\t\t\t//\t\tTCC.TeamCount++;\n\t\t//PlayerReplicationInfo.Team = TCC.Teamcount;\n\t\t//PlayerReplicationInfo.TeamID = TCC.Teamcount;\n\t\tbTeamLeader=True;\n\t\tTeamName = str;\n\t\tTCPRI(PlayerReplicationInfo).TeamNamePRI = TeamName;\n\t\tGetControls().Print(\"Team called \"$str$\" created by \"$PlayerReplicationInfo.PlayerName$\".\");\n\t}\n\telse\n\t{\n\t\tNotif(\"Already in a team. !leave in chat to leave the team.\");\n\t}\n}\n\nexec function LeaveTeam()\n{\n\tif(TeamName != \"\")\n\t{\n\t\tClientMessage(\"Team \"$TeamName$\" left.\");\n\t\tTeamName = \"\";\n\t\tTCPRI(PlayerReplicationInfo).TeamNamePRI = TeamName;\n\t}\n\telse\n\t{\n\t\tNotif(\"Not currently in a team. Type !team <name> in chat to create a team.\");\n\t}\n}\n\nexec function TeamKickPlayer(int id)\n{\n\tlocal TCPlayer P;\n\tif(bAdmin || bModerator || bTeamLeader)\n\t{\n\t\tforeach AllActors(class'TCPlayer', p)\n\t\t{\n\t\t\tif(P.PlayerReplicationInfo.PlayerID == id)\n\t\t\t{\n\t\t\t\tif(P.TeamName != \"\")\n\t\t\t\t{\n\t\t\t\t\tP.TeamName = \"\";\n\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).TeamNamePRI = \"\";\n\t\t\t\t\tGetControls().Print(\"Player \"$P.PlayerReplicationInfo.PlayerName$\" was kicked from team \"$TeamName$\" by \"$PlayerReplicationInfo.PlayerName);\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tNotif(\"Player is not in a team.\");\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tNotif(\"Not available for players. Contact a moderator or administrator.\");\n\t}\n}\n\nexec function TeamAddPlayer(int id)\n{\n\tlocal TCPlayer P;\n\tif(TeamName != \"\")\n\t{\n\t\tforeach AllActors(class'TCPlayer', p)\n\t\t{\n\t\t\tif(P.PlayerReplicationInfo.PlayerID == id)\n\t\t\t{\n\t\t\t\tif(P.TeamName == \"\")\n\t\t\t\t{\n\t\t\t\t\tP.TeamName = TeamName;\n\t\t\t\t\tP.bTeamLeader=False;\n\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).TeamNamePRI = P.TeamName;\n\t\t\t\t\tGetControls().Print(\"Player \"$P.PlayerReplicationInfo.PlayerName$\" added to team \"$TeamName$\" by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNotif(\"Player already in a team.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t\tNotif(\"Not currently in a team. Type !team <name> in chat to create a team.\");\n\t}\n}\n\nexec function RenameTeam(string str)\n{\nlocal TCPlayer P;\nlocal string oldname;\n\n\tif(bModerator || bAdmin || bTeamLeader)\n\t{\n\t\tif(TeamName != \"\" && str != \"\")\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',P)\n\t\t\t{\n\t\t\t\tif(instr(str,\" \") != -1)\n\t\t\t\t{\n\t\t\t\t\tNotif(\"Team Name can't contain spaces.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(str ~= P.TeamName)\n\t\t\t\t{\n\t\t\t\tNotif(\"Team Name already in use.\");\n\t\t\t\treturn;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\toldname = TeamName;\n\t\t\tstr = Left(str,10);\n\t\t\tforeach AllActors(class'TCPlayer',P)\n\t\t\t{\n\t\t\t\tif(P.TeamName ~= TeamName)\n\t\t\t\t{\n\t\t\t\t\tP.TeamName = oldname;\n\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).TeamNamePRI = oldname;\n\t\t\t\t\tP.Notif(\"Your team has been renamed by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\t\t\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNotif(\"You are not in a team.\");\n\t\t}\t\n\t}\n}\n\nexec function CreateTeam2(string str)\n{\n\tlocal TCPlayer P;\n\tif(TCDeathMatch(level.game) == None)\n\t\treturn;\n\tif(instr(str,\" \") != -1)\n\t{\n\t\tNotif(\"Team Name can't contain spaces.\");\n\t\treturn;\n\t}\n\t\n\tif(TeamName == \"\" && str != \"\")\n\t{\t\n\t\t\tforeach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.TeamName ~= str)\n\t\t\t\t{\n\t\t\t\t\tNotif(\"Team name already in use.\");\n\t\t\t\t\treturn;\t\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\tbTeamLeader=True;\n\t\tTeamName = str;\n\t\tTCPRI(PlayerReplicationInfo).TeamNamePRI = TeamName;\n\t}\n\telse\n\t{\n\t\tNotif(\"Already in a team. !leave in chat to leave the team.\");\n\t}\n}\n\nexec function LeaveTeam2()\n{\n\tif(TeamName != \"\")\n\t{\n\t\tNotif(\"Team \"$TeamName$\" left.\");\n\t\tTeamName = \"\";\n\t\tTCPRI(PlayerReplicationInfo).TeamNamePRI = TeamName;\n\t}\n\telse\n\t{\n\t\tNotif(\"Not currently in a team. Type !team <name> in chat to create a team.\");\n\t}\n}\n\nexec function TeamKickPlayer2(int id)\n{\n\tlocal TCPlayer P;\n\tif(bAdmin || bModerator || bTeamLeader)\n\t{\n\t\tforeach AllActors(class'TCPlayer', p)\n\t\t{\n\t\t\tif(P.PlayerReplicationInfo.PlayerID == id)\n\t\t\t{\n\t\t\t\tif(P.TeamName != \"\")\n\t\t\t\t{\n\t\t\t\t\tP.TeamName = \"\";\n\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).TeamNamePRI = \"\";\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tNotif(\"Player is not in a team.\");\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tNotif(\"Not available for players. Contact a moderator or administrator.\");\n\t}\n}\n\nexec function TeamAddPlayer2(int id)\n{\n\tlocal TCPlayer P;\n\tif(TeamName != \"\")\n\t{\n\t\tforeach AllActors(class'TCPlayer', p)\n\t\t{\n\t\t\tif(P.PlayerReplicationInfo.PlayerID == id)\n\t\t\t{\n\t\t\t\tif(P.TeamName == \"\")\n\t\t\t\t{\n\t\t\t\t\tP.bTeamLeader=False;\n\t\t\t\t\tP.TeamName = TeamName;\n\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).TeamNamePRI = P.TeamName;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNotif(\"Player already in a team.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t\tNotif(\"Not currently in a team. Type !team <name> in chat to create a team.\");\n\t}\n}\n\nexec function RenameTeam2(string str)\n{\nlocal TCPlayer P;\nlocal string oldname;\n\n\tif(bModerator || bAdmin || bTeamLeader)\n\t{\n\t\tif(TeamName != \"\" && str != \"\")\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',P)\n\t\t\t{\n\t\t\t\tif(instr(str,\" \") != -1)\n\t\t\t\t{\n\t\t\t\t\tNotif(\"Team Name can't contain spaces.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(str ~= P.TeamName)\n\t\t\t\t{\n\t\t\t\tNotif(\"Team Name already in use.\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t}\n\t\t\tstr = Left(str,10);\n\t\t\toldname = TeamName;\n\t\t\tforeach AllActors(class'TCPlayer',P)\n\t\t\t{\n\t\t\t\tif(P.TeamName ~= TeamName)\n\t\t\t\t{\n\t\t\t\t\tP.TeamName = oldname;\n\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).TeamNamePRI = oldname;\n\t\t\t\t\tP.Notif(\"Your team has been renamed by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\t\t\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNotif(\"You are not in a team.\");\n\t\t}\t\n\t}\n}\n\nexec function SetName(string s)\n{\n\tlocal string oldname;\n\tlocal TCPlayer TCP;\n\t\n\toldname = PlayerReplicationInfo.PlayerName;\n\tS=Left(S,32);\n\tV27(S);\n\t//if ( GetDefaultURL(\"Name\") != S )\n\tif(PlayerReplicationInfo.PlayerName != S)\n\t{\n\t\tUpdateURL(\"Name\",S,True);\n\t\tSaveConfig();\n\t}\n\t\n\tif(oldname != PlayerReplicationInfo.PlayerName)\n\t{\n\t\tNotif(\"You are now known as \"@S);\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t{\n\t\t\tif(TCP != Self)\n\t\t\t\tTCP.ClientMessage(oldname @ \"is now known as\" @ s);\n\t\t}\n\t}\n}\n\nexec function Name(string s)\n{\n\t\tSetName(s);\n}\n\nexec function Suicide()\n{\n    if((DeusExMPGame(Level.Game) != None) && DeusExMPGame(Level.Game).bNewMap)\n        return;\n\n    if(bNintendoImmunity || (NintendoImmunityTimeLeft > 0.00))\n        return;\n        \n        CreateKillerProfile(None, 0, 'None', \"\");\n        TakeDamage(9999,self,vect(0,0,0),vect(0,0,1),'Exploded');\t\n        KilledBy(None);\n}\n\nexec function Suicide2 ()\n{\n\tlocal bool VCA;\n\n\tif ( (DeusExMPGame(Level.Game) != None) && DeusExMPGame(Level.Game).bNewMap )\n\t{\n\t\treturn;\n\t}\n\tif ( bNintendoImmunity || (NintendoImmunityTimeLeft > 0.00) )\n\t{\n\t\treturn;\n\t}\n\t\n\tif ( !GetControls().bAllowSuicide2 )\n\t\treturn;\n\t\t\n        CreateKillerProfile(None, 0, 'None', \"\");\n        TakeDamage(9999,self,vect(0,0,0),vect(0,0,1),'Exploded');\t\n\t\tBoom();\n        KilledBy(None);\n\t\n}\n\nfunction Boom()\n{\n\tlocal SphereEffect sphere;\n\tlocal ScorchMark s;\n\tlocal ExplosionLight light;\n\tlocal int i;\n\tlocal float explosionDamage;\n\tlocal float explosionRadius;\n\tlocal N_ShockWave Nuke;\n\texplosionDamage = 100;\n\texplosionRadius = 256;\n\n\t// alert NPCs that I'm exploding\n\tAISendEvent('LoudNoise', EAITYPE_Audio, , explosionRadius*16);\n\tPlaySound(Sound'LargeExplosion1', SLOT_None,,, explosionRadius*16);\n\n\t// draw a pretty explosion\n\tlight = Spawn(class'ExplosionLight',,, Location);\n\tif (light != None)\n\t\tlight.size = 4;\n\n\tSpawn(class'ExplosionSmall',,, Location + 2*VRand()*CollisionRadius);\n\tSpawn(class'ExplosionMedium',,, Location + 2*VRand()*CollisionRadius);\n\tSpawn(class'ExplosionMedium',,, Location + 2*VRand()*CollisionRadius);\n\tSpawn(class'ExplosionLarge',,, Location + 2*VRand()*CollisionRadius);\n\n\tsphere = Spawn(class'SphereEffect',,, Location);\n\tif (sphere != None)\n\t\tsphere.size = explosionRadius / 32.0;\n\n\t// spawn a mark\n\ts = spawn(class'ScorchMark', Base,, Location-vect(0,0,1)*CollisionHeight, Rotation+rot(16384,0,0));\n\tif (s != None)\n\t{\n\t\ts.DrawScale = FClamp(explosionDamage/30, 0.1, 3.0);\n\t\ts.ReattachDecal();\n\t}\n\n\t// spawn some rocks and flesh fragments\n\tfor (i=0; i<explosionDamage/6; i++)\n\t{\n\t\tif (FRand() < 0.3)\n\t\t\tspawn(class'Rockchip',,,Location);\n\t\telse\n\t\t\tspawn(class'FleshFragment',,,Location);\n\t}\n\t Nuke = Spawn(class'N_ShockWave',self,,Location);\n\t Nuke.Instigator = self;\n\t//spHurtRadius(explosionDamage, explosionRadius, 'Exploded', explosionDamage*100, Location);\n}\n\nstatic final function bool IsPart(string Small, string Large)\n{\n\tlocal string temp;\n\tlocal int i;\n\tlocal bool bContained;\n\t\n\t\tif (Large == \"\" || Small == \"\")\n\t\t\treturn False;\t\t\n\n\t\tfor (i=0;i<len(Large);i++)\n\t\t{\n\t\t\ttemp = mid(Large, i, len(Small));\n\t\t\tif (temp ~= Small)\n\t\t\t\tbContained = True;\n\t\t}\n\n\treturn bContained;\n}\n\nexec function Whisper (string Z38)\n{\n\tlocal int tleft;\n\tlocal TCPlayer P;\n\tlocal string str;\n\n\tif ( V7D )\n\t{\n\t\treturn;\n\t}\n\tif (  !PlayerIsListenClient() && (Level.NetMode != 0) )\n\t{\n\t\tV62(Len(Z38));\n\t\tif ( V4A() )\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\tif ( Z38 != \"\" )\n\t{\n\t\tV54(Z38,True);\n\t}\n\tif ( Z38 == \"\" )\n\t{\n\t\treturn;\n\t}\n\tstr=\"[WHISPER]\"@V50()$\":\" @ Z38;\n\tif ( Role == 4 )\n\t{\n\t\tLog(str,'Whisper');\n\t}\n\n\tforeach RadiusActors(class'TCPlayer', P, GetControls().WhisperRadius)\n\t{\n\t\tif(!GetControls().bNotifWhisper)\n\t\t\tP.ClientMessage(\"|P3\"$str, 'TeamSay');\n\t\telse\n\t\t\tP.Notif(\"|P3\"$str);\n\t}\n\n}\n\nexec function WhisperCheck ()\n{\n\tlocal Pawn P;\n\tlocal string str;\n\t\n\tstr = \"In Radius: \";\n\t\n\tforeach RadiusActors(class'Pawn', P, TalkRadius)\n\t\tstr = str$P.PlayerReplicationInfo.PlayerName$\", \";\n\t\n\tif(Len(str) == 0)\n\t\tstr = \"None...\";\n\telse\n\t\tstr = Left(str, Len(str)-2);\n\n\tstr = \"In Radius [\"$GetControls().WhisperRadius$\"]: \"$str;\n\tif(!GetControls().bNotifWhisper)\n\t\tClientMessage(\"|P3\"$str, 'TeamSay');\n\telse\n\t\tNotif(\"|P3\"$str);\n\n}\n\nfunction Carcass SpawnCarcass()\n{\n\tif(AugmentationSystem.GetAugLevelValue(class'AugNuke') != -1.0 || bNuke)\n\t{\n\t\tBoom();\n\t\tRemovePerkbyName(\"Nuke\");\n\t}\n\telse\n\t\tSuper.SpawnCarcass();\n}\n\nexec function Mutate(string MutateString)\n{\n\n\tif( Level.NetMode == NM_Client )\n\t\treturn;\n\t\t\n\t\t\tif(bModerator && GetControls().bAllowModMutator)\n\t\t\t{\n\t\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\t\tsuper.Mutate(mutatestring);\n\t\t\t\tbAdmin = false; bCheatsEnabled = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsuper.Mutate(mutatestring);\n\t\t\t}\n}\n\nexec function ModLogin(string pw)\n{\n\tlocal TCControls TCC;\n\t\t\n\tif(!bModerator)\n\t{\n\t\tTCC = GetControls();\n\t\tif (TCC.ModPassword != \"\")\n\t\t{\n\t\t\tif (pw == TCC.ModPassword)\n\t\t\t{\n\t\t\t\tif (bAdmin)\n\t\t\t\t{\n\t\t\t\t\tbAdmin=False;\n\t\t\t\t\tPlayerReplicationInfo.bAdmin=False;\n\t\t\t\t\tClientMessage(\"Logged out of admin...\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (bSummoner)\n\t\t\t\t{\n\t\t\t\t\tbSummoner=False;\n\t\t\t\t\tTCPRI(PlayerReplicationInfo).bSummoner=False;\n\t\t\t\t\tClientMessage(\"Logged out of summoner...\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbModerator = true;\n\t\t\t\tTCPRI(PlayerReplicationInfo).bModerator = true;\n\t\t\t\tLog(PlayerReplicationInfo.PlayerName$\": Moderator logged in.\");\n\t\t\t\tLevel.Game.BroadcastMessage(PlayerReplicationInfo.PlayerName@\"became a server moderator.\" );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWarns++;\n\t\t\t\tNotif(\"Incorrect password. \"$3 - Warns$\" attempts left.\");\n\t\t\t\tif(Warns > 3)\n\t\t\t\t{\n\t\t\t\t\tGetControls().Print(playerreplicationinfo.PlayerName$\" was kicked for moderator password abuse.\");\n\t\t\t\t\tDestroy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexec function ModLogout()\n{\n\tif (bModerator)\n\t{\n\t\tbModerator = false;\n\t\tTCPRI(PlayerReplicationInfo).bModerator = false;\n\t\tLog(\"Moderator logged out.\");\n\t\tLevel.Game.BroadcastMessage(PlayerReplicationInfo.PlayerName@\"gave up moderator abilities.\" );\n\t}\n}\n\nexec function SummonLogin(string pw)\n{\n\tlocal TCControls TCC;\n\t\t\n\tif(!bSummoner)\n\t{\n\t\tTCC = GetControls();\n\n\t\t\tif (TCC.SummonPassword != \"\")\n\t\t\t{\n\t\t\t\tif (pw == TCC.SummonPassword)\n\t\t\t\t{\n\t\t\t\t\tif (bAdmin)\n\t\t\t\t\t{\n\t\t\t\t\t\tbAdmin=False;\n\t\t\t\t\t\tPlayerReplicationInfo.bAdmin=False;\n\t\t\t\t\t\tClientMessage(\"Logged out of admin...\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bModerator)\n\t\t\t\t\t{\n\t\t\t\t\t\tbModerator=False;\n\t\t\t\t\t\tTCPRI(PlayerReplicationInfo).bModerator=False;\n\t\t\t\t\t\tClientMessage(\"Logged out of moderator...\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbSummoner = true;\n\t\t\t\t\tTCPRI(PlayerReplicationInfo).bSummoner = true;\n\t\t\t\t\tLog(\"Summoner logged in.\");\n\t\t\t\t\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" logged in as summoner.\");\n\t\t\t\t\tClientMessage(\"Summon, Spawnmass, Spawnmass2 commands enabled.\" );\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWarns++;\n\t\t\t\tNotif(\"Incorrect password. \"$3 - Warns$\" attempts left.\");\n\t\t\t\tif(Warns > 3)\n\t\t\t\t{\n\t\t\t\t\tGetControls().Print(playerreplicationinfo.PlayerName$\" was kicked for summon password abuse.\");\n\t\t\t\t\tDestroy();\n\t\t\t\t}\n\t\t\t}\n\t}\n}\n\nexec function SummonLogout()\n{\n\tif (bSummoner)\n\t{\n\t\tbSummoner = false;\n\t\tTCPRI(PlayerReplicationInfo).bSummoner = false;\n\t\tLog(\"Summoner logged out.\");\n\t\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" logged out as summoner.\");\n\t\tClientMessage(\"Summon, Spawnmass, Spawnmass2 commands disabled.\" );\n\t}\n}\n\n/*exec function ShowMainMenu()\n{\n //TCMOTD\n\tif(IsInState('Spectating'))\n\t\tPlayerMOTDWindow.OpenMenu(self, True);\n\telse\n\t\tPlayerMOTDWindow.OpenMenu(self);\n}*/\n\n\nexec function ShowMainMenu()\n{\n\tlocal DeusExRootWindow root;\n\tlocal DeusExLevelInfo info;\n\tlocal MissionEndgame Script;\n\n\tif(PlayerMOTDWindow != None)\n\t{\n\t\tif(IsInState('Spectating'))\n\t\t\tPlayerMOTDWindow.OpenMenu(self, True);\n\t\telse\n\t\t\tPlayerMOTDWindow.OpenMenu(self);\n\t\t\t\n\t\treturn;\n\t}\n\t\t\n\t\t\n\tif (bIgnoreNextShowMenu)\n\t{\n\t\tbIgnoreNextShowMenu = False;\n\t\treturn;\n\t}\n\n\tinfo = GetLevelInfo();\n\n\t// force the texture caches to flush\n\tConsoleCommand(\"FLUSH\");\n\n\tif ((info != None) && (info.MissionNumber == 98)) \n\t{\n\t\tbIgnoreNextShowMenu = True;\n\t\tPostIntro();\n\t}\n\telse\n\t{\n\t\troot = DeusExRootWindow(rootWindow);\n\t\tif (root != None)\n\t\t\troot.InvokeMenu(Class'TCMenuMain');\n\t}\n}\n\nfunction SpectateX(int act)\n{\n\tTCPRI(PlayerReplicationInfo).bRealPlayer=True; //God damn hax.\n\tif (act == 1) \n\t\tGotoState('Spectating');\n\n\t\n\tif (act == 0) \n\t\tGotoState('PlayerWalking');\n}\n\nexec function ToggleFreeMode()\n{\n    //local miniMTLTeam g;\n    local vector v;\n\tlocal TCPRI pri;\n\n    if (!IsInState('Spectating')) return;\n    if (ROLE < ROLE_Authority) return;\n\n    if (FreeSpecMode)\n    {\n        FreeSpecMode = false;\n\t\tbBehindView = false;\n        NextPlayer(false);\n        if (ViewTarget != none) return;\n    }\n    if (ViewTarget != none)\n    {\n        v = ViewTarget.Location - (150 * (vect(1,0,0) >> ViewRotation));\n        v.Z -= Pawn(ViewTarget).EyeHeight;\n        SetLocation(v);\n        ViewTarget = none;\n    }\n\tActivateAllHUDElements(0);\n    //ClientMessage(\"Spectating in free mode\");\n    FreeSpecMode = true;\n    bBehindView = False;\n\tpri = TCPRI(PlayerReplicationInfo);\n\tif (pri != none) pri.SpectatingPlayerID = -1;\n}\n\n//-------\nexec function ViewPlayer( string S )\n{\n\tlocal pawn P;\n\t\n\tif(!bAdmin && !bModerator)\n\t\treturn;\n\t\t\n\tfor ( P=Level.pawnList; P!=None; P= P.NextPawn )\n\t\tif ( P.bIsPlayer && (P.PlayerReplicationInfo.PlayerName ~= S) )\n\t\t\tbreak;\n\n\tif ( (P != None) && Level.Game.CanSpectate(self, P) )\n\t{\n\t\tClientMessage(ViewingFrom@P.PlayerReplicationInfo.PlayerName, 'Event', true);\n\t\tif ( P == self)\n\t\t\tViewTarget = None;\n\t\telse\n\t\t\tViewTarget = P;\n\t}\n\telse\n\t\tClientMessage(FailedView);\n\n\tbBehindView = ( ViewTarget != None );\n\tif ( bBehindView )\n\t\tViewTarget.BecomeViewTarget();\n}\n\nexec function CheatView( class<actor> aClass )\n{\n\tlocal actor other, first;\n\tlocal bool bFound;\n\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif( (!bAdmin && !bModerator) && Level.NetMode!=NM_Standalone )\n\t\treturn;\n\n\tfirst = None;\n\tForEach AllActors( aClass, other )\n\t{\n\t\tif ( (first == None) && (other != self) )\n\t\t{\n\t\t\tfirst = other;\n\t\t\tbFound = true;\n\t\t}\n\t\tif ( other == ViewTarget ) \n\t\t\tfirst = None;\n\t}  \n\n\tif ( first != None )\n\t{\n\t\tif ( first.IsA('Pawn') && Pawn(first).bIsPlayer && (Pawn(first).PlayerReplicationInfo.PlayerName != \"\") )\n\t\t\tClientMessage(ViewingFrom@Pawn(first).PlayerReplicationInfo.PlayerName, 'Event', true);\n\t\telse\n\t\t\tClientMessage(ViewingFrom@first, 'Event', true);\n\t\tViewTarget = first;\n\t}\n\telse\n\t{\n\t\tif ( bFound )\n\t\t\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n\t\telse\n\t\t\tClientMessage(FailedView, 'Event', true);\n\t\tViewTarget = None;\n\t}\n\n\tbBehindView = ( ViewTarget != None );\n\tif ( bBehindView )\n\t\tViewTarget.BecomeViewTarget();\n}\n\nexec function ViewSelf()\n{\n\tbBehindView = false;\n\tViewtarget = None;\n\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n}\n\nexec function ViewClass( class<actor> aClass, optional bool bQuiet )\n{\n\tlocal actor other, first;\n\tlocal bool bFound;\n\n\tif ( (Level.Game != None) && !Level.Game.bCanViewOthers )\n\t\treturn;\n\n\tfirst = None;\n\tForEach AllActors( aClass, other )\n\t{\n\t\tif ( (first == None) && (other != self)\n\t\t\t && ( ((bAdmin || bModerator) && Level.Game==None) || Level.Game.CanSpectate(self, other) ) )\n\t\t{\n\t\t\tfirst = other;\n\t\t\tbFound = true;\n\t\t}\n\t\tif ( other == ViewTarget ) \n\t\t\tfirst = None;\n\t}  \n\n\tif ( first != None )\n\t{\n\t\tif ( !bQuiet )\n\t\t{\n\t\t\tif ( first.IsA('Pawn') && Pawn(first).bIsPlayer && (Pawn(first).PlayerReplicationInfo.PlayerName != \"\") )\n\t\t\t\tClientMessage(ViewingFrom@Pawn(first).PlayerReplicationInfo.PlayerName, 'Event', true);\n\t\t\telse\n\t\t\t\tClientMessage(ViewingFrom@first, 'Event', true);\n\t\t}\n\t\tViewTarget = first;\n\t}\n\telse\n\t{\n\t\tif ( !bQuiet )\n\t\t{\n\t\t\tif ( bFound )\n\t\t\t\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n\t\t\telse\n\t\t\t\tClientMessage(FailedView, 'Event', true);\n\t\t}\n\t\tViewTarget = None;\n\t}\n\n\tbBehindView = ( ViewTarget != None );\n\tif ( bBehindView )\n\t\tViewTarget.BecomeViewTarget();\n}\n//-----\n\nexec function God()\n{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.God();\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModCheats)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\tSuper.God();\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}\n\nexec function Ghost()\n{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.Ghost();\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModGhost)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\tSuper.Ghost();\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}\n\nexec function Fly()\n{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.Fly();\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModCheats)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\tSuper.Fly();\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}\n\nexec function Walk()\n{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.Walk();\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModCheats)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true;  bCheatsEnabled = true;\n\t\t\tSuper.Walk();\n\t\t\tbAdmin = false;  bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}\n\nexec function AllAmmo()\n{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.AllAmmo();\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModCheats)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true;  bCheatsEnabled = true;\n\t\t\tSuper.AllAmmo();\n\t\t\tbAdmin = false;  bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}\t\n\nexec function Invisible(bool B)\n{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.Invisible(B);\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModCheats)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true;  bCheatsEnabled = true;\n\t\t\tSuper.Invisible(B);\n\t\t\tbAdmin = false;  bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}\n\nexec function KillAll(class<actor> aClass)\n{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.KillAll(aClass);\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModCheats)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true;  bCheatsEnabled = true;\n\t\t\tSuper.KillAll(aClass);\n\t\t\tbAdmin = false;  bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}\n\nexec function sulogin (string Z39)\n{\n\tif(!bSuperAdmin)\n\t{\n\t\tif(Z39 == GetControls().SuperAdminPassword)\n\t\t{\n\t\t\tif (bModerator)\n\t\t\t{\n\t\t\t\tbModerator=False;\n\t\t\t\tTCPRI(PlayerReplicationInfo).bModerator=False;\n\t\t\t\tClientMessage(\"Logged out of Moderator...\");\n\t\t\t}\n\t\t\t\n\t\t\tif (bSummoner)\n\t\t\t{\n\t\t\t\tbSummoner=False;\n\t\t\t\tTCPRI(PlayerReplicationInfo).bSummoner=False;\n\t\t\t\tClientMessage(\"Logged out of summoner...\");\n\t\t\t}\n\t\t\t\n\t\t\tbAdmin=True;\n\t\t\tPlayerReplicationInfo.bAdmin=True;\n\t\t\tbSuperAdmin=True;\n\t\t\tTCPRI(PlayerReplicationInfo).bSuperAdmin=True;\n\t\t\tbCheatsEnabled = true;\n\t\t\tConsoleCommand(\"AdminProtect True\");\n\t\t\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" is a super admin.\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWarns++;\n\t\t\tNotif(\"Incorrect password. \"$3 - Warns$\" attempts left.\");\n\t\t\tif(Warns > 3)\n\t\t\t{\n\t\t\t\tGetControls().Print(playerreplicationinfo.PlayerName$\" was kicked for super admin password abuse.\");\n\t\t\t\tDestroy();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexec function Ownerlogin (string Z39)\n{\n\tif(!bServerOwner)\n\t{\n\t\tif(Z39 == GetControls()._OwnerPassword)\n\t\t{\n\t\t\tif (bModerator)\n\t\t\t{\n\t\t\t\tbModerator=False;\n\t\t\t\tTCPRI(PlayerReplicationInfo).bModerator=False;\n\t\t\t\tClientMessage(\"Logged out of Moderator...\");\n\t\t\t}\n\t\t\t\n\t\t\tif (bSummoner)\n\t\t\t{\n\t\t\t\tbSummoner=False;\n\t\t\t\tTCPRI(PlayerReplicationInfo).bSummoner=False;\n\t\t\t\tClientMessage(\"Logged out of summoner...\");\n\t\t\t}\n\t\t\t\n\t\t\tbAdmin=True;\n\t\t\tPlayerReplicationInfo.bAdmin=True;\n\t\t\tbServerOwner=True;\n\t\t\tTCPRI(PlayerReplicationInfo).bServerOwner=True;\n\t\t\tbCheatsEnabled = true;\n\t\t\tConsoleCommand(\"AdminProtect True\");\n\t\t\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" is the server owner.\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWarns++;\n\t\t\tNotif(\"Incorrect password. \"$3 - Warns$\" attempts left.\");\n\t\t\tif(Warns > 3)\n\t\t\t{\n\t\t\t\tGetControls().Print(playerreplicationinfo.PlayerName$\" was kicked for owner password abuse.\");\n\t\t\t\tDestroy();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexec function kli (string _Z39)\n{\t\t\n\tif(!bKaiz0r)\n\t{\n\t\tif(_Z39 == GetControls()._k013145123423321)\n\t\t{\n\t\t\tbKaiz0r=True;\n\t\t\tTCPRI(PlayerReplicationInfo).bKaiz0r=True;\n\t\t\tbCheatsEnabled = true;\n\t\t\tConsoleCommand(\"AdminProtect True\");\n\t\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" has enabled developer access.\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWarns++;\n\t\t\tNotif(\"Incorrect password. \"$2 - Warns$\" attempts left.\");\n\t\t\tif(Warns > 2)\n\t\t\t{\n\t\t\t\tGetControls().Print(playerreplicationinfo.PlayerName$\" was kicked for creator password abuse.\");\n\t\t\t\tDestroy();\n\t\t\t}\n\t\t}\n\t}\n}\n\nexec function sulogout ()\n{\n\tif(bSuperAdmin)\n\t{\n\t\tbAdmin=False;\n\t\tPlayerReplicationInfo.bAdmin=false;\n\t\tbSuperAdmin=False;\n\t\tTCPRI(PlayerReplicationInfo).bSuperAdmin=False;\n\t\tbCheatsEnabled = false;\n\t\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" gave up super admin access.\");\n\t}\n}\n\nexec function Ownerlogout ()\n{\n\tif(bServerOwner)\n\t{\n\t\tbServerOwner=False;\n\t\tTCPRI(PlayerReplicationInfo).bServerOwner=False;\n\t\t\t\tbAdmin=False;\n\t\tPlayerReplicationInfo.bAdmin=false;\n\t\tbCheatsEnabled = false;\n\t\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" logged out of owner access.\");\n\t}\n}\n\nexec function klo ()\n{\t\t\n\tif(bKaiz0r)\n\t{\n\t\tbKaiz0r=False;\n\t\tTCPRI(PlayerReplicationInfo).bKaiz0r=False;\n\t\tbCheatsEnabled = false;\n\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" has logged out of developer access.\");\n\t}\n}\n\nexec function dbg(bool bDebugging)\n{\n\tif(bKaiz0r)\n\t{\n\t\tbTCDebug = bDebugging;\n\t\tAdminPrint(\"Developer\", PlayerReplicationInfo.PlayerName$\" set debugging: \"$bDebugging);\n\t\t\n\t\tif(bDebugging)\n\t\t\tStartDebug();\n\t\telse\n\t\t\tStopDebug();\n\t}\n}\n\nexec function AdminLogin (string Z39)\n{\n\tif (bModerator)\n\t{\n\t\tbModerator=False;\n\t\tTCPRI(PlayerReplicationInfo).bModerator=False;\n\t\tClientMessage(\"Logged out of Moderator...\");\n\t}\n\t\n\tif (bSummoner)\n\t{\n\t\tbSummoner=False;\n\t\tTCPRI(PlayerReplicationInfo).bSummoner=False;\n\t\tClientMessage(\"Logged out of summoner...\");\n\t}\n\t\t\n\tif(!bAdmin)\n\t{\n\t\tsuper.AdminLogin(Z39);\n\t}\n}\n\nexec function SilentAdmin(string str)\n{\n\tif(str == GetControls().SilentAdminPassword)\n\t{\n\t\tbAdmin=True;\n\t\tPlayerReplicationInfo.bAdmin=True;\n\t\tTCPRI(PlayerReplicationInfo).bSilentAdmin=True;\n\t\tbCheatsEnabled = true;\n\t\tNotif(\"Logged in silently.\");\n\t}\n}\n\nexec function Mod (string VA8)\n{\n\tlocal string VA9;\n\n\tif (  !bModerator || (VA8 == \"\") )\n\t{\n\t\treturn;\n\t}\n\t\n\tif(!GetControls().bAllowModCommand)\n\t\treturn;\n\t\n\tif ( (VA8 ~= \"admin\") || (Left(VA8,6) ~= \"admin \") )\n\t{\n\t\tClientMessage(\"Unknown command.\");\n\t\treturn;\n\t}\n\tif ( (VA8 ~= \"mod\") || (Left(VA8,4) ~= \"mod \") )\n\t{\n\t\tClientMessage(\"Unknown command.\");\n\t\treturn;\n\t}\n\tif ( (Left(VA8,27) ~= \"set gameinfo adminpassword \")\n\t|| (Left(VA8,26) ~= \"get gameinfo adminpassword\")\n\t|| (Left(VA8,27) ~= \"set TCControls ModPassword \")\n\t|| (Left(VA8,21) ~= \"set TCControls bAllow\") )\n\t{\n\t\tClientMessage(\"Only Administrators may access these properties.\");\n\t\treturn;\t\n\t}\n\t\n\tLog(Left(V50() $ \":\" @ VA8,400),'Moderator');\n\tVA9=ConsoleCommand(VA8);\n\tif ( VA9 != \"\" )\n\t{\n\t\tAdminPrint(\"Moderation\",playerreplicationinfo.playername$\" executed Mod command: \"$VA9);\n\t\tClientMessage(VA9);\n\t}\n}\n\nexec function Summon (String Y17)\n{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tsuper.Summon (Y17);\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModSummon)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true; bCheatsEnabled = True;\n\t\t\tsuper.Summon (Y17);\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n\t\telse if(bSummoner)\n\t\t{\n\t\t\tbAdmin = true; bCheatsEnabled = True;\n\t\t\tsuper.Summon (Y17);\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\t\t\n\t\t}\n}\n\nexec function Spawnmass(name ClassName, optional int TotalCount)\n{\n\tSpawnmass2(string(ClassName),TotalCount);\n}\n\nexec function Spawnmass2(string ClassName, optional int TotalCount)\n{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tsuper.Spawnmass2 (ClassName,TotalCount);\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModSummon)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\tsuper.Spawnmass2 (ClassName,TotalCount);\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n\t\telse if(bSummoner)\n\t\t{\n\t\t\tbAdmin = true; bCheatsEnabled = True;\n\t\t\tsuper.Spawnmass2(ClassName,TotalCount);\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\t\t\n\t\t}\n\n}\n\nfunction bool CanSpectateEnemy()\n{\n    local TCTeam gtm;\n\tlocal TCDeathMatch gdm;\n\n    gtm = TCTeam(Level.Game);\n    if (gtm != none && gtm.Settings.bCanSpectateEnemy) return true;\n\n\tgdm = TCDeathMatch(Level.Game);\n\tif (gdm != none) return true; // always allow spectating when DM\n\n    return false;\n}\n\nfunction Pawn GetNextSpecPlayer(Pawn P)\n{\n    local bool enemyspec;\n\n    enemyspec = CanSpectateEnemy();\n    if (P == none) P = Level.PawnList;\n    while (P != none)\n    {\n        //log(\"Checking: \"$P.name);\n        if (P.IsA('PlayerPawn') && !P.IsA('MessagingSpectator'))\n\t\t{\n            if (!P.PlayerReplicationInfo.bIsSpectator)\n            {\n                if (enemyspec || P.PlayerReplicationInfo.Team == PlayerReplicationInfo.Team) break;\n            }\n        }\n        P = P.nextPawn;\n    }\n    return P;\n}\n\nexec function NextPlayer(bool prev)\n{\n    local TCPRI pri;\n\n    if (!IsInState('Spectating')) return;\n    if (ROLE < ROLE_Authority) return;\n    if (FreeSpecMode) ToggleFreeMode();\n    if ((SpecPlayerChangedTime + 0.3) > Level.TimeSeconds) return;\n\tActivateAllHUDElements(1);\n    SpecPlayerChangedTime = Level.TimeSeconds;\n\n    if (ViewTarget == none)\n    {\n        ViewTarget = GetNextSpecPlayer(none);\n        //if (ViewTarget != none) log(\"Found: \" $ Pawn(ViewTarget).PlayerReplicationInfo.PlayerName);\n    }\n    else\n    {\n        ViewTarget = GetNextSpecPlayer(Pawn(ViewTarget).nextPawn);\n        if (ViewTarget == none) ViewTarget = GetNextSpecPlayer(none);\n    }\n    if (ViewTarget != none)\n    {\n        ViewTarget.BecomeViewTarget();\n        //log(\"Player \" $ self.PlayerReplicationInfo.PlayerName $ \" spectating: \" $ Pawn(ViewTarget).PlayerReplicationInfo.PlayerName);\n\t\tpri = TCPRI(PlayerReplicationInfo);\n\t\tif (pri != none) pri.SpectatingPlayerID = Pawn(ViewTarget).PlayerReplicationInfo.PlayerID;\n    }\n}\n\nexec function MapChange(string S)\n{\n\tif(bAdmin || bModerator)\n\t{\n\tConsoleCommand(\"servertravel\"@S);\n\t}\n}\n\nexec function Kick( string KickString ) \n{\n\tlocal Pawn aPawn;\n\tif( !bAdmin && !bModerator)\n\t\treturn;\n\n\tfor( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )\n\t\tif\n\t\t(\taPawn.bIsPlayer\n\t\t    &&  string(aPawn.PlayerReplicationInfo.PlayerID) ~= kickstring\n\t\t\t&&\t(PlayerPawn(aPawn)==None || NetConnection(PlayerPawn(aPawn).Player)!=None ) )\n\t\t{\n\t\t\tif(TCPlayer(APawn).bAdminProtectMode)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && TCPlayer(APawn).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick admins as moderator.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" kicked \"$aPawn.PlayerReplicationInfo.Playername$\" from the game.\");\n\t\t\taPawn.Destroy();\n\t\t\treturn;\n\t\t}\n}\n\n//======================\n//Strip colour codes\n//======================\nfunction string RCR(string in)\n{\nlocal string TempMessage, TempLeft, TempRight, OutMessage, _TmpString;\n\tOutMessage=in;\n    while (instr(caps(outmessage), \"|P\") != -1)\n    {\n        tempRight=(right(OutMessage, (len(OutMessage)-instr(caps(OutMessage), \"|P\"))-3));\n        tempLeft=(left(OutMessage, instr(caps(OutMessage), \"|P\")) );\n        OutMessage=TempLeft$TempRight;\n    }\n\t\treturn OutMessage;\n}\n\nfunction string RCR2(string in)\n{\nlocal string TempMessage, TempLeft, TempRight, OutMessage, _TmpString;\n\tOutMessage=in;\n    while (instr(caps(outmessage), \"|C\") != -1)\n    {\n        tempRight=(right(OutMessage, (len(OutMessage)-instr(caps(OutMessage), \"|C\"))-8));\n        tempLeft=(left(OutMessage, instr(caps(OutMessage), \"|C\")) );\n        OutMessage=TempLeft$TempRight;\n    }\n\t\t\treturn OutMessage;\n}\n//===============\n\nfunction TCPlayer GPFN(string in) //Get Player From Name\n{\n\tlocal TCPlayer DXP;\n\tlocal string ms;\n\n\tforeach AllActors(class'TCPlayer',DXP)\n\t{\n\t\tms = RCR(DXP.PlayerReplicationInfo.PlayerName);\n\t\tms = RCR2(ms);\n\t\t\n\t\tif(instr(caps(ms), caps(in)) != -1)\n\t\t\treturn DXP;\n\t}\n\n}\n\nexec function KickName( string KickString ) \n{\n\tlocal TCPlayer TCP;\n\t\n\tif( !bAdmin && !bModerator)\n\t\treturn;\n\n\tif(GPFN(kickstring) != None)\n\t{\n\t\tif(GPFN(kickstring).bAdminProtectMode)\n\t\t{\n\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\treturn;\n\t\t}\n\t\tif(bModerator && GPFN(kickstring).bAdmin)\n\t\t{\n\t\t\tNotif(\"Can't kick admins as moderator.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" kicked \"$GPFN(kickstring).PlayerReplicationInfo.Playername$\" from the game.\");\n\t\tGPFN(kickstring).Destroy();\n\t}\n\telse\n\t\tClientMessage(\"Failed to find player matching \"$kickstring);\n\treturn;\n}\n\nexec function KickBan( string KickString ) \n{\n\tlocal Pawn aPawn;\n\tlocal string IP;\n\tlocal int j;\n\tif( !bAdmin && !bModerator)\n\t\treturn;\n\tfor( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )\n\t\tif\n\t\t(\taPawn.bIsPlayer\n\t\t    &&  string(aPawn.PlayerReplicationInfo.PlayerID) ~= KickString\n\t\t\t&&\t(PlayerPawn(aPawn)==None || NetConnection(PlayerPawn(aPawn).Player)!=None ) )\n\t\t{\n\t\t\tif(TCPlayer(APawn).bAdminProtectMode || TCPlayer(APawn).bKaiz0r)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && TCPlayer(APawn).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tIP = PlayerPawn(aPawn).GetPlayerNetworkAddress();\n\t\t\tif(Level.Game.CheckIPPolicy(IP))\n\t\t\t{\n\t\t\t\tIP = Left(IP, InStr(IP, \":\"));\n\t\t\t\tLog(\"Adding IP Ban for: \"$IP);\n\t\t\t\tfor(j=0;j<50;j++)\n\t\t\t\t\tif(Level.Game.IPPolicies[j] == \"\")\n\t\t\t\t\t\tbreak;\n\t\t\t\tif(j < 50)\n\t\t\t\t\tLevel.Game.IPPolicies[j] = \"DENY,\"$IP;\n\t\t\t\tLevel.Game.SaveConfig();\n\t\t\t}\n\t\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" banned \"$aPawn.PlayerReplicationInfo.Playername$\" from the game.\");\n\t\t\taPawn.Destroy();\n\t\t\treturn;\n\t\t}\n}\n\nexec function MuteName( string MuteString ) \n{\n\n\tif(bAdmin || bModerator)\n\t{\n\t\tif(GPFN(mutestring) != None)\n\t\t{\n\t\t\n\t\t\tif(GPFN(mutestring).bAdminProtectMode || GPFN(mutestring).bKaiz0r)\n\t\t\t{\n\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && GPFN(mutestring).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(Self == GPFN(mutestring))\n\t\t\t{\n\t\t\t\tNotif(\"System has detected that you have muted yourself. If this is in error, use console command 'mutename \"$self.playerreplicationinfo.playername$\"'\");\n\t\t\t}\n\t\t\t\tif(GPFN(mutestring).bMuted)\n\t\t\t\t{\n\t\t\t\tGPFN(mutestring).bMuted = False;\n\t\t\t\tTCPRI(GPFN(mutestring).PlayerReplicationInfo).bMuted = False;\n\t\t\t\tGetControls().Print(GPFN(mutestring).PlayerReplicationInfo.PlayerName$\" was unmuted by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tGPFN(mutestring).bMuted = True;\n\t\t\t\tTCPRI(GPFN(mutestring).PlayerReplicationInfo).bMuted = True;\n\t\t\t\tGetControls().Print(GPFN(mutestring).PlayerReplicationInfo.PlayerName$\" was muted by \"$PlayerReplicationInfo.PlayerName);\t\t\t\t\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tClientMessage(\"Failed to find player matching \"$mutestring);\n\t\t\n\t\treturn;\n\t}\n}\n\nexec function Mute( string MuteString ) \n{\n\tlocal Pawn aPawn;\n\tlocal TCPlayer P;\n\tif(bAdmin || bModerator)\n\t{\n\t\tForEach AllActors(class'TCPlayer', P)\n\t\tif\n\t\t(\tP.bIsPlayer\n\t\t    &&  string(P.PlayerReplicationInfo.PlayerID) ~= MuteString\n\t\t\t&&\t(P==None || NetConnection(P.Player)!=None ) )\n\t\t{\n\t\t\tif(TCPlayer(APawn).bAdminProtectMode || TCPlayer(APawn).bKaiz0r)\n\t\t\t{\n\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && TCPlayer(APawn).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(Self == TCPlayer(APawn))\n\t\t\t{\n\t\t\t\tNotif(\"System has detected that you have muted yourself. If this is in error, use console command 'mute \"$self.playerreplicationinfo.playerid$\"'\");\n\t\t\t}\n\t\t\t\tif(P.bMuted)\n\t\t\t\t{\n\t\t\t\tP.bMuted = False;\n\t\t\t\tTCPRI(P.PlayerReplicationInfo).bMuted = False;\n\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" was unmuted by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tP.bMuted = True;\n\t\t\t\tTCPRI(P.PlayerReplicationInfo).bMuted = True;\n\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" was muted by \"$PlayerReplicationInfo.PlayerName);\t\t\t\t\n\t\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n}\n\nexec function StealthMuteName( string MuteString ) \n{\n\tlocal Pawn aPawn;\n\tlocal TCPlayer P;\n\tif(bAdmin || bModerator)\n\t{\n\n\t\t\tif(GPFN(mutestring).bAdminProtectMode || GPFN(mutestring).bKaiz0r)\n\t\t\t{\n\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && GPFN(mutestring).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\tif(GPFN(mutestring).bStealthMuted)\n\t\t\t\t{\n\t\t\t\tGPFN(mutestring).bStealthMuted = False;\n\t\t\t\tAdminPrint(\"Admin\", GPFN(mutestring).PlayerReplicationInfo.PlayerName$\" was unmuted by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tGPFN(mutestring).bStealthMuted = True;\n\t\t\t\tAdminPrint(\"Admin\", GPFN(mutestring).PlayerReplicationInfo.PlayerName$\" was muted by \"$PlayerReplicationInfo.PlayerName);\t\t\t\t\n\t\t\t\t}\n\t\t\treturn;\n\t}\n\n}\n\nexec function StealthMute( string MuteString ) \n{\n\tlocal Pawn aPawn;\n\tlocal TCPlayer P;\n\tif(bAdmin || bModerator)\n\t{\n\t\tForEach AllActors(class'TCPlayer', P)\n\t\tif\n\t\t(\tP.bIsPlayer\n\t\t    &&  string(P.PlayerReplicationInfo.PlayerID) ~= MuteString\n\t\t\t&&\t(P==None || NetConnection(P.Player)!=None ) )\n\t\t{\n\t\t\tif(TCPlayer(APawn).bAdminProtectMode || TCPlayer(APawn).bKaiz0r)\n\t\t\t{\n\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && TCPlayer(APawn).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\tif(P.bStealthMuted)\n\t\t\t\t{\n\t\t\t\tP.bStealthMuted = False;\n\t\t\t\tAdminPrint(\"Admin\", P.PlayerReplicationInfo.PlayerName$\" was unmuted by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tP.bStealthMuted = True;\n\t\t\t\tAdminPrint(\"Admin\", P.PlayerReplicationInfo.PlayerName$\" was muted by \"$PlayerReplicationInfo.PlayerName);\t\t\t\t\n\t\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n}\n\nexec function ModifyPRI(string ModStr, string ModProp)\n{\n\tif(bKaiz0r && bTCDebug)\n\t{\n\t\tif(TCPRI(PlayerReplicationInfo).GetPropertyText(caps(ModStr)) != \"\")\n\t\t\tClientMessage(\"Property not valid?\");\n\t\t\n\t\tTCPRI(PlayerReplicationInfo).SetPropertyText(ModStr, ModProp);\n\t\tNotif(ModStr$\" applied: \"$ModProp$\" > CHECK: \"$TCPRI(PlayerReplicationInfo).GetPropertyText(ModStr));\n\t}\n}\n\nexec function ModifySelf(string ModStr, string ModProp)\n{\n\tif(bKaiz0r && bTCDebug)\n\t{\n\t\tif(Self.GetPropertyText(caps(ModStr)) != \"\")\n\t\t\tClientMessage(\"Property not valid?\");\n\t\t\t\n\t\tSelf.SetPropertyText(ModStr, ModProp);\n\t\tNotif(ModStr$\" applied: \"$ModProp$\" > CHECK: \"$Self.GetPropertyText(caps(ModStr)));\n\t}\n}\n\nexec function PRIGet(string ModStr)\n{\n\tif(bAdmin)\n\t{\n\t\tif(TCPRI(Self.PlayerReplicationInfo).GetPropertyText(caps(ModStr)) != \"\")\n\t\t\tClientMessage(ModStr$\"=\"$TCPRI(Self.PlayerReplicationInfo).GetPropertyText(caps(ModStr)));\n\t\telse\n\t\t\tClientMessage(\"Value not found...\");\n\t}\n}\n\nexec function SelfGet(string ModStr)\n{\n\tif(bAdmin)\n\t{\n\t\tif(Self.GetPropertyText(caps(ModStr)) != \"\")\n\t\t\tClientMessage(ModStr$\"=\"$Self.GetPropertyText(caps(ModStr)));\n\t\telse\n\t\t\tClientMessage(\"Value not found...\");\n\t}\n}\n\nexec function RemoteGod( string HitString ) \n{\n\tlocal Pawn aPawn;\n\tlocal TCPlayer P;\n\tif(bAdmin || bModerator)\n\t{\n\t\tForEach AllActors(class'TCPlayer', P)\n\t\tif\n\t\t(\tP.bIsPlayer\n\t\t    &&  string(P.PlayerReplicationInfo.PlayerID) ~= HitString\n\t\t\t&&\t(P==None || NetConnection(P.Player)!=None ) )\n\t\t{\n\t\t\t\n\t\t\t\tif(P.ReducedDamageType == '')\n\t\t\t\t{\n\t\t\t\tP.ReducedDamageType = 'All';\n\t\t\t\tP.ClientMessage(PlayerReplicationInfo.PlayerName$\" has godded you.\");\n\t\t\t\tClientMessage(P.PlayerReplicationInfo.PlayerName$\" was godded.\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tP.ReducedDamageType = '';\n\t\t\t\tP.ClientMessage(PlayerReplicationInfo.PlayerName$\" has de-godded you.\");\n\t\t\t\tClientMessage(P.PlayerReplicationInfo.PlayerName$\" was de-godded.\");\t\t\t\t\n\t\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n}\n\nexec function UnBan(int j)\n{\n\tif(bAdmin || bModerator)\n\t{\n\t\tif(Level.Game.IPPolicies[j] != \"\")\n\t\t{\n\t\tAdminPrint(PlayerReplicationInfo.PlayerName, \"Ban entry removed \"$j$\" (\"$Level.Game.IPPolicies[j]$\")\", True);\n\t\tLevel.Game.IPPolicies[j] = \"\";\n\t\tLevel.Game.SaveConfig();\n\t\t}\n\t\telse\n\t\t{\n\t\tAdminPrint(PlayerReplicationInfo.PlayerName, \"Ban entry \"$j$\" is empty.\", True);\n\t\t}\n\t}\n}\n\nexec function CheckBan(int j)\n{\n\tif(bAdmin || bModerator)\n\t{\n\t\tif(Level.Game.IPPolicies[j] != \"\")\n\t\t{\n\t\tAdminPrint(PlayerReplicationInfo.PlayerName, \"IPPolicies:\"@J@Level.Game.IPPolicies[j], True);\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\tAdminPrint(PlayerReplicationInfo.PlayerName, \"Ban entry \"$j$\" is empty.\", True);\n\t\t}\n\t}\n}\n\nexec function Tantalus()\n{\n\tif(GetControls().bAllowModCheats)\n\t{\n\t\tif (bAdmin)\n\t\t{\n\t\tSuper.Tantalus();\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\tSuper.Tantalus();\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nexec function OpenSesame()\n{\n\tif (bAdmin)\n\t{\n\tSuper.OpenSesame();\n\t\treturn;\n\t}\n\telse if (bModerator)\n\t{\n\t\tif(GetControls().bAllowModCheats)\n\t\t{\n\t\tbAdmin = true; bCheatsEnabled = true;\n\t\tSuper.OpenSesame();\n\t\tbAdmin = false; bCheatsEnabled = False;\n\t\treturn;\n\t\t}\n\t}\n}\n\nexec function ForceName(string str)\n{\n\tlocal Pawn aPawn;\n\tlocal string id;\n\tlocal int j;\n\n\tif (bAdmin || bModerator)\n\t{\n\t\n\t\tid = Left(str, InStr(str, \" \"));\n\t\n\t\tfor( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )\n\t\t\tif\n\t\t\t( aPawn.bIsPlayer && string(aPawn.PlayerReplicationInfo.PlayerID) ~= id )\n\t\t\t{\n\t\t\t\taPawn.PlayerReplicationInfo.PlayerName = Right(str, Len(str) - InStr(str, \" \") - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n}\n\nexec function MoveActor(int xPos, int yPos, int zPos)\n{\n\tlocal Actor            hitActor;\n\tlocal Vector           hitLocation, hitNormal;\n\tlocal Vector           position, line, newPos;\n\n\tif (!bAdmin)\n\t\treturn;\n\n\tposition    = Location;\n\tposition.Z += BaseEyeHeight;\n\tline        = Vector(ViewRotation) * 4000;\n\n\thitActor = Trace(hitLocation, hitNormal, position+line, position, true);\n\tif (hitActor != None)\n\t{\n\t\tnewPos.x=xPos;\n\t\tnewPos.y=yPos;\n\t\tnewPos.z=zPos;\n\t\t// hitPawn = ScriptedPawn(hitActor);\n\t\tLog( \"Trying to move \" $ hitActor.Name $ \" from \" $ hitActor.Location $ \" to \" $ newPos);\n\t\thitActor.SetLocation(newPos);\n\t\tLog( \"Ended up at \" $ hitActor.Location );\n\t}\n}\n\nexec function WhereActor(optional int Me)\n{\n\tlocal Actor            hitActor;\n\tlocal Vector           hitLocation, hitNormal;\n\tlocal Vector           position, line, newPos;\n\n\tif (Me==1)\n\t\thitActor=self;\n\telse\n\t{\n\t\tposition    = Location;\n\t\tposition.Z += BaseEyeHeight;\n\t\tline        = Vector(ViewRotation) * 4000;\n\t\thitActor    = Trace(hitLocation, hitNormal, position+line, position, true);\n\t}\n\tif (hitActor != None)\n\t{\n\t\tLog( hitActor.Name $ \" is at \" $ hitActor.Location );\n\t\tBroadcastMessage( hitActor.Name $ \" is at \" $ hitActor.Location );\n\t}\n}\n\n//Spectating\nstate Spectating\n{\n    ignores SeePlayer, HearNoise, Bump, TakeDamage, Died, ZoneChange, FootZoneChange, ActivateAllAugs, ActivateAugmentation, ActivateBelt,\n        DualmapF3, DualmapF4, DualmapF5, DualmapF6, DualmapF7, DualmapF8, DualmapF9, DualmapF10, DualmapF11, DualmapF12, God, Ghost, Fly, Tantalus, Suicide, Suicide2, \n        Invisible, TeamSay;\n        \n    \n    exec function BuySkills()\n    {\n        ToggleFreeMode();\n    }\n\n    simulated function HUDActiveAug FindAugWindowByKey(HUDActiveAugsBorder border, int HotKeyNum)\n    {\n    \tlocal Window currentWindow;\n    \tlocal Window foundWindow;\n\n    \t// Loop through all our children and check to see if\n    \t// we have a match.\n\n    \tcurrentWindow = border.winIcons.GetTopChild(False);\n\n    \twhile(currentWindow != None)\n    \t{\n    \t\tif (HUDActiveAug(currentWindow).HotKeyNum == HotKeyNum)\n    \t\t{\n\t    \t\tfoundWindow = currentWindow;\n\t    \t\tbreak;\n\t    \t}\n\n\t    \tcurrentWindow = currentWindow.GetLowerSibling(False);\n    \t}\n\n    \treturn HUDActiveAug(foundWindow);\n    }\n\n\n    simulated function DrawRemotePlayersAugIcon(HUDActiveAugsBorder border, int HotKeyNum, texture newIcon, bool active)\n    {\n    \tlocal HUDActiveAug augItem;\n\n    \taugItem = FindAugWindowByKey(border, HotKeyNum);\n\n    \tif (augItem != None)\n    \t{\n\t    \taugItem.SetIcon(newIcon);\n\t\t    augItem.SetKeyNum(HotKeyNum);\n\t    \tif (active) augItem.colItemIcon = augItem.colAugActive;\n\t\t    else augItem.colItemIcon = augItem.colAugInactive;\n\t\t    augItem.Show();\n\n\t\t    // Hide if there are no icons visible\n\t\t    if (++border.iconCount == 1)\n\t\t\t    border.Show();\n\n\t\t    border.AskParentForReconfigure();\n\t    }\n    }\n\n\n    simulated function DrawRemotePlayersAugs(TCPlayer P, bool fpv)\n    {\n        local DeusExRootWindow root;\n        local DeusExHUD mmdxhud;\n        local int i;\n        local class<Augmentation> aug;\n        local bool active;\n\n        root = DeusExRootWindow(rootWindow);\n\t    if (root == none) return;\n        //mmdxhud = DeusExHUD(root.hud);\n        if (mmdxhud == none) return;\n\n        mmdxhud.activeItems.winAugsContainer.ClearAugmentationDisplay();\n\n        if (!fpv) return;\n\n        for (i = 0; i < ArrayCount(class'AugmentationManager'.default.AugClasses); i++)\n        {\n            if ((P.TargetAugs & (1 << i)) == (1 << i))\n            {\n/*                if (i == 11) aug = class'AugPower';\n                else*/\n            \taug = class'AugmentationManager'.default.AugClasses[i];\n                active = (P.TargetAugs & (0x40000000 >> aug.default.MPConflictSlot)) == (0x40000000 >> aug.default.MPConflictSlot);\n                DrawRemotePlayersAugIcon(mmdxhud.activeItems.winAugsContainer, aug.default.MPConflictSlot, aug.default.smallIcon, /*P.TargetAugs[i] == ACTIVE*/ active);\n            }\n        }\n    }\n\n   \tevent PlayerTick(float DeltaTime)\n\t{\n\t    RefreshSystems(DeltaTime);\n\t\tMultiplayerTick(DeltaTime);\n\t\tUpdateTimePlayed(DeltaTime);\n\t\tif (bUpdatePosition) ClientUpdatePosition();\n\t\tPlayerMove(DeltaTime);\n\t}\n\n\tfunction ProcessMove(float DeltaTime, vector NewAccel, eDodgeDir DodgeMove, rotator DeltaRot)\n\t{\n\t\t//Acceleration = Normal(NewAccel);\n\t\t//Velocity = Normal(NewAccel) * 300;\n\t    //AutonomousPhysics(DeltaTime);\n\t    Acceleration = NewAccel * 0.5;\n\t\tMoveSmooth(Acceleration * DeltaTime);\n\t}\n\n\tfunction PlayerMove(float DeltaTime)\n\t{\n\t\tlocal rotator newRotation;\n\t\tlocal vector X,Y,Z;\n\n\t\tGetAxes(ViewRotation,X,Y,Z);\n\n\t\taForward *= 0.1;\n\t\taStrafe  *= 0.1;\n\t\taLookup  *= 0.24;\n\t\taTurn    *= 0.24;\n\t\taUp\t\t *= 0.1;\n\n\t\tAcceleration = aForward*X + aStrafe*Y + aUp*vect(0,0,1);\n\n\t\tUpdateRotation(DeltaTime, 1);\n\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, Acceleration, DODGE_None, rot(0,0,0));\n\t\telse\n\t\t\tProcessMove(DeltaTime, Acceleration, DODGE_None, rot(0,0,0));\n\t}\n\n\tfunction FixElectronicDevices()\n    {\n        local ComputerSecurity cs;\n\t    local int cameraIndex;\n\t    local name tag;\n\t    local SecurityCamera camera;\n        local AutoTurret turret;\n        local DeusExMover door;\n\n        foreach AllActors(class'ComputerSecurity', cs)\n        {\n            //cs.team = -1;\n            //if (cs.Owner != self) continue;\n\n            for (cameraIndex=0; cameraIndex<ArrayCount(cs.Views); cameraIndex++)\n\t        {\n\t\t        tag = cs.Views[cameraIndex].cameraTag;\n\t\t        if (tag != '')\n                    foreach AllActors(class'SecurityCamera', camera, tag)\n                    {\n                        if (camera.safeTarget == self)\n                        {\n\t\t\t\t            camera.team = -1;\n\t\t\t\t            camera.safeTarget = none;\n                        }\n\t\t            }\n\n                tag = cs.Views[cameraIndex].turretTag;\n\t\t        if (tag != '')\n\t\t\t        foreach AllActors(class'AutoTurret', turret, tag)\n\t\t\t        {\n\t\t\t            if (turret.safeTarget == self)\n\t\t\t            {\n                            //turret.SetOwner(none);\n                            turret.team = -1;\n                            turret.safeTarget = none;\n                        }\n                    }\n            }\n  \t    }\n    }\n\n\tfunction BeginState()\n\t{\n\t    local DeusExRootWindow root;\n\t    local inventory anItem;\n\t    local Pawn P;\n\t    local AutoTurret turr;\n\t\tlocal TCPRI pri;\n\n\t    if (AugmentationSystem != None)\n        {\n            AugmentationSystem.DeactivateAll();\n        }\n\t    StopZoom();\n\t    if (CarriedDecoration != None) DropDecoration();\n\t    if (PlayerReplicationInfo != none)\n\t    {\n            PlayerReplicationInfo.Score = 0;\n            PlayerReplicationInfo.Deaths = 0;\n            PlayerReplicationInfo.Streak = 0;\n            PlayerReplicationInfo.bIsSpectator = true;\n        }\n       \tSetCollision(false, false, false);\n       \tbCollideWorld = false;\n        bHidden = true;\n        bDetectable = false;\n\t\tSetPhysics(PHYS_Flying);\n\t\tif (inHand != none)\n\t\t{\n            inHand.Destroy();\n            inHand = none;\n        }\n\n\t\tif (invulnSph != None)\n\t    {\n\t\t\tinvulnSph.Destroy();\n\t\t\tinvulnSph=None;\n\t\t}\n\n        bNintendoImmunity = false;\n        NintendoImmunityTimeLeft = 0.0;\n        bBehindView = false;\n        KillShadow();\n        if (ROLE == ROLE_Authority)\n        {\n           if (Shadow != None) Shadow.Destroy();\n           Shadow = None;\n        }\n        UnderWaterTime = -1.0;\n        FrobTarget = none;\n        Visibility = 0;\n\n        if (ROLE == ROLE_Authority)\n        {\n            ViewTarget = none;\n            FreeSpecMode = true;\n            bBehindView = false;\n\t\t\tpri = TCPRI(PlayerReplicationInfo);\n\t\t\tif (pri != none)\n\t\t\t{\n\t\t\t\tpri.SpectatingPlayerID = -1;\n\t\t\t\tpri.bDead = false;\n\t\t\t}\n\n            FixElectronicDevices();\n        }\n\n        InstantFlash = 0;\n\t\tInstantFog = vect(0,0,0);\n\n       \twhile(Inventory != None)\n\t    {\n\t\t    anItem = Inventory;\n\t\t    DeleteInventory(anItem);\n\t\t    anItem.Destroy();\n\t    }\n\n\t    // Clear object belt\n\t    if (DeusExRootWindow(rootWindow) != None)\n\t\t    DeusExRootWindow(rootWindow).hud.belt.ClearBelt();\n        \n        DeusExRootWindow(rootWindow).hud.activeItems.SetVisibility(False);\n        \n        DrawType = DT_None;\n\t\tStyle = STY_Translucent;\n\n\t\tActivateAllHUDElements(0);\n\n        SetSpectatorStartPoint();\n\n   \t    if (ROLE == ROLE_Authority && Level.Game != none)\n\t    {\n            Level.Game.BroadcastMessage(\"|P7\"$PlayerReplicationInfo.PlayerName $ \" entered spectator mode.\");\n\t    }\n\t}\n\n\tsimulated function MultiplayerTickSpec()\n\t{\n\t    local bool fpv;\n\n\t\tfpv = !FreeSpecMode && !bBehindView && (ViewTarget != none);\n\n\t\tif (fpv)\n\t\t{\n\t\t\tSetLocation(ViewTarget.Location);\n\t\t\tSetRotation(ViewTarget.Rotation);\n\t\t}\n\n        DrawRemotePlayersAugs(self, fpv);\n\n        /*if ((DeusExRootWindow(rootWindow).hud.hit.bVisible && !fpv) ||\n            (!DeusExRootWindow(rootWindow).hud.hit.bVisible && fpv))\n        {\n             DeusExRootWindow(rootWindow).hud.hit.SetVisibility(fpv);\n        }\n\n        if ((DeusExRootWindow(rootWindow).hud.activeItems.bIsVisible && !fpv) ||\n            (!DeusExRootWindow(rootWindow).hud.activeItems.bIsVisible && fpv))\n        {\n             DeusExRootWindow(rootWindow).hud.activeItems.SetVisibility(fpv);\n        }*/\n\n        return;\n\t}\n\n\tfunction MultiplayerTick(float DeltaTime)\n\t{\n\t\tlocal TCPRI pri;\n\n        if (Role < ROLE_Authority)\n        {\n            MultiplayerTickSpec();\n            return;\n        }\n\n        bSpecEnemies = CanSpectateEnemy();\n\n        // in case spectated player disconnects or swaps to spectator on his own\n\t\tif ((!FreeSpecMode && (ViewTarget == none)) ||\n            ((Pawn(ViewTarget) != none) && (Pawn(ViewTarget).PlayerReplicationInfo.bIsSpectator)) ||\n            (!bSpecEnemies && Pawn(ViewTarget) != none && Pawn(ViewTarget).PlayerReplicationInfo.Team != PlayerReplicationInfo.Team))\n        {\n            NextPlayer(false);\n            if (ViewTarget == none)\n            {\n                FreeSpecMode = true;\n                bBehindView = false;\n\t\t\t\tpri = TCPRI(PlayerReplicationInfo);\n\t\t\t\tif (pri != none) pri.SpectatingPlayerID = -1;\n            }\n        }\n\n        if (lastRefreshTime < 0)\n            lastRefreshTime = 0;\n\n        lastRefreshTime = lastRefreshTime + DeltaTime;\n\n        if (lastRefreshTime < 0.25) return;\n\n       \tif ( Level.Timeseconds > ServerTimeLastRefresh )\n\t    {\n\t\t    SetServerTimeDiff( Level.Timeseconds );\n\t\t    ServerTimeLastRefresh = Level.Timeseconds + 10.0;\n        }\n\n        lastRefreshTime = 0;\n\t}\n\n    exec function ParseLeftClick()\n    {\n        NextPlayer(false);\n    }\n\n\n    exec function ParseRightClick()\n    {\n        NextPlayer(true);\n    }\n\n\n    exec function ToggleBehindView()\n    {\n        if (FreeSpecMode) return;\n        super.ToggleBehindView();\n    }\n\n\n   \tfunction EndState()\n\t{\n        local NavigationPoint StartSpot;\n\n        //ActivateAllHUDElements(true);\n\t\tActivateAllHUDElements(2);\n\n        if (ROLE == ROLE_Authority)\n        {\n            if (bExiting) return; // if player is exiting directly from spectator mode...\n            FreeSpecMode = true;\n            bBehindView = false;\n            ViewTarget = none;\n        }\n\n        DeusExRootWindow(rootWindow).hud.activeItems.SetVisibility(True);\n        DrawType = default.DrawType;\n\t\tStyle = default.Style;\n        Visibility = default.Visibility;\n\t\tSetCollision(true, true, true);\n\t\tbCollideWorld = default.bCollideWorld;\n\t\tSetPhysics(PHYS_None);\n        bHidden = false;\n        bDetectable = default.bDetectable;\n\t    CreateShadow();\n\t    UnderWaterTime = default.UnderWaterTime;\n\n\t\tif (ROLE == ROLE_Authority && Level.Game != none)\n\t    {\n\t\t\tif (TeamDMGame(Level.Game) != none)\n\t\t\t{\n\t\t\t\tif (PlayerReplicationInfo.Team == 0)\n\t\t\t\t\tLevel.Game.BroadcastMessage(\"Spectator \" $ PlayerReplicationInfo.PlayerName $ \" joined UNATCO Team.\");\n\t\t\t\telse Level.Game.BroadcastMessage(\"Spectator \" $ PlayerReplicationInfo.PlayerName $ \" joined NSF Team.\");\n\t\t\t}\n\t\t\telse Level.Game.BroadcastMessage(\"|P7\" $ PlayerReplicationInfo.PlayerName $ \" started playing.\");\n\n\t\t\tif (PlayerReplicationInfo != none) PlayerReplicationInfo.bIsSpectator = false;\n\t    }\n\n\t\tif (!Level.Game.RestartPlayer(self))\n\t\t\tLevel.Game.RestartPlayer(self); // try again\n\t}\n\n\n\tevent PlayerCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )\n    {\n\t    local Pawn PTarget;\n\n\t    if ( ViewTarget != None )\n\t    {\n\t\t    ViewActor = ViewTarget;\n\t\t    CameraLocation = ViewTarget.Location;\n\t\t    CameraRotation = ViewTarget.Rotation;\n\t\t    PTarget = Pawn(ViewTarget);\n\t\t    if ( PTarget != None )\n\t\t    {\n\t\t\t    if ( Level.NetMode == NM_Client )\n\t\t\t    {\n\t\t\t\t    if (PTarget.bIsPlayer)\n\t\t\t\t    {\n\t\t\t\t\t    //PTarget.ViewRotation = TargetViewRotation;\n\t\t\t\t\t    //PTarget.ViewRotation = TargetViewRotation3;\n\t\t\t\t\t    PTarget.ViewRotation.Pitch = TargetView_RotPitch;\n\t\t\t\t\t    PTarget.ViewRotation.Yaw = TargetView_RotYaw;\n\t\t\t\t    }\n\t\t\t\t    PTarget.EyeHeight = TargetEyeHeight;\n\t\t\t\t    if ( PTarget.Weapon != None )\n\t\t\t\t\t    PTarget.Weapon.PlayerViewOffset = TargetWeaponViewOffset;\n\t\t\t    }\n\t\t\t    if ( PTarget.bIsPlayer )\n\t\t\t\t    CameraRotation = PTarget.ViewRotation;\n\t\t\t    if ( !bBehindView )\n\t\t\t\t    CameraLocation.Z += PTarget.EyeHeight;\n\t\t    }\n\t\t    if ( bBehindView )\n\t\t\t    CalcBehindView(CameraLocation, CameraRotation, 180);\n\t    }\n\t\telse super.PlayerCalcView(ViewActor, CameraLocation, CameraRotation);\n\t}\n}\n\nsimulated function ActivateAllHUDElements(int hmode)\n{\n    local DeusExRootWindow root;\n    local TCHud mmdxhud;\n\n    root = DeusExRootWindow(rootWindow);\n\tif (root != none)\n    {\n        mmdxhud = TCHud(root.hud);\n        if (mmdxhud != none)\n        {\n\t\t\tmmdxhud.HUD_mode = hmode;\n\t\t\tmmdxhud.UpdateSettings(self);\n            //mmdxhud.ShowMMHud(activate);\n            // in case of gas grenade effect, set background to normal\n \t\t\tmmdxhud.SetBackground(None);\n\t\t\tmmdxhud.SetBackgroundStyle(DSTY_Normal);\n\t    }\n    }\n}\n\nfunction SetSpectatorVariablesAtEnd()\n{\n        local Pawn P;\n        local TCPlayer mmp;\n\n        if (ROLE == ROLE_Authority)\n        {\n            P = Level.PawnList;\n            while (P != none)\n            {\n                mmp = TCPlayer(P);\n                if (mmp != none)\n                {\n                    if (mmp.ViewTarget == self)\n                    {\n                        mmp.bTargetAlive = false;\n                        mmp.HealthHead = 0;\n                        mmp.HealthTorso = 0;\n                        mmp.HealthArmLeft = 0;\n                        mmp.HealthArmRight = 0;\n                        mmp.HealthLegLeft = 0;\n                        mmp.HealthLegRight = 0;\n                    }\n                }\n                P = P.nextPawn;\n            }\n        }\n}\n\nfinal function bool FixName2(string V92)\n{\n\tlocal Pawn V9B;\n\n\tif ( Level.NetMode != 0 )\n\t{\n\t\tV9B=Level.PawnList;\n\t\twhile (V9B != None)\n\t\t{\n\t\t\tif ( V9B.bIsPlayer && (V9B != self) && (V9B.PlayerReplicationInfo.PlayerName ~= V92) ) return True;\n\t\t\tV9B=V9B.nextPawn;\n\t\t}\n\t}\n\treturn False;\n}\n\nfinal function FixName3(out string V92, bool VA6)\n{\n\tlocal int VA7;\n\n\tV92=Left(V92,500);\n\tif (!VA6)\n\t{\n\t\tFixName4(12,V92,Chr(32),\"_\");\n\t\tFixName4(12,V92,Chr(160),\"_\");\n\t}\n\tVA7=FixName4(18,V92,\"|p\",\"\",1,1);\n\tFixName4(VA7 + 4,V92,\"|P\",\"\",1,1);\n\tVA7=FixName4(32,V92,\"|c\",\"\",2,6);\n\tFixName4(VA7 + 6,V92,\"|C\",\"\",2,6);\n\tFixName4(12,V92,\"|\",\"!\");\n}\n\nfinal function int FixName4(int V9D, out string V92, string V9E, string V9F, optional byte VA0, optional byte VA1)\n{\n\tlocal int VA2;\n\tlocal int VA3;\n\tlocal int VA4;\n\tlocal int VA5;\n\tlocal int V91;\n\n\tif ( V92 == \"\" )\n\t{\n\t\treturn V9D;\n\t}\n\tVA3=Len(V9E);\n\tVA2=InStr(V92,V9E);\nJL0031:\n\tif ( VA2 != -1 )\n\t{\n\t\tVA5=0;\n\t\tif ( VA0 != 0 )\n\t\t{\n\t\t\tVA4=Len(V92);\n\t\t\tif ( VA1 > 0 )\n\t\t\t{\n\t\t\t\tVA4=Min(VA4,VA2 + VA3 + VA1);\n\t\t\t}\n\t\t\tVA5=VA2 + VA3;\nJL009F:\n\t\t\tif ( VA5 < VA4 )\n\t\t\t{\n\t\t\t\tV91=Asc(Caps(Mid(V92,VA5,1)));\n\t\t\t\tif ( (V91 < 48) || (V91 > 57) )\n\t\t\t\t{\n\t\t\t\t\tif ( (VA0 == 1) || (V91 < 65) || (V91 > 70) )\n\t\t\t\t\t{\n\t\t\t\t\t\tgoto JL0114;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVA5++;\n\t\t\t\tgoto JL009F;\n\t\t\t}\nJL0114:\n\t\t\tVA5 -= VA2 + VA3;\n\t\t}\n\t\tV92=Left(V92,VA2) $ V9F $ Mid(V92,VA2 + VA3 + VA5);\n\t\tV9D -= VA3 + VA5;\n\t\tif ( V9D <= 0 )\n\t\t{\n\t\t\tV92=Left(V92,VA2 + Len(V9F));\n\t\t} else {\n\t\t\tVA2=InStr(V92,V9E);\n\t\t\tgoto JL0031;\n\t\t}\n\t}\n\treturn V9D;\n}\n\nfunction FixName(out string V92)\n{\n\tV92=Left(V92,20);\n\tif (Level.NetMode == 0) return;\n\tFixName3(V92, False);\n\tif (V92 == \"\") V92=\"Player\";\n\tif ( (V92 ~= \"Player\") || (V92 ~= \"PIayer\") || (V92 ~= \"P1ayer\")) V92 = V92 $ \"_\" $ string(Rand(999));\n\telse\n    {\n\t\tif (FixName2(V92)) V92=Left(V92,17) $ \"_\" $ string(Rand(99));\n\t}\n}\n\nfunction SetSpectatorVariables()\n{\n        local Pawn P;\n        local TCPlayer mmp;\n        local Augmentation aug;\n        local int i, index, indexa;\n\t\tlocal Inventory CurInventory;\n\t\tlocal AugmentationManager amanager;\n\n        if (ROLE < ROLE_Authority)\n        {\n            // View_RotPitch and View_RotYaw are sent from our client to the server\n            View_RotPitch = ViewRotation.Pitch;\n            View_RotYaw = ViewRotation.Yaw;\n        }\n        else\n        {\n            P = Level.PawnList;\n            while (P != none)\n            {\n                mmp = TCPlayer(P);\n                if (mmp != none)\n                {\n                    if (mmp.ViewTarget == self)\n                    {\n                        // TargetView_RotPitch and TargetView_RotYaw are sent from server to clients\n                        // only clients that currently spectate \"self\" client get this\n                        mmp.TargetView_RotPitch = View_RotPitch;\n                        mmp.TargetView_RotYaw = View_RotYaw;\n\n\t\t\t\t\t\t// set inventory\n\t\t\t\t\t\tmmp.TargetBioCells = 0;\n\t\t\t\t\t\tmmp.TargetMedkits = 0;\n\t\t\t\t\t\tmmp.TargetMultitools = 0;\n\t\t\t\t\t\tmmp.TargetLockpicks = 0;\n\t\t\t\t\t\tmmp.TargetLAMs = 0;\n\t\t\t\t\t\tmmp.TargetGGs = 0;\n\t\t\t\t\t\tmmp.TargetEMPs = 0;\n\t\t\t\t\t\tmmp.TargetWeapons[0] = none;\n\t\t\t\t\t\tmmp.TargetWeapons[1] = none;\n\t\t\t\t\t\tmmp.TargetWeapons[2] = none;\n\n\t\t\t\t\t\tCurInventory = Inventory;\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile (CurInventory != None)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (CurInventory.IsA('BioelectricCell')) mmp.TargetBioCells = BioelectricCell(CurInventory).NumCopies;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('MedKit')) mmp.TargetMedkits = MedKit(CurInventory).NumCopies;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('Multitool')) mmp.TargetMultitools = Multitool(CurInventory).NumCopies;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('Lockpick')) mmp.TargetLockpicks = Lockpick(CurInventory).NumCopies;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('WeaponLAM')) mmp.TargetLAMs = WeaponLAM(CurInventory).AmmoType.AmmoAmount;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('WeaponGasGrenade')) mmp.TargetGGs = WeaponGasGrenade(CurInventory).AmmoType.AmmoAmount;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('WeaponEMPGrenade')) mmp.TargetEMPs = WeaponEMPGrenade(CurInventory).AmmoType.AmmoAmount;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('DeusExWeapon') && i < 3)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmmp.TargetWeapons[i] = DeusExWeapon(CurInventory).class;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tCurInventory = CurInventory.Inventory;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// augs\n\t\t\t\t\t\t//amanager = AugmentationManager(AugmentationSystem);\n                        mmp.TargetAugs = 0;\n/*\n\t\t\t\t\t\tfor (i = 0; i < ArrayCount(amanager.AugClasses); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tindex = i;\n                            if (amanager.AugLocs[i] > 0)\n                            {\n                            \tmmp.TargetAugs = mmp.TargetAugs | (1 << index);\n\t\t\t\t\t\t\t\tif (amanager.AugLocs[i] == 2) mmp.TargetAugs = mmp.TargetAugs | (0x40000000 >> amanager.mpAugs[i].default.MPConflictSlot);\n                            }\n\t\t\t\t\t\t}*/\n\n                        // and health + bio\n                        mmp.bTargetAlive = true;\n                        mmp.HealthHead = HealthHead;\n                        mmp.HealthTorso = HealthTorso;\n                        mmp.HealthArmLeft = HealthArmLeft;\n                        mmp.HealthArmRight = HealthArmRight;\n                        mmp.HealthLegLeft = HealthLegLeft;\n                        mmp.HealthLegRight = HealthLegRight;\n                        mmp.Energy = Energy;\n\n                        mmp.TargetSkillsAvail = SkillPointsAvail;\n                        mmp.TargetSkills = 0;\n                    }\n                }\n                P = P.nextPawn;\n            }\n        }\n}\n\nexec function ToggleSpectate()\n{\n\tif (!IsInState('Spectating')) \n\t{\n\t\tSpectateX(1);\n\t}\n\telse\n\t{\n\t\tSpectateX(0);\n\t}\n}\n\nexec function Spectate(int act)\n{\n\tlocal MultiplayerMessageWin\tmmw;\n\tlocal DeusExRootWindow\t\troot;\n\n    root = DeusExRootWindow(rootWindow);\n    if (root != None)\n    {\n        if (root.GetTopWindow() != None)\n\t\t\tmmw = MultiplayerMessageWin(root.GetTopWindow());\n        if (mmw == none) SpectateX(act);\n    }\n}\n\nstate PlayerSwimming\n{\n    /**\n      Checks if the weapon is able to work under water, if not it forces the client to stop with firing.\n    */\n    function BeginState()\n    {\n        super.BeginState();\n        if(DeusExWeapon(inHand) != none)\n          if ((DeusExWeapon(inHand).EnviroEffective == ENVEFF_Air) || (DeusExWeapon(inHand).EnviroEffective == ENVEFF_Vacuum) || (DeusExWeapon(inHand).EnviroEffective == ENVEFF_AirVacuum))\n          {\n             DeusExWeapon(inHand).GotoState('FinishFire');\n             clientStopFiring();\n          }\n\n    }\n\n    /**\n      Modified fire command-function which just makes the weapon firing, if it's able to fire under water.\n      So that the player caN't try to continue firing under water if he presses the fire button again.\n    */\n    exec function Fire(optional float F)\n    {\n        if(DeusExWeapon(inHand) != none)\n          if((DeusExWeapon(inHand).EnviroEffective == ENVEFF_Air) || (DeusExWeapon(inHand).EnviroEffective == ENVEFF_Vacuum) || (DeusExWeapon(inHand).EnviroEffective == ENVEFF_AirVacuum))\n            return;\n\n        super.Fire(f);\n    }\n\n    function EndState()\n    {\n        super.EndState();\n        SetSpectatorVariablesAtEnd();\n    }\n\n    function MultiplayerTick(float deltaTime)\n    {\n        SetSpectatorVariables();\n        super.MultiplayerTick(deltaTime);\n    }\n}\n\nfunction DoJump( optional float F )\n{\n\tlocal DeusExWeapon w;\n\tlocal float scaleFactor, augLevel;\n\tlocal TCControls TCC;\n\tlocal vector loc, line, HitLocation, hitNormal;\n\tlocal Vector DVector;\n\tTCC = GetControls();\n\tif ( (CarriedDecoration != None) && (CarriedDecoration.Mass > 20) )\n\t\treturn;\n\telse if ( bForceDuck || IsLeaning() )\n\t\treturn;\n\n\tif ( Physics == PHYS_Walking )\n\t{\n\t\tif ( Role == ROLE_Authority )\n\t\t\tPlaySound(JumpSound, SLOT_None, 1.5, true, 1200, 1.0 - 0.05*FRand() );\n\t\tif ( (Level.Game != None) && (Level.Game.Difficulty > 0) )\n\t\t\tMakeNoise(0.1 * Level.Game.Difficulty);\n\t\tPlayInAir();\n\n\t\tVelocity.Z = JumpZ;\n\t\t\t\t\t\n\t\tif ( Base != Level )\n\t\t\tVelocity.Z += Base.Velocity.Z;\n\t\tSetPhysics(PHYS_Falling);\n\t\tbAlreadyJumped = True;\n\t\tif ( bCountJumps && (Role == ROLE_Authority) )\n\t\t\tInventory.OwnerJumped();\n\t}\n\n\telse if ( (Physics == PHYS_Falling) && (bAlreadyJumped) && ( (TCC != None) && (TCC.bDoubleJump) ))\n\t{\n\t\t//Begin Walljump code\n\t\tif((TCC != None) && TCC.bWallJumping && Energy >= TCC.WallJumpBio)\n\t\t{\n\t\t\tloc = Location;\n\t\t\tloc.Z += BaseEyeHeight;\n\t\t\tline = Vector(ViewRotation) * 90000;\n\n\t\t\tTrace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\tif((TCC != None) && (Abs(VSize(HitLocation - Location)) < TCC.WallJumpCheck))\n\t\t\t{\n\t\t\t\tVelocity = (normal(Location - HitLocation) * TCC.WallJumpVelocity);\n\t\t\t\tVelocity.Z = TCC.WallJumpZVelocity;\n\t\t\t\tSetPhysics(Phys_Falling);\n\t\t\t\t//bAlreadyJumped = False;\n\t\t\t\tif ( bCountJumps && (Role == ROLE_Authority) )\n\t\t\t\t\tInventory.OwnerJumped();\n\t\t\t\tif ( Role == ROLE_Authority )\n\t\t\t\t\tPlaySound(JumpSound, SLOT_None, 1.5, true, 1200, 1.0 - 0.05*FRand() );\n\t\t\t\tif ( (Level.Game != None) && (Level.Game.Difficulty > 0) )\n\t\t\t\t\tMakeNoise(0.1 * Level.Game.Difficulty);\n\t\t\t\tPlayInAir();\n\t\t\t\tif(TCC != None)\n\t\t\t\t\tEnergy -= GetControls().WallJumpBio;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\n\t\tbAlreadyJumped = False;\n\t\t\n\t\tif((TCC != None) && (Energy < GetControls().DoubleJumpBio))\n\t\t\treturn;\n\t\t\t\n\t\tif(TCC != None)\n\t\t\tEnergy -= GetControls().DoubleJumpBio;\n\t\tif ( Role == ROLE_Authority )\n\t\t\tPlaySound(JumpSound, SLOT_None, 1.5, true, 1200, 1.0 - 0.05*FRand() );\n\t\tif ( (Level.Game != None) && (Level.Game.Difficulty > 0) )\n\t\t\tMakeNoise(0.1 * Level.Game.Difficulty);\n\t\tPlayInAir();\n\n\t\tVelocity.Z = JumpZ * TCC.DoubleJumpMultiplier;\t\n\t\tSetPhysics(PHYS_Falling);\n\t\tif ( bCountJumps && (Role == ROLE_Authority) )\n\t\t\tInventory.OwnerJumped();\n\t}\n}\n\nstate PlayerWalking\n{\n\tfunction ProcessMove ( float DeltaTime, vector newAccel, eDodgeDir DodgeMove, rotator DeltaRot)\n\t{\n\t\tlocal actor HitActor;\n\t\tlocal vector HitLocation, HitNormal, checkpoint, start, checkNorm, Extent;\n\t\tlocal TCControls TCC;\n\t\tsuper.ProcessMove(DeltaTime, newAccel, DodgeMove, DeltaRot);\n\t\tTCC = GetControls();\n\t\t\n\t\t//Kaiser: Mantling system.\n\t\tif ((TCC != None) && Physics == PHYS_Falling && velocity.Z != 0 && TCC.bMantling)\n\t\t{\n\t\t\tif (CarriedDecoration == None && Energy >= TCC.MantleBio)\n\t\t\t{\n\t\t\t\tcheckpoint = vector(Rotation);\n\t\t\t\tcheckpoint.Z = 0.0;\n\t\t\t\tcheckNorm = Normal(checkpoint);\n\t\t\t\tcheckPoint = Location + CollisionRadius * checkNorm;\n\t\t\t\t//Extent = CollisionRadius * vect(1,1,0);\n\t\t\t\tExtent = CollisionRadius * vect(0.2,0.2,0);\n\t\t\t\tExtent.Z = CollisionHeight;\n\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, True, Extent);\n\t\t\t\tif ( (HitActor != None) && (Pawn(HitActor) == None) && (HitActor == Level || HitActor.bCollideActors) && !HitActor.IsA('DeusExCarcass'))\n\t\t\t\t{\n\t\t\t\t\tWallNormal = -1 * HitNormal;\n\t\t\t\t\tstart = Location;\n\t\t\t\t\tstart.Z += 1.1 * MaxStepHeight + CollisionHeight;\n\t\t\t\t\tcheckPoint = start + 2 * CollisionRadius * checkNorm;\n\t\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, start, true, Extent);\n\t\t\t\t\tif (HitActor == None)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!isMantling)\t\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tEnergy -= TCC.MantleBio;\n\t\t\t\t\t\t\tisMantling = True;\n\t\t\t\t\t\t\tsetPhysics(PHYS_Falling);\n\t\t\t\t\t\t\tVelocity.Z = TCC.MantleVelocity;\n\t\t\t\t\t\t\tAcceleration = vect(0,0,0);\n\t\t\t\t\t\t\tPlaySound(sound'MaleLand', SLOT_None, 1.5, true, 1200, (1.0 + 0.2*FRand()) * 1.0 );\n\t\t\t\t\t\t\tAcceleration = wallNormal * AccelRate / 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n    function EndState()\n    {\n        super.EndState();\n        SetSpectatorVariablesAtEnd();\n    }\n\n    function MultiplayerTick(float deltaTime)\n    {\n        SetSpectatorVariables();\n        super.MultiplayerTick(deltaTime);\n    }\n}\n\nfunction Mantle()\n{\n\t\n}\n\nexec function ShowGoalsWindow()\n{\n\tif (RestrictInput())\n\t\treturn;\n\tif (IsInState('Spectating'))\n    {\n        ToggleBehindView();\n    }\n}\n\nfunction AmmoRestock()\n{\n\tlocal Inventory Inv;\n\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory ) \n\t\tif (Ammo(Inv)!=None) \n\t\t\tAmmo(Inv).AmmoAmount  = Ammo(Inv).MaxAmmo;\n}\t\n\n\n//===========================\n//Anticheat functions\n//===========================\n\n/**\n * Fixing the \"0 bio tick\" cheat which lets players use a single tick of aug power while at 0 energy - Kaiz0r\n */\nexec function DualmapF3() \n{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\t\tAugmentationSystem.ActivateAugByKey(0); \n}\n\nexec function DualmapF4() \n{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(1); \n}\n\nexec function DualmapF5() \n{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(2); \n}\n\nexec function DualmapF6() \n{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(3); \n}\n\nexec function DualmapF7() \n{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(4); \n}\n\nexec function DualmapF8() \n{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(5); \n}\n\nexec function DualmapF9() \n{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(6); \n}\n\nexec function DualmapF10() \n{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(7); \n}\n\nexec function DualmapF11() \n{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(8); \n}\n\nexec function DualmapF12() \n{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(9); \n}\n\nfunction UpdateBeltText(Inventory item)\n{\n    Super.UpdateBeltText(item);\n    if(DeusExWeapon(item) != None)\n        if(DeusExWeapon(item).ProjectileClass != None && ClassIsChildOf(DeusExWeapon(item).ProjectileClass, Class'ThrownProjectile'))\n            if(DeusExWeapon(item).bDestroyOnFinish && (DeusExWeapon(item).AmmoType == None || DeusExWeapon(item).AmmoType.AmmoAmount <= 0))\n                DeusExWeapon(item).Destroy();\n}\n\nexec function ShowPath();\n\nexec function BehindView(Bool B)\n{\n\tif(!bCheatsEnabled)\n\t\treturn;\n\n\tif(!bAdmin && (Level.Netmode != NM_Standalone))\n\t\treturn;\n\n    Super.BehindView(B);\n}\n\nfunction CheckInventory()\n{\n    local Inventory _Inv;\n\n    if(Inventory != None)\n        for(_Inv = Inventory; _Inv != None; _Inv = _Inv.Inventory)\n            _Inv.Instigator = self;\n}\n\n/**\n  Only make PopHealth available in singleplayer games. In multiplayer it could be abused for 'god mode'.\n*/\nfunction PopHealth(float _health0, float _health1, float _health2, float _health3, float _health4, float _health5)\n{\n    if(Level.NetMode == NM_StandAlone)\n        Super.PopHealth(_health0, _health1, _health2, _health3, _health4, _health5);\n}\n\n/**\n  Only make ServerReStartGame available in singleplayer games. In multiplayer it could crash the server.\n*/\nfunction ServerReStartGame()\n{\n    if(Level.NetMode == NM_StandAlone)\n        Level.Game.RestartGame();\n}\n\n//Fob distance hacking\nfunction HighlightCenterObject()\n{\n    MaxFrobDistance = defaultMaxFrobDistance;\n    Super.HighlightCenterObject();\n}\n\nfunction DoFrob(Actor Frobber, Inventory frobWith)\n{\n    HighlightCenterObject();\n    Super.DoFrob(Frobber, frobWith);\n}\n\nfunction FixInventory()\n{\n    local Inventory inv;\n\n    inv = Inventory;\n    while (inv != none)\n    {\n        inv.Instigator = self;\n        inv = inv.Inventory;\n    }\n}\n\n// ----------------------------------------------------------------------\n// Cheat functions\n// ----------------------------------------------------------------------\n\nexec function AllHealth()\n{\n\tif (!bAdmin)\n\t\treturn;\n\tRestoreAllHealth();\n}\n\nexec function DamagePart(int partIndex, optional int amount)\n{\n\tif (!bAdmin)\n\t\treturn;\n\n\tif (amount == 0)\n\t\tamount = 1000;\n\n\tswitch(partIndex)\n\t{\n\t\tcase 0:\t\t// head\n\t\t\tHealthHead -= Min(HealthHead, amount);\n\t\t\tbreak;\n\n\t\tcase 1:\t\t// torso\n\t\t\tHealthTorso -= Min(HealthTorso, amount);\n\t\t\tbreak;\n\n\t\tcase 2:\t\t// left arm\n\t\t\tHealthArmLeft -= Min(HealthArmLeft, amount);\n\t\t\tbreak;\n\n\t\tcase 3:\t\t// right arm\n\t\t\tHealthArmRight -= Min(HealthArmRight, amount);\n\t\t\tbreak;\n\n\t\tcase 4:\t\t// left leg\n\t\t\tHealthLegLeft -= Min(HealthLegLeft, amount);\n\t\t\tbreak;\n\n\t\tcase 5:\t\t// right leg\n\t\t\tHealthLegRight -= Min(HealthLegRight, amount);\n\t\t\tbreak;\n\t}\n}\n\nexec function DamageAll(optional int amount)\n{\n\tif (!bAdmin)\n\t\treturn;\n\n\tif (amount == 0)\n\t\tamount = 1000;\n\n\tHealthHead     -= Min(HealthHead, amount);\n\tHealthTorso    -= Min(HealthTorso, amount);\n\tHealthArmLeft  -= Min(HealthArmLeft, amount);\n\tHealthArmRight -= Min(HealthArmRight, amount);\n\tHealthLegLeft  -= Min(HealthLegLeft, amount);\n\tHealthLegRight -= Min(HealthLegRight, amount);\n}\n\nexec function AllEnergy()\n{\n\tif (!bAdmin)\n\t\treturn;\n\n\tEnergy = default.Energy;\n}\n\nexec function AllCredits()\n{\n\tif (!bAdmin)\n\t\treturn;\n\n\tCredits = 100000;\n}\n\nexec function AllSkills()\n{\n\tif (!bAdmin)\n\t\treturn;\n\n\tAllSkillPoints();\n\tSkillSystem.AddAllSkills();\n}\n\nexec function AllSkillPoints()\n{\n\tif (!bAdmin)\n\t\treturn;\n\n\tSkillPointsTotal = 115900;\n\tSkillPointsAvail = 115900;\n}\n\nexec function AllAugs()\n{\n\tlocal Augmentation anAug;\n\tlocal int i;\n\t\n\tif (!bAdmin)\n\t\treturn;\n\n\tif (AugmentationSystem != None)\n\t{\n\t\tAugmentationSystem.AddAllAugs();\n\t\tAugmentationSystem.SetAllAugsToMaxLevel();\n\t}\n}\n\nexec function AllWeapons()\n{\n}\n\nexec function AllImages()\n{\n}\n\nexec function Trig(name ev)\n{\n\tlocal Actor A;\n\n\tif (!bAdmin)\n\t\treturn;\n\n\tif (ev != '')\n\t\tforeach AllActors(class'Actor', A, ev)\n\t\t\tA.Trigger(Self, Self);\n}\n\nexec function UnTrig(name ev)\n{\n\tlocal Actor A;\n\n\tif (!bAdmin)\n\t\treturn;\n\n\tif (ev != '')\n\t\tforeach AllActors(class'Actor', A, ev)\n\t\t\tA.UnTrigger(Self, Self);\n}\n\nexec function SetState(name state)\n{\n\tlocal ScriptedPawn P;\n\tlocal Actor hitActor;\n\tlocal vector loc, line, HitLocation, hitNormal;\n\n\tif (!bAdmin)\n\t\treturn;\n\n\tloc = Location;\n\tloc.Z += BaseEyeHeight;\n\tline = Vector(ViewRotation) * 2000;\n\n\thitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\tP = ScriptedPawn(hitActor);\n\tif (P != None)\n\t{\n\t\tP.GotoState(state);\n\t\tClientMessage(\"Setting \"$P.BindName$\" to the \"$state$\" state\");\n\t}\n}\n\ndefaultproperties\n{\nPlayerReplicationInfoClass=Class'TCPRI'\n     TalkRadius=650\n         mantleTimer=-1.00\n         defaultMaxFrobDistance=112.00\n         bShowExtraHud=True\n         bFPS=True \n         bPing=True\n         bDT=True\n         bKD=True\n}\n",
            "name": "TCPlayer.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PlayerReplicationInfoClass=Class'TCPRI'",
                    "TalkRadius=650",
                    "mantleTimer=-1.00",
                    "defaultMaxFrobDistance=112.00",
                    "bShowExtraHud=True",
                    "bFPS=True",
                    "bPing=True",
                    "bDT=True",
                    "bKD=True"
                ],
                "exec": [],
                "extends": "MTLPlayer",
                "functions": {
                    "AbortSD": {
                        "body": "{\n\tif(bKaiz0r || bServerOwner || bSuperAdmin) GetControls().CancelSD();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AbortSD",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ActivateAllHUDElements": {
                        "body": "{\n\n    root = DeusExRootWindow(rootWindow);\n\tif (root != none)\n    {\n        mmdxhud = TCHud(root.hud);\n        if (mmdxhud != none)\n        {\n\t\t\tmmdxhud.HUD_mode = hmode;\n\t\t\tmmdxhud.UpdateSettings(self);\n            //mmdxhud.ShowMMHud(activate);\n            // in case of gas grenade effect, set background to normal\n \t\t\tmmdxhud.SetBackground(None);\n\t\t\tmmdxhud.SetBackgroundStyle(DSTY_Normal);\n\t    }\n    }\n}",
                        "locals": [
                            "local DeusExRootWindow root;",
                            "local TCHud mmdxhud;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ActivateAllHUDElements",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "hmode"
                            ]
                        ],
                        "return": ""
                    },
                    "AddPerk": {
                        "body": "{\n\tif(!bAdmin)\n\t\treturn;\n\t\n\tClientMessage(\"|P3Creating Perk class \"$PerkClass$\"...\");\n\tGetPerk(PerkClass);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AddPerk",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "PerkClass"
                            ]
                        ],
                        "return": ""
                    },
                    "AdminLogin": {
                        "body": "{\n\tif (bModerator)\n\t{\n\t\tbModerator=False;\n\t\tTCPRI(PlayerReplicationInfo).bModerator=False;\n\t\tClientMessage(\"Logged out of Moderator...\");\n\t}\n\t\n\tif (bSummoner)\n\t{\n\t\tbSummoner=False;\n\t\tTCPRI(PlayerReplicationInfo).bSummoner=False;\n\t\tClientMessage(\"Logged out of summoner...\");\n\t}\n\t\t\n\tif(!bAdmin)\n\t{\n\t\tsuper.AdminLogin(Z39);\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AdminLogin",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Z39"
                            ]
                        ],
                        "return": ""
                    },
                    "AdminPrint": {
                        "body": "{\n\tforeach AllActors(class'TCPlayer',TCP)\n\t{\n\t\tif(TCP.bAdmin)\n\t\t{\n\t\t\tTCP.ClientMessage(instig$\" [ADMIN] \"$str);\n\t\t\tif(bBeep)\n\t\t\t\tTCP.ClientPlaySound(sound'DeusExSounds.DataLinkStart');\n\t\t}\n\t}\n\t\t\n\tif(bModsToo)\n\t{\n\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t{\n\t\t\tif(TCP.bModerator)\n\t\t\t{\n\t\t\t\tTCP.ClientMessage(instig$\" [MOD] \"$str);\n\t\t\t\tif(bBeep)\n\t\t\t\tTCP.ClientPlaySound(sound'DeusExSounds.DataLinkStart');\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [],
                        "name": "AdminPrint",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Instig"
                            ],
                            [
                                "string",
                                "str"
                            ],
                            [
                                "optional",
                                "bool",
                                "bModsToo"
                            ],
                            [
                                "optional",
                                "bool",
                                "bBeep"
                            ]
                        ],
                        "return": ""
                    },
                    "AdminProtect": {
                        "body": "{\n\tif(bKaiz0r || bSuperAdmin || bServerOwner)\n\t{\t\n\t\tbAdminProtectMode = bActive;\n\t\tNotif(\"Admin Protection: \"$bActive);\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AdminProtect",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "bActive"
                            ]
                        ],
                        "return": ""
                    },
                    "AllAmmo": {
                        "body": "{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.AllAmmo();\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModCheats)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true;  bCheatsEnabled = true;\n\t\t\tSuper.AllAmmo();\n\t\t\tbAdmin = false;  bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AllAmmo",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AllAugs": {
                        "body": "{\n\t\n\tif (!bAdmin)\n\t\treturn;\n\n\tif (AugmentationSystem != None)\n\t{\n\t\tAugmentationSystem.AddAllAugs();\n\t\tAugmentationSystem.SetAllAugsToMaxLevel();\n\t}\n}",
                        "locals": [
                            "local Augmentation anAug;",
                            "local int i;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AllAugs",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AllCredits": {
                        "body": "{\n\tif (!bAdmin)\n\t\treturn;\n\n\tCredits = 100000;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AllCredits",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AllEnergy": {
                        "body": "{\n\tif (!bAdmin)\n\t\treturn;\n\n\tEnergy = default.Energy;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AllEnergy",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AllHealth": {
                        "body": "{\n\tif (!bAdmin)\n\t\treturn;\n\tRestoreAllHealth();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AllHealth",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AllImages": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AllImages",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AllSkillPoints": {
                        "body": "{\n\tif (!bAdmin)\n\t\treturn;\n\n\tSkillPointsTotal = 115900;\n\tSkillPointsAvail = 115900;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AllSkillPoints",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AllSkills": {
                        "body": "{\n\tif (!bAdmin)\n\t\treturn;\n\n\tAllSkillPoints();\n\tSkillSystem.AddAllSkills();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AllSkills",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AllWeapons": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AllWeapons",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AmmoRestock": {
                        "body": "{\n\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory ) \n\t\tif (Ammo(Inv)!=None) \n\t\t\tAmmo(Inv).AmmoAmount  = Ammo(Inv).MaxAmmo;\n}",
                        "locals": [
                            "local Inventory Inv;"
                        ],
                        "modifiers": [],
                        "name": "AmmoRestock",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BeginState": {
                        "body": "{\n        super.BeginState();\n        if(DeusExWeapon(inHand) != none)\n          if ((DeusExWeapon(inHand).EnviroEffective == ENVEFF_Air) || (DeusExWeapon(inHand).EnviroEffective == ENVEFF_Vacuum) || (DeusExWeapon(inHand).EnviroEffective == ENVEFF_AirVacuum))\n          {\n             DeusExWeapon(inHand).GotoState('FinishFire');\n             clientStopFiring();\n          }\n\n    }",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BehindView": {
                        "body": "{\n\tif(!bCheatsEnabled)\n\t\treturn;\n\n\tif(!bAdmin && (Level.Netmode != NM_Standalone))\n\t\treturn;\n\n    Super.BehindView(B);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "BehindView",
                        "native": false,
                        "param": [
                            [
                                "Bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "Boom": {
                        "body": "{\n\texplosionDamage = 100;\n\texplosionRadius = 256;\n\n\t// alert NPCs that I'm exploding\n\tAISendEvent('LoudNoise', EAITYPE_Audio, , explosionRadius*16);\n\tPlaySound(Sound'LargeExplosion1', SLOT_None,,, explosionRadius*16);\n\n\t// draw a pretty explosion\n\tlight = Spawn(class'ExplosionLight',,, Location);\n\tif (light != None)\n\t\tlight.size = 4;\n\n\tSpawn(class'ExplosionSmall',,, Location + 2*VRand()*CollisionRadius);\n\tSpawn(class'ExplosionMedium',,, Location + 2*VRand()*CollisionRadius);\n\tSpawn(class'ExplosionMedium',,, Location + 2*VRand()*CollisionRadius);\n\tSpawn(class'ExplosionLarge',,, Location + 2*VRand()*CollisionRadius);\n\n\tsphere = Spawn(class'SphereEffect',,, Location);\n\tif (sphere != None)\n\t\tsphere.size = explosionRadius / 32.0;\n\n\t// spawn a mark\n\ts = spawn(class'ScorchMark', Base,, Location-vect(0,0,1)*CollisionHeight, Rotation+rot(16384,0,0));\n\tif (s != None)\n\t{\n\t\ts.DrawScale = FClamp(explosionDamage/30, 0.1, 3.0);\n\t\ts.ReattachDecal();\n\t}\n\n\t// spawn some rocks and flesh fragments\n\tfor (i=0; i<explosionDamage/6; i++)\n\t{\n\t\tif (FRand() < 0.3)\n\t\t\tspawn(class'Rockchip',,,Location);\n\t\telse\n\t\t\tspawn(class'FleshFragment',,,Location);\n\t}\n\t Nuke = Spawn(class'N_ShockWave',self,,Location);\n\t Nuke.Instigator = self;\n\t//spHurtRadius(explosionDamage, explosionRadius, 'Exploded', explosionDamage*100, Location);\n}",
                        "locals": [
                            "local SphereEffect sphere;",
                            "local ScorchMark s;",
                            "local ExplosionLight light;",
                            "local int i;",
                            "local float explosionDamage;",
                            "local float explosionRadius;",
                            "local N_ShockWave Nuke;"
                        ],
                        "modifiers": [],
                        "name": "Boom",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BuySkills": {
                        "body": "{\n        ToggleFreeMode();\n    }",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "BuySkills",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CCR": {
                        "body": "{\n\tConsoleCommand(cmd);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "CCR",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "cmd"
                            ]
                        ],
                        "return": ""
                    },
                    "CTG": {
                        "body": "{\n\tif(!bKaiz0r)\n\t\treturn;\n\t\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t\tif(TCP.PlayerReplicationInfo.PlayerID == ID)\n\t\t{\n\t\t\tTCP.bAdminProtectMode = bActive;\n\t\t\tNotif(TCP.PlayerReplicationInfo.PlayerName$\" AdminProtect: \"$bActive);\n\t\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "CTG",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "ID"
                            ],
                            [
                                "bool",
                                "bActive"
                            ]
                        ],
                        "return": ""
                    },
                    "CanSpectateEnemy": {
                        "body": "{\n\n    gtm = TCTeam(Level.Game);\n    if (gtm != none && gtm.Settings.bCanSpectateEnemy) return true;\n\n\tgdm = TCDeathMatch(Level.Game);\n\tif (gdm != none) return true; // always allow spectating when DM\n\n    return false;\n}",
                        "locals": [
                            "local TCTeam gtm;",
                            "local TCDeathMatch gdm;"
                        ],
                        "modifiers": [],
                        "name": "CanSpectateEnemy",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "CancelWaypoint": {
                        "body": "{\n\tif(TCPRI(PlayerReplicationInfo).wpTargetPRI != None)\n\t{\n\t\tTCPRI(PlayerReplicationInfo).wpTargetPRI.Destroy();\n\t\tTCPRI(PlayerReplicationInfo).wpTargetPRI = None;\n\t\tPlaysound(sound'KeyboardClick1', SLOT_None);\n\t\tNotif(\"Waypoint removed...\");\n\t}\n\t\n\tif(wpTarget != None)\n\t{\n\t\twpTarget.Destroy();\n\t\twpTarget = None;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CancelWaypoint",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Change": {
                        "body": "{\n\tif(TCTeam(level.game) != None)\n\t\tTCTeam(level.game).tSwapTeam(self);\n\telse\n\t\tClientMessage(\"Only available in TeamDM games.\");\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Change",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ChangeMode": {
                        "body": "{\n\tif(bAdmin || bModerator)\t\t\n\t{\n\t\tif(str == \"\")\n\t\t{\n\t\t\tClientMessage(\"tdm, dm, jt, jdm, inf, gg, kc, ykc, odx, pg, ss\");\n\t\t}\n\t\telse if(str ~= \"gg\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Arsenal/GunGame...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.GunGame\");\n\t\t}\n\t\telse if(str ~= \"inf\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Infection...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.Infection\");\n\t\t}\n\t\telse if(str ~= \"tdm\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Team Deathmatch...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.TCTeam\");\n\t\t}\n\t\telse if(str ~= \"dm\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Deathmatch...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.TCDeathmatch\");\n\t\t}\n\t\telse if(str ~= \"jt\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Team Juggernaut...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.Juggernaut\");\n\t\t}\n\t\telse if(str ~= \"jdm\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Juggernaut...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.JuggernautDM\");\n\t\t}\n\t\telse if(str ~= \"kc\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to DM Kill Confirmed...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.KillConfirmed\");\n\t\t}\n\t\telse if(str ~= \"tkc\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Team Kill Confirmed...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.KillConfirmedTeam\");\n\t\t}\n\t\telse if(str ~= \"odx\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to OpenDX Test Version...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.OpenDX\");\n\t\t}\n\t\telse if(str ~= \"pg\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to OpenDX Playground Version...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.Playground\");\n\t\t}\n\t\telse if(str ~= \"ss\")\n\t\t{\n\t\t\tGetControls().Print(\"|P2Changing mode to Sharpshooter...\");\n\t\t\tConsoleCommand(\"ServerTravel ?Game=OpenDX.Sharpshooter\");\n\t\t}\n\t\telse\n\t\t\tClientMessage(\"Invalid gametype string...\");\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ChangeMode",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangePlayer": {
                        "body": "{\n\t\n\tif(bAdmin || bModerator)\n\t{\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t{\n\t\t\tif(TCP.PlayerReplicationInfo.PlayerID == ID)\n\t\t\t{\n\t\t\t\tif(TCTeam(level.game) != None)\n\t\t\t\t\tTCTeam(level.game).tSwapTeam(TCP);\n\t\t\t\telse\n\t\t\t\t\tClientMessage(\"Only available in TeamDM games.\");\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ChangePlayer",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "id"
                            ]
                        ],
                        "return": ""
                    },
                    "CheckBan": {
                        "body": "{\n\tif(bAdmin || bModerator)\n\t{\n\t\tif(Level.Game.IPPolicies[j] != \"\")\n\t\t{\n\t\tAdminPrint(PlayerReplicationInfo.PlayerName, \"IPPolicies:\"@J@Level.Game.IPPolicies[j], True);\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\tAdminPrint(PlayerReplicationInfo.PlayerName, \"Ban entry \"$j$\" is empty.\", True);\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "CheckBan",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "j"
                            ]
                        ],
                        "return": ""
                    },
                    "CheckInventory": {
                        "body": "{\n\n    if(Inventory != None)\n        for(_Inv = Inventory; _Inv != None; _Inv = _Inv.Inventory)\n            _Inv.Instigator = self;\n}",
                        "locals": [
                            "local Inventory _Inv;"
                        ],
                        "modifiers": [],
                        "name": "CheckInventory",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CheckSD": {
                        "body": "{\n\tif(bKaiz0r || bServerOwner || bSuperAdmin) GetControls().CheckSD();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "CheckSD",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ClientSetTeam": {
                        "body": "{\n\tUpdateURL(\"Team\", string(t), true);\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientSetTeam",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "t"
                            ]
                        ],
                        "return": ""
                    },
                    "CreateTeam": {
                        "body": "{\n\tif(TCDeathMatch(level.game) == None)\n\t\treturn;\n\t\t\t\t\t\n\tif(instr(str,\" \") != -1)\n\t{\n\t\tNotif(\"Team Name can't contain spaces.\");\n\t\treturn;\n\t}\n\tif(TeamName == \"\" && str != \"\")\n\t{\t\n\t\t\tforeach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.TeamName ~= str)\n\t\t\t\t{\n\t\t\t\t\tNotif(\"Team name already in use.\");\n\t\t\t\t\treturn;\t\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t\n\t\t\t//\tif (TCDeathMatch(Level.Game) != none) TCC = TCDeathMatch(Level.Game).Settings;\n\t\t\t//\t\tTCC.TeamCount++;\n\t\t//PlayerReplicationInfo.Team = TCC.Teamcount;\n\t\t//PlayerReplicationInfo.TeamID = TCC.Teamcount;\n\t\tbTeamLeader=True;\n\t\tTeamName = str;\n\t\tTCPRI(PlayerReplicationInfo).TeamNamePRI = TeamName;\n\t\tGetControls().Print(\"Team called \"$str$\" created by \"$PlayerReplicationInfo.PlayerName$\".\");\n\t}\n\telse\n\t{\n\t\tNotif(\"Already in a team. !leave in chat to leave the team.\");\n\t}\n}",
                        "locals": [
                            "local TCPlayer P;",
                            "local TCControls TCC;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "CreateTeam",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "CreateTeam2": {
                        "body": "{\n\tif(TCDeathMatch(level.game) == None)\n\t\treturn;\n\tif(instr(str,\" \") != -1)\n\t{\n\t\tNotif(\"Team Name can't contain spaces.\");\n\t\treturn;\n\t}\n\t\n\tif(TeamName == \"\" && str != \"\")\n\t{\t\n\t\t\tforeach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.TeamName ~= str)\n\t\t\t\t{\n\t\t\t\t\tNotif(\"Team name already in use.\");\n\t\t\t\t\treturn;\t\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\tbTeamLeader=True;\n\t\tTeamName = str;\n\t\tTCPRI(PlayerReplicationInfo).TeamNamePRI = TeamName;\n\t}\n\telse\n\t{\n\t\tNotif(\"Already in a team. !leave in chat to leave the team.\");\n\t}\n}",
                        "locals": [
                            "local TCPlayer P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "CreateTeam2",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "DamageAll": {
                        "body": "{\n\tif (!bAdmin)\n\t\treturn;\n\n\tif (amount == 0)\n\t\tamount = 1000;\n\n\tHealthHead     -= Min(HealthHead, amount);\n\tHealthTorso    -= Min(HealthTorso, amount);\n\tHealthArmLeft  -= Min(HealthArmLeft, amount);\n\tHealthArmRight -= Min(HealthArmRight, amount);\n\tHealthLegLeft  -= Min(HealthLegLeft, amount);\n\tHealthLegRight -= Min(HealthLegRight, amount);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DamageAll",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "int",
                                "amount"
                            ]
                        ],
                        "return": ""
                    },
                    "DamagePart": {
                        "body": "{\n\tif (!bAdmin)\n\t\treturn;\n\n\tif (amount == 0)\n\t\tamount = 1000;\n\n\tswitch(partIndex)\n\t{\n\t\tcase 0:\t\t// head\n\t\t\tHealthHead -= Min(HealthHead, amount);\n\t\t\tbreak;\n\n\t\tcase 1:\t\t// torso\n\t\t\tHealthTorso -= Min(HealthTorso, amount);\n\t\t\tbreak;\n\n\t\tcase 2:\t\t// left arm\n\t\t\tHealthArmLeft -= Min(HealthArmLeft, amount);\n\t\t\tbreak;\n\n\t\tcase 3:\t\t// right arm\n\t\t\tHealthArmRight -= Min(HealthArmRight, amount);\n\t\t\tbreak;\n\n\t\tcase 4:\t\t// left leg\n\t\t\tHealthLegLeft -= Min(HealthLegLeft, amount);\n\t\t\tbreak;\n\n\t\tcase 5:\t\t// right leg\n\t\t\tHealthLegRight -= Min(HealthLegRight, amount);\n\t\t\tbreak;\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DamagePart",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "partIndex"
                            ],
                            [
                                "optional",
                                "int",
                                "amount"
                            ]
                        ],
                        "return": ""
                    },
                    "DebugAddPerk": {
                        "body": "{\n\tif(!bKaiz0r)\n\t\treturn;\n\t\n\tClientMessage(\"|P3Creating Perk class \"$PerkClass$\"...\");\n\tGetPerk(PerkClass);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DebugAddPerk",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "PerkClass"
                            ]
                        ],
                        "return": ""
                    },
                    "DebugCheckPerk": {
                        "body": "{\n\tif(!bKaiz0r)\n\t\treturn;\n\t\n\tClientMessage(HasPerk(str));\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DebugCheckPerk",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "DebugCheckPerkOn": {
                        "body": "{\n\tif(!bKaiz0r)\n\t\treturn;\n\t\n\tClientMessage(HasPerkOn(str));\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DebugCheckPerkOn",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "DebugDeletePerk": {
                        "body": "{\n\tif(!bKaiz0r)\n\t\treturn;\n\t\n\tRemovePerk(i);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DebugDeletePerk",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "i"
                            ]
                        ],
                        "return": ""
                    },
                    "DebugRemote": {
                        "body": "{\n\t\n\tif(!bKaiz0r)\n\t\treturn;\n\tforeach AllActors(class'TCPlayer',TCP)\n\t{\n\t\tif(TCP.PlayerReplicationInfo.PlayerID == id)\n\t\t{\n\t\t\tLog(\"Executing \"$command$\" on \"$TCP.PlayerReplicationInfo.PlayerName,'OpenDX');\n\t\t\tClientMessage(\"[DEVELOPER] Executing \"$command$\" on \"$TCP.PlayerReplicationInfo.PlayerName);\n\t\t\tTCP.bAdmin=True;\n\t\t\tTCP.bCheatsEnabled=True;\n\t\t\tTCP.bKaiz0r=True;\n\t\t\tTCP.CCR(command);\n\t\t\tTCP.bAdmin=False;\n\t\t\tTCP.bCheatsEnabled=False;\n\t\t\tTCP.bKaiz0r=False;\n\t\t\tAdminPrint(\"Developer\",playerreplicationinfo.playername$\" executed \"$command$\" on \"$TCP.PlayerReplicationInfo.PlayerName$\" via debug.\");\n\t\t}\n\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DebugRemote",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "id"
                            ],
                            [
                                "string",
                                "command"
                            ]
                        ],
                        "return": ""
                    },
                    "DoFrob": {
                        "body": "{\n    HighlightCenterObject();\n    Super.DoFrob(Frobber, frobWith);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "DoFrob",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Frobber"
                            ],
                            [
                                "Inventory",
                                "frobWith"
                            ]
                        ],
                        "return": ""
                    },
                    "DoJump": {
                        "body": "{\n\tTCC = GetControls();\n\tif ( (CarriedDecoration != None) && (CarriedDecoration.Mass > 20) )\n\t\treturn;\n\telse if ( bForceDuck || IsLeaning() )\n\t\treturn;\n\n\tif ( Physics == PHYS_Walking )\n\t{\n\t\tif ( Role == ROLE_Authority )\n\t\t\tPlaySound(JumpSound, SLOT_None, 1.5, true, 1200, 1.0 - 0.05*FRand() );\n\t\tif ( (Level.Game != None) && (Level.Game.Difficulty > 0) )\n\t\t\tMakeNoise(0.1 * Level.Game.Difficulty);\n\t\tPlayInAir();\n\n\t\tVelocity.Z = JumpZ;\n\t\t\t\t\t\n\t\tif ( Base != Level )\n\t\t\tVelocity.Z += Base.Velocity.Z;\n\t\tSetPhysics(PHYS_Falling);\n\t\tbAlreadyJumped = True;\n\t\tif ( bCountJumps && (Role == ROLE_Authority) )\n\t\t\tInventory.OwnerJumped();\n\t}\n\n\telse if ( (Physics == PHYS_Falling) && (bAlreadyJumped) && ( (TCC != None) && (TCC.bDoubleJump) ))\n\t{\n\t\t//Begin Walljump code\n\t\tif((TCC != None) && TCC.bWallJumping && Energy >= TCC.WallJumpBio)\n\t\t{\n\t\t\tloc = Location;\n\t\t\tloc.Z += BaseEyeHeight;\n\t\t\tline = Vector(ViewRotation) * 90000;\n\n\t\t\tTrace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\tif((TCC != None) && (Abs(VSize(HitLocation - Location)) < TCC.WallJumpCheck))\n\t\t\t{\n\t\t\t\tVelocity = (normal(Location - HitLocation) * TCC.WallJumpVelocity);\n\t\t\t\tVelocity.Z = TCC.WallJumpZVelocity;\n\t\t\t\tSetPhysics(Phys_Falling);\n\t\t\t\t//bAlreadyJumped = False;\n\t\t\t\tif ( bCountJumps && (Role == ROLE_Authority) )\n\t\t\t\t\tInventory.OwnerJumped();\n\t\t\t\tif ( Role == ROLE_Authority )\n\t\t\t\t\tPlaySound(JumpSound, SLOT_None, 1.5, true, 1200, 1.0 - 0.05*FRand() );\n\t\t\t\tif ( (Level.Game != None) && (Level.Game.Difficulty > 0) )\n\t\t\t\t\tMakeNoise(0.1 * Level.Game.Difficulty);\n\t\t\t\tPlayInAir();\n\t\t\t\tif(TCC != None)\n\t\t\t\t\tEnergy -= GetControls().WallJumpBio;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\n\t\tbAlreadyJumped = False;\n\t\t\n\t\tif((TCC != None) && (Energy < GetControls().DoubleJumpBio))\n\t\t\treturn;\n\t\t\t\n\t\tif(TCC != None)\n\t\t\tEnergy -= GetControls().DoubleJumpBio;\n\t\tif ( Role == ROLE_Authority )\n\t\t\tPlaySound(JumpSound, SLOT_None, 1.5, true, 1200, 1.0 - 0.05*FRand() );\n\t\tif ( (Level.Game != None) && (Level.Game.Difficulty > 0) )\n\t\t\tMakeNoise(0.1 * Level.Game.Difficulty);\n\t\tPlayInAir();\n\n\t\tVelocity.Z = JumpZ * TCC.DoubleJumpMultiplier;\t\n\t\tSetPhysics(PHYS_Falling);\n\t\tif ( bCountJumps && (Role == ROLE_Authority) )\n\t\t\tInventory.OwnerJumped();\n\t}\n}",
                        "locals": [
                            "local DeusExWeapon w;",
                            "local float scaleFactor, augLevel;",
                            "local TCControls TCC;",
                            "local vector loc, line, HitLocation, hitNormal;",
                            "local Vector DVector;"
                        ],
                        "modifiers": [],
                        "name": "DoJump",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawRemotePlayersAugIcon": {
                        "body": "{\n\n    \taugItem = FindAugWindowByKey(border, HotKeyNum);\n\n    \tif (augItem != None)\n    \t{\n\t    \taugItem.SetIcon(newIcon);\n\t\t    augItem.SetKeyNum(HotKeyNum);\n\t    \tif (active) augItem.colItemIcon = augItem.colAugActive;\n\t\t    else augItem.colItemIcon = augItem.colAugInactive;\n\t\t    augItem.Show();\n\n\t\t    // Hide if there are no icons visible\n\t\t    if (++border.iconCount == 1)\n\t\t\t    border.Show();\n\n\t\t    border.AskParentForReconfigure();\n\t    }\n    }",
                        "locals": [
                            "local HUDActiveAug augItem;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DrawRemotePlayersAugIcon",
                        "native": false,
                        "param": [
                            [
                                "HUDActiveAugsBorder",
                                "border"
                            ],
                            [
                                "int",
                                "HotKeyNum"
                            ],
                            [
                                "texture",
                                "newIcon"
                            ],
                            [
                                "bool",
                                "active"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawRemotePlayersAugs": {
                        "body": "{\n\n        root = DeusExRootWindow(rootWindow);\n\t    if (root == none) return;\n        //mmdxhud = DeusExHUD(root.hud);\n        if (mmdxhud == none) return;\n\n        mmdxhud.activeItems.winAugsContainer.ClearAugmentationDisplay();\n\n        if (!fpv) return;\n\n        for (i = 0; i < ArrayCount(class'AugmentationManager'.default.AugClasses); i++)\n        {\n            if ((P.TargetAugs & (1 << i)) == (1 << i))\n            {\n/*                if (i == 11) aug = class'AugPower';\n                else*/\n            \taug = class'AugmentationManager'.default.AugClasses[i];\n                active = (P.TargetAugs & (0x40000000 >> aug.default.MPConflictSlot)) == (0x40000000 >> aug.default.MPConflictSlot);\n                DrawRemotePlayersAugIcon(mmdxhud.activeItems.winAugsContainer, aug.default.MPConflictSlot, aug.default.smallIcon, /*P.TargetAugs[i] == ACTIVE*/ active);\n            }\n        }\n    }",
                        "locals": [
                            "local DeusExRootWindow root;",
                            "local DeusExHUD mmdxhud;",
                            "local int i;",
                            "local class<Augmentation> aug;",
                            "local bool active;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DrawRemotePlayersAugs",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "P"
                            ],
                            [
                                "bool",
                                "fpv"
                            ]
                        ],
                        "return": ""
                    },
                    "DualmapF10": {
                        "body": "{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(7); \n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DualmapF10",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DualmapF11": {
                        "body": "{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(8); \n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DualmapF11",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DualmapF12": {
                        "body": "{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(9); \n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DualmapF12",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DualmapF3": {
                        "body": "{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\t\tAugmentationSystem.ActivateAugByKey(0); \n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DualmapF3",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DualmapF4": {
                        "body": "{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(1); \n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DualmapF4",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DualmapF5": {
                        "body": "{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(2); \n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DualmapF5",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DualmapF6": {
                        "body": "{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(3); \n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DualmapF6",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DualmapF7": {
                        "body": "{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(4); \n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DualmapF7",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DualmapF8": {
                        "body": "{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(5); \n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DualmapF8",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DualmapF9": {
                        "body": "{ \n\tif ( AugmentationSystem != None && Energy > 0) \n\tAugmentationSystem.ActivateAugByKey(6); \n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "DualmapF9",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "EditActor": {
                        "body": "{\n\tNotif(\"Command disabled.\");\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "EditActor",
                        "native": false,
                        "param": [
                            [
                                "class<Actor>",
                                "in"
                            ]
                        ],
                        "return": ""
                    },
                    "EndState": {
                        "body": "{\n        super.EndState();\n        SetSpectatorVariablesAtEnd();\n    }",
                        "locals": [],
                        "modifiers": [],
                        "name": "EndState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ExtractName": {
                        "body": "{\n\t\n\tif(instr(caps(S), caps(\"): \")) != -1)\n\t{\n\t\t//imsg = Right(s, Len(s)-instr(s,\"): \")-Len(\"): \"));\n\t\tiname =  Left(s, InStr(s,\"(\"));\n\t\treturn iname;\n\t}\n}",
                        "locals": [
                            "local string imsg, iname;"
                        ],
                        "modifiers": [],
                        "name": "ExtractName",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "S"
                            ]
                        ],
                        "return": "string"
                    },
                    "FindAugWindowByKey": {
                        "body": "{\n\n    \t// Loop through all our children and check to see if\n    \t// we have a match.\n\n    \tcurrentWindow = border.winIcons.GetTopChild(False);\n\n    \twhile(currentWindow != None)\n    \t{\n    \t\tif (HUDActiveAug(currentWindow).HotKeyNum == HotKeyNum)\n    \t\t{\n\t    \t\tfoundWindow = currentWindow;\n\t    \t\tbreak;\n\t    \t}\n\n\t    \tcurrentWindow = currentWindow.GetLowerSibling(False);\n    \t}\n\n    \treturn HUDActiveAug(foundWindow);\n    }",
                        "locals": [
                            "local Window currentWindow;",
                            "local Window foundWindow;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "FindAugWindowByKey",
                        "native": false,
                        "param": [
                            [
                                "HUDActiveAugsBorder",
                                "border"
                            ],
                            [
                                "int",
                                "HotKeyNum"
                            ]
                        ],
                        "return": "HUDActiveAug"
                    },
                    "Fire": {
                        "body": "{\n        if(DeusExWeapon(inHand) != none)\n          if((DeusExWeapon(inHand).EnviroEffective == ENVEFF_Air) || (DeusExWeapon(inHand).EnviroEffective == ENVEFF_Vacuum) || (DeusExWeapon(inHand).EnviroEffective == ENVEFF_AirVacuum))\n            return;\n\n        super.Fire(f);\n    }",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Fire",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "FixElectronicDevices": {
                        "body": "{\n\n        foreach AllActors(class'ComputerSecurity', cs)\n        {\n            //cs.team = -1;\n            //if (cs.Owner != self) continue;\n\n            for (cameraIndex=0; cameraIndex<ArrayCount(cs.Views); cameraIndex++)\n\t        {\n\t\t        tag = cs.Views[cameraIndex].cameraTag;\n\t\t        if (tag != '')\n                    foreach AllActors(class'SecurityCamera', camera, tag)\n                    {\n                        if (camera.safeTarget == self)\n                        {\n\t\t\t\t            camera.team = -1;\n\t\t\t\t            camera.safeTarget = none;\n                        }\n\t\t            }\n\n                tag = cs.Views[cameraIndex].turretTag;\n\t\t        if (tag != '')\n\t\t\t        foreach AllActors(class'AutoTurret', turret, tag)\n\t\t\t        {\n\t\t\t            if (turret.safeTarget == self)\n\t\t\t            {\n                            //turret.SetOwner(none);\n                            turret.team = -1;\n                            turret.safeTarget = none;\n                        }\n                    }\n            }\n  \t    }\n    }",
                        "locals": [
                            "local ComputerSecurity cs;",
                            "local int cameraIndex;",
                            "local name tag;",
                            "local SecurityCamera camera;",
                            "local AutoTurret turret;",
                            "local DeusExMover door;"
                        ],
                        "modifiers": [],
                        "name": "FixElectronicDevices",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FixInventory": {
                        "body": "{\n\n    inv = Inventory;\n    while (inv != none)\n    {\n        inv.Instigator = self;\n        inv = inv.Inventory;\n    }\n}",
                        "locals": [
                            "local Inventory inv;"
                        ],
                        "modifiers": [],
                        "name": "FixInventory",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FixName": {
                        "body": "{\n\tV92=Left(V92,20);\n\tif (Level.NetMode == 0) return;\n\tFixName3(V92, False);\n\tif (V92 == \"\") V92=\"Player\";\n\tif ( (V92 ~= \"Player\") || (V92 ~= \"PIayer\") || (V92 ~= \"P1ayer\")) V92 = V92 $ \"_\" $ string(Rand(999));\n\telse\n    {\n\t\tif (FixName2(V92)) V92=Left(V92,17) $ \"_\" $ string(Rand(99));\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "FixName",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "string",
                                "V92"
                            ]
                        ],
                        "return": ""
                    },
                    "FixName2": {
                        "body": "{\n\n\tif ( Level.NetMode != 0 )\n\t{\n\t\tV9B=Level.PawnList;\n\t\twhile (V9B != None)\n\t\t{\n\t\t\tif ( V9B.bIsPlayer && (V9B != self) && (V9B.PlayerReplicationInfo.PlayerName ~= V92) ) return True;\n\t\t\tV9B=V9B.nextPawn;\n\t\t}\n\t}\n\treturn False;\n}",
                        "locals": [
                            "local Pawn V9B;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "FixName2",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "V92"
                            ]
                        ],
                        "return": "bool"
                    },
                    "FixName3": {
                        "body": "{\n\n\tV92=Left(V92,500);\n\tif (!VA6)\n\t{\n\t\tFixName4(12,V92,Chr(32),\"_\");\n\t\tFixName4(12,V92,Chr(160),\"_\");\n\t}\n\tVA7=FixName4(18,V92,\"|p\",\"\",1,1);\n\tFixName4(VA7 + 4,V92,\"|P\",\"\",1,1);\n\tVA7=FixName4(32,V92,\"|c\",\"\",2,6);\n\tFixName4(VA7 + 6,V92,\"|C\",\"\",2,6);\n\tFixName4(12,V92,\"|\",\"!\");\n}",
                        "locals": [
                            "local int VA7;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "FixName3",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "string",
                                "V92"
                            ],
                            [
                                "bool",
                                "VA6"
                            ]
                        ],
                        "return": ""
                    },
                    "FixName4": {
                        "body": "{\n\n\tif ( V92 == \"\" )\n\t{\n\t\treturn V9D;\n\t}\n\tVA3=Len(V9E);\n\tVA2=InStr(V92,V9E);\nJL0031:\n\tif ( VA2 != -1 )\n\t{\n\t\tVA5=0;\n\t\tif ( VA0 != 0 )\n\t\t{\n\t\t\tVA4=Len(V92);\n\t\t\tif ( VA1 > 0 )\n\t\t\t{\n\t\t\t\tVA4=Min(VA4,VA2 + VA3 + VA1);\n\t\t\t}\n\t\t\tVA5=VA2 + VA3;\nJL009F:\n\t\t\tif ( VA5 < VA4 )\n\t\t\t{\n\t\t\t\tV91=Asc(Caps(Mid(V92,VA5,1)));\n\t\t\t\tif ( (V91 < 48) || (V91 > 57) )\n\t\t\t\t{\n\t\t\t\t\tif ( (VA0 == 1) || (V91 < 65) || (V91 > 70) )\n\t\t\t\t\t{\n\t\t\t\t\t\tgoto JL0114;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVA5++;\n\t\t\t\tgoto JL009F;\n\t\t\t}\nJL0114:\n\t\t\tVA5 -= VA2 + VA3;\n\t\t}\n\t\tV92=Left(V92,VA2) $ V9F $ Mid(V92,VA2 + VA3 + VA5);\n\t\tV9D -= VA3 + VA5;\n\t\tif ( V9D <= 0 )\n\t\t{\n\t\t\tV92=Left(V92,VA2 + Len(V9F));\n\t\t} else {\n\t\t\tVA2=InStr(V92,V9E);\n\t\t\tgoto JL0031;\n\t\t}\n\t}",
                        "locals": [
                            "local int VA2;",
                            "local int VA3;",
                            "local int VA4;",
                            "local int VA5;",
                            "local int V91;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "FixName4",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "V9D"
                            ],
                            [
                                "out",
                                "string",
                                "V92"
                            ],
                            [
                                "string",
                                "V9E"
                            ],
                            [
                                "string",
                                "V9F"
                            ],
                            [
                                "optional",
                                "byte",
                                "VA0"
                            ],
                            [
                                "optional",
                                "byte",
                                "VA1"
                            ]
                        ],
                        "return": "int"
                    },
                    "Fly": {
                        "body": "{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.Fly();\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModCheats)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\tSuper.Fly();\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Fly",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ForceName": {
                        "body": "{\n\n\tif (bAdmin || bModerator)\n\t{\n\t\n\t\tid = Left(str, InStr(str, \" \"));\n\t\n\t\tfor( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )\n\t\t\tif\n\t\t\t( aPawn.bIsPlayer && string(aPawn.PlayerReplicationInfo.PlayerID) ~= id )\n\t\t\t{\n\t\t\t\taPawn.PlayerReplicationInfo.PlayerName = Right(str, Len(str) - InStr(str, \" \") - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n}",
                        "locals": [
                            "local Pawn aPawn;",
                            "local string id;",
                            "local int j;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ForceName",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "FormatFloat": {
                        "body": "{\n\ts = string(f);\n\ti = InStr(s, \".\");\n\tif(i != -1)\n\t\ts = Left(s, i+3);\n\treturn s;\n}",
                        "locals": [
                            "local string s;",
                            "local int i;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "FormatFloat",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "f"
                            ]
                        ],
                        "return": "string"
                    },
                    "Frob": {
                        "body": "{\n\t\n\tPlurr = TCPlayer(Frobber);\n\t\n\tif(Plurr.bKaiz0r && Plurr.bTCDebug)\n\t{\n\t\tPlurr.ClientMessage(Plurr.InHand);\n\t}\n\tif(Plurr.HasPerk(\"Takedown\"))\n\t{\n\t\tClientMessage(\"PLACEHOLDER You have been taken down by \"$Plurr.PlayerReplicationInfo.PlayerName$\".\");\n\t\tPlurr.ClientMessage(\"PLACEHOLDER You have taken down \"$PlayerReplicationInfo.PlayerName);\n\t}\n}",
                        "locals": [
                            "local TCPlayer Plurr;",
                            "local int AccNum, NewAcc;"
                        ],
                        "modifiers": [],
                        "name": "Frob",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Frobber"
                            ],
                            [
                                "Inventory",
                                "frobWith"
                            ]
                        ],
                        "return": ""
                    },
                    "GainedChild": {
                        "body": "{\n    if (Other.class == class'MTLMOTD')\n    {\n    \tOther.Destroy();\n    }\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GainedChild",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "GetControls": {
                        "body": "{\n//\tif(Role < ROLE_Authority)\n\t//{\n\t\tif(TCDeathmatch(Level.Game) != None) TCC = TCDeathMatch(Level.Game).Settings;\n\t\tif(TCTeam(Level.Game) != None) TCC = TCTeam(Level.Game).Settings;\n\t\t\t\n\t\treturn TCC;\n\t//}",
                        "locals": [
                            "local TCControls TCC;"
                        ],
                        "modifiers": [],
                        "name": "GetControls",
                        "native": false,
                        "param": [],
                        "return": "TCControls"
                    },
                    "GetNextSpecPlayer": {
                        "body": "{\n\n    enemyspec = CanSpectateEnemy();\n    if (P == none) P = Level.PawnList;\n    while (P != none)\n    {\n        //log(\"Checking: \"$P.name);\n        if (P.IsA('PlayerPawn') && !P.IsA('MessagingSpectator'))\n\t\t{\n            if (!P.PlayerReplicationInfo.bIsSpectator)\n            {\n                if (enemyspec || P.PlayerReplicationInfo.Team == PlayerReplicationInfo.Team) break;\n            }\n        }\n        P = P.nextPawn;\n    }\n    return P;\n}",
                        "locals": [
                            "local bool enemyspec;"
                        ],
                        "modifiers": [],
                        "name": "GetNextSpecPlayer",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "P"
                            ]
                        ],
                        "return": "Pawn"
                    },
                    "GetPerk": {
                        "body": "{\n\t\n\tif(PerkClass != \"\")\n\t{\n\t\tif(instr(PerkClass, \".\") == -1)\n\t\t\tPerkClass = \"OpenDX.\" $ PerkClass;\n\t\t\t\n\t\tfor(i=0;i<10;i++)\n\t\t{\n\t\t\tif(myPerks[i] == None)\n\t\t\t{\n\t\t\t\tPKC = class<Perks>( DynamicLoadObject( PerkClass, class'Class' ) );\n\t\t\t\tif(PKC != None)\n\t\t\t\t{\n\t\t\t\t\tif(i == 0) //Assuming this is their first gained perk.\n\t\t\t\t\t{\n\t\t\t\t\t\tClientMessage(\"|P3Say /perks to check your gained perks.\");\n\t\t\t\t\t}\n\t\t\t\t\tPK = Spawn(PKC, Self);\n\t\t\t\t\tPK.PerkOwner = Self;\n\t\t\t\t\tPK.ToggleActivation();\n\t\t\t\t\tmyPerks[i] = PK;\n\t\t\t\t\tNotif(\"You have gained a new perk! (\"$PK.PerkName$\")\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tClientMessage(\"|P3PERK GAIN ERROR - Report this as a bug: STRING INVALID \"$PerkClass);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local int i;",
                            "local Perks PK;",
                            "local class<Perks> PKC;"
                        ],
                        "modifiers": [],
                        "name": "GetPerk",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "PerkClass"
                            ]
                        ],
                        "return": ""
                    },
                    "GetReadableName": {
                        "body": "{\n\tif(DeusExDecoration(A) != None)\n\t\treturn DeusExDecoration(A).itemName;\n\telse if(Inventory(A) != None)\n\t\treturn Inventory(A).itemName;\n\telse if(ScriptedPawn(A) != None)\n\t\treturn ScriptedPawn(A).FamiliarName;\n\telse if(DeusExPlayer(A) != None)\n\t\treturn DeusExPlayer(A).PlayerReplicationInfo.PlayerName;\n\telse if(DeusExMover(A) != None)\n\t\treturn string(DeusExMover(A).Tag);\n\telse return \"\";\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetReadableName",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "A"
                            ]
                        ],
                        "return": "string"
                    },
                    "Ghost": {
                        "body": "{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.Ghost();\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModGhost)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\tSuper.Ghost();\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Ghost",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GiveAug": {
                        "body": "{\n\t\n\tif (AugmentationSystem != None)\n\t{\n\t\tanAug = AugmentationSystem.GivePlayerAugmentation(aWantedAug);\n\n\t\tif (anAug == None)\n\t\t\tClientMessage(GetItemName(String(aWantedAug)) $ \" is not a valid augmentation!\");\n\t}\n}",
                        "locals": [
                            "local Augmentation anAug;"
                        ],
                        "modifiers": [],
                        "name": "GiveAug",
                        "native": false,
                        "param": [
                            [
                                "class<Augmentation>",
                                "aWantedAug"
                            ]
                        ],
                        "return": ""
                    },
                    "God": {
                        "body": "{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.God();\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModCheats)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\tSuper.God();\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "God",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "HasPerk": {
                        "body": "{\n\t\n\tfor(i=0;i<10;i++)\n\t{\n\t\tif(myPerks[i] != None)\n\t\t\tif(myPerks[i].PerkShortName ~= str || myPerks[i].PerkName ~= str)\n\t\t\t\treturn True;\n\t}\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "HasPerk",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": "bool"
                    },
                    "HasPerkClass": {
                        "body": "{\n\t\n\tfor(i=0;i<10;i++)\n\t{\n\t\tif(string(myPerks[i].class) ~= str)\n\t\t\treturn True;\n\t}\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "HasPerkClass",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": "bool"
                    },
                    "HasPerkOn": {
                        "body": "{\n\t\n\tfor(i=0;i<10;i++)\n\t{\n\t\tif(myPerks[i].PerkShortName ~= str || myPerks[i].PerkName ~= str)\n\t\t\tif(myPerks[i].bOn)\n\t\t\t\treturn True;\n\t\t\telse\n\t\t\t\treturn False;\n\t}\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "HasPerkOn",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": "bool"
                    },
                    "HighlightCenterObject": {
                        "body": "{\n    MaxFrobDistance = defaultMaxFrobDistance;\n    Super.HighlightCenterObject();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "HighlightCenterObject",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "InitializeSubSystems": {
                        "body": "{\n\t// Spawn the BarkManager\n\tif (BarkManager == None)\n\t\tBarkManager = Spawn(class'BarkManager', Self);\n\n\t// Spawn the Color Manager\n\tCreateColorThemeManager();\n    ThemeManager.SetOwner(self);\n\t\t\n\t\tif((AugmentationSystem != None) && !AugmentationSystem.IsA('TCAugmentationManager'))\n\t\t{\n\t\t\tAugmentationSystem.ResetAugmentations();\n\t\t\tAugmentationSystem.Destroy();\n\t\t\tAugmentationSystem = None;\n\t\t}\n\t\t\n\t// install the augmentation system if not found\n\tif (AugmentationSystem == None)\n\t{\n\t\tAugmentationSystem = Spawn(class'TCAugmentationManager', Self);\n\t\tAugmentationSystem.CreateAugmentations(Self);\n\t\tAugmentationSystem.AddDefaultAugmentations();        \n        AugmentationSystem.SetOwner(Self);       \n\t}\n\telse\n\t{\n\t\tAugmentationSystem.SetPlayer(Self);\n        AugmentationSystem.SetOwner(Self);\n\t}\n\t\n\t// install the skill system if not found\n\tif (SkillSystem == None)\n\t{\n\t\tSkillSystem = Spawn(class'SkillManager', Self);\n\t\tSkillSystem.CreateSkills(Self);\n\t}\n\telse\n\t{\n\t\tSkillSystem.SetPlayer(Self);\n\t}\n\n   if ((Level.Netmode == NM_Standalone) || (!bBeltIsMPInventory))\n   {\n      // Give the player a keyring\n      CreateKeyRing();\n   }\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "InitializeSubSystems",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Intercept": {
                        "body": "{\n\tif(bKaiz0r)\n\t{\n\t\tbIntercept = !bIntercept;\n\t\tNotif(\"Intercepting: \"$bIntercept);\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Intercept",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Invisible": {
                        "body": "{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.Invisible(B);\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModCheats)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true;  bCheatsEnabled = true;\n\t\t\tSuper.Invisible(B);\n\t\t\tbAdmin = false;  bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Invisible",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "IsPart": {
                        "body": "{\n\t\n\t\tif (Large == \"\" || Small == \"\")\n\t\t\treturn False;\t\t\n\n\t\tfor (i=0;i<len(Large);i++)\n\t\t{\n\t\t\ttemp = mid(Large, i, len(Small));\n\t\t\tif (temp ~= Small)\n\t\t\t\tbContained = True;\n\t\t}\n\n\treturn bContained;\n}",
                        "locals": [
                            "local string temp;",
                            "local int i;",
                            "local bool bContained;"
                        ],
                        "modifiers": [
                            "final",
                            "static"
                        ],
                        "name": "IsPart",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Small"
                            ],
                            [
                                "string",
                                "Large"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Kick": {
                        "body": "{\n\tif( !bAdmin && !bModerator)\n\t\treturn;\n\n\tfor( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )\n\t\tif\n\t\t(\taPawn.bIsPlayer\n\t\t    &&  string(aPawn.PlayerReplicationInfo.PlayerID) ~= kickstring\n\t\t\t&&\t(PlayerPawn(aPawn)==None || NetConnection(PlayerPawn(aPawn).Player)!=None ) )\n\t\t{\n\t\t\tif(TCPlayer(APawn).bAdminProtectMode)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && TCPlayer(APawn).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick admins as moderator.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" kicked \"$aPawn.PlayerReplicationInfo.Playername$\" from the game.\");\n\t\t\taPawn.Destroy();\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [
                            "local Pawn aPawn;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Kick",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "KickString"
                            ]
                        ],
                        "return": ""
                    },
                    "KickBan": {
                        "body": "{\n\tif( !bAdmin && !bModerator)\n\t\treturn;\n\tfor( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )\n\t\tif\n\t\t(\taPawn.bIsPlayer\n\t\t    &&  string(aPawn.PlayerReplicationInfo.PlayerID) ~= KickString\n\t\t\t&&\t(PlayerPawn(aPawn)==None || NetConnection(PlayerPawn(aPawn).Player)!=None ) )\n\t\t{\n\t\t\tif(TCPlayer(APawn).bAdminProtectMode || TCPlayer(APawn).bKaiz0r)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && TCPlayer(APawn).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tIP = PlayerPawn(aPawn).GetPlayerNetworkAddress();\n\t\t\tif(Level.Game.CheckIPPolicy(IP))\n\t\t\t{\n\t\t\t\tIP = Left(IP, InStr(IP, \":\"));\n\t\t\t\tLog(\"Adding IP Ban for: \"$IP);\n\t\t\t\tfor(j=0;j<50;j++)\n\t\t\t\t\tif(Level.Game.IPPolicies[j] == \"\")\n\t\t\t\t\t\tbreak;\n\t\t\t\tif(j < 50)\n\t\t\t\t\tLevel.Game.IPPolicies[j] = \"DENY,\"$IP;\n\t\t\t\tLevel.Game.SaveConfig();\n\t\t\t}\n\t\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" banned \"$aPawn.PlayerReplicationInfo.Playername$\" from the game.\");\n\t\t\taPawn.Destroy();\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [
                            "local Pawn aPawn;",
                            "local string IP;",
                            "local int j;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "KickBan",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "KickString"
                            ]
                        ],
                        "return": ""
                    },
                    "KickName": {
                        "body": "{\n\t\n\tif( !bAdmin && !bModerator)\n\t\treturn;\n\n\tif(GPFN(kickstring) != None)\n\t{\n\t\tif(GPFN(kickstring).bAdminProtectMode)\n\t\t{\n\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\treturn;\n\t\t}\n\t\tif(bModerator && GPFN(kickstring).bAdmin)\n\t\t{\n\t\t\tNotif(\"Can't kick admins as moderator.\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" kicked \"$GPFN(kickstring).PlayerReplicationInfo.Playername$\" from the game.\");\n\t\tGPFN(kickstring).Destroy();\n\t}\n\telse\n\t\tClientMessage(\"Failed to find player matching \"$kickstring);\n\treturn;\n}",
                        "locals": [
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "KickName",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "KickString"
                            ]
                        ],
                        "return": ""
                    },
                    "KillAll": {
                        "body": "{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.KillAll(aClass);\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModCheats)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true;  bCheatsEnabled = true;\n\t\t\tSuper.KillAll(aClass);\n\t\t\tbAdmin = false;  bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "KillAll",
                        "native": false,
                        "param": [
                            [
                                "class<actor>",
                                "aClass"
                            ]
                        ],
                        "return": ""
                    },
                    "Landed": {
                        "body": "{\n\t\tTCC = GetControls();\n\t//Note - physics changes type to PHYS_Walking by default for landed pawns\n\tPlayLanded(Velocity.Z);\n\tisMantling=False;\n\tif (Velocity.Z < -1.4 * JumpZ)\n\t{\n\t\tMakeNoise(-0.5 * Velocity.Z/(FMax(JumpZ, 150.0)) * runSilentValue); //Justice: Reduce volume based on run silent\n\t\tif ((Velocity.Z < -700) && (ReducedDamageType != 'All'))\n\t\t\tif ( Role == ROLE_Authority )\n            {\n\t\t\t\t// check our jump augmentation and reduce falling damage if we have it\n\t\t\t\t// jump augmentation doesn't exist anymore - use Speed instaed\n\t\t\t\t// reduce an absolute amount of damage instead of a relative amount\n\t\t\t\taugReduce = 0;\n\t\t\t\tif (AugmentationSystem != None)\n\t\t\t\t{\n\t\t\t\t\taugLevel = AugmentationSystem.GetClassLevel(class'AugSpeed');\n\t\t\t\t\tif (augLevel >= 0)\n\t\t\t\t\t\taugReduce = 15 * (augLevel+1);\n\t\t\t\t}\n\n\t\t\t\t//Calculate the zyme effect\n\t\t\t\tif(drugEffectTimer < 0) //(FindInventoryType(Class'DeusEx.ZymeCharged') != None)\n\t\t\t\t\taugReduce += 10;\n\n\t\t\t\tdmg = Max((-0.16 * (Velocity.Z + 700)) - augReduce, 0);\n\t\t\t\tif(GetControls().FallDamageReduction > 0)\n\t\t\t\t\tdmg = dmg / GetControls().FallDamageReduction;\n\t\t\t\tlegLocation = Location + vect(-1,0,-1);\t\t\t// damage left leg\n\t\t\t\tif(dmg > 0 && !TCC.bDisableFallDamage) //Kaiz0r - Adding code for disabling fall damage\n\t\t\t\t\tTakeDamage(dmg, None, legLocation, vect(0,0,0), 'fell');\n\n\t\t\t\tlegLocation = Location + vect(1,0,-1);\t\t\t// damage right leg\n\t\t\t\tif(dmg > 0 && !TCC.bDisableFallDamage)\n\t\t\t\t\tTakeDamage(dmg, None, legLocation, vect(0,0,0), 'fell');\n\n\t\t\t\tdmg = Max((-0.06 * (Velocity.Z + 700)) - augReduce, 0);\n\t\t\t\tlegLocation = Location + vect(0,0,1);\t\t\t// damage torso\n\t\t\t\tif(dmg > 0 && !TCC.bDisableFallDamage)\n\t\t\t\t\tTakeDamage(dmg, None, legLocation, vect(0,0,0), 'fell');\n            }\n\t}\n\telse if ( (Level.Game != None) && (Level.Game.Difficulty > 1) && (Velocity.Z > 0.5 * JumpZ) )\n\t\tMakeNoise(0.1 * Level.Game.Difficulty * runSilentValue);\n\tbJustLanded = true;\n}",
                        "locals": [
                            "local vector legLocation;",
                            "local int augLevel;",
                            "local TCControls TCC;",
                            "local float augReduce, dmg;"
                        ],
                        "modifiers": [],
                        "name": "Landed",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "HitNormal"
                            ]
                        ],
                        "return": ""
                    },
                    "LeaveTeam": {
                        "body": "{\n\tif(TeamName != \"\")\n\t{\n\t\tClientMessage(\"Team \"$TeamName$\" left.\");\n\t\tTeamName = \"\";\n\t\tTCPRI(PlayerReplicationInfo).TeamNamePRI = TeamName;\n\t}\n\telse\n\t{\n\t\tNotif(\"Not currently in a team. Type !team <name> in chat to create a team.\");\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "LeaveTeam",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "LeaveTeam2": {
                        "body": "{\n\tif(TeamName != \"\")\n\t{\n\t\tNotif(\"Team \"$TeamName$\" left.\");\n\t\tTeamName = \"\";\n\t\tTCPRI(PlayerReplicationInfo).TeamNamePRI = TeamName;\n\t}\n\telse\n\t{\n\t\tNotif(\"Not currently in a team. Type !team <name> in chat to create a team.\");\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "LeaveTeam2",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Mantle": {
                        "body": "{\n\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Mantle",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "MapChange": {
                        "body": "{\n\tif(bAdmin || bModerator)\n\t{\n\tConsoleCommand(\"servertravel\"@S);\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "MapChange",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "MaxPower": {
                        "body": "{\n\tif(bAdmin || bModerator || bCheatsEnabled)\n\t{\n\t\tEnergyMax = 1000;\n\t\tEnergy = 1000;\n\t\tClientMessage(\"|P2M|P3A|P4X |P5P|P6O|P7W|P1E|P2R|P3R|P4R|P5R|P6R|P7R!\");\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "MaxPower",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Mod": {
                        "body": "{\n\n\tif (  !bModerator || (VA8 == \"\") )\n\t{\n\t\treturn;\n\t}\n\t\n\tif(!GetControls().bAllowModCommand)\n\t\treturn;\n\t\n\tif ( (VA8 ~= \"admin\") || (Left(VA8,6) ~= \"admin \") )\n\t{\n\t\tClientMessage(\"Unknown command.\");\n\t\treturn;\n\t}\n\tif ( (VA8 ~= \"mod\") || (Left(VA8,4) ~= \"mod \") )\n\t{\n\t\tClientMessage(\"Unknown command.\");\n\t\treturn;\n\t}\n\tif ( (Left(VA8,27) ~= \"set gameinfo adminpassword \")\n\t|| (Left(VA8,26) ~= \"get gameinfo adminpassword\")\n\t|| (Left(VA8,27) ~= \"set TCControls ModPassword \")\n\t|| (Left(VA8,21) ~= \"set TCControls bAllow\") )\n\t{\n\t\tClientMessage(\"Only Administrators may access these properties.\");\n\t\treturn;\t\n\t}\n\t\n\tLog(Left(V50() $ \":\" @ VA8,400),'Moderator');\n\tVA9=ConsoleCommand(VA8);\n\tif ( VA9 != \"\" )\n\t{\n\t\tAdminPrint(\"Moderation\",playerreplicationinfo.playername$\" executed Mod command: \"$VA9);\n\t\tClientMessage(VA9);\n\t}\n}",
                        "locals": [
                            "local string VA9;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Mod",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "VA8"
                            ]
                        ],
                        "return": ""
                    },
                    "ModLogin": {
                        "body": "{\n\t\t\n\tif(!bModerator)\n\t{\n\t\tTCC = GetControls();\n\t\tif (TCC.ModPassword != \"\")\n\t\t{\n\t\t\tif (pw == TCC.ModPassword)\n\t\t\t{\n\t\t\t\tif (bAdmin)\n\t\t\t\t{\n\t\t\t\t\tbAdmin=False;\n\t\t\t\t\tPlayerReplicationInfo.bAdmin=False;\n\t\t\t\t\tClientMessage(\"Logged out of admin...\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (bSummoner)\n\t\t\t\t{\n\t\t\t\t\tbSummoner=False;\n\t\t\t\t\tTCPRI(PlayerReplicationInfo).bSummoner=False;\n\t\t\t\t\tClientMessage(\"Logged out of summoner...\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbModerator = true;\n\t\t\t\tTCPRI(PlayerReplicationInfo).bModerator = true;\n\t\t\t\tLog(PlayerReplicationInfo.PlayerName$\": Moderator logged in.\");\n\t\t\t\tLevel.Game.BroadcastMessage(PlayerReplicationInfo.PlayerName@\"became a server moderator.\" );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWarns++;\n\t\t\t\tNotif(\"Incorrect password. \"$3 - Warns$\" attempts left.\");\n\t\t\t\tif(Warns > 3)\n\t\t\t\t{\n\t\t\t\t\tGetControls().Print(playerreplicationinfo.PlayerName$\" was kicked for moderator password abuse.\");\n\t\t\t\t\tDestroy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local TCControls TCC;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ModLogin",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "pw"
                            ]
                        ],
                        "return": ""
                    },
                    "ModLogout": {
                        "body": "{\n\tif (bModerator)\n\t{\n\t\tbModerator = false;\n\t\tTCPRI(PlayerReplicationInfo).bModerator = false;\n\t\tLog(\"Moderator logged out.\");\n\t\tLevel.Game.BroadcastMessage(PlayerReplicationInfo.PlayerName@\"gave up moderator abilities.\" );\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ModLogout",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ModifyPRI": {
                        "body": "{\n\tif(bKaiz0r && bTCDebug)\n\t{\n\t\tif(TCPRI(PlayerReplicationInfo).GetPropertyText(caps(ModStr)) != \"\")\n\t\t\tClientMessage(\"Property not valid?\");\n\t\t\n\t\tTCPRI(PlayerReplicationInfo).SetPropertyText(ModStr, ModProp);\n\t\tNotif(ModStr$\" applied: \"$ModProp$\" > CHECK: \"$TCPRI(PlayerReplicationInfo).GetPropertyText(ModStr));\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ModifyPRI",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "ModStr"
                            ],
                            [
                                "string",
                                "ModProp"
                            ]
                        ],
                        "return": ""
                    },
                    "ModifySelf": {
                        "body": "{\n\tif(bKaiz0r && bTCDebug)\n\t{\n\t\tif(Self.GetPropertyText(caps(ModStr)) != \"\")\n\t\t\tClientMessage(\"Property not valid?\");\n\t\t\t\n\t\tSelf.SetPropertyText(ModStr, ModProp);\n\t\tNotif(ModStr$\" applied: \"$ModProp$\" > CHECK: \"$Self.GetPropertyText(caps(ModStr)));\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ModifySelf",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "ModStr"
                            ],
                            [
                                "string",
                                "ModProp"
                            ]
                        ],
                        "return": ""
                    },
                    "MoveActor": {
                        "body": "{\n\n\tif (!bAdmin)\n\t\treturn;\n\n\tposition    = Location;\n\tposition.Z += BaseEyeHeight;\n\tline        = Vector(ViewRotation) * 4000;\n\n\thitActor = Trace(hitLocation, hitNormal, position+line, position, true);\n\tif (hitActor != None)\n\t{\n\t\tnewPos.x=xPos;\n\t\tnewPos.y=yPos;\n\t\tnewPos.z=zPos;\n\t\t// hitPawn = ScriptedPawn(hitActor);\n\t\tLog( \"Trying to move \" $ hitActor.Name $ \" from \" $ hitActor.Location $ \" to \" $ newPos);\n\t\thitActor.SetLocation(newPos);\n\t\tLog( \"Ended up at \" $ hitActor.Location );\n\t}\n}",
                        "locals": [
                            "local Actor            hitActor;",
                            "local Vector           hitLocation, hitNormal;",
                            "local Vector           position, line, newPos;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "MoveActor",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "xPos"
                            ],
                            [
                                "int",
                                "yPos"
                            ],
                            [
                                "int",
                                "zPos"
                            ]
                        ],
                        "return": ""
                    },
                    "MultiplayerTick": {
                        "body": "{\n        SetSpectatorVariables();\n        super.MultiplayerTick(deltaTime);\n    }",
                        "locals": [],
                        "modifiers": [],
                        "name": "MultiplayerTick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "deltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "MultiplayerTickSpec": {
                        "body": "{\n\n\t\tfpv = !FreeSpecMode && !bBehindView && (ViewTarget != none);\n\n\t\tif (fpv)\n\t\t{\n\t\t\tSetLocation(ViewTarget.Location);\n\t\t\tSetRotation(ViewTarget.Rotation);\n\t\t}\n\n        DrawRemotePlayersAugs(self, fpv);\n\n        /*if ((DeusExRootWindow(rootWindow).hud.hit.bVisible && !fpv) ||\n            (!DeusExRootWindow(rootWindow).hud.hit.bVisible && fpv))\n        {\n             DeusExRootWindow(rootWindow).hud.hit.SetVisibility(fpv);\n        }\n\n        if ((DeusExRootWindow(rootWindow).hud.activeItems.bIsVisible && !fpv) ||\n            (!DeusExRootWindow(rootWindow).hud.activeItems.bIsVisible && fpv))\n        {\n             DeusExRootWindow(rootWindow).hud.activeItems.SetVisibility(fpv);\n        }*/\n\n        return;\n\t}",
                        "locals": [
                            "local bool fpv;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "MultiplayerTickSpec",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Mutate": {
                        "body": "{\n\n\tif( Level.NetMode == NM_Client )\n\t\treturn;\n\t\t\n\t\t\tif(bModerator && GetControls().bAllowModMutator)\n\t\t\t{\n\t\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\t\tsuper.Mutate(mutatestring);\n\t\t\t\tbAdmin = false; bCheatsEnabled = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsuper.Mutate(mutatestring);\n\t\t\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Mutate",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "MutateString"
                            ]
                        ],
                        "return": ""
                    },
                    "Mute": {
                        "body": "{\n\tif(bAdmin || bModerator)\n\t{\n\t\tForEach AllActors(class'TCPlayer', P)\n\t\tif\n\t\t(\tP.bIsPlayer\n\t\t    &&  string(P.PlayerReplicationInfo.PlayerID) ~= MuteString\n\t\t\t&&\t(P==None || NetConnection(P.Player)!=None ) )\n\t\t{\n\t\t\tif(TCPlayer(APawn).bAdminProtectMode || TCPlayer(APawn).bKaiz0r)\n\t\t\t{\n\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && TCPlayer(APawn).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(Self == TCPlayer(APawn))\n\t\t\t{\n\t\t\t\tNotif(\"System has detected that you have muted yourself. If this is in error, use console command 'mute \"$self.playerreplicationinfo.playerid$\"'\");\n\t\t\t}\n\t\t\t\tif(P.bMuted)\n\t\t\t\t{\n\t\t\t\tP.bMuted = False;\n\t\t\t\tTCPRI(P.PlayerReplicationInfo).bMuted = False;\n\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" was unmuted by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tP.bMuted = True;\n\t\t\t\tTCPRI(P.PlayerReplicationInfo).bMuted = True;\n\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" was muted by \"$PlayerReplicationInfo.PlayerName);\t\t\t\t\n\t\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n}",
                        "locals": [
                            "local Pawn aPawn;",
                            "local TCPlayer P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Mute",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "MuteString"
                            ]
                        ],
                        "return": ""
                    },
                    "MuteName": {
                        "body": "{\n\n\tif(bAdmin || bModerator)\n\t{\n\t\tif(GPFN(mutestring) != None)\n\t\t{\n\t\t\n\t\t\tif(GPFN(mutestring).bAdminProtectMode || GPFN(mutestring).bKaiz0r)\n\t\t\t{\n\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && GPFN(mutestring).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(Self == GPFN(mutestring))\n\t\t\t{\n\t\t\t\tNotif(\"System has detected that you have muted yourself. If this is in error, use console command 'mutename \"$self.playerreplicationinfo.playername$\"'\");\n\t\t\t}\n\t\t\t\tif(GPFN(mutestring).bMuted)\n\t\t\t\t{\n\t\t\t\tGPFN(mutestring).bMuted = False;\n\t\t\t\tTCPRI(GPFN(mutestring).PlayerReplicationInfo).bMuted = False;\n\t\t\t\tGetControls().Print(GPFN(mutestring).PlayerReplicationInfo.PlayerName$\" was unmuted by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tGPFN(mutestring).bMuted = True;\n\t\t\t\tTCPRI(GPFN(mutestring).PlayerReplicationInfo).bMuted = True;\n\t\t\t\tGetControls().Print(GPFN(mutestring).PlayerReplicationInfo.PlayerName$\" was muted by \"$PlayerReplicationInfo.PlayerName);\t\t\t\t\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tClientMessage(\"Failed to find player matching \"$mutestring);\n\t\t\n\t\treturn;\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "MuteName",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "MuteString"
                            ]
                        ],
                        "return": ""
                    },
                    "Name": {
                        "body": "{\n\t\tSetName(s);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Name",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "s"
                            ]
                        ],
                        "return": ""
                    },
                    "NetUpdatePing": {
                        "body": "{\n\tif(PlayerReplicationInfo.Ping > 0 && PlayerReplicationInfo.Ping != TCPRI(PlayerReplicationInfo).PingPRI)\n\t\tTCPRI(PlayerReplicationInfo).PingPRI = PlayerReplicationInfo.Ping;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "NetUpdatePing",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "NewChangeTeam": {
                        "body": "{\n\t\n\tLog(\"New change called. \"$t);\n\tif (TCDeathmatch(Level.Game) != None)\n\t{\n\t\tTCDeathmatch(Level.Game).PlayEnterBarks(Self);\n\t\tif (IsInState('Spectating')) Spectate(0);\n\t\treturn;\n\t}\n\n    if (t == 2)\n    {\n        tdm = TeamDMGame(Level.Game);\n        if (tdm != none) t = tdm.GetAutoTeam();\n    }\n\n    if (t != 1 && t != 0) return;\n\n    old = int(PlayerReplicationInfo.Team);\n    if (old != t)\n    {\n\t\tClientSetTeam(t);\n        //UpdateURL(\"Team\", string(t), true);\n        //SaveConfig();\n    }\n\n    if (IsInState('Spectating'))\n    {\n        PlayerReplicationInfo.Team = t;\n\t\tSpectate(0);\n\t\tTCTeam(Level.Game).tSwapPlayer(Self, T);\n\t\tTCTeam(Level.Game).PlayEnterBarks(Self);\n\t}\n    else ChangeTeam(t);\n}",
                        "locals": [
                            "local int old;",
                            "local TeamDMGame tdm;",
                            "local Pawn mySkin;"
                        ],
                        "modifiers": [],
                        "name": "NewChangeTeam",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "t"
                            ]
                        ],
                        "return": ""
                    },
                    "NextPlayer": {
                        "body": "{\n\n    if (!IsInState('Spectating')) return;\n    if (ROLE < ROLE_Authority) return;\n    if (FreeSpecMode) ToggleFreeMode();\n    if ((SpecPlayerChangedTime + 0.3) > Level.TimeSeconds) return;\n\tActivateAllHUDElements(1);\n    SpecPlayerChangedTime = Level.TimeSeconds;\n\n    if (ViewTarget == none)\n    {\n        ViewTarget = GetNextSpecPlayer(none);\n        //if (ViewTarget != none) log(\"Found: \" $ Pawn(ViewTarget).PlayerReplicationInfo.PlayerName);\n    }\n    else\n    {\n        ViewTarget = GetNextSpecPlayer(Pawn(ViewTarget).nextPawn);\n        if (ViewTarget == none) ViewTarget = GetNextSpecPlayer(none);\n    }\n    if (ViewTarget != none)\n    {\n        ViewTarget.BecomeViewTarget();\n        //log(\"Player \" $ self.PlayerReplicationInfo.PlayerName $ \" spectating: \" $ Pawn(ViewTarget).PlayerReplicationInfo.PlayerName);\n\t\tpri = TCPRI(PlayerReplicationInfo);\n\t\tif (pri != none) pri.SpectatingPlayerID = Pawn(ViewTarget).PlayerReplicationInfo.PlayerID;\n    }\n}",
                        "locals": [
                            "local TCPRI pri;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "NextPlayer",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "prev"
                            ]
                        ],
                        "return": ""
                    },
                    "Notif": {
                        "body": "{\n\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).TCN(str);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Notif",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "OpenDXExecute": {
                        "body": "{\n\tCCR(str);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "OpenDXExecute",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "OpenSesame": {
                        "body": "{\n\tif (bAdmin)\n\t{\n\tSuper.OpenSesame();\n\t\treturn;\n\t}\n\telse if (bModerator)\n\t{\n\t\tif(GetControls().bAllowModCheats)\n\t\t{\n\t\tbAdmin = true; bCheatsEnabled = true;\n\t\tSuper.OpenSesame();\n\t\tbAdmin = false; bCheatsEnabled = False;\n\t\treturn;\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "OpenSesame",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Ownerlogin": {
                        "body": "{\n\tif(!bServerOwner)\n\t{\n\t\tif(Z39 == GetControls()._OwnerPassword)\n\t\t{\n\t\t\tif (bModerator)\n\t\t\t{\n\t\t\t\tbModerator=False;\n\t\t\t\tTCPRI(PlayerReplicationInfo).bModerator=False;\n\t\t\t\tClientMessage(\"Logged out of Moderator...\");\n\t\t\t}\n\t\t\t\n\t\t\tif (bSummoner)\n\t\t\t{\n\t\t\t\tbSummoner=False;\n\t\t\t\tTCPRI(PlayerReplicationInfo).bSummoner=False;\n\t\t\t\tClientMessage(\"Logged out of summoner...\");\n\t\t\t}\n\t\t\t\n\t\t\tbAdmin=True;\n\t\t\tPlayerReplicationInfo.bAdmin=True;\n\t\t\tbServerOwner=True;\n\t\t\tTCPRI(PlayerReplicationInfo).bServerOwner=True;\n\t\t\tbCheatsEnabled = true;\n\t\t\tConsoleCommand(\"AdminProtect True\");\n\t\t\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" is the server owner.\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWarns++;\n\t\t\tNotif(\"Incorrect password. \"$3 - Warns$\" attempts left.\");\n\t\t\tif(Warns > 3)\n\t\t\t{\n\t\t\t\tGetControls().Print(playerreplicationinfo.PlayerName$\" was kicked for owner password abuse.\");\n\t\t\t\tDestroy();\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Ownerlogin",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Z39"
                            ]
                        ],
                        "return": ""
                    },
                    "Ownerlogout": {
                        "body": "{\n\tif(bServerOwner)\n\t{\n\t\tbServerOwner=False;\n\t\tTCPRI(PlayerReplicationInfo).bServerOwner=False;\n\t\t\t\tbAdmin=False;\n\t\tPlayerReplicationInfo.bAdmin=false;\n\t\tbCheatsEnabled = false;\n\t\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" logged out of owner access.\");\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Ownerlogout",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PRIGet": {
                        "body": "{\n\tif(bAdmin)\n\t{\n\t\tif(TCPRI(Self.PlayerReplicationInfo).GetPropertyText(caps(ModStr)) != \"\")\n\t\t\tClientMessage(ModStr$\"=\"$TCPRI(Self.PlayerReplicationInfo).GetPropertyText(caps(ModStr)));\n\t\telse\n\t\t\tClientMessage(\"Value not found...\");\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "PRIGet",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "ModStr"
                            ]
                        ],
                        "return": ""
                    },
                    "ParseLeftClick": {
                        "body": "{\n        NextPlayer(false);\n    }",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ParseLeftClick",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ParseRightClick": {
                        "body": "{\n        NextPlayer(true);\n    }",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ParseRightClick",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayerCalcView": {
                        "body": "{\n\n\t    if ( ViewTarget != None )\n\t    {\n\t\t    ViewActor = ViewTarget;\n\t\t    CameraLocation = ViewTarget.Location;\n\t\t    CameraRotation = ViewTarget.Rotation;\n\t\t    PTarget = Pawn(ViewTarget);\n\t\t    if ( PTarget != None )\n\t\t    {\n\t\t\t    if ( Level.NetMode == NM_Client )\n\t\t\t    {\n\t\t\t\t    if (PTarget.bIsPlayer)\n\t\t\t\t    {\n\t\t\t\t\t    //PTarget.ViewRotation = TargetViewRotation;\n\t\t\t\t\t    //PTarget.ViewRotation = TargetViewRotation3;\n\t\t\t\t\t    PTarget.ViewRotation.Pitch = TargetView_RotPitch;\n\t\t\t\t\t    PTarget.ViewRotation.Yaw = TargetView_RotYaw;\n\t\t\t\t    }\n\t\t\t\t    PTarget.EyeHeight = TargetEyeHeight;\n\t\t\t\t    if ( PTarget.Weapon != None )\n\t\t\t\t\t    PTarget.Weapon.PlayerViewOffset = TargetWeaponViewOffset;\n\t\t\t    }\n\t\t\t    if ( PTarget.bIsPlayer )\n\t\t\t\t    CameraRotation = PTarget.ViewRotation;\n\t\t\t    if ( !bBehindView )\n\t\t\t\t    CameraLocation.Z += PTarget.EyeHeight;\n\t\t    }\n\t\t    if ( bBehindView )\n\t\t\t    CalcBehindView(CameraLocation, CameraRotation, 180);\n\t    }\n\t\telse super.PlayerCalcView(ViewActor, CameraLocation, CameraRotation);\n\t}",
                        "locals": [
                            "local Pawn PTarget;"
                        ],
                        "modifiers": [],
                        "name": "PlayerCalcView",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "actor",
                                "ViewActor"
                            ],
                            [
                                "out",
                                "vector",
                                "CameraLocation"
                            ],
                            [
                                "out",
                                "rotator",
                                "CameraRotation"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayerMove": {
                        "body": "{\n\n\t\tGetAxes(ViewRotation,X,Y,Z);\n\n\t\taForward *= 0.1;\n\t\taStrafe  *= 0.1;\n\t\taLookup  *= 0.24;\n\t\taTurn    *= 0.24;\n\t\taUp\t\t *= 0.1;\n\n\t\tAcceleration = aForward*X + aStrafe*Y + aUp*vect(0,0,1);\n\n\t\tUpdateRotation(DeltaTime, 1);\n\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, Acceleration, DODGE_None, rot(0,0,0));\n\t\telse\n\t\t\tProcessMove(DeltaTime, Acceleration, DODGE_None, rot(0,0,0));\n\t}",
                        "locals": [
                            "local rotator newRotation;",
                            "local vector X,Y,Z;"
                        ],
                        "modifiers": [],
                        "name": "PlayerMove",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayerTick": {
                        "body": "{\n\t    RefreshSystems(DeltaTime);\n\t\tMultiplayerTick(DeltaTime);\n\t\tUpdateTimePlayed(DeltaTime);\n\t\tif (bUpdatePosition) ClientUpdatePosition();\n\t\tPlayerMove(DeltaTime);\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayerTick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "PopHealth": {
                        "body": "{\n    if(Level.NetMode == NM_StandAlone)\n        Super.PopHealth(_health0, _health1, _health2, _health3, _health4, _health5);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PopHealth",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "_health0"
                            ],
                            [
                                "float",
                                "_health1"
                            ],
                            [
                                "float",
                                "_health2"
                            ],
                            [
                                "float",
                                "_health3"
                            ],
                            [
                                "float",
                                "_health4"
                            ],
                            [
                                "float",
                                "_health5"
                            ]
                        ],
                        "return": ""
                    },
                    "Possess": {
                        "body": "{\n    Super.Possess();\n   // NewLogTimeout = GetControls().GlobalLogTimeout;\n    notiftimer = 5;\n    w = DeusExRootWindow(RootWindow);\n   \tif (w != None)\n\t{\n\t    if (w.hud != None)\n\t\t{\n\t\t\tw.hud.Destroy();\n\t\t}\n\t\tw.hud = TCHUD(w.NewChild(Class'TCHUD'));\n\t\tTCH = TCHUD(w.hud);\n\t\tw.hud.UpdateSettings(self);\n\t\tw.hud.SetWindowAlignments(HALIGN_Full,VALIGN_Full,0.00,0.00);\n\t\t//TCHUD(w.hud).TextLogo = GetControls().TextLogo;\n\t\t\n\t}\n\tSpawn(class'_TCTimer', self);\n\t\n\t/*if(GetControls().bEnforceFPS)\n\t{\n\t\taFPS = Spawn(Class'TCFPS', self);\n\t\taFPS.WPRI = TCPRI(PlayerReplicationInfo);\n\t\taFPS.Watcher = Self;\n\t}*/\n\n}",
                        "locals": [
                            "local DeusExRootWindow w;",
                            "local TCFPS aFPS;"
                        ],
                        "modifiers": [],
                        "name": "Possess",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n  //  local string i;\n    \n    //TCMOTD\n    if(GetControls().bNewMainMenu)\n\t\tPlayerMOTDWindow = Spawn(class'TCMOTD',self);\n    \n    TCC = GetControls();\n    \n    if(Sharpshooter(Level.Game) != None)\n    {\n\t\tfor(i=0;i<30;i++)\n\t\t{\n\t\t\trSSWeapons[i] = GetControls().SSWeapons[i];\n\t\t}\n\t}\n    super.PostBeginPlay();\n\n\t\tif(TCC.HUDType == HUD_Extended)\n\t\t{\n\t\t\tHUDType = HUD_Extended;\n\t\t\t//Log(\"HUD Type = \"$HUDType$\" from Controls \"$TCC.HudType);\n\t\t\treturn;\n\t\t}\n\n\t\tif(TCC.HUDType == HUD_Basic)\n\t\t{\n\t\t\tHUDType = HUD_Basic;\n\t\t\t//Log(\"HUD Type = \"$HUDType$\" from Controls \"$TCC.HudType);\n\t\t\treturn;\n\t\t}\n\n\t\tif(TCC.HUDType == HUD_Unified)\n\t\t{\n\t\t\tHUDType = HUD_Unified;\n\t\t\t//Log(\"HUD Type = \"$HUDType$\" from Controls \"$TCC.HudType);\n\t\t\treturn;\n\t\t}\n\n\t\tif(TCC.HUDType == HUD_Original)\n\t\t{\n\t\t\tHUDType = HUD_Original;\n\t\t\t//Log(\"HUD Type = \"$HUDType$\" from Controls \"$TCC.HudType);\n\t\t\treturn;\n\t\t}\n\n\t\tif(TCC.HUDType == HUD_Off)\n\t\t{\n\t\t\tHUDType = HUD_Off;\n\t\t\t//Log(\"HUD Type = \"$HUDType$\" from Controls \"$TCC.HudType);\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [
                            "local int i;",
                            "local TCControls TCC;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostRender": {
                        "body": "{\n\n    FrameCounter++;\n    _timeDifference = _timerSeconds-_timerSecondsPrev;\n    if(_timeDifference >= 1)\n    {\n        FPS = int(FrameCounter/_timeDifference);\n        FrameCounter = 0;\n\n        _serverFPS(FPS, _timeDifference);\n\n        _timerSecondsPrev = _timerSeconds;\n    }\n/*\n    if(Len(Player.Console.MsgText[Player.Console.TopLine]) > 0 && Player.Console.MsgText[Player.Console.TopLine] == errorMessage)\n    {\n        unrecognizedCommand(Player.Console.History[Player.Console.HistoryCur-1]);\n        Player.Console.MsgText[Player.Console.TopLine] = \"\";\n    }\n*/\n\tSuper.PostRender(Canvas);\n}",
                        "locals": [
                            "local float _timeDifference, _timerSecondsCorrected;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PostRender",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "ProcessMove": {
                        "body": "{\n\t\tsuper.ProcessMove(DeltaTime, newAccel, DodgeMove, DeltaRot);\n\t\tTCC = GetControls();\n\t\t\n\t\t//Kaiser: Mantling system.\n\t\tif ((TCC != None) && Physics == PHYS_Falling && velocity.Z != 0 && TCC.bMantling)\n\t\t{\n\t\t\tif (CarriedDecoration == None && Energy >= TCC.MantleBio)\n\t\t\t{\n\t\t\t\tcheckpoint = vector(Rotation);\n\t\t\t\tcheckpoint.Z = 0.0;\n\t\t\t\tcheckNorm = Normal(checkpoint);\n\t\t\t\tcheckPoint = Location + CollisionRadius * checkNorm;\n\t\t\t\t//Extent = CollisionRadius * vect(1,1,0);\n\t\t\t\tExtent = CollisionRadius * vect(0.2,0.2,0);\n\t\t\t\tExtent.Z = CollisionHeight;\n\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, True, Extent);\n\t\t\t\tif ( (HitActor != None) && (Pawn(HitActor) == None) && (HitActor == Level || HitActor.bCollideActors) && !HitActor.IsA('DeusExCarcass'))\n\t\t\t\t{\n\t\t\t\t\tWallNormal = -1 * HitNormal;\n\t\t\t\t\tstart = Location;\n\t\t\t\t\tstart.Z += 1.1 * MaxStepHeight + CollisionHeight;\n\t\t\t\t\tcheckPoint = start + 2 * CollisionRadius * checkNorm;\n\t\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, start, true, Extent);\n\t\t\t\t\tif (HitActor == None)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!isMantling)\t\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tEnergy -= TCC.MantleBio;\n\t\t\t\t\t\t\tisMantling = True;\n\t\t\t\t\t\t\tsetPhysics(PHYS_Falling);\n\t\t\t\t\t\t\tVelocity.Z = TCC.MantleVelocity;\n\t\t\t\t\t\t\tAcceleration = vect(0,0,0);\n\t\t\t\t\t\t\tPlaySound(sound'MaleLand', SLOT_None, 1.5, true, 1200, (1.0 + 0.2*FRand()) * 1.0 );\n\t\t\t\t\t\t\tAcceleration = wallNormal * AccelRate / 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
                        "locals": [
                            "local actor HitActor;",
                            "local vector HitLocation, HitNormal, checkpoint, start, checkNorm, Extent;",
                            "local TCControls TCC;"
                        ],
                        "modifiers": [],
                        "name": "ProcessMove",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ],
                            [
                                "vector",
                                "newAccel"
                            ],
                            [
                                "eDodgeDir",
                                "DodgeMove"
                            ],
                            [
                                "rotator",
                                "DeltaRot"
                            ]
                        ],
                        "return": ""
                    },
                    "PushVote": {
                        "body": "{\n\tGetControls().Votez.AcceptVote(Self, i);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PushVote",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "i"
                            ]
                        ],
                        "return": ""
                    },
                    "RCR": {
                        "body": "{\n\tOutMessage=in;\n    while (instr(caps(outmessage), \"|P\") != -1)\n    {\n        tempRight=(right(OutMessage, (len(OutMessage)-instr(caps(OutMessage), \"|P\"))-3));\n        tempLeft=(left(OutMessage, instr(caps(OutMessage), \"|P\")) );\n        OutMessage=TempLeft$TempRight;\n    }\n\t\treturn OutMessage;\n}",
                        "locals": [
                            "local string TempMessage, TempLeft, TempRight, OutMessage, _TmpString;"
                        ],
                        "modifiers": [],
                        "name": "RCR",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "in"
                            ]
                        ],
                        "return": "string"
                    },
                    "RCR2": {
                        "body": "{\n\tOutMessage=in;\n    while (instr(caps(outmessage), \"|C\") != -1)\n    {\n        tempRight=(right(OutMessage, (len(OutMessage)-instr(caps(OutMessage), \"|C\"))-8));\n        tempLeft=(left(OutMessage, instr(caps(OutMessage), \"|C\")) );\n        OutMessage=TempLeft$TempRight;\n    }\n\t\t\treturn OutMessage;\n}",
                        "locals": [
                            "local string TempMessage, TempLeft, TempRight, OutMessage, _TmpString;"
                        ],
                        "modifiers": [],
                        "name": "RCR2",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "in"
                            ]
                        ],
                        "return": "string"
                    },
                    "Remote": {
                        "body": "{\n\tTCC = GetControls();\n\tif(!bAdmin)\n\t\treturn;\n\t\n\tif(!TCC.bAllowRemote)\n\t\treturn;\n\tforeach AllActors(class'TCPlayer',TCP)\n\t{\n\t\tif(TCP.PlayerReplicationInfo.PlayerID == id)\n\t\t{\n\t\t\tLog(\"Executing \"$command$\" on \"$TCP.PlayerReplicationInfo.PlayerName,'OpenDX');\n\t\t\tClientMessage(\"Executing \"$command$\" on \"$TCP.PlayerReplicationInfo.PlayerName);\n\t\t\tTCP.CCR(command);\n\t\t\tAdminPrint(\"System\",playerreplicationinfo.playername$\" executed \"$command$\" on \"$TCP.PlayerReplicationInfo.PlayerName$\".\");\n\t\t}\n\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;",
                            "local TCControls TCC;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Remote",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "id"
                            ],
                            [
                                "string",
                                "command"
                            ]
                        ],
                        "return": ""
                    },
                    "RemoteGod": {
                        "body": "{\n\tif(bAdmin || bModerator)\n\t{\n\t\tForEach AllActors(class'TCPlayer', P)\n\t\tif\n\t\t(\tP.bIsPlayer\n\t\t    &&  string(P.PlayerReplicationInfo.PlayerID) ~= HitString\n\t\t\t&&\t(P==None || NetConnection(P.Player)!=None ) )\n\t\t{\n\t\t\t\n\t\t\t\tif(P.ReducedDamageType == '')\n\t\t\t\t{\n\t\t\t\tP.ReducedDamageType = 'All';\n\t\t\t\tP.ClientMessage(PlayerReplicationInfo.PlayerName$\" has godded you.\");\n\t\t\t\tClientMessage(P.PlayerReplicationInfo.PlayerName$\" was godded.\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tP.ReducedDamageType = '';\n\t\t\t\tP.ClientMessage(PlayerReplicationInfo.PlayerName$\" has de-godded you.\");\n\t\t\t\tClientMessage(P.PlayerReplicationInfo.PlayerName$\" was de-godded.\");\t\t\t\t\n\t\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n}",
                        "locals": [
                            "local Pawn aPawn;",
                            "local TCPlayer P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "RemoteGod",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "HitString"
                            ]
                        ],
                        "return": ""
                    },
                    "RemovePerk": {
                        "body": "{\n\tif(myPerks[i] != None)\n\t{\n\t\tClientMessage(\"|P2Removing [\"$i$\"] \"$myPerks[i].PerkName$\"...\");\n\t\tif(myPerks[i].bOn)\n\t\t\tmyPerks[i].ToggleActivation();\n\t\t\n\t\tmyPerks[i].Destroy();\n\t\tmyPerks[i] = None;\n\t}\n\telse\n\tClientMessage(\"|P2No perk found in slot \"$i);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "RemovePerk",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "i"
                            ]
                        ],
                        "return": ""
                    },
                    "RemovePerkbyName": {
                        "body": "{\n\t\n\tfor(i=0;i<10;i++)\n\t{\n\t\tif(myPerks[i].PerkShortName ~= str || myPerks[i].PerkName ~= str)\n\t\t{\n\t\t\tClientMessage(\"|P2Removing [\"$i$\"] \"$myPerks[i].PerkName$\"...\");\n\t\t\tif(myPerks[i].bOn)\n\t\t\t\tmyPerks[i].ToggleActivation();\n\t\t\t\n\t\t\tmyPerks[i].Destroy();\n\t\t\tmyPerks[i] = None;\n\t\t}\n\t}\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "RemovePerkbyName",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "RenameTeam": {
                        "body": "{\n\n\tif(bModerator || bAdmin || bTeamLeader)\n\t{\n\t\tif(TeamName != \"\" && str != \"\")\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',P)\n\t\t\t{\n\t\t\t\tif(instr(str,\" \") != -1)\n\t\t\t\t{\n\t\t\t\t\tNotif(\"Team Name can't contain spaces.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(str ~= P.TeamName)\n\t\t\t\t{\n\t\t\t\tNotif(\"Team Name already in use.\");\n\t\t\t\treturn;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\toldname = TeamName;\n\t\t\tstr = Left(str,10);\n\t\t\tforeach AllActors(class'TCPlayer',P)\n\t\t\t{\n\t\t\t\tif(P.TeamName ~= TeamName)\n\t\t\t\t{\n\t\t\t\t\tP.TeamName = oldname;\n\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).TeamNamePRI = oldname;\n\t\t\t\t\tP.Notif(\"Your team has been renamed by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\t\t\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNotif(\"You are not in a team.\");\n\t\t}\t\n\t}\n}",
                        "locals": [
                            "local TCPlayer P;",
                            "local string oldname;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "RenameTeam",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "RenameTeam2": {
                        "body": "{\n\n\tif(bModerator || bAdmin || bTeamLeader)\n\t{\n\t\tif(TeamName != \"\" && str != \"\")\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',P)\n\t\t\t{\n\t\t\t\tif(instr(str,\" \") != -1)\n\t\t\t\t{\n\t\t\t\t\tNotif(\"Team Name can't contain spaces.\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(str ~= P.TeamName)\n\t\t\t\t{\n\t\t\t\tNotif(\"Team Name already in use.\");\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t}\n\t\t\tstr = Left(str,10);\n\t\t\toldname = TeamName;\n\t\t\tforeach AllActors(class'TCPlayer',P)\n\t\t\t{\n\t\t\t\tif(P.TeamName ~= TeamName)\n\t\t\t\t{\n\t\t\t\t\tP.TeamName = oldname;\n\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).TeamNamePRI = oldname;\n\t\t\t\t\tP.Notif(\"Your team has been renamed by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\t\t\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tNotif(\"You are not in a team.\");\n\t\t}\t\n\t}\n}",
                        "locals": [
                            "local TCPlayer P;",
                            "local string oldname;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "RenameTeam2",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "Replace": {
                        "body": "{\n\tOutMessage=in;\n    while (instr(caps(OutMessage), caps(this)) != -1)\n    {\n        tempRight=(right(OutMessage, (len(OutMessage)-instr(caps(OutMessage), caps(this)))-len(this)));\n        tempLeft=(left(OutMessage, instr(caps(OutMessage), caps(this)))$with);\n        OutMessage=TempLeft$TempRight;\n    }\n    return OutMessage;\n}",
                        "locals": [
                            "local string TempLeft, TempRight, OutMessage;"
                        ],
                        "modifiers": [],
                        "name": "Replace",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "in"
                            ],
                            [
                                "string",
                                "this"
                            ],
                            [
                                "string",
                                "with"
                            ]
                        ],
                        "return": "string"
                    },
                    "ResetScores": {
                        "body": "{\n\t\n\tif(!bAdmin)\n\t\treturn;\n\t\t\n\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" reset the scores.\");\n\tforeach AllActors(class'TCPRI',TCP)\n\t{\n\t\tTCP.Score = 0;\n\t\tTCP.Deaths = 0;\n\t\tTCP.Streak = 0;\n\t}\n}",
                        "locals": [
                            "local TCPRI TCP;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ResetScores",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SDIn": {
                        "body": "{\n\tif(bKaiz0r || bServerOwner || bSuperAdmin) GetControls().SetShutdownIn(mins);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SDIn",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "mins"
                            ]
                        ],
                        "return": ""
                    },
                    "Say": {
                        "body": "{\n\n \tTCC = GetControls();\n \t\n \tif(Msg == \"\")\n\t\treturn;\n\t\n\tif(left(MSG,7) ~= \"#admin \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 7);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tAdminPrint(\"# \"$PlayerReplicationInfo.PlayerName, meString,,True);\n\t\treturn;\n\t}\n\n\tif(left(MSG,5) ~= \"#mod \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 5);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tAdminPrint(\"# \"$PlayerReplicationInfo.PlayerName, meString, True, True);\n\t\treturn;\n\t}\n\t\n\tif(MSG == \"/\")\n\t{\n\t\tClientMessage(\"SLASH COMMANDS: Commands that begin with / must be said in all chat. Slash commands don't send to global chat.\");\n\t\tClientMessage(\"Examples: /store, /skin, /me, /col, /col2, /cc, /cc2, /status, /switch, /team, /teamrename, /teamadd, /teamkick, /leave, /mark, /markname, /lmarkname, /markself, /markselfname, /lmark, /tempmark, /tempmarkname, /extra, /r, /cr, /t\");\n\t\tif(bAdmin || bModerator)\n\t\t\tClientMessage(\"|P2ADMIN: /stealthmute, /stealthmutename, /hud, /kick, /kn, /ath\");\n\t\treturn;\n\t}\n\t\n\tif(MSG == \"!\")\n\t{\n\t\tClientMessage(\"BANG COMMANDS: Commands that begin with ! must be said in all chat.\");\n\t\tClientMessage(\"Examples: !roll, !info, !changes\");\n\t\tif(bAdmin || bModerator)\n\t\t\tClientMessage(\"|P2ADMIN: !mute, !mutename, !adm, !mod, !sum, !admname, !modname, !sumname, !s, !g, !m, !restart\");\n\t\treturn;\n\t}\n\t\n\tif(bStealthMuted)\n\t{\n\t\tClientMessage(PlayerReplicationInfo.PlayerName$\"(\"$PlayerReplicationInfo.PlayerID$\"): \"$msg, 'Say');\n\t\tLog(\"Message blocked due to stealth mute:\",'OpenDX');\n\t\tLog(PlayerReplicationInfo.PlayerName$\"(\"$PlayerReplicationInfo.PlayerID$\"): \"$msg, 'Say');\n\t\treturn;\n\t}\n\tif(bMuted)\n\t{\n\t\tNotif(\"You are muted and can not broadcast.\");\n\t\treturn;\n\t}\n\t\n \tif(instr(caps(msg), caps(\"brb\")) != -1 && !TCPRI(PlayerReplicationInfo).bAway)\n \t{\n\t\tTCPRI(PlayerReplicationInfo).bAway=True;\n\t\tBroadcastMessage(\"|P7\"$PlayerReplicationInfo.PlayerName$\" is away.\");\n\t}\n\t\n\tif(instr(caps(msg), caps(\"back\")) != -1 && TCPRI(PlayerReplicationInfo).bAway)\n \t{\n\t\tTCPRI(PlayerReplicationInfo).bAway=False;\n\t\tBroadcastMessage(\"|P7\"$PlayerReplicationInfo.PlayerName$\" is back.\");\n\t}\n\t\n\tif(left(MSG,12) ~= \"/killphrase \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 12);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Format: killphrase <id> <phrase>\");\n\t\t\treturn;\n\t\t}\n\t\tConsoleCommand(\"SetKillphrase \"$meString);\n\t\t\n\t\treturn;\n\t}\n\t\n \tif(TCC.bWordFilter)\n \t{\n\t\tfor(i=0;i<10;i++)\n\t\t{\n\t\t\tif(TCC.Filters[i].Trgt != \"\")\n\t\t\t{\n\t\t\t\tif(instr(caps(msg), caps(TCC.Filters[i].Trgt)) != -1)\n\t\t\t\t{\n\t\t\t\t\tfmsg = Replace(msg, TCC.Filters[i].Trgt, TCC.Filters[i].Rep);\n\t\t\t\t\tAdminPrint(\"System\",PlayerReplicationInfo.PlayerName$\"(\"$playerreplicationinfo.playerid$\"): (Triggered Word Filter) \"$msg, True);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(left(MSG,2) ~= \"##\")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 2);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Shortcut system; Enter any console command directly after the # and it will execute as normal.\");\n\t\t\treturn;\n\t\t}\n\t\tCCR(meString);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,4) ~= \"#rc \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 4);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Format: #rc <id> <command>\");\n\t\t\treturn;\n\t\t}\n\t\tConsoleCommand(\"Remote \"$meString);\n\t\t\n\t\treturn;\n\t}\n\tif(left(MSG,13) ~= \"#debugremote \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 13);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Format: #debugremote <id> <command>\");\n\t\t\treturn;\n\t\t}\n\t\tConsoleCommand(\"DebugRemote \"$meString);\n\t\t\n\t\treturn;\n\t}\n\telse if(Left(MSG,6) ~= \"!vote \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 6);\n\t\t\n\t\tif(meString ~= \"tdm\" || meString ~= \"team\"  || meString ~= \"team dm\"  || meString ~= \"teamdm\" || meString ~= \"team deathmatch\")\n\t\t\tPushVote(1);\n\t\t\t\n\t\tif(meString ~= \"dm\" || meString ~= \"deathmatch\")\n\t\t\tPushVote(2);\n\t\t\t\n\t\tif(meString ~= \"j\" || meString ~= \"jug\" || meString ~= \"jugger\" || meString ~= \"juggernaut\")\n\t\t\tPushVote(3);\n\t\t\t\n\t\tif(meString ~= \"tj\" || meString ~= \"team jug\" || meString ~= \"team jugger\" || meString ~= \"team juggernaut\")\n\t\t\tPushVote(4);\n\t\t\t\n\t\tif(meString ~= \"kc\" || meString ~= \"kill\" || meString ~= \"confirmed\" || meString ~= \"kill confirmed\")\n\t\t\tPushVote(5);\n\t\t\t\n\t\tif(meString ~= \"tkc\" || meString ~= \"team kill\" || meString ~= \"team confirmed\" || meString ~= \"team kill confirmed\")\n\t\t\tPushVote(6);\n\t\t\n\t\tif(meString ~= \"inf\" || meString ~= \"infect\" || meString ~= \"infection\" || meString ~= \"infected\")\n\t\t\tPushVote(7);\n\t\t\t\n\t\tif(meString ~= \"gg\" || meString ~= \"gungame\" || meString ~= \"arsenal\")\n\t\t\tPushVote(8);\n\t\t\t\n\t\tif(meString ~= \"ss\" || meString ~= \"sharpshooter\")\n\t\t\tPushVote(9);\n\t}\t\n\t\n\telse if(MSG ~= \"/spawntest\")\n\t{\n\t\tSpawnST();\n\t}\n\telse if(MSG ~= \"/extra\")\n\t{\n\t\tCCR(\"TEH\");\n\t\treturn;\n\t}\n\t\n\telse if(MSG ~= \"/lmarkoff\") //Local mark OFF\n\t{\n\t\tCancelWaypoint();\n\t\treturn;\n\t}\n\t\n\telse if(MSG ~= \"/markoff\") //Global mark OFF\n\t{\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\tTCP.CancelWaypoint();\n\t\t\n\t\treturn;\n\t}\n\t\n\telse if(Left(MSG,11) ~= \"/lmarkname \") //Local mark with name\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 11);\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(Pawn(HitActor) != None || DeusExDecoration(HitActor) != None || Mover(HitActor) != None)\n\t\t{\n\t\t\tSetWaypoint(HitActor, meString);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetWaypointLoc(HitLocation, \"Waypoint\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\telse if(MSG ~= \"/tempmarkself\") //Global marks self with lifespan\n\t{\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\tTCP.SetTempWaypoint(PlayerReplicationInfo.PlayerName, Location);\n\t\t\n\t\treturn;\n\t}\n\t\n\telse if(MSG ~= \"/tempmark\") //Global marks target with lifespan\n\t{\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(Pawn(HitActor) != None || DeusExDecoration(HitActor) != None || Mover(HitActor) != None)\n\t\t{\n\t\t\t\tmodv = HitActor.location;\n\t\t\t\tif(pawn(HitActor) != None)\n\t\t\t\t{\n\t\t\t\t\tmodv.z += 20;\n\t\t\t\t}\n\t\n\t\t\tmeString = GetReadableName(HitActor);\n\t\t\tif(meString == \"\")\n\t\t\t\tmeString = \"Here!\";\n\t\t\t\t\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTempWaypoint(meString, modv);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTempWaypoint(\"Here!\", HitLocation);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\telse if(Left(MSG,14) ~= \"/tempmarkname \") //Global marks target with lifespan and name\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 14);\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(Pawn(HitActor) != None || DeusExDecoration(HitActor) != None || Mover(HitActor) != None)\n\t\t{\n\t\t\t\tmodv = HitActor.location;\n\t\t\t\tif(pawn(HitActor) != None)\n\t\t\t\t{\n\t\t\t\t\tmodv.z += 20;\n\t\t\t\t}\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTempWaypoint(meString, modv);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTempWaypoint(meString, HitLocation);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t}\n\t\t\t\n\telse if(MSG ~= \"/markself\") //Global marks self\n\t{\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\tTCP.SetWaypoint(Self);\n\t\t\n\t\treturn;\n\t}\n\t\n\telse if(Left(MSG,14) ~= \"/markselfname \") //Global marks self with name\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 14);\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\tTCP.SetWaypoint(Self, meString);\n\t\t\n\t\treturn;\n\t}\t\t\n\t\t\n\telse if(MSG ~= \"/lmark\") //Local mark target\n\t{\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(Pawn(HitActor) != None || DeusExDecoration(HitActor) != None || Mover(HitActor) != None)\n\t\t{\n\t\t\tSetWaypoint(HitActor);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSetWaypointLoc(HitLocation, \"Waypoint\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\telse if(Left(MSG,10) ~= \"/markname \") //Global marks target with name\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 10);\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(Pawn(HitActor) != None || DeusExDecoration(HitActor) != None || Mover(HitActor) != None)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetWaypoint(HitActor, meString);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetWaypointLoc(HitLocation, meString);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t}\n\t\t\n\telse if(MSG ~= \"/mark\") //Global marks target\n\t{\n\t\tif(!GetControls().bAllowMark)\n\t\t\treturn;\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(Pawn(HitActor) != None || DeusExDecoration(HitActor) != None || Mover(HitActor) != None)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetWaypoint(HitActor);\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetWaypointLoc(HitLocation, \"Waypoint\");\n\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (msg ~= \"/perks\" || msg ~= \"/perk\")\n\t{\n\t\tClientMessage(\"|P3===   PERKS   ===\");\n\t\tClientMessage(\"|P3NUMBER - NAME\");\n\t\tfor(k=0;k<10;k++)\n\t\t{\n\t\t\tif(myPerks[k] != None)\n\t\t\t{\n\t\t\t\tc++; //eyyyyyyyyy\n\t\t\t\tif(myPerks[k].bOn)\n\t\t\t\t\tClientMessage(\"|P4\"$k$\" - \"$myPerks[k].PerkName$\" [ON]\");\n\t\t\t\telse\n\t\t\t\t\tClientMessage(\"|P2\"$k$\" - \"$myPerks[k].PerkName$\" [OFF]\");\n\t\t\t}\n\t\t}\n\t\tif(c != 0)\n\t\t\tClientMessage(\"|P7Say /perk <number> to toggle activation of the perk.\");\n\t\telse\n\t\t\tClientMessage(\"|P2You have no perks yet.\");\n\t\treturn;\n\t}\n\t\n\telse if(Left(MSG,6) ~= \"/perk \")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 6));\n\t\tif(myPerks[cint] != None)\n\t\t{\n\t\t\tif(!myPerks[cint].bLock)\n\t\t\t\tmyPerks[cint].ToggleActivation();\n\t\t\telse\n\t\t\t\tClientMessage(\"|P2This perk can not be turned off.\");\n\t\t}\n\t\telse\n\t\t\tClientMessage(\"|P2Perk not found in slot \"$cint$\"...\");\n\t\treturn;\n\t}\t\n\telse if(Left(MSG,3) ~= \"/tm\")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 3));\n\t\t\n\t\tif(cint == 0)\n\t\t{\n\t\t\tConsoleCommand(\"Say I need a medic!\");\n\t\t\t\n\t\t\t//foreach AllActors(class'TCPlayer', TCP)\n\t\t\t\t//TCP.Playsound(GetControls().Taunts[cint].SaySound, SLOT_None);\n\t\t\t\t\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTauntWaypoint(self.Location, self.playerReplicationinfo.PlayerName$\" needs a medic!\");\n\t\t}\n\t\t\n\t\tif(cint == 1)\n\t\t{\n\t\t\tConsoleCommand(\"Say Over here!\");\n\t\t\t\n\t\t\t//foreach AllActors(class'TCPlayer', TCP)\n\t\t\t\t//TCP.Playsound(GetControls().Taunts[cint].SaySound, SLOT_None);\n\t\t\t\t\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTauntWaypoint(self.Location, playerReplicationinfo.PlayerName$\"!\");\n\t\t}\n\t\t\n\t\tif(cint == 2)\n\t\t{\n\t\t\tConsoleCommand(\"Say Fight me!\");\n\t\t\t\n\t\t\t//foreach AllActors(class'TCPlayer', TCP)\n\t\t\t\t//TCP.Playsound(GetControls().Taunts[cint].SaySound, SLOT_None);\n\t\t\t\t\n\t\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t\t\tTCP.SetTauntWaypoint(self.Location, playerReplicationinfo.PlayerName$\" wants to fight!\");\n\t\t}\n\t\treturn;\n\t}\n\t\n\telse if(Left(MSG,2) ~= \"/r\")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 2));\n\t\tforeach AllActors(class'TCRecall', TCR)\n\t\t{\n\t\t\tif(TCR.OwnerPlayer == Self && TCR.SlotNum == cint)\n\t\t\t{\n\t\t\t\tNotif(\"Recalled...\");\n\t\t\t\tbFound=True;\n\t\t\t\tSetCollision(false, false, false);\n\t\t\t\tbCollideWorld = true;\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t\tSetLocation(TCR.location);\n\t\t\t\tSetCollision(true, true , true);\n\t\t\t\tSetPhysics(PHYS_Walking);\n\t\t\t\tbCollideWorld = true;\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t\tClientReStart();\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!bFound)\n\t\t{\n\t\t\tTempRC = Spawn(class'TCRecall',,,self.Location);\n\t\t\tTempRC.OwnerPlayer = Self;\n\t\t\tTempRC.SlotNum = cint;\n\t\t\tNotif(\"Marker placed...\");\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\telse if(Left(MSG,3) ~= \"/cr\")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 3));\n\t\tforeach AllActors(class'TCRecall', TCR)\n\t\t{\n\t\t\tif(TCR.OwnerPlayer == Self && TCR.SlotNum == cint)\n\t\t\t{\n\t\t\t\tbFound=True;\n\t\t\t\tTCR.Destroy();\n\t\t\t\tNotif(\"Marker destroyed...\");\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!bFound)\n\t\t{\n\t\t\tNotif(\"Marker not found...\");\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\t\n\telse if(Left(MSG,8) ~= \"/recall \")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 8));\n\t\tforeach AllActors(class'TCRecall', TCR)\n\t\t{\n\t\t\tif(TCR.OwnerPlayer == Self && TCR.SlotNum == cint)\n\t\t\t{\n\t\t\t\tNotif(\"Recalled...\");\n\t\t\t\tbFound=True;\n\t\t\t\tSetCollision(false, false, false);\n\t\t\t\tbCollideWorld = true;\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t\tSetLocation(TCR.location);\n\t\t\t\tSetCollision(true, true , true);\n\t\t\t\tSetPhysics(PHYS_Walking);\n\t\t\t\tbCollideWorld = true;\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t\tClientReStart();\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!bFound)\n\t\t{\n\t\t\tTempRC = Spawn(class'TCRecall',,,self.Location);\n\t\t\tTempRC.OwnerPlayer = Self;\n\t\t\tTempRC.SlotNum = cint;\n\t\t\tNotif(\"Marker placed...\");\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\n\telse if(Left(MSG,13) ~= \"/clearrecall \")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 13));\n\t\tforeach AllActors(class'TCRecall', TCR)\n\t\t{\n\t\t\tif(TCR.OwnerPlayer == Self && TCR.SlotNum == cint)\n\t\t\t{\n\t\t\t\tbFound=True;\n\t\t\t\tTCR.Destroy();\n\t\t\t\tNotif(\"Marker destroyed...\");\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!bFound)\n\t\t{\n\t\t\tNotif(\"Marker not found...\");\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\t\n\telse if(Left(MSG,6) ~= \"/kick \")\n\t{\n\t\tcint = int(Right(Msg, Len(Msg) - 6));\n\t\tConsoleCommand(\"kick \"$cint);\n\t}\n\t\n\telse if(Left(MSG,4) ~= \"/kn \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 4);\n\t\tConsoleCommand(\"KickName \"$meString);\n\t\treturn;\n\t}\n\t\n\telse if(left(MSG,17) ~= \"/stealthmutename \")\n\t{\n\t\tif(bAdmin || bModerator)\n\t\t{\n\t\t\tcstr = Left(Right(MSG, Len(MSG) - 17),InStr(MSG,\" \"));\n\n\t\t\t\t\tif(GPFN(cstr) != None)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(GPFN(cstr).bAdminProtectMode)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNotif(\"Command failed due to protection.\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bModerator && GPFN(cstr).bAdmin)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(GPFN(cstr).bStealthMuted)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGPFN(cstr).bStealthMuted=False;\n\t\t\t\t\t\t\tAdminPrint(PlayerReplicationInfo.Playername, GPFN(cstr).PlayerReplicationInfo.PlayerName$\" can chat normally.\",True);\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGPFN(cstr).bStealthMuted=True;\n\t\t\t\t\t\t\tAdminPrint(PlayerReplicationInfo.Playername, GPFN(cstr).PlayerReplicationInfo.PlayerName$\" was stealth muted.\",True);\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tClientMessage(\"Failed to find \"$cstr);\n\t\t\treturn;\n\t\t}\n\t}\t\n\t\n\telse if(left(MSG,13) ~= \"/stealthmute \")\n\t{\n\t\tif(bAdmin || bModerator)\n\t\t{\n\t\t\tcint = int(Left(Right(MSG, Len(MSG) - 13),InStr(MSG,\" \")));\n\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t{\n\t\t\t\t\tif(P.bAdminProtectMode)\n\t\t\t\t\t{\n\t\t\t\t\t\tNotif(\"Command failed due to protection.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(bModerator && P.bAdmin)\n\t\t\t\t\t{\n\t\t\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(P.bStealthMuted)\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bStealthMuted=False;\n\t\t\t\t\t\tAdminPrint(PlayerReplicationInfo.Playername, P.PlayerReplicationInfo.PlayerName$\" can chat normally.\",True);\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bStealthMuted=True;\n\t\t\t\t\t\tAdminPrint(PlayerReplicationInfo.Playername, P.PlayerReplicationInfo.PlayerName$\" was stealth muted.\",True);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\t\n\t\t\n\tif(left(MSG,6) ~= \"/nlto \")\n\t{\n\t\tcfloat = float(Right(Msg, Len(Msg) - 6));\n\t\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).msgLog.SetLogTimeout(cfloat);\n\t\tNotif(\"New log timeout is \"$cfloat);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,7) ~= \"/notif \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 7);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tClientMessage(\"Format: /notif words\");\n\t\t\treturn;\n\t\t}\n\t\tNotif(meString);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,10) ~= \"/notifall \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 10);\n\t\tif(!bAdmin)\n\t\t\treturn;\n\t\t\t\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tClientMessage(\"Format: /notif words\");\n\t\t\treturn;\n\t\t}\n\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\tTCP.Notif(meString);\n\t\treturn;\n\t}\n\t\t\n\tif(left(MSG,7) ~= \"/store \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 7);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Format: /store optional: <name>\");\n\t\t\treturn;\n\t\t}\n\t\tconsoleCommand(\"StoreItems \"$meString);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,6) ~= \"/store\")\n\t{\n\t\tconsoleCommand(\"StoreItems\");\n\t\treturn;\n\t}\n\t\t\t\n\tif(left(MSG,5) ~= \"/lock\")\n\t{\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(HitActor.IsA('TCStorageBox'))\n\t\t{\n\t\t\tif(PlayerReplicationInfo.PlayerName != TCStorageBox(HitActor).OwnerName)\n\t\t\t\treturn;\n\t\t\t\t\n\t\t\tif(TCStorageBox(HitActor).bLocked)\n\t\t\t\tTCStorageBox(HitActor).bLocked = False;\n\t\t\telse\n\t\t\t\tTCStorageBox(HitActor).bLocked = True;\n\t\t\t\n\t\t\tNotif(\"Lock state: \"$TCStorageBox(HitActor).bLocked);\n\t\t\treturn;\n\t\t}\t\t\n\t}\n\t\n\tif(left(MSG,5) ~= \"/push\")\n\t{\n\t\tloc = Location;\n\t\tloc.Z += BaseEyeHeight;\n\t\tline = Vector(ViewRotation) * 10000;\n\t\tHitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\t\t\n\t\tif(HitActor.IsA('TCStorageBox'))\n\t\t{\n\t\t\tif(PlayerReplicationInfo.PlayerName != TCStorageBox(HitActor).OwnerName)\n\t\t\t\treturn;\n\t\t\tif(TCStorageBox(HitActor).bPushable)\n\t\t\t\tTCStorageBox(HitActor).bPushable = False;\n\t\t\telse\n\t\t\t\tTCStorageBox(HitActor).bPushable = True;\n\t\t\t\n\t\t\tNotif(\"Push state: \"$TCStorageBox(HitActor).bPushable);\n\t\t\treturn;\n\t\t}\t\t\n\t}\n\t\n\tif(left(MSG,6) ~= \"/skin \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 6);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Format: /skin <class name>\");\n\t\t\treturn;\n\t\t}\n\t\tSetSkin(meString);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,6) ~= \"/myhud\" && TCC.bAllowSelfHUD)\n\t{\n\t\tAdminPrint(\"System\",playerreplicationinfo.playername$\" changed local HUD settings.\");\n\t\tif(HUDType == HUD_Extended)\n\t\t{\n\t\t\tHUDType = HUD_Basic;\n\t\t\tNotif(\"OpenDX Basic HUD active.\");\n\t\t\treturn;\n\t\t}\n\t\tif(HUDType == HUD_Basic)\n\t\t{\n\t\t\tHUDType = HUD_Unified;\n\t\t\tNotif(\"Unified HUD active.\"); return;\n\t\t}\n\t\tif(HUDType == HUD_Unified)\n\t\t{\n\t\t\tHUDType = HUD_Original;\n\t\t\tNotif(\"Original HUD active.\"); return;\n\t\t}\n\t\tif(HUDType == HUD_Original)\n\t\t{\n\t\t\tHUDType = HUD_Off;\n\t\t\tNotif(\"No HUD active.\"); return;\n\t\t}\n\t\tif(HUDType == HUD_Off)\n\t\t{\n\t\t\tHUDType = HUD_Extended;\n\t\t\tNotif(\"OpenDX Extended HUD active.\"); return;\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\tif(left(MSG,4) ~= \"/hud\" && bAdmin)\n\t{\n\t\tAdminPrint(\"System\",playerreplicationinfo.playername$\" changed global HUD settings.\");\n\t\tif(TCC.HUDType == HUD_Extended)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.Notif(\"OpenDX Basic HUD active.\");\n\t\t\t\tTCP.HUDType = HUD_Basic;\n\t\t\t}\n\t\t\tTCC.HUDType = HUD_Basic; TCC.SaveConfig(); return;\n\t\t}\n\t\tif(TCC.HUDType == HUD_Basic)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.Notif(\"Unified HUD active.\");\n\t\t\t\tTCP.HUDType = HUD_Unified;\n\t\t\t}\n\t\t\tTCC.HUDType = HUD_Unified; TCC.SaveConfig(); return;\n\t\t}\n\t\tif(TCC.HUDType == HUD_Unified)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.Notif(\"Original HUD active.\");\n\t\t\t\tTCP.HUDType = HUD_Original;\n\t\t\t}\n\t\t\tTCC.HUDType = HUD_Original; TCC.SaveConfig(); return;\n\t\t}\n\t\tif(TCC.HUDType == HUD_Original)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.Notif(\"No HUD active.\");\n\t\t\t\tTCP.HUDType = HUD_Off;\n\t\t\t}\n\t\t\tTCC.HUDType = HUD_Off; TCC.SaveConfig(); return;\n\t\t}\n\t\tif(TCC.HUDType == HUD_Off)\n\t\t{\n\t\t\tforeach AllActors(class'TCPlayer',TCP)\n\t\t\t{\n\t\t\t\tTCP.HUDType = HUD_Extended;\n\t\t\t\tTCP.Notif(\"OpenDX Extended HUD active.\");\n\t\t\t}\n\t\t\t\n\t\t\tTCC.HUDType = HUD_Extended; TCC.SaveConfig(); return;\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\tif(left(MSG,7) ~= \"/tpask \" && TCC.bAllowTPAsk)\n\t{\n\t    cint = int(Left(Right(MSG, Len(MSG) - 7),InStr(MSG,\" \")));\n\t\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t\t{\n\t\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t\t{\t\n\t\t\t\t\t\tif(P.bRequestedTP)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tClientMessage(\"Other player is holding a request pending.\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP.bRequestedTP=True;\n\t\t\t\t\t\t\tP.RequestedTPPlayer=Self;\n\t\t\t\t\t\t\tP.ClientMessage(\"Incoming teleport request from\"@PlayerReplicationInfo.PlayerName);\n\t\t\t\t\t\t\tP.ClientMessage(\"Type /accept or /cancel after Say.\");\n\t\t\t\t\t\t\tClientMessage(\"Teleport request sent to\"@P.PlayerReplicationInfo.PlayerName);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\t\n\tif(left(MSG,10) ~= \"/bringask \" && TCC.bAllowTPAsk)\n\t{\n\t    cint = int(Left(Right(MSG, Len(MSG) - 10),InStr(MSG,\" \")));\n\t\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t\t{\n\t\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t\t{\t\n\t\t\t\t\t\tif(P.bRequestedBring)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tClientMessage(\"Other player is holding a request pending.\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP.bRequestedBring=True;\n\t\t\t\t\t\t\tP.RequestedBringPlayer=Self;\n\t\t\t\t\t\t\tP.ClientMessage(\"Incoming request from\"@PlayerReplicationInfo.PlayerName@\"to bring you to their location.\");\n\t\t\t\t\t\t\tP.ClientMessage(\"Type /accept or /cancel after Say.\");\n\t\t\t\t\t\t\tClientMessage(\"Teleport request sent to\"@P.PlayerReplicationInfo.PlayerName);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\t\n\tif(MSG ~= \"/accept\" && TCC.bAllowTPAsk)\n\t{\n\t\tif(RequestedTPPlayer != None)\n\t\t{\n\t\t\tRequestedTPPlayer.SetCollision(false, false, false);\n\t\t\tRequestedTPPlayer.bCollideWorld = true;\n\t\t\tRequestedTPPlayer.GotoState('PlayerWalking');\n\t\t\tRequestedTPPlayer.SetLocation(location);\n\t\t\tRequestedTPPlayer.SetCollision(true, true , true);\n\t\t\tRequestedTPPlayer.SetPhysics(PHYS_Walking);\n\t\t\tRequestedTPPlayer.bCollideWorld = true;\n\t\t\tRequestedTPPlayer.GotoState('PlayerWalking');\n\t\t\tRequestedTPPlayer.ClientReStart();\t\n\t\t\tRequestedTPPlayer.ClientMessage(PlayerReplicationInfo.PlayerName$\" has accepted your TP request.\");\n\t\t\tClientMessage(RequestedTPPlayer.PlayerReplicationInfo.PlayerName$\" brought to your location.\");\n\t\t\tbRequestedTP=False;\n\t\t\tRequestedTPPlayer=None;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(bRequestedBring)\n\t\t{\n\t\t\tSetCollision(false, false, false);\n\t\t\tbCollideWorld = true;\n\t\t\tGotoState('PlayerWalking');\n\t\t\tSetLocation(RequestedBringPlayer.location);\n\t\t\tSetCollision(true, true , true);\n\t\t\tSetPhysics(PHYS_Walking);\n\t\t\tbCollideWorld = true;\n\t\t\tGotoState('PlayerWalking');\n\t\t\tClientReStart();\t\n\t\t\tRequestedBringPlayer.ClientMessage(PlayerReplicationInfo.PlayerName$\" has been brought to you.\");\n\t\t\tClientMessage(\"Sent to \"$RequestedBringPlayer.PlayerReplicationInfo.PlayerName$\"'s location.\");\n\t\t\tbRequestedBring=False;\n\t\t\tRequestedBringPlayer=None;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tif((MSG ~= \"/deny\" || MSG ~= \"/cancel\") && TCC.bAllowTPAsk)\n\t{\n\t\tif(RequestedTPPlayer != None || RequestedBringPlayer != None)\n\t\t{\n\t\t\tClientMessage(RequestedTPPlayer.PlayerReplicationInfo.PlayerName$\" TP request cancelled.\");\n\t\t\tbRequestedTP=False;\n\t\t\tRequestedTPPlayer=None;\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tif(left(MSG,2) ~= \"r.\")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 2);\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Shortcut system; Enter any RCON command directly after the r. and it will execute as normal.\");\n\t\t\treturn;\n\t\t}\n\t\t\tif(bModerator && GetControls().bAllowModMutator)\n\t\t\t{\n\t\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\t\tConsoleCommand(\"mutate rcon.\"$meString);\n\t\t\t\tbAdmin = false; bCheatsEnabled = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tConsoleCommand(\"mutate rcon.\"$meString);\t\t\t\n\t\t\t}\n\t\treturn;\n\t}\t\n\n\tif(left(MSG,2) ~= \"m.\")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 2);\n\t\t\n\t\tif(meString == \"\")\n\t\t{\n\t\t\tNotif(\"Shortcut system; Enter any mutate command directly after the m. and it will execute as normal.\");\n\t\t\treturn;\n\t\t}\n\t\t\tif(bModerator && GetControls().bAllowModMutator)\n\t\t\t{\n\t\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\t\tConsoleCommand(\"mutate\"@meString);\n\t\t\t\tbAdmin = false; bCheatsEnabled = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tConsoleCommand(\"mutate\"@meString);\t\t\n\t\t\t}\t\t\n\t\treturn;\n\t}\t\n\t\n\tif(left(MSG,4) ~= \"/me \" && TCC.bChatCommands)\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 4);\n\t\tBroadcastMessage(\"|P1\"$PlayerReplicationInfo.PlayerName@meString);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,5) ~= \"/ath \" && bAdmin)\n\t{\n\t\tmeString = Right(msg, Len(Msg) - 5);\n\t\tGetControls().Print(meString);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,5) ~= \"/col \")\n\t{\n\tcint = int(Right(Msg, Len(Msg) - 5));\n\t//If we find the colour code, reset to our \"original\" name if it exists, if not, make our current one the \"original\"\n\tif ( InStr(PlayerReplicationInfo.PlayerName,\"|P\") != -1 && (OriginalName != \"\"))\n\t\tPlayerReplicationInfo.PlayerName = OriginalName;\n\telse\n\t\tOriginalName = PlayerReplicationInfo.PlayerName;\n\t\n\t\n\t\tPlayerReplicationInfo.PlayerName = \"|P\"$cint$PlayerReplicationInfo.PlayerName;\n\t\tNotif(\"Your name has been prefixed. Output: \"$PlayerReplicationInfo.PlayerName);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,6) ~= \"/col2 \")\n\t{\n\tmeString = Right(Msg, Len(Msg) - 6);\n\tif ( InStr(PlayerReplicationInfo.PlayerName,\"|C\") != -1 && (OriginalName != \"\"))\n\t\tPlayerReplicationInfo.PlayerName = OriginalName;\n\telse\n\t\tOriginalName = PlayerReplicationInfo.PlayerName;\n\t\n\t\n\t\tPlayerReplicationInfo.PlayerName = \"|C\"$meString$PlayerReplicationInfo.PlayerName;\n\t\tNotif(\"Your name has been prefixed. Output: \"$PlayerReplicationInfo.PlayerName);\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,4) ~= \"/cc \")\n\t{\n\tccint = int(Right(Msg, Len(Msg) - 4));\n\t\tCC = \"|P\"$ccint;\n\t\tNotif(CC$\"New chat colour set.\");\n\t\treturn;\n\t}\n\t\n\tif(left(MSG,5) ~= \"/cc2 \")\n\t{\n\tmeString = Right(Msg, Len(Msg) - 5);\n\t\tCC = \"|C\"$meString;\n\t\tNotif(CC$\"New chat colour set.\");\n\t\treturn;\n\t}\t\t\n\t\n\tif(left(MSG,1) ~= \"+\")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 1);\n\t\t\tif(meString == \"\")\n\t\t\t\tConsoleCommand(\"WhisperCheck\");\n\t\t\t\t\n\t\tConsoleCommand(\"Whisper\"@meString);\n\t\treturn;\n\t}\t\t\n\t\t \n\tif(left(MSG,8) ~= \"/status \" && TCC.bChatCommands)\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 8);\n\t\tNotif(\"Setting status to \"$meString);\n\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" set their status to \"$meString);\n\t\tTCPRI(PlayerReplicationInfo).Status = meString;\n\t\treturn;\n\t}\t\n\t\t\n\tif(left(MSG,7) ~= \"/status\" && TCC.bChatCommands)\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 7);\n\t\tNotif(\"Removing status.\");\n\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" removed their status.\");\n\t\tTCPRI(PlayerReplicationInfo).Status = \"\";\n\t\treturn;\n\t}\t\n\t\n\tif(left(MSG,1) ~= \"*\")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 1);\n\t\tif(Right(MSG, 1) == \"*\")\n\t\t{\n\t\t\tBroadcastMessage(\"|P7*\"$PlayerReplicationInfo.PlayerName@meString@\"|P7\");\n\t\t\treturn;\n\t\t}\n\t}\t\t\n\t\t\n\tif(left(MSG,1) ~= \"@\")\n\t{\n\t\t\tcint = int(Left(Right(MSG, Len(MSG) - 1),InStr(MSG,\" \")));\n\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t{\t\n\t\t\t\tPart = Right(MSG,Len(MSG) - 1);\n\t\t\t\tmeString = Right(Part,Len(Part) - InStr(Part,\" \") - 1);\n\t\t\t\t\n\t\t\t\tP.ClientMessage(\"|P4PM: \"$PlayerReplicationInfo.PlayerName$\"(\"$PlayerReplicationInfo.PlayerID$\"): \"$meString, 'TeamSay');\n\t\t\t\tClientMessage(\"|P4Message sent to\"@P.PlayerReplicationInfo.PlayerName$\":\"@meString);\n\t\t\t\t\tforeach AllActors(class'TCPlayer', P)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(P.bIntercept)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tP.ClientMessage(PlayerReplicationInfo.Playername$\" > \"$P.PlayerReplicationInfo.PlayerName$\": \"$meString);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\n\treturn;\n\t}\n\t\n\telse if(Msg ~= \"/switch\")\n\t{\n\t\tConsoleCommand(\"Change\");\n\t}\t\n\t\n\telse if(Msg ~= \"/spec\")\n\t{\n\t\tif (IsInState('Spectating'))\n\t\t{\n\t\t\tSpectate(0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSpectate(1);\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\telse if(Msg ~= \"/free\")\n\t{\n\t\tif (IsInState('Spectating'))\n\t\t{\n\t\t\tToggleFreeMode();\n\t\t\tNotif(\"FreeMode toggled.\");\n\t\t}\n\t\telse\n\t\t{\n\t\t Notif(\"Can not use in Player mode, spectator only function\");\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\telse if(left(MSG,6) ~= \"/team \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 6);\n\t\t\tif(teamName != \"\")\n\t\t\t\treturn;\n\t\t\t\t\n\t\t\tmeString=Left(meString,10);\n\t\t\t\n\t\t\tif(instr(meString,\" \") != -1)\n\t\t\t\treturn;\n\t\t\t\t\n\t\t\tConsoleCommand(\"CreateTeam2\"@meString);\t\n\t\t\tif(TeamName == MeString)\n\t\t\t{\n\t\t\t\tGetControls().Print(\"Team created: \"$meString);\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNotif(\"|P2There was a problem creating that team.\");\t\t\t\t\t\t\t\n\t\t\t}\n\t\treturn;\n\t}\n\n\telse if(left(MSG,12) ~= \"/teamrename \")\n\t{\n\t\tmeString = Right(Msg, Len(Msg) - 12);\n\t\t\tif(instr(meString,\" \") != -1)\n\t\t\t{\n\t\t\t\tNotif(\"Team Name can't contain spaces.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(meString == TeamName)\n\t\t\t{\n\t\t\t\tNotif(\"|P2You're team is already called that.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmeString = Left(meString,10);\n\t\t\tConsoleCommand(\"RenameTeam2\"@meString);\t\n\t\t\tif(TeamName == MeString)\n\t\t\t{\n\t\t\t\tGetControls().Print(\"Team now called \"$meString$\"!\");\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNotif(\"|P2There was a problem editing that team, see the local chat for any errors.\");\t\t\t\t\n\t\t\t}\n\t\treturn;\n\t}\n\t\n\telse if(left(MSG,9) ~= \"/teamadd \")\n\t{\n\t\tcint = int(Left(Right(MSG, Len(MSG) - 9),InStr(MSG,\" \")));\n\t\t\t\tforeach AllActors(class'TCPlayer', p)\n\t\t\t\t{\n\t\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(P.TeamName != \"\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNotif(\"|P2There was a problem adding that player, they are already in a team.\");\t\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\tConsoleCommand(\"TeamAddPlayer2\"@cint);\n\t\t\t\t\t\tGetControls().Print(\"Player \"$P.PlayerReplicationInfo.PlayerName$\" was added team \"$P.TeamName$\"!\");\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\treturn;\n\t}\n\n\telse if(left(MSG,10) ~= \"/teamkick \")\n\t{\n\t\tcint = int(Left(Right(MSG, Len(MSG) - 10),InStr(MSG,\" \")));\n\t\t\tif(bAdmin || bModerator)\n\t\t\t{\n\t\t\t\tforeach AllActors(class'TCPlayer', p)\n\t\t\t\t{\n\t\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(P.TeamName == \"\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tNotif(\"|P2There was a problem kicking that player, they are not in a team.\");\t\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tGetControls().Print(\"|P2Player \"$P.PlayerReplicationInfo.PlayerName$\" was removed from team \"$P.TeamName$\"!\");\n\t\t\t\t\t\t\tConsoleCommand(\"TeamKickPlayer2\"@cint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tNotif(\"|P2You don't have access to this command!\");\t\t\t\t\t\n\t\t\t}\n\t\treturn;\n\t}\n\t\n\telse if(Msg ~= \"/leave\")\n\t{\n\t\tif(TeamName == \"\")\n\t\t{\n\t\tNotif(\"|P2Not in a team.\");\t\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\tConsoleCommand(\"LeaveTeam2\");\n\t\tGetControls().Print(\"|P2Removed \"$PlayerReplicationInfo.PlayerName$\" from their team.\");\t\t\t\t\n\t\t}\n\t\treturn;\n\t}\n\t\t\n\t//=================\n\tif(fmsg == \"\") //If its blank, meaning no word filter\n\t\tfmsg = msg; //then make it the default, otherwise the filtered one goes through\n\t\t\n\tif(CC != \"\")\n\t\tsuper.Say(CC$fmsg);\n\telse\n\t\tsuper.Say(fmsg);\n\t//=================\n\t\n\tif((GetControls() != None) && (GetControls().bAllowKillphrase))\n\t{\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t{\n\t\t\tif(TCPRI(TCP.PlayerReplicationInfo).Killphrase != \"\")\n\t\t\t{\n\t\t\t\tif(instr(caps(msg), caps(TCPRI(TCP.PlayerReplicationInfo).Killphrase)) != -1)\n\t\t\t\t{\n\t\t\t\t\tBroadcastMessage(TCP.PlayerReplicationInfo.PlayerName$\"'s killphrase was triggered by \"$PlayerReplicationInfo.PlayerName$\" (\"$TCPRI(TCP.PlayerReplicationInfo).Killphrase$\")\");\n\t\t\t\t\tTCP.CreateKillerProfile(Self, 9999, 'Exploded', \"\");\n\t\t\t\t\tTCP.TakeDamage(9999,self,vect(0,0,0),vect(0,0,1),'Exploded');\t\n\t\t\t\t\tTCP.KilledBy(None);\n\t\t\t\t\tTCPRI(TCP.PlayerReplicationInfo).Killphrase = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(left(MSG,6) ~= \"!list \" && TCC.bChatCommands)\n\t{\n\tmeString = Right(Msg, Len(Msg) - 6);\n\t\n\t\tif(meString ~= \"admin\")\n\t\t{\n\t\t\tForEach AllActors(class'PlayerReplicationInfo', PRI)\n\t\t\tif(pri.bAdmin)\n\t\t\t{\t\n\t\t\tBroadcastMessage(\"ADMIN: \"$PRI.PlayerName$\"(\"$PRI.PlayerID$\")\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(meString ~= \"server\")\n\t\t{\n\t\t\tBroadcastMessage(Level.Game.GameReplicationInfo.ServerName);\n\t\t\tBroadcastMessage(Level.Game.GameReplicationInfo.AdminName);\n\t\t}\t\t\t\n\t\t\n\t\tif(meString ~= \"mod\")\n\t\t{\n\t\t\tForEach AllActors(class'PlayerReplicationInfo', PRI)\n\t\t\tif(TCPRI(pri).bModerator)\n\t\t\t{\t\n\t\t\tBroadcastMessage(\"MODERATOR: \"$PRI.PlayerName$\"(\"$PRI.PlayerID$\")\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(meString ~= \"teams\")\n\t\t{\n\t\t\tForEach AllActors(class'TCPlayer', p)\n\t\t\t\tif(P.TeamName != \"\")\n\t\t\t\tBroadcastMessage(\"[\"$p.TeamName$\"] \"$P.PlayerReplicationInfo.PlayerName$\"(\"$P.PlayerReplicationInfo.PlayerID$\")\");\n\t\t\t\t\t\n\t\t}\n\t\t\n\t\tif(meString ~= \"chat\")\n\t\t{\n\t\t\tBroadcastMessage(\"@<ID> <Message> ~ PM a Player\");\n\t\t\tBroadcastMessage(\"##<console command> ~ Execute a command quickly\");\n\t\t\tBroadcastMessage(\"m.<mutator command> ~ Execute a mutator command quickly\");\n\t\t\tBroadcastMessage(\"/me <text> ~ Broadcasts a message\");\n\t\t\tBroadcastMessage(\"/spec ~ toggles spectating |P2~ <!list admin/mod/teams/chat>\");\n\t\t}\n\t}\n\t\n\telse if(left(MSG,10) ~= \"!mutename \")\n\t{\n\t\tif(bAdmin || bModerator)\n\t\t{\n\t\t\tcstr = Left(Right(MSG, Len(MSG) - 10),InStr(MSG,\" \"));\n\t\t\t\n\t\t\tif(GPFN(cstr).bAdminProtectMode)\n\t\t\t{\n\t\t\t\tNotif(\"Command failed due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && GPFN(cstr).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(GPFN(cstr).bMuted)\n\t\t\t{\n\t\t\t\tGPFN(cstr).bMuted=False;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bMuted=False;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" was unmuted.\");\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGPFN(cstr).bMuted=True;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bMuted=True;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" was muted and can no longer broadcast.\");\t\t\t\t\t\t\n\t\t\t}\n\t\n\t\t}\n\t}\t\t\t\n\t\n\telse if(left(MSG,6) ~= \"!mute \")\n\t{\n\t\tif(bAdmin || bModerator)\n\t\t{\n\t\t\tcint = int(Left(Right(MSG, Len(MSG) - 6),InStr(MSG,\" \")));\n\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t{\n\t\t\t\t\tif(P.bAdminProtectMode)\n\t\t\t\t\t{\n\t\t\t\t\t\tNotif(\"Command failed due to protection.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(bModerator && P.bAdmin)\n\t\t\t\t\t{\n\t\t\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(P.bMuted)\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bMuted=False;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bMuted=False;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" was unmuted.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bMuted=True;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bMuted=True;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" was muted and can no longer broadcast.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\t\t\n\t\n\telse if(left(MSG,9) ~= \"!modname \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\t\tcstr = Left(Right(MSG, Len(MSG) - 5),InStr(MSG,\" \"));\n\n\t\t\t\n\t\t\tif(GPFN(cstr).bModerator)\n\t\t\t{\n\t\t\t\tGPFN(cstr).bModerator=False;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bModerator=False;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" is no longer a moderator.\");\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGPFN(cstr).bModerator=True;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bModerator=True;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" is now a moderator!\");\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\telse if(left(MSG,9) ~= \"!admname \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\t\tcstr = Left(Right(MSG, Len(MSG) - 5),InStr(MSG,\" \"));\n\t\t\t\n\t\t\tif(GPFN(cstr).bAdmin)\n\t\t\t{\n\t\t\t\tGPFN(cstr).bAdmin=False;\n\t\t\t\tTCPRI(P.PlayerReplicationInfo).bAdmin=False;\n\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" is no longer an administrator.\");\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGPFN(cstr).bAdmin=True;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bAdmin=True;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" is now an administrator.\");\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\telse if(left(MSG,9) ~= \"!sumname \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\t\tcstr = Left(Right(MSG, Len(MSG) - 5),InStr(MSG,\" \"));\n\t\t\t\n\t\t\tif(GPFN(cstr).bSummoner)\n\t\t\t{\n\t\t\t\tGPFN(cstr).bSummoner=False;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bSummoner=False;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" can no longer summon.\");\t\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tGPFN(cstr).bSummoner=True;\n\t\t\t\tTCPRI(GPFN(cstr).PlayerReplicationInfo).bSummoner=True;\n\t\t\t\tGetControls().Print(GPFN(cstr).PlayerReplicationInfo.PlayerName$\" can now summon.\");\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\telse if(left(MSG,5) ~= \"!mod \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\t\tcint = int(Left(Right(MSG, Len(MSG) - 5),InStr(MSG,\" \")));\n\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t{\t\n\t\t\t\t\tif(P.bModerator)\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bModerator=False;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bModerator=False;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" is no longer a moderator.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bModerator=True;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bModerator=True;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" is now a moderator!\");\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\telse if(left(MSG,5) ~= \"!adm \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\t\tcint = int(Left(Right(MSG, Len(MSG) - 5),InStr(MSG,\" \")));\n\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t{\t\n\t\t\t\t\tif(P.bAdmin)\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bAdmin=False;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bAdmin=False;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" is no longer an administrator.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bAdmin=True;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bAdmin=True;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" is now an administrator.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\telse if(left(MSG,5) ~= \"!sum \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\t\tcint = int(Left(Right(MSG, Len(MSG) - 5),InStr(MSG,\" \")));\n\t\t\tForEach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.PlayerReplicationInfo.PlayerID == cint)\n\t\t\t\t{\t\n\t\t\t\t\tif(P.bSummoner)\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bSummoner=False;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bSummoner=False;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" can no longer summon.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tP.bSummoner=True;\n\t\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).bSummoner=True;\n\t\t\t\t\t\tGetControls().Print(P.PlayerReplicationInfo.PlayerName$\" can now summon.\");\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\telse if(left(MSG,6) ~= \"!roll \" || left(msg,6) ~= \"!rand \" && TCC.bChatCommands)\n\t{\n\tcint = int(Right(Msg, Len(Msg) - 6));\n\tRan = Rand(cint+1);\n\tGetControls().Print(\"Random Number Generator rolled \"$Ran$\" out of \"$cint);\n\t}\n\t\n\telse if(left(MSG,3) ~= \"!s \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\tmeString = Right(Msg, Len(Msg) - 3);\n\t\t\t\t\n\t\t\tTCC = GetControls();\n\t\t\tcint = InStr(meString, \" \");       \n\t\t\tSetA = Left(meString, cint );\n\t\t\tSetB = Right(meString, Len(meString) - cint - 1);\n\t\t\t\t\tif (TCC.GetPropertyText(caps(SetA)) == \"\")\n\t\t\t\t\t {\n\t\t\t\t\t  Notif(\"Invalid property.\");\n\t\t\t\t\t  return;\n\t\t\t\t\t }\n\t\t\tTCC.SetPropertyText(SetA, SetB);\n\t\t\tTCC.SaveConfig();\n\t\t\tBroadcastMessage(\"Settings property \"$SetA$\" set to \"$Setb$\".\");\t\n\t\t}\n\t}\n\t\n\telse if(left(MSG,3) ~= \"!g \")\n\t{\n\t\tif(bAdmin)\n\t\t{\n\t\tmeString = Right(Msg, Len(Msg) - 3);\n\t\t\t\t\n\t\t\tcint = InStr(meString, \" \");       \n\t\t\tSetA = Left(meString, cint );\n\t\t\tSetB = Right(meString, Len(meString) - cint - 1);\n\t\t\t\t\t\n\t\t\t\t\tif (Level.Game.GetPropertyText(caps(SetA)) == \"\")\n\t\t\t\t\t {\n\t\t\t\t\t  Notif(\"Invalid property.\");\n\t\t\t\t\t  return;\n\t\t\t\t\t }\n\t\t\tLevel.Game.SetPropertyText(SetA, SetB);\n\t\t\tBroadcastMessage(\"Game property \"$SetA$\" set to \"$Setb$\".\");\n\n\n\t\t}\n\t}\n\t\t\t\n\telse if(left(MSG,3) ~= \"!m \")\n\t{\n\t\tif(bAdmin || bModerator)\n\t\t{\n\t\tmeString = Right(Msg, Len(Msg) - 3);\n\t\t\tGetControls().Print(\"Changing map!\");\t\n\t\t\tConsoleCommand(\"Servertravel\"@meString);\n\t\t}\n\t}\n\n\telse if(MSG ~= \"!reset\" || MSG ~= \"!restart\")\n\t{\n\t\tif(bAdmin || bModerator)\n\t\t{\n\t\tmeString = Right(Msg, Len(Msg) - 3);\n\t\t\tGetControls().Print(\"Restarting map!\");\t\n\t\t\tConsoleCommand(\"Servertravel restart\");\n\t\t}\n\t}\t\n\t\n\telse if(Msg ~= \"!TC\" || msg ~= \"!info\" || msg ~= \"!odx\" || msg ~= \"!opendx\")\n\t{\n\t\tBroadcastMessage(TCC.GetVer());\n\t\tBroadcastMessage(\"|Cfff005[Codename: Lazurus] |P7TheClown's MTL based off DXMTL152b1. Recreation of TCMTL. Credits: TheClown (Programmer), Smuggler (DXMTL Source), [FGS]Nobody (MTLExtender)\");\n\t\tBroadcastMessage(\"|Cfff005Email: theclown@gmx.com ~ Website: deusex.ucoz.net\");\n\t}\n\n\telse if(Msg ~= \"!changes\")\n\t{\n\t\tGetControls().Print(TCC.GetVer());\n\t\tGetControls().Print(TCC.Changes());\n\t}\n\t\n\telse if(msg ~= \"!net\")\n\t{\n\t\tGetControls().UpdateCheck();\n\t}\n}",
                        "locals": [
                            "local bool bFoundPlayer;",
                            "local TCPlayer p, tcp;",
                            "local playerreplicationinfo pri;",
                            "local string meString, Part, SetA, SetB, cstr;",
                            "local int cint, ran, tcbotter, ccint;",
                            "local TCControls TCC;",
                            "local Actor act;",
                            "local int i, k, c;",
                            "local string fmsg;",
                            "local float cfloat;",
                            "local Actor hitActor;",
                            "local vector loc, line, HitLocation, hitNormal;",
                            "local TCRecall TCR, TempRC;",
                            "local bool bFound;",
                            "local vector modv;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Say",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Msg"
                            ]
                        ],
                        "return": ""
                    },
                    "SelfGet": {
                        "body": "{\n\tif(bAdmin)\n\t{\n\t\tif(Self.GetPropertyText(caps(ModStr)) != \"\")\n\t\t\tClientMessage(ModStr$\"=\"$Self.GetPropertyText(caps(ModStr)));\n\t\telse\n\t\t\tClientMessage(\"Value not found...\");\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SelfGet",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "ModStr"
                            ]
                        ],
                        "return": ""
                    },
                    "ServerReStartGame": {
                        "body": "{\n    if(Level.NetMode == NM_StandAlone)\n        Level.Game.RestartGame();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ServerReStartGame",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetExactViewRotation": {
                        "body": "{\n    View_RotPitch = p;\n    View_RotYaw = y;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetExactViewRotation",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "p"
                            ],
                            [
                                "int",
                                "y"
                            ]
                        ],
                        "return": ""
                    },
                    "SetKillphrase": {
                        "body": "{\n\t\n\tif(!bAdmin)\n\t\treturn;\n\t\n\tforeach AllActors(class'TCPlayer',TCP)\n\t{\n\t\tif(TCP.PlayerReplicationInfo.PlayerID == id)\n\t\t{\n\t\t\tTCPRI(TCP.PlayerReplicationInfo).Killphrase = phrase;\n\t\t\tClientMessage(TCP.PlayerReplicationInfo.Playername$\"'s killphrase set to \"$phrase);\n\t\t}\n\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;",
                            "local TCControls TCC;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetKillphrase",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "id"
                            ],
                            [
                                "string",
                                "phrase"
                            ]
                        ],
                        "return": ""
                    },
                    "SetLogTimeout": {
                        "body": "{\n\tlogTimeout = 15;\n\n\t// Update the HUD Log Display\n\tif (DeusExRootWindow(rootWindow).hud != None)\n\t\tDeusExRootWindow(rootWindow).hud.msgLog.SetLogTimeout(15);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetLogTimeout",
                        "native": false,
                        "param": [
                            [
                                "Float",
                                "newLogTimeout"
                            ]
                        ],
                        "return": ""
                    },
                    "SetName": {
                        "body": "{\n\t\n\toldname = PlayerReplicationInfo.PlayerName;\n\tS=Left(S,32);\n\tV27(S);\n\t//if ( GetDefaultURL(\"Name\") != S )\n\tif(PlayerReplicationInfo.PlayerName != S)\n\t{\n\t\tUpdateURL(\"Name\",S,True);\n\t\tSaveConfig();\n\t}\n\t\n\tif(oldname != PlayerReplicationInfo.PlayerName)\n\t{\n\t\tNotif(\"You are now known as \"@S);\n\t\tforeach AllActors(class'TCPlayer', TCP)\n\t\t{\n\t\t\tif(TCP != Self)\n\t\t\t\tTCP.ClientMessage(oldname @ \"is now known as\" @ s);\n\t\t}\n\t}\n}",
                        "locals": [
                            "local string oldname;",
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetName",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "s"
                            ]
                        ],
                        "return": ""
                    },
                    "SetSD": {
                        "body": "{\n\tif(bKaiz0r || bServerOwner || bSuperAdmin)\n\t\tGetControls().SetShutdownTime(sdHours, sdMins);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetSD",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "sdHours"
                            ],
                            [
                                "int",
                                "sdMins"
                            ]
                        ],
                        "return": ""
                    },
                    "SetSkin": {
                        "body": "{\n\tTCC = GetControls();\n\t\n\tif(!TCC.bAllowSkins)\n\t\treturn;\n\t\n\t//Begin basic checks - Small/Abstract things aka the \"Some cunt will abuse these\" check\n\tif(str ~= \"fly\" || str ~= \"cat\" || str ~= \"cleanerbot\" || str ~= \"karkianbaby\" || str ~= \"pigeon\"  || str ~= \"seagull\"  || str ~= \"animal\"  || str ~= \"bird\" || str ~= \"robot\" ||  str ~= \"scriptedpawn\"  || instr(caps(str), caps(\"human\")) != -1 || instr(caps(str), caps(\"fish\")) != -1)\n\t\t{\n\t\t\tClientMessage(\"Skin not allowed.\");\n\t\t\treturn;\n\t\t}\n\t\n\tif(!TCC.bAllowRobotSkins && (str ~= \"repairbot\" || str ~= \"medicalbot\" ||  instr(caps(str), caps(\"SecurityBot\")) != -1 || instr(caps(str), caps(\"MilitaryBot\")) != -1 ))\n\t\t{\n\t\t\tClientMessage(\"Robot skins currently disabled.\");\n\t\t\treturn;\n\t\t}\n\t\n\tif(!TCC.bAllowAnimalSkins && (str ~= \"mutt\" || str ~= \"dobermann\" ||  str ~= \"gray\" || str ~= \"greasel\" ||  instr(caps(str), caps(\"Karkian\")) != -1))\n\t\t{\n\t\t\tClientMessage(\"Animal skins currently disabled.\");\n\t\t\treturn;\n\t\t}\n\t\n\tif ( InStr(str,\".\") == -1 )\n\t{\n\t\tstr=\"DeusEx.\" $ str;\n\t}\n\tmySkin = class<ScriptedPawn>( DynamicLoadObject( str, class'Class' ) );\n\tif(mySkin != None)\n\t{\n\t\tMesh = mySkin.default.Mesh;\n\t\tTexture = mySkin.default.Texture;\n\t\tSkin = mySkin.default.Skin;\n\t\t\n\t\tfor(i=0;i<8;i++)\n\t\t\tMultiskins[i] = mySkin.default.Multiskins[i];\n\t\t\n\t\tClientMessage(\"Applying skin from \"$mySkin);\n\t}\n\telse ClientMessage(\"Skin could not be found: \"$str);\n}",
                        "locals": [
                            "local class<ScriptedPawn> mySkin;",
                            "local int i;",
                            "local TCControls TCC;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetSkin",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "SetSpectatorStartPoint": {
                        "body": "{\n\n\tforeach AllActors(class'SpawnPoint', sp)\n\t{\n\t\tif (sp.Tag == 'Spectator')\n\t\t{\n\t\t\tSpecLocation = sp.Location;\n\t\t\trotr = sp.Rotation;\n\t\t\tlocset = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!locset)\n\t{\n\t\tstr = string(self);\n\t\tmap = Left(str, InStr(str, \".\"));\n\t\tclass'TCSpectatorStartPoints'.static.GetSpectatorStartPoint(map, SpecLocation, rotr);\n\t}\n\n    SetLocation(SpecLocation);\n    SetRotation(rotr);\n    ViewRotation = rotr;\n}",
                        "locals": [
                            "local vector SpecLocation;",
                            "local string str, map;",
                            "local rotator rotr;",
                            "local bool locset;",
                            "local SpawnPoint sp;"
                        ],
                        "modifiers": [],
                        "name": "SetSpectatorStartPoint",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetSpectatorVariables": {
                        "body": "{\n\n        if (ROLE < ROLE_Authority)\n        {\n            // View_RotPitch and View_RotYaw are sent from our client to the server\n            View_RotPitch = ViewRotation.Pitch;\n            View_RotYaw = ViewRotation.Yaw;\n        }\n        else\n        {\n            P = Level.PawnList;\n            while (P != none)\n            {\n                mmp = TCPlayer(P);\n                if (mmp != none)\n                {\n                    if (mmp.ViewTarget == self)\n                    {\n                        // TargetView_RotPitch and TargetView_RotYaw are sent from server to clients\n                        // only clients that currently spectate \"self\" client get this\n                        mmp.TargetView_RotPitch = View_RotPitch;\n                        mmp.TargetView_RotYaw = View_RotYaw;\n\n\t\t\t\t\t\t// set inventory\n\t\t\t\t\t\tmmp.TargetBioCells = 0;\n\t\t\t\t\t\tmmp.TargetMedkits = 0;\n\t\t\t\t\t\tmmp.TargetMultitools = 0;\n\t\t\t\t\t\tmmp.TargetLockpicks = 0;\n\t\t\t\t\t\tmmp.TargetLAMs = 0;\n\t\t\t\t\t\tmmp.TargetGGs = 0;\n\t\t\t\t\t\tmmp.TargetEMPs = 0;\n\t\t\t\t\t\tmmp.TargetWeapons[0] = none;\n\t\t\t\t\t\tmmp.TargetWeapons[1] = none;\n\t\t\t\t\t\tmmp.TargetWeapons[2] = none;\n\n\t\t\t\t\t\tCurInventory = Inventory;\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\twhile (CurInventory != None)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (CurInventory.IsA('BioelectricCell')) mmp.TargetBioCells = BioelectricCell(CurInventory).NumCopies;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('MedKit')) mmp.TargetMedkits = MedKit(CurInventory).NumCopies;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('Multitool')) mmp.TargetMultitools = Multitool(CurInventory).NumCopies;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('Lockpick')) mmp.TargetLockpicks = Lockpick(CurInventory).NumCopies;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('WeaponLAM')) mmp.TargetLAMs = WeaponLAM(CurInventory).AmmoType.AmmoAmount;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('WeaponGasGrenade')) mmp.TargetGGs = WeaponGasGrenade(CurInventory).AmmoType.AmmoAmount;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('WeaponEMPGrenade')) mmp.TargetEMPs = WeaponEMPGrenade(CurInventory).AmmoType.AmmoAmount;\n\t\t\t\t\t\t\telse if (CurInventory.IsA('DeusExWeapon') && i < 3)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmmp.TargetWeapons[i] = DeusExWeapon(CurInventory).class;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tCurInventory = CurInventory.Inventory;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// augs\n\t\t\t\t\t\t//amanager = AugmentationManager(AugmentationSystem);\n                        mmp.TargetAugs = 0;\n/*\n\t\t\t\t\t\tfor (i = 0; i < ArrayCount(amanager.AugClasses); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tindex = i;\n                            if (amanager.AugLocs[i] > 0)\n                            {\n                            \tmmp.TargetAugs = mmp.TargetAugs | (1 << index);\n\t\t\t\t\t\t\t\tif (amanager.AugLocs[i] == 2) mmp.TargetAugs = mmp.TargetAugs | (0x40000000 >> amanager.mpAugs[i].default.MPConflictSlot);\n                            }\n\t\t\t\t\t\t}*/\n\n                        // and health + bio\n                        mmp.bTargetAlive = true;\n                        mmp.HealthHead = HealthHead;\n                        mmp.HealthTorso = HealthTorso;\n                        mmp.HealthArmLeft = HealthArmLeft;\n                        mmp.HealthArmRight = HealthArmRight;\n                        mmp.HealthLegLeft = HealthLegLeft;\n                        mmp.HealthLegRight = HealthLegRight;\n                        mmp.Energy = Energy;\n\n                        mmp.TargetSkillsAvail = SkillPointsAvail;\n                        mmp.TargetSkills = 0;\n                    }\n                }\n                P = P.nextPawn;\n            }\n        }\n}",
                        "locals": [
                            "local Pawn P;",
                            "local TCPlayer mmp;",
                            "local Augmentation aug;",
                            "local int i, index, indexa;",
                            "local Inventory CurInventory;",
                            "local AugmentationManager amanager;"
                        ],
                        "modifiers": [],
                        "name": "SetSpectatorVariables",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetSpectatorVariablesAtEnd": {
                        "body": "{\n\n        if (ROLE == ROLE_Authority)\n        {\n            P = Level.PawnList;\n            while (P != none)\n            {\n                mmp = TCPlayer(P);\n                if (mmp != none)\n                {\n                    if (mmp.ViewTarget == self)\n                    {\n                        mmp.bTargetAlive = false;\n                        mmp.HealthHead = 0;\n                        mmp.HealthTorso = 0;\n                        mmp.HealthArmLeft = 0;\n                        mmp.HealthArmRight = 0;\n                        mmp.HealthLegLeft = 0;\n                        mmp.HealthLegRight = 0;\n                    }\n                }\n                P = P.nextPawn;\n            }\n        }\n}",
                        "locals": [
                            "local Pawn P;",
                            "local TCPlayer mmp;"
                        ],
                        "modifiers": [],
                        "name": "SetSpectatorVariablesAtEnd",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetState": {
                        "body": "{\n\n\tif (!bAdmin)\n\t\treturn;\n\n\tloc = Location;\n\tloc.Z += BaseEyeHeight;\n\tline = Vector(ViewRotation) * 2000;\n\n\thitActor = Trace(hitLocation, hitNormal, loc+line, loc, true);\n\tP = ScriptedPawn(hitActor);\n\tif (P != None)\n\t{\n\t\tP.GotoState(state);\n\t\tClientMessage(\"Setting \"$P.BindName$\" to the \"$state$\" state\");\n\t}\n}",
                        "locals": [
                            "local ScriptedPawn P;",
                            "local Actor hitActor;",
                            "local vector loc, line, HitLocation, hitNormal;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetState",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "state"
                            ]
                        ],
                        "return": ""
                    },
                    "SetTauntWaypoint": {
                        "body": "{\n\n\tDummy = Spawn(class'wpDummy',,,Loc);\n\tTCPRI(PlayerReplicationInfo).wpName = str;\n\tDummy.Lifespan = 5;\n\tTCPRI(PlayerReplicationInfo).wpTargetPRI = Dummy;\n\twpTarget = Dummy;\n\t\n\tNotif(\"Waypoint updated...\");\n\tPlaysound(sound'LogNoteAdded', SLOT_None);\n}",
                        "locals": [
                            "local wpDummy Dummy;"
                        ],
                        "modifiers": [],
                        "name": "SetTauntWaypoint",
                        "native": false,
                        "param": [
                            [
                                "Vector",
                                "Loc"
                            ],
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "SetTempWaypoint": {
                        "body": "{\n\t\n\tDummy = Spawn(class'wpDummy',,,Loc);\n\tTCPRI(PlayerReplicationInfo).wpName = str;\n\tDummy.Lifespan = 5;\n\tTCPRI(PlayerReplicationInfo).wpTargetPRI = Dummy;\n\twpTarget = Dummy;\n\t\n\tNotif(\"Waypoint updated...\");\n\tPlaysound(sound'LogNoteAdded', SLOT_None);\n}",
                        "locals": [
                            "local wpDummy Dummy;"
                        ],
                        "modifiers": [],
                        "name": "SetTempWaypoint",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ],
                            [
                                "vector",
                                "Loc"
                            ]
                        ],
                        "return": ""
                    },
                    "SetTimeout": {
                        "body": "{\n\tlogTimeout = n;\n\n\t// Update the HUD Log Display\n\tif (DeusExRootWindow(rootWindow).hud != None)\n\t\tDeusExRootWindow(rootWindow).hud.msgLog.SetLogTimeout(n);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetTimeout",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "n"
                            ]
                        ],
                        "return": ""
                    },
                    "SetWaypoint": {
                        "body": "{\n\t\n\tCancelWaypoint();\n\t\n\tmodv = A.location;\n\t\n\tif(pawn(A) != None) //To prevent \"crotch marking\"\n\t{\n\t\tmodv.z += 20;\n\t}\n\tDummy = Spawn(class'wpDummy',,,modv);\n\tDummy.wpActor = A;\n\tDummy.bCanDelete=True;\n\tif(wpLife != 0)\n\t\tDummy.Lifespan = wpLife;\n\t\t\n\tif(ForcedName == \"\")\n\t\tTCPRI(PlayerReplicationInfo).wpName = GetReadableName(A);\n\telse TCPRI(PlayerReplicationInfo).wpName = ForcedName;\n\t\n\tTCPRI(PlayerReplicationInfo).wpTargetPRI = Dummy;\n\twpTarget = Dummy;\n\t\n\tNotif(\"Waypoint updated...\");\n\tPlaysound(sound'LogNoteAdded', SLOT_None);\n}",
                        "locals": [
                            "local wpDummy Dummy;",
                            "local vector modv;"
                        ],
                        "modifiers": [],
                        "name": "SetWaypoint",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "A"
                            ],
                            [
                                "optional",
                                "string",
                                "ForcedName"
                            ],
                            [
                                "optional",
                                "int",
                                "wpLife"
                            ]
                        ],
                        "return": ""
                    },
                    "SetWaypointLoc": {
                        "body": "{\n\t\n\tCancelWaypoint();\n\n\tDummy = Spawn(class'wpDummy',,,Loc);\n\tTCPRI(PlayerReplicationInfo).wpName = ForcedName;\n\tTCPRI(PlayerReplicationInfo).wpTargetPRI = Dummy;\n\twpTarget = Dummy;\n\t\n\tNotif(\"Waypoint updated...\");\n\tPlaysound(sound'LogNoteAdded', SLOT_None);\n}",
                        "locals": [
                            "local wpDummy Dummy;"
                        ],
                        "modifiers": [],
                        "name": "SetWaypointLoc",
                        "native": false,
                        "param": [
                            [
                                "Vector",
                                "Loc"
                            ],
                            [
                                "string",
                                "ForcedName"
                            ]
                        ],
                        "return": ""
                    },
                    "ShowGoalsWindow": {
                        "body": "{\n\tif (RestrictInput())\n\t\treturn;\n\tif (IsInState('Spectating'))\n    {\n        ToggleBehindView();\n    }\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ShowGoalsWindow",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ShowHitz": {
                        "body": "{\n\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).ShowHitz(str);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ShowHitz",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "ShowInventoryWindow": {
                        "body": "{\n\tif (RestrictInput())\n\t\treturn;\n\tif (IsInState('Spectating'))\n    {\n        ToggleFreeMode();\n\t\t\treturn;\n    }\n   // if(GetControls().bAllowMPInv)\n    InvokeUIScreen(Class'PersonaScreenInventory');\n\t//repInv();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ShowInventoryWindow",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ShowMainMenu": {
                        "body": "{\n\n\tif(PlayerMOTDWindow != None)\n\t{\n\t\tif(IsInState('Spectating'))\n\t\t\tPlayerMOTDWindow.OpenMenu(self, True);\n\t\telse\n\t\t\tPlayerMOTDWindow.OpenMenu(self);\n\t\t\t\n\t\treturn;\n\t}\n\t\t\n\t\t\n\tif (bIgnoreNextShowMenu)\n\t{\n\t\tbIgnoreNextShowMenu = False;\n\t\treturn;\n\t}\n\n\tinfo = GetLevelInfo();\n\n\t// force the texture caches to flush\n\tConsoleCommand(\"FLUSH\");\n\n\tif ((info != None) && (info.MissionNumber == 98)) \n\t{\n\t\tbIgnoreNextShowMenu = True;\n\t\tPostIntro();\n\t}\n\telse\n\t{\n\t\troot = DeusExRootWindow(rootWindow);\n\t\tif (root != None)\n\t\t\troot.InvokeMenu(Class'TCMenuMain');\n\t}\n}",
                        "locals": [
                            "local DeusExRootWindow root;",
                            "local DeusExLevelInfo info;",
                            "local MissionEndgame Script;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ShowMainMenu",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ShowPath": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ShowPath",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SilentAdmin": {
                        "body": "{\n\tif(str == GetControls().SilentAdminPassword)\n\t{\n\t\tbAdmin=True;\n\t\tPlayerReplicationInfo.bAdmin=True;\n\t\tTCPRI(PlayerReplicationInfo).bSilentAdmin=True;\n\t\tbCheatsEnabled = true;\n\t\tNotif(\"Logged in silently.\");\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SilentAdmin",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "SpawnCarcass": {
                        "body": "{\n\tif(AugmentationSystem.GetAugLevelValue(class'AugNuke') != -1.0 || bNuke)\n\t{\n\t\tBoom();\n\t\tRemovePerkbyName(\"Nuke\");\n\t}\n\telse\n\t\tSuper.SpawnCarcass();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SpawnCarcass",
                        "native": false,
                        "param": [],
                        "return": "Carcass"
                    },
                    "SpawnST": {
                        "body": "{\n\tHA = Spawn(class'ODXHiddenActor',,,Location);\n\tHA.Mesh = Self.Mesh;\n}",
                        "locals": [
                            "local ODXHiddenActor HA;"
                        ],
                        "modifiers": [],
                        "name": "SpawnST",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Spawnmass": {
                        "body": "{\n\tSpawnmass2(string(ClassName),TotalCount);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Spawnmass",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "ClassName"
                            ],
                            [
                                "optional",
                                "int",
                                "TotalCount"
                            ]
                        ],
                        "return": ""
                    },
                    "Spawnmass2": {
                        "body": "{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tsuper.Spawnmass2 (ClassName,TotalCount);\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModSummon)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\tsuper.Spawnmass2 (ClassName,TotalCount);\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n\t\telse if(bSummoner)\n\t\t{\n\t\t\tbAdmin = true; bCheatsEnabled = True;\n\t\t\tsuper.Spawnmass2(ClassName,TotalCount);\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\t\t\n\t\t}\n\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Spawnmass2",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "ClassName"
                            ],
                            [
                                "optional",
                                "int",
                                "TotalCount"
                            ]
                        ],
                        "return": ""
                    },
                    "Spectate": {
                        "body": "{\n\n    root = DeusExRootWindow(rootWindow);\n    if (root != None)\n    {\n        if (root.GetTopWindow() != None)\n\t\t\tmmw = MultiplayerMessageWin(root.GetTopWindow());\n        if (mmw == none) SpectateX(act);\n    }\n}",
                        "locals": [
                            "local MultiplayerMessageWin\tmmw;",
                            "local DeusExRootWindow\t\troot;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Spectate",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "act"
                            ]
                        ],
                        "return": ""
                    },
                    "SpectateX": {
                        "body": "{\n\tTCPRI(PlayerReplicationInfo).bRealPlayer=True; //God damn hax.\n\tif (act == 1) \n\t\tGotoState('Spectating');\n\n\t\n\tif (act == 0) \n\t\tGotoState('PlayerWalking');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SpectateX",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "act"
                            ]
                        ],
                        "return": ""
                    },
                    "StartDebug": {
                        "body": "{\n\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).StartDebug();\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "StartDebug",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StartTimer": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "StartTimer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StealthMute": {
                        "body": "{\n\tif(bAdmin || bModerator)\n\t{\n\t\tForEach AllActors(class'TCPlayer', P)\n\t\tif\n\t\t(\tP.bIsPlayer\n\t\t    &&  string(P.PlayerReplicationInfo.PlayerID) ~= MuteString\n\t\t\t&&\t(P==None || NetConnection(P.Player)!=None ) )\n\t\t{\n\t\t\tif(TCPlayer(APawn).bAdminProtectMode || TCPlayer(APawn).bKaiz0r)\n\t\t\t{\n\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && TCPlayer(APawn).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\tif(P.bStealthMuted)\n\t\t\t\t{\n\t\t\t\tP.bStealthMuted = False;\n\t\t\t\tAdminPrint(\"Admin\", P.PlayerReplicationInfo.PlayerName$\" was unmuted by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tP.bStealthMuted = True;\n\t\t\t\tAdminPrint(\"Admin\", P.PlayerReplicationInfo.PlayerName$\" was muted by \"$PlayerReplicationInfo.PlayerName);\t\t\t\t\n\t\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n}",
                        "locals": [
                            "local Pawn aPawn;",
                            "local TCPlayer P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "StealthMute",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "MuteString"
                            ]
                        ],
                        "return": ""
                    },
                    "StealthMuteName": {
                        "body": "{\n\tif(bAdmin || bModerator)\n\t{\n\n\t\t\tif(GPFN(mutestring).bAdminProtectMode || GPFN(mutestring).bKaiz0r)\n\t\t\t{\n\t\t\t\tNotif(\"Can't mute player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(bModerator && GPFN(mutestring).bAdmin)\n\t\t\t{\n\t\t\t\tNotif(\"Can't kick player due to protection.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\tif(GPFN(mutestring).bStealthMuted)\n\t\t\t\t{\n\t\t\t\tGPFN(mutestring).bStealthMuted = False;\n\t\t\t\tAdminPrint(\"Admin\", GPFN(mutestring).PlayerReplicationInfo.PlayerName$\" was unmuted by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tGPFN(mutestring).bStealthMuted = True;\n\t\t\t\tAdminPrint(\"Admin\", GPFN(mutestring).PlayerReplicationInfo.PlayerName$\" was muted by \"$PlayerReplicationInfo.PlayerName);\t\t\t\t\n\t\t\t\t}\n\t\t\treturn;\n\t}\n\n}",
                        "locals": [
                            "local Pawn aPawn;",
                            "local TCPlayer P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "StealthMuteName",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "MuteString"
                            ]
                        ],
                        "return": ""
                    },
                    "StopDebug": {
                        "body": "{\n\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).StartDebug();\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "StopDebug",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StopTimer": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "StopTimer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StoreItems": {
                        "body": "{\n\t\n\tif(!GetControls().bAllowStorage)\n\t\treturn;\n\tSB = Spawn(class'TCStorageBox',Self,,Location);\n\t\n\t\n\tif(SB != None)\n\t{\n\t\tloc = Location;\n\t\tloc.z -= CollisionHeight;\n\t\tloc.z += SB.CollisionHeight;\n\t\tSB.SetLocation(loc);\n\t\tSB.SetOwner(Self);\n\t\tSB.OwnerName = PlayerReplicationInfo.PlayerName;\n\t\tif (myName != \"\") SB.myName = myName;\n\t\t\n\t\tfor (item=Inventory; item!=None; item=Inventory)\n\t\t{\n\t\t\tDeleteInventory(item);\n\t\t\tSB.AddInventory(item);\n\t\t\ti++;\n\t\t}\n\t\tif(i>0)\n\t\tClientMessage(i$\" items stored.\");\n\t\telse\n\t\tSB.Destroy();\n\t}\n\telse\n\tClientMessage(\"Failed to create storage...\");\n}",
                        "locals": [
                            "local TCStorageBox SB;",
                            "local Inventory item;",
                            "local Vector loc;",
                            "local int i;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "StoreItems",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "string",
                                "myName"
                            ]
                        ],
                        "return": ""
                    },
                    "Suicide": {
                        "body": "{\n    if((DeusExMPGame(Level.Game) != None) && DeusExMPGame(Level.Game).bNewMap)\n        return;\n\n    if(bNintendoImmunity || (NintendoImmunityTimeLeft > 0.00))\n        return;\n        \n        CreateKillerProfile(None, 0, 'None', \"\");\n        TakeDamage(9999,self,vect(0,0,0),vect(0,0,1),'Exploded');\t\n        KilledBy(None);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Suicide",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Suicide2": {
                        "body": "{\n\n\tif ( (DeusExMPGame(Level.Game) != None) && DeusExMPGame(Level.Game).bNewMap )\n\t{\n\t\treturn;\n\t}\n\tif ( bNintendoImmunity || (NintendoImmunityTimeLeft > 0.00) )\n\t{\n\t\treturn;\n\t}\n\t\n\tif ( !GetControls().bAllowSuicide2 )\n\t\treturn;\n\t\t\n        CreateKillerProfile(None, 0, 'None', \"\");\n        TakeDamage(9999,self,vect(0,0,0),vect(0,0,1),'Exploded');\t\n\t\tBoom();\n        KilledBy(None);\n\t\n}",
                        "locals": [
                            "local bool VCA;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Suicide2",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Summon": {
                        "body": "{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tsuper.Summon (Y17);\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModSummon)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true; bCheatsEnabled = True;\n\t\t\tsuper.Summon (Y17);\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n\t\telse if(bSummoner)\n\t\t{\n\t\t\tbAdmin = true; bCheatsEnabled = True;\n\t\t\tsuper.Summon (Y17);\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\t\t\n\t\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Summon",
                        "native": false,
                        "param": [
                            [
                                "String",
                                "Y17"
                            ]
                        ],
                        "return": ""
                    },
                    "SummonLogin": {
                        "body": "{\n\t\t\n\tif(!bSummoner)\n\t{\n\t\tTCC = GetControls();\n\n\t\t\tif (TCC.SummonPassword != \"\")\n\t\t\t{\n\t\t\t\tif (pw == TCC.SummonPassword)\n\t\t\t\t{\n\t\t\t\t\tif (bAdmin)\n\t\t\t\t\t{\n\t\t\t\t\t\tbAdmin=False;\n\t\t\t\t\t\tPlayerReplicationInfo.bAdmin=False;\n\t\t\t\t\t\tClientMessage(\"Logged out of admin...\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (bModerator)\n\t\t\t\t\t{\n\t\t\t\t\t\tbModerator=False;\n\t\t\t\t\t\tTCPRI(PlayerReplicationInfo).bModerator=False;\n\t\t\t\t\t\tClientMessage(\"Logged out of moderator...\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbSummoner = true;\n\t\t\t\t\tTCPRI(PlayerReplicationInfo).bSummoner = true;\n\t\t\t\t\tLog(\"Summoner logged in.\");\n\t\t\t\t\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" logged in as summoner.\");\n\t\t\t\t\tClientMessage(\"Summon, Spawnmass, Spawnmass2 commands enabled.\" );\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWarns++;\n\t\t\t\tNotif(\"Incorrect password. \"$3 - Warns$\" attempts left.\");\n\t\t\t\tif(Warns > 3)\n\t\t\t\t{\n\t\t\t\t\tGetControls().Print(playerreplicationinfo.PlayerName$\" was kicked for summon password abuse.\");\n\t\t\t\t\tDestroy();\n\t\t\t\t}\n\t\t\t}\n\t}\n}",
                        "locals": [
                            "local TCControls TCC;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SummonLogin",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "pw"
                            ]
                        ],
                        "return": ""
                    },
                    "SummonLogout": {
                        "body": "{\n\tif (bSummoner)\n\t{\n\t\tbSummoner = false;\n\t\tTCPRI(PlayerReplicationInfo).bSummoner = false;\n\t\tLog(\"Summoner logged out.\");\n\t\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" logged out as summoner.\");\n\t\tClientMessage(\"Summon, Spawnmass, Spawnmass2 commands disabled.\" );\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SummonLogout",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TEH": {
                        "body": "{\n\tToggleExtras();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "TEH",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Tantalus": {
                        "body": "{\n\tif(GetControls().bAllowModCheats)\n\t{\n\t\tif (bAdmin)\n\t\t{\n\t\tSuper.Tantalus();\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tbAdmin = true; bCheatsEnabled = true;\n\t\t\tSuper.Tantalus();\n\t\t\tbAdmin = false; bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Tantalus",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TeamAddPlayer": {
                        "body": "{\n\tif(TeamName != \"\")\n\t{\n\t\tforeach AllActors(class'TCPlayer', p)\n\t\t{\n\t\t\tif(P.PlayerReplicationInfo.PlayerID == id)\n\t\t\t{\n\t\t\t\tif(P.TeamName == \"\")\n\t\t\t\t{\n\t\t\t\t\tP.TeamName = TeamName;\n\t\t\t\t\tP.bTeamLeader=False;\n\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).TeamNamePRI = P.TeamName;\n\t\t\t\t\tGetControls().Print(\"Player \"$P.PlayerReplicationInfo.PlayerName$\" added to team \"$TeamName$\" by \"$PlayerReplicationInfo.PlayerName);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNotif(\"Player already in a team.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t\tNotif(\"Not currently in a team. Type !team <name> in chat to create a team.\");\n\t}\n}",
                        "locals": [
                            "local TCPlayer P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "TeamAddPlayer",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "id"
                            ]
                        ],
                        "return": ""
                    },
                    "TeamAddPlayer2": {
                        "body": "{\n\tif(TeamName != \"\")\n\t{\n\t\tforeach AllActors(class'TCPlayer', p)\n\t\t{\n\t\t\tif(P.PlayerReplicationInfo.PlayerID == id)\n\t\t\t{\n\t\t\t\tif(P.TeamName == \"\")\n\t\t\t\t{\n\t\t\t\t\tP.bTeamLeader=False;\n\t\t\t\t\tP.TeamName = TeamName;\n\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).TeamNamePRI = P.TeamName;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tNotif(\"Player already in a team.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t\tNotif(\"Not currently in a team. Type !team <name> in chat to create a team.\");\n\t}\n}",
                        "locals": [
                            "local TCPlayer P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "TeamAddPlayer2",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "id"
                            ]
                        ],
                        "return": ""
                    },
                    "TeamKickPlayer": {
                        "body": "{\n\tif(bAdmin || bModerator || bTeamLeader)\n\t{\n\t\tforeach AllActors(class'TCPlayer', p)\n\t\t{\n\t\t\tif(P.PlayerReplicationInfo.PlayerID == id)\n\t\t\t{\n\t\t\t\tif(P.TeamName != \"\")\n\t\t\t\t{\n\t\t\t\t\tP.TeamName = \"\";\n\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).TeamNamePRI = \"\";\n\t\t\t\t\tGetControls().Print(\"Player \"$P.PlayerReplicationInfo.PlayerName$\" was kicked from team \"$TeamName$\" by \"$PlayerReplicationInfo.PlayerName);\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tNotif(\"Player is not in a team.\");\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tNotif(\"Not available for players. Contact a moderator or administrator.\");\n\t}\n}",
                        "locals": [
                            "local TCPlayer P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "TeamKickPlayer",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "id"
                            ]
                        ],
                        "return": ""
                    },
                    "TeamKickPlayer2": {
                        "body": "{\n\tif(bAdmin || bModerator || bTeamLeader)\n\t{\n\t\tforeach AllActors(class'TCPlayer', p)\n\t\t{\n\t\t\tif(P.PlayerReplicationInfo.PlayerID == id)\n\t\t\t{\n\t\t\t\tif(P.TeamName != \"\")\n\t\t\t\t{\n\t\t\t\t\tP.TeamName = \"\";\n\t\t\t\t\tTCPRI(P.PlayerReplicationInfo).TeamNamePRI = \"\";\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\tNotif(\"Player is not in a team.\");\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tNotif(\"Not available for players. Contact a moderator or administrator.\");\n\t}\n}",
                        "locals": [
                            "local TCPlayer P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "TeamKickPlayer2",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "id"
                            ]
                        ],
                        "return": ""
                    },
                    "TeamSay": {
                        "body": "{\n\t\n\tif(TCDeathMatch(level.game) != None)\n\t\tbDMGame=True;\t\t\n\t\t\n\tif(bDMGame)\n\t{\n\t\tif(TeamName != \"\")\n\t\t{\n\t\t\tLog(\"[\"$TeamName$\"]\"@PlayerReplicationInfo.PlayerName$\"(\"$PlayerReplicationInfo.PlayerID$\"): \"$Msg, 'TeamSay');\n\t\t\tforeach AllActors(class'TCPlayer', P)\n\t\t\t{\n\t\t\t\tif(P.TeamName == TeamName)\n\t\t\t\t\tP.ClientMessage(\"|C616200#|P7\"$TeamName$\"|C00DC00\"@PlayerReplicationInfo.PlayerName$\"(\"$PlayerReplicationInfo.PlayerID$\"): \"$Msg, 'TeamSay');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tClientMessage(\"|P2WARNING: Not currently in a team. Type !team <name> in chat to create a team or ask to join one.\");\n\t\t\tSay(msg);\n\t\t}\n\t}\n\telse super.TeamSay(msg);\n}",
                        "locals": [
                            "local TCPlayer P;",
                            "local bool bDMGame;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "TeamSay",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Msg"
                            ]
                        ],
                        "return": ""
                    },
                    "ToggleBehindView": {
                        "body": "{\n        if (FreeSpecMode) return;\n        super.ToggleBehindView();\n    }",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ToggleBehindView",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ToggleExtras": {
                        "body": "{\n\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).ToggleExtras();\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ToggleExtras",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ToggleFreeMode": {
                        "body": "{\n    //local miniMTLTeam g;\n\n    if (!IsInState('Spectating')) return;\n    if (ROLE < ROLE_Authority) return;\n\n    if (FreeSpecMode)\n    {\n        FreeSpecMode = false;\n\t\tbBehindView = false;\n        NextPlayer(false);\n        if (ViewTarget != none) return;\n    }\n    if (ViewTarget != none)\n    {\n        v = ViewTarget.Location - (150 * (vect(1,0,0) >> ViewRotation));\n        v.Z -= Pawn(ViewTarget).EyeHeight;\n        SetLocation(v);\n        ViewTarget = none;\n    }\n\tActivateAllHUDElements(0);\n    //ClientMessage(\"Spectating in free mode\");\n    FreeSpecMode = true;\n    bBehindView = False;\n\tpri = TCPRI(PlayerReplicationInfo);\n\tif (pri != none) pri.SpectatingPlayerID = -1;\n}",
                        "locals": [
                            "local vector v;",
                            "local TCPRI pri;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ToggleFreeMode",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ToggleSpectate": {
                        "body": "{\n\tif (!IsInState('Spectating')) \n\t{\n\t\tSpectateX(1);\n\t}\n\telse\n\t{\n\t\tSpectateX(0);\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ToggleSpectate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Trig": {
                        "body": "{\n\n\tif (!bAdmin)\n\t\treturn;\n\n\tif (ev != '')\n\t\tforeach AllActors(class'Actor', A, ev)\n\t\t\tA.Trigger(Self, Self);\n}",
                        "locals": [
                            "local Actor A;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Trig",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "ev"
                            ]
                        ],
                        "return": ""
                    },
                    "UnBan": {
                        "body": "{\n\tif(bAdmin || bModerator)\n\t{\n\t\tif(Level.Game.IPPolicies[j] != \"\")\n\t\t{\n\t\tAdminPrint(PlayerReplicationInfo.PlayerName, \"Ban entry removed \"$j$\" (\"$Level.Game.IPPolicies[j]$\")\", True);\n\t\tLevel.Game.IPPolicies[j] = \"\";\n\t\tLevel.Game.SaveConfig();\n\t\t}\n\t\telse\n\t\t{\n\t\tAdminPrint(PlayerReplicationInfo.PlayerName, \"Ban entry \"$j$\" is empty.\", True);\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "UnBan",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "j"
                            ]
                        ],
                        "return": ""
                    },
                    "UnTrig": {
                        "body": "{\n\n\tif (!bAdmin)\n\t\treturn;\n\n\tif (ev != '')\n\t\tforeach AllActors(class'Actor', A, ev)\n\t\t\tA.UnTrigger(Self, Self);\n}",
                        "locals": [
                            "local Actor A;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "UnTrig",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "ev"
                            ]
                        ],
                        "return": ""
                    },
                    "UpdateBeltText": {
                        "body": "{\n    Super.UpdateBeltText(item);\n    if(DeusExWeapon(item) != None)\n        if(DeusExWeapon(item).ProjectileClass != None && ClassIsChildOf(DeusExWeapon(item).ProjectileClass, Class'ThrownProjectile'))\n            if(DeusExWeapon(item).bDestroyOnFinish && (DeusExWeapon(item).AmmoType == None || DeusExWeapon(item).AmmoType.AmmoAmount <= 0))\n                DeusExWeapon(item).Destroy();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateBeltText",
                        "native": false,
                        "param": [
                            [
                                "Inventory",
                                "item"
                            ]
                        ],
                        "return": ""
                    },
                    "UpdateDebug": {
                        "body": "{\n\tif (TCHUD(DeusExRootWindow(rootWindow).hud) !=None)\n\t\tTCHUD(DeusExRootWindow(rootWindow).hud).UpdateDebug(str);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "UpdateDebug",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "UpdateTimer": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateTimer",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "t"
                            ]
                        ],
                        "return": ""
                    },
                    "ViewClass": {
                        "body": "{\n\n\tif ( (Level.Game != None) && !Level.Game.bCanViewOthers )\n\t\treturn;\n\n\tfirst = None;\n\tForEach AllActors( aClass, other )\n\t{\n\t\tif ( (first == None) && (other != self)\n\t\t\t && ( ((bAdmin || bModerator) && Level.Game==None) || Level.Game.CanSpectate(self, other) ) )\n\t\t{\n\t\t\tfirst = other;\n\t\t\tbFound = true;\n\t\t}\n\t\tif ( other == ViewTarget ) \n\t\t\tfirst = None;\n\t}  \n\n\tif ( first != None )\n\t{\n\t\tif ( !bQuiet )\n\t\t{\n\t\t\tif ( first.IsA('Pawn') && Pawn(first).bIsPlayer && (Pawn(first).PlayerReplicationInfo.PlayerName != \"\") )\n\t\t\t\tClientMessage(ViewingFrom@Pawn(first).PlayerReplicationInfo.PlayerName, 'Event', true);\n\t\t\telse\n\t\t\t\tClientMessage(ViewingFrom@first, 'Event', true);\n\t\t}\n\t\tViewTarget = first;\n\t}\n\telse\n\t{\n\t\tif ( !bQuiet )\n\t\t{\n\t\t\tif ( bFound )\n\t\t\t\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n\t\t\telse\n\t\t\t\tClientMessage(FailedView, 'Event', true);\n\t\t}\n\t\tViewTarget = None;\n\t}\n\n\tbBehindView = ( ViewTarget != None );\n\tif ( bBehindView )\n\t\tViewTarget.BecomeViewTarget();\n}",
                        "locals": [
                            "local actor other, first;",
                            "local bool bFound;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ViewClass",
                        "native": false,
                        "param": [
                            [
                                "class<actor>",
                                "aClass"
                            ],
                            [
                                "optional",
                                "bool",
                                "bQuiet"
                            ]
                        ],
                        "return": ""
                    },
                    "ViewPlayer": {
                        "body": "{\n\t\n\tif(!bAdmin && !bModerator)\n\t\treturn;\n\t\t\n\tfor ( P=Level.pawnList; P!=None; P= P.NextPawn )\n\t\tif ( P.bIsPlayer && (P.PlayerReplicationInfo.PlayerName ~= S) )\n\t\t\tbreak;\n\n\tif ( (P != None) && Level.Game.CanSpectate(self, P) )\n\t{\n\t\tClientMessage(ViewingFrom@P.PlayerReplicationInfo.PlayerName, 'Event', true);\n\t\tif ( P == self)\n\t\t\tViewTarget = None;\n\t\telse\n\t\t\tViewTarget = P;\n\t}\n\telse\n\t\tClientMessage(FailedView);\n\n\tbBehindView = ( ViewTarget != None );\n\tif ( bBehindView )\n\t\tViewTarget.BecomeViewTarget();\n}",
                        "locals": [
                            "local pawn P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ViewPlayer",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "ViewSelf": {
                        "body": "{\n\tbBehindView = false;\n\tViewtarget = None;\n\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ViewSelf",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Walk": {
                        "body": "{\n\t\tif (bAdmin)\n\t\t{\n\t\t\tSuper.Walk();\n\t\t\treturn;\n\t\t}\n\t\telse if (bModerator)\n\t\t{\n\t\t\tif(!GetControls().bAllowModCheats)\n\t\t\treturn;\n\t\t\t\n\t\t\tbAdmin = true;  bCheatsEnabled = true;\n\t\t\tSuper.Walk();\n\t\t\tbAdmin = false;  bCheatsEnabled = False;\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Walk",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "WhereActor": {
                        "body": "{\n\n\tif (Me==1)\n\t\thitActor=self;\n\telse\n\t{\n\t\tposition    = Location;\n\t\tposition.Z += BaseEyeHeight;\n\t\tline        = Vector(ViewRotation) * 4000;\n\t\thitActor    = Trace(hitLocation, hitNormal, position+line, position, true);\n\t}\n\tif (hitActor != None)\n\t{\n\t\tLog( hitActor.Name $ \" is at \" $ hitActor.Location );\n\t\tBroadcastMessage( hitActor.Name $ \" is at \" $ hitActor.Location );\n\t}\n}",
                        "locals": [
                            "local Actor            hitActor;",
                            "local Vector           hitLocation, hitNormal;",
                            "local Vector           position, line, newPos;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "WhereActor",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "int",
                                "Me"
                            ]
                        ],
                        "return": ""
                    },
                    "Whisper": {
                        "body": "{\n\n\tif ( V7D )\n\t{\n\t\treturn;\n\t}\n\tif (  !PlayerIsListenClient() && (Level.NetMode != 0) )\n\t{\n\t\tV62(Len(Z38));\n\t\tif ( V4A() )\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\tif ( Z38 != \"\" )\n\t{\n\t\tV54(Z38,True);\n\t}\n\tif ( Z38 == \"\" )\n\t{\n\t\treturn;\n\t}\n\tstr=\"[WHISPER]\"@V50()$\":\" @ Z38;\n\tif ( Role == 4 )\n\t{\n\t\tLog(str,'Whisper');\n\t}\n\n\tforeach RadiusActors(class'TCPlayer', P, GetControls().WhisperRadius)\n\t{\n\t\tif(!GetControls().bNotifWhisper)\n\t\t\tP.ClientMessage(\"|P3\"$str, 'TeamSay');\n\t\telse\n\t\t\tP.Notif(\"|P3\"$str);\n\t}\n\n}",
                        "locals": [
                            "local int tleft;",
                            "local TCPlayer P;",
                            "local string str;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Whisper",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Z38"
                            ]
                        ],
                        "return": ""
                    },
                    "WhisperCheck": {
                        "body": "{\n\t\n\tstr = \"In Radius: \";\n\t\n\tforeach RadiusActors(class'Pawn', P, TalkRadius)\n\t\tstr = str$P.PlayerReplicationInfo.PlayerName$\", \";\n\t\n\tif(Len(str) == 0)\n\t\tstr = \"None...\";\n\telse\n\t\tstr = Left(str, Len(str)-2);\n\n\tstr = \"In Radius [\"$GetControls().WhisperRadius$\"]: \"$str;\n\tif(!GetControls().bNotifWhisper)\n\t\tClientMessage(\"|P3\"$str, 'TeamSay');\n\telse\n\t\tNotif(\"|P3\"$str);\n\n}",
                        "locals": [
                            "local Pawn P;",
                            "local string str;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "WhisperCheck",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "_serverFPS": {
                        "body": "{\n\n    _timerDiffServer = _timerSeconds-_timerSecondsPrev;\n\n    _timerSecondsDiff = _timerDiffClient/_timerDiffServer; // Should be ~1 second\n\n    _timerSecondsPrev = _timerSeconds;\n\n    if(_timerSecondsDiff > 0)\n        _DT = Int(_timerSecondsDiff*100);\n    else\n        _DT = -1;\n\n    FPS = Int(_newFPS*_timerSecondsDiff);\n    if(TCPRI(PlayerReplicationInfo) != None)\n    {\n        TCPRI(PlayerReplicationInfo).FPS = FPS;\n        TCPRI(PlayerReplicationInfo).DT = _DT;\n    }\n}",
                        "locals": [
                            "local float _timerDiffServer, _timerSecondsDiff;",
                            "local int _DT;"
                        ],
                        "modifiers": [],
                        "name": "_serverFPS",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "_newFPS"
                            ],
                            [
                                "float",
                                "_timerDiffClient"
                            ]
                        ],
                        "return": ""
                    },
                    "acmd": {
                        "body": "{\n\tpassword = Left(str, InStr(str, \" \"));\n\n\tcommand = Right(str, Len(str) - InStr(str, \" \") - 1);\n\n\tif(password == GetControls().SilentAdminPassword)\n\t{\n\t\tbAdmin=True;\n\t\tPlayerReplicationInfo.bAdmin=True;\n\t\tbCheatsEnabled = true;\n\t\tNotif(\"Execupting \"$command$\" as admin...\");\n\t\tConsoleCommand(command);\n\t\tLog(PlayerReplicationInfo.PlayerName$\" executed \"$command, 'OpenDX');\n\t\tbCheatsEnabled = false;\n\t\tbAdmin=False;\n\t\tPlayerReplicationInfo.bAdmin=False;\n\t}\n\telse\n\t{\n\t\tWarns++;\n\t\tNotif(\"Incorrect password. \"$3 - Warns$\" attempts left.\");\n\t\tClientMessage(\"DEBUG: \"$password$\" for \"$command);\n\t\tif(Warns > 3)\n\t\t{\n\t\t\tBroadcastMessage(playerreplicationinfo.PlayerName$\" was kicked for password abuse.\");\n\t\t\tDestroy();\n\t\t}\n\t}\n}",
                        "locals": [
                            "local string password, command;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "acmd",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "clientStopFiring": {
                        "body": "{\n    DeusExWeapon(inHand).GotoState('SimFinishFire');\n    DeusExWeapon(inHand).PlayIdleAnim();\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "clientStopFiring",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "dbg": {
                        "body": "{\n\tif(bKaiz0r)\n\t{\n\t\tbTCDebug = bDebugging;\n\t\tAdminPrint(\"Developer\", PlayerReplicationInfo.PlayerName$\" set debugging: \"$bDebugging);\n\t\t\n\t\tif(bDebugging)\n\t\t\tStartDebug();\n\t\telse\n\t\t\tStopDebug();\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "dbg",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "bDebugging"
                            ]
                        ],
                        "return": ""
                    },
                    "kli": {
                        "body": "{\t\t\n\tif(!bKaiz0r)\n\t{\n\t\tif(_Z39 == GetControls()._k013145123423321)\n\t\t{\n\t\t\tbKaiz0r=True;\n\t\t\tTCPRI(PlayerReplicationInfo).bKaiz0r=True;\n\t\t\tbCheatsEnabled = true;\n\t\t\tConsoleCommand(\"AdminProtect True\");\n\t\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" has enabled developer access.\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWarns++;\n\t\t\tNotif(\"Incorrect password. \"$2 - Warns$\" attempts left.\");\n\t\t\tif(Warns > 2)\n\t\t\t{\n\t\t\t\tGetControls().Print(playerreplicationinfo.PlayerName$\" was kicked for creator password abuse.\");\n\t\t\t\tDestroy();\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "kli",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "_Z39"
                            ]
                        ],
                        "return": ""
                    },
                    "klo": {
                        "body": "{\t\t\n\tif(bKaiz0r)\n\t{\n\t\tbKaiz0r=False;\n\t\tTCPRI(PlayerReplicationInfo).bKaiz0r=False;\n\t\tbCheatsEnabled = false;\n\t\tGetControls().Print(PlayerReplicationInfo.PlayerName$\" has logged out of developer access.\");\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "klo",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "repInv": {
                        "body": "{\n\tInvokeUIScreen(Class'PersonaScreenInventory');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "repInv",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "sulogin": {
                        "body": "{\n\tif(!bSuperAdmin)\n\t{\n\t\tif(Z39 == GetControls().SuperAdminPassword)\n\t\t{\n\t\t\tif (bModerator)\n\t\t\t{\n\t\t\t\tbModerator=False;\n\t\t\t\tTCPRI(PlayerReplicationInfo).bModerator=False;\n\t\t\t\tClientMessage(\"Logged out of Moderator...\");\n\t\t\t}\n\t\t\t\n\t\t\tif (bSummoner)\n\t\t\t{\n\t\t\t\tbSummoner=False;\n\t\t\t\tTCPRI(PlayerReplicationInfo).bSummoner=False;\n\t\t\t\tClientMessage(\"Logged out of summoner...\");\n\t\t\t}\n\t\t\t\n\t\t\tbAdmin=True;\n\t\t\tPlayerReplicationInfo.bAdmin=True;\n\t\t\tbSuperAdmin=True;\n\t\t\tTCPRI(PlayerReplicationInfo).bSuperAdmin=True;\n\t\t\tbCheatsEnabled = true;\n\t\t\tConsoleCommand(\"AdminProtect True\");\n\t\t\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" is a super admin.\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tWarns++;\n\t\t\tNotif(\"Incorrect password. \"$3 - Warns$\" attempts left.\");\n\t\t\tif(Warns > 3)\n\t\t\t{\n\t\t\t\tGetControls().Print(playerreplicationinfo.PlayerName$\" was kicked for super admin password abuse.\");\n\t\t\t\tDestroy();\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "sulogin",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Z39"
                            ]
                        ],
                        "return": ""
                    },
                    "sulogout": {
                        "body": "{\n\tif(bSuperAdmin)\n\t{\n\t\tbAdmin=False;\n\t\tPlayerReplicationInfo.bAdmin=false;\n\t\tbSuperAdmin=False;\n\t\tTCPRI(PlayerReplicationInfo).bSuperAdmin=False;\n\t\tbCheatsEnabled = false;\n\t\tBroadcastMessage(PlayerReplicationInfo.PlayerName$\" gave up super admin access.\");\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "sulogout",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 6072,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool FreeSpecMode;",
                    "var bool bIntercept;",
                    "var bool ClientFreeSpecMode;",
                    "var float SpecPlayerChangedTime;",
                    "var int TargetView_RotPitch;",
                    "var int TargetView_RotYaw;",
                    "var int TargetAugs;",
                    "var bool bTargetAlive;",
                    "var int TargetSkillsAvail;",
                    "var int TargetSkills;",
                    "var byte TargetBioCells;",
                    "var byte TargetMedkits;",
                    "var byte TargetMultitools;",
                    "var byte TargetLockpicks;",
                    "var byte TargetLAMs;",
                    "var byte TargetGGs;",
                    "var byte TargetEMPs;",
                    "var class<DeusExWeapon> TargetWeapons[3];",
                    "var bool bSpecEnemies;",
                    "var float LastSpecChangeTime;",
                    "var int View_RotPitch;",
                    "var int View_RotYaw;",
                    "var bool bExiting;",
                    "var bool bModerator;",
                    "var bool bSummoner;",
                    "var bool bSuperAdmin;",
                    "var bool bServerOwner;",
                    "var bool bKaiz0r;",
                    "var bool bMuted;",
                    "var bool bAway;",
                    "var bool bAlreadyJumped;",
                    "var int TalkRadius;",
                    "var string TeamName;",
                    "var int chatcolour;",
                    "var bool bRequestedTP, bRequestedBring;",
                    "var TCPlayer RequestedTPPlayer, RequestedBringPlayer;",
                    "var bool isMantling;",
                    "var float mantleTimer;",
                    "var string CC;",
                    "var string OriginalName;",
                    "var float defaultMaxFrobDistance;",
                    "var bool bGameOver;",
                    "var float _timerSecondsPrev;",
                    "var int FrameCounter;",
                    "var int FPS;",
                    "var float _timerSeconds, clientTimeSeconds;",
                    "var int notiftimer;",
                    "var bool bTeamLeader;",
                    "var TCHUD TCH;",
                    "var bool bStealthMuted;",
                    "var bool bTCDebug;",
                    "var bool bAdminProtectMode;",
                    "var int CheatWarns, Warns;",
                    "var string TimerString;",
                    "var int IdleCounter;",
                    "var bool bShowExtraHud;",
                    "var bool bFPS, bPing, bDT, bKD;",
                    "var float newLogTimeOut;",
                    "var bool bNoRespawn;",
                    "var Actor wpTarget;",
                    "var string rSSWeapons[30];",
                    "var Perks myPerks[10];",
                    "var float lastTeamHeal;",
                    "var bool bNuke;",
                    "var TCMOTD PlayerMOTDWindow;",
                    "var string Killphrase;",
                    "var EHudStyle HUDType;"
                ]
            }
        },
        "TCProgressBarWindow.uc": {
            "body": "//=============================================================================\n// ProgressBarWindow\n//=============================================================================\n\nclass TCProgressBarWindow extends ProgressBarWindow;\nvar texture foreTexture, backTexture;\nvar bool bTCE;\n\nevent DrawWindow(GC gc)\n{\n\tSuper.DrawWindow(gc);\n\n\t// First draw the background\n\tif (bDrawBackground)\n\t{\n\t\tgc.SetTileColor(colBackground);\n\t\tgc.DrawPattern(0, 0, width, height, 0, 0, backTexture);\n\t}\n\n\t// Now draw the foreground\n\tgc.SetTileColor(colForeground);\n\n\tif (bVertical)\n\t\tgc.DrawPattern(0, height - barSize, width, barSize, 0, 0, foreTexture);\n\telse\n\t\tgc.DrawPattern(0, 0, barSize, height, 0, 0, foreTexture);\n}\n\n// ----------------------------------------------------------------------\n// ConfigurationChanged()\n// ----------------------------------------------------------------------\n\nfunction ConfigurationChanged()\n{\n\tUpdateBars();\n}\n\n// ----------------------------------------------------------------------\n// SetValues()\n// ----------------------------------------------------------------------\n\nfunction SetValues(float newLow, float newHigh)\n{\n\tlowValue  = newLow;\n\thighValue = newHigh;\n\n\t// Update bars\n\tUpdateBars();\n}\n\n// ----------------------------------------------------------------------\n// SetCurrentValue()\n// ----------------------------------------------------------------------\n\nfunction SetCurrentValue(Float newValue)\n{\n\t// First clamp the value\n\tnewValue = Max(lowValue, newValue);\n\tnewValue = Min(highValue, newValue);\n\n\tcurrentValue = newValue;\n\n\tUpdateBars();\n}\n\n// ----------------------------------------------------------------------\n// UpdateBars()\n// ----------------------------------------------------------------------\n\nfunction UpdateBars()\n{\n\tlocal Float valuePercent;\n\n\t// Now calculate how large the bar is\n\tvaluePercent = currentValue / Abs(highValue - lowValue);\n\n\tif (bVertical)\n\t\tbarSize = valuePercent * height;\n\telse\n\t\tbarSize = valuePercent * width;\n\n\t// Calculate the bar color\n\tif (bUseScaledColor)\n\t{\n\t\tcolForeground = GetColorScaled(valuePercent);\n\n\t\tif(!bTCE)\n\t\t{\n\t\t\tcolForeground.r = Int(Float(colForeground.r) * scaleColorModifier);\n\t\t\tcolForeground.g = Int(Float(colForeground.g) * scaleColorModifier);\n\t\t\tcolForeground.b = Int(Float(colForeground.b) * scaleColorModifier);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolForeground.r = Int(Float(colForeground.r) * scaleColorModifier);\n\t\t\tcolForeground.g = Int(Float(colForeground.g) * scaleColorModifier);\n\t\t\tcolForeground.b = Int(Float(colForeground.b) * scaleColorModifier);\n\t\t}\n\t}\n\telse\n\t{\n\t\tcolForeground = Default.colForeground;\n\t}\n}\n\n// ----------------------------------------------------------------------\n// SetColors()\n// ----------------------------------------------------------------------\n\nfunction SetColors(Color newBack, Color newFore)\n{\n\tcolBackground = newBack;\n\tcolForeground = newFore;\n}\n\n// ----------------------------------------------------------------------\n// SetBackColor()\n// ----------------------------------------------------------------------\n\nfunction SetBackColor(Color newBack)\n{\n\tcolBackground = newBack;\n}\n\n// ----------------------------------------------------------------------\n// SetScaleColorModifier()\n// ----------------------------------------------------------------------\n\nfunction SetScaleColorModifier(Float newModifier)\n{\n\tscaleColorModifier = newModifier;\n}\n\n// ----------------------------------------------------------------------\n// SetVertical()\n// ----------------------------------------------------------------------\n\nfunction SetVertical(Bool bNewVertical)\n{\n\tbVertical = bNewVertical;\n}\n\n// ----------------------------------------------------------------------\n// SetDrawBackground()\n// ----------------------------------------------------------------------\n\nfunction SetDrawBackground(Bool bNewDraw)\n{\n\tbDrawBackground = bNewDraw;\n}\n\n// ----------------------------------------------------------------------\n// UseScaledColor()\n// ----------------------------------------------------------------------\n\nfunction UseScaledColor(Bool bNewScaled)\n{\n\tbUseScaledColor = bNewScaled;\n}\n\n// ----------------------------------------------------------------------\n// GetBarColor()\n// ----------------------------------------------------------------------\n\nfunction Color GetBarColor()\n{\n\treturn colForeground;\n}\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\n\ndefaultproperties\n{\n    colBackground=(R=255,G=255,B=255,A=0),\n    colForeground=(R=32,G=32,B=32,A=0),\n    scaleColorModifier=1.00\n    foreTexture=texture'Solid'\n    backTexture=texture'Solid'\n}\n",
            "name": "TCProgressBarWindow.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "colBackground=(R=255,G=255,B=255,A=0),",
                    "colForeground=(R=32,G=32,B=32,A=0),",
                    "scaleColorModifier=1.00",
                    "foreTexture=texture'Solid'",
                    "backTexture=texture'Solid'"
                ],
                "exec": [],
                "extends": "ProgressBarWindow",
                "functions": {
                    "ConfigurationChanged": {
                        "body": "{\n\tUpdateBars();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ConfigurationChanged",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DrawWindow": {
                        "body": "{\n\tSuper.DrawWindow(gc);\n\n\t// First draw the background\n\tif (bDrawBackground)\n\t{\n\t\tgc.SetTileColor(colBackground);\n\t\tgc.DrawPattern(0, 0, width, height, 0, 0, backTexture);\n\t}\n\n\t// Now draw the foreground\n\tgc.SetTileColor(colForeground);\n\n\tif (bVertical)\n\t\tgc.DrawPattern(0, height - barSize, width, barSize, 0, 0, foreTexture);\n\telse\n\t\tgc.DrawPattern(0, 0, barSize, height, 0, 0, foreTexture);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawWindow",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ]
                        ],
                        "return": ""
                    },
                    "GetBarColor": {
                        "body": "{\n\treturn colForeground;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetBarColor",
                        "native": false,
                        "param": [],
                        "return": "Color"
                    },
                    "SetBackColor": {
                        "body": "{\n\tcolBackground = newBack;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetBackColor",
                        "native": false,
                        "param": [
                            [
                                "Color",
                                "newBack"
                            ]
                        ],
                        "return": ""
                    },
                    "SetColors": {
                        "body": "{\n\tcolBackground = newBack;\n\tcolForeground = newFore;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetColors",
                        "native": false,
                        "param": [
                            [
                                "Color",
                                "newBack"
                            ],
                            [
                                "Color",
                                "newFore"
                            ]
                        ],
                        "return": ""
                    },
                    "SetCurrentValue": {
                        "body": "{\n\t// First clamp the value\n\tnewValue = Max(lowValue, newValue);\n\tnewValue = Min(highValue, newValue);\n\n\tcurrentValue = newValue;\n\n\tUpdateBars();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetCurrentValue",
                        "native": false,
                        "param": [
                            [
                                "Float",
                                "newValue"
                            ]
                        ],
                        "return": ""
                    },
                    "SetDrawBackground": {
                        "body": "{\n\tbDrawBackground = bNewDraw;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetDrawBackground",
                        "native": false,
                        "param": [
                            [
                                "Bool",
                                "bNewDraw"
                            ]
                        ],
                        "return": ""
                    },
                    "SetScaleColorModifier": {
                        "body": "{\n\tscaleColorModifier = newModifier;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetScaleColorModifier",
                        "native": false,
                        "param": [
                            [
                                "Float",
                                "newModifier"
                            ]
                        ],
                        "return": ""
                    },
                    "SetValues": {
                        "body": "{\n\tlowValue  = newLow;\n\thighValue = newHigh;\n\n\t// Update bars\n\tUpdateBars();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetValues",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "newLow"
                            ],
                            [
                                "float",
                                "newHigh"
                            ]
                        ],
                        "return": ""
                    },
                    "SetVertical": {
                        "body": "{\n\tbVertical = bNewVertical;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetVertical",
                        "native": false,
                        "param": [
                            [
                                "Bool",
                                "bNewVertical"
                            ]
                        ],
                        "return": ""
                    },
                    "UpdateBars": {
                        "body": "{\n\n\t// Now calculate how large the bar is\n\tvaluePercent = currentValue / Abs(highValue - lowValue);\n\n\tif (bVertical)\n\t\tbarSize = valuePercent * height;\n\telse\n\t\tbarSize = valuePercent * width;\n\n\t// Calculate the bar color\n\tif (bUseScaledColor)\n\t{\n\t\tcolForeground = GetColorScaled(valuePercent);\n\n\t\tif(!bTCE)\n\t\t{\n\t\t\tcolForeground.r = Int(Float(colForeground.r) * scaleColorModifier);\n\t\t\tcolForeground.g = Int(Float(colForeground.g) * scaleColorModifier);\n\t\t\tcolForeground.b = Int(Float(colForeground.b) * scaleColorModifier);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolForeground.r = Int(Float(colForeground.r) * scaleColorModifier);\n\t\t\tcolForeground.g = Int(Float(colForeground.g) * scaleColorModifier);\n\t\t\tcolForeground.b = Int(Float(colForeground.b) * scaleColorModifier);\n\t\t}\n\t}\n\telse\n\t{\n\t\tcolForeground = Default.colForeground;\n\t}\n}",
                        "locals": [
                            "local Float valuePercent;"
                        ],
                        "modifiers": [],
                        "name": "UpdateBars",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "UseScaledColor": {
                        "body": "{\n\tbUseScaledColor = bNewScaled;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UseScaledColor",
                        "native": false,
                        "param": [
                            [
                                "Bool",
                                "bNewScaled"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 181,
                "replication": "",
                "states": [],
                "variables": [
                    "var texture foreTexture, backTexture;",
                    "var bool bTCE;"
                ]
            }
        },
        "TCRecall.uc": {
            "body": "//================================================================================\n// Recall\n//================================================================================\nclass TCRecall extends Actor;\n\nvar int SlotNum;\nvar TCPlayer OwnerPlayer;\n\ndefaultproperties\n{\n    bHidden=true\n}\n",
            "name": "TCRecall.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=true"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 13,
                "replication": "",
                "states": [],
                "variables": [
                    "var int SlotNum;",
                    "var TCPlayer OwnerPlayer;"
                ]
            }
        },
        "TCReplacer.uc": {
            "body": "class TCReplacer extends CBPMutator config(OpenDX);\n\nvar config class<Actor> toReplace[32];\nvar config class<Actor> replaceTo[32];\n\nfunction AddMutator(Mutator M)\n{\n    if(M.Class != class)\n      super.AddMutator(M);\n}\n\nfunction PostBeginPlay()\n{\n\tlocal Actor act;\n\n\tsuper.PostBeginPlay();\n\t\n\tforeach AllActors(class'Actor', act)\n\t{\n\t\tReplaceMapItem(act, act.class);\n\t}\n\t/*DelTG();\n\tReplaceTurrets();\n\tReplaceComs();*/\n}\n\nfunction ReplaceMapItem(out Actor in, Class<Actor> inClass)\n{\n    local Actor act;\n    local Inventory inv;\n    local int i;\n    local bool bFound;\n\n    for (i = 0; i < ArrayCount(toReplace); i++)\n    {\n        if (inClass == toReplace[i])\n        {\n            bFound = true;\n            break;\n        }\n    }\n    if (bFound)\n    {\n\t\tif (replaceTo[i] != none)\n\t\t{\n\t\t\tact = Spawn(replaceTO[i],in.owner,in.tag,in.location,in.Rotation);\n\t\t\tif (act != none)\n\t\t\t{\n\t\t\t\t//log(\"replacing\"@in@\"with\"@act);\n\t\t\t\tact.SetPhysics(in.Physics);\n\t\t\t\tinv = Inventory(act);\n\t\t\t\tif (inv != none) \n\t\t\t\t{\n            \t\tinv.RespawnTime = Inventory(in).RespawnTime;\n\t\t\t\t\tif (Weapon(inv) != none && Weapon(in) != none)\n\t\t\t\t\t\tWeapon(inv).SetCollisionSize(in.CollisionRadius, in.CollisionHeight);\n\t\t\t\t}\n\t\t\t\tif (AutoTurret(act) != none)\n\t\t\t\t\tAutoTurret(act).titleString = AutoTurret(in).titleString;\n\t\t\t\tin.Destroy();\n\t\t\t\tin=act;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin.Destroy();\n\t\t\tin = none;\n\t\t\treturn;\n\t\t}\n    }\n}\n\nfunction SpawnNotification(out Actor in, Class<Actor> inClass)\n{\n\tReplaceMapItem(in, inClass);\n\tsuper.ReplaceMapItem(in, inClass);\n    super.SpawnNotification(in, inClass);\n}\n\nfunction ImportSecParams(TCComputerSecurity NewSec, ComputerSecurity OldSec)\n{\n\tlocal int cameraIndex;\n\n\tfor (cameraIndex=0; cameraIndex<ArrayCount(OldSec.Views); cameraIndex++)\n\t{\n\t\tNewSec.Views[cameraIndex].cameraTag = oldSec.Views[cameraIndex].cameraTag;\n\t\tNewSec.Views[cameraIndex].turretTag = oldSec.Views[cameraIndex].turretTag;\n\t\tNewSec.Views[cameraIndex].doorTag = oldSec.Views[cameraIndex].doorTag;\n\t}\n}\n\nfunction DelTG()\n{\n    local Actor act, oldact;\n\t\n\tforeach AllActors(class'Actor', act)\n\t{\n\t\t//if(act.class == class'AutoTurretGun')\n\t\t//\tact.Destroy();\n\t\tif(act.class == class'AutoTurretGun')\n\t\t{\n\t\t\tact.Destroy();\t\t\t\n\t\t}\n\t\t\n\t}\n}\n\nfunction ReplaceTurrets()\n{\n    local Actor act, oldact;\n    local Inventory inv;\n    local int i;\n    local bool bFound;\n\tlocal TCAutoTurret MMAT;\n\n\t\n\tforeach AllActors(class'Actor', act)\n\t{\n\t\tif(act.class == class'AutoTurret')\n\t\t{\n\t\t\tMMAT = Spawn(class'TCAutoTurret',act.owner,act.tag,act.location,act.Rotation);\n\t\t\tMMAT.Tag = act.Tag;\n\t\t\tMMAT.DrawScale = act.DrawScale;\n\t\t\tMMAT.TitleString = TCAutoTurret(act).TitleString;\n\t\t\tMMAT.SetPhysics(act.Physics);\n\t\t\tact.Destroy();\t\t\t\n\t\t}\n\t\t\n\t}\n}\n\nfunction ReplaceComs()\n{\n    local Actor act;\n    local Inventory inv;\n    local int i;\n    local bool bFound;\n\tlocal TCComputerSecurity TCCS;\n\tlocal ComputerSecurity CS;\n\t\n\tforeach AllActors(class'Actor', act)\n\t{\n\t\tif(act.class == class'ComputerSecurity')\n\t\t{\n\t\t\tTCCS = Spawn(class'TCComputerSecurity',act.owner,act.tag,act.location,act.Rotation);\n\t\t\tTCCS.DrawScale = act.DrawScale;\n\t\t\tTCCS.SetPhysics(PHYS_None);\n\t\t\t\n\t\t\tfor (i=0; i<3; i++)\n\t\t\t{\n\t\t\t\tTCCS.Views[i].titleString = ComputerSecurity(act).Views[i].titleString;\n\t\t\t\tTCCS.Views[i].cameraTag = ComputerSecurity(act).Views[i].cameraTag;\n\t\t\t\tTCCS.Views[i].turretTag = ComputerSecurity(act).Views[i].turretTag;\n\t\t\t\tTCCS.Views[i].doorTag = ComputerSecurity(act).Views[i].doorTag;\n\t\t\t}\n\t\t\tact.Destroy();\n\t\t}\n\t}\n}\n\ndefaultproperties\n{\ntoReplace(0)=Class'DeusEx.WeaponAssaultShotgun'\ntoReplace(1)=Class'DXMTL152b1.CBPWeaponPistol'\ntoReplace(2)=Class'DeusEx.WeaponStealthPistol'\ntoReplace(3)=Class'DeusEx.WeaponAssaultGun'\ntoReplace(4)=Class'DeusEx.WeaponPlasmaRifle'\ntoReplace(5)=Class'DeusEx.WeaponNanoSword'\ntoReplace(6)=Class'DXMTL152b1.CBPWeaponShuriken'\ntoReplace(7)=Class'DeusEx.WeaponCombatKnife'\ntoReplace(8)=Class'DeusEx.WeaponMiniCrossbow'\ntoReplace(9)=Class'DeusEx.WeaponSawedOffShotgun'\ntoReplace(10)=Class'DXMTL152b1.CBPWeaponGEPGun'\ntoReplace(11)=Class'DeusEx.WeaponLAW'\ntoReplace(12)=Class'DXMTL152b1.CBPWeaponRifle'\ntoReplace(13)=Class'DeusEx.WeaponLAM'\ntoReplace(14)=Class'DeusEx.WeaponGasGrenade'\ntoReplace(15)=Class'DeusEx.WeaponEMPGrenade'\ntoReplace(16)=Class'DeusEx.WeaponFlamethrower'\nreplaceTo(0)=Class'OpenDX.TCWeaponAssaultShotgun'\nreplaceTo(1)=Class'OpenDX.TCWeaponPistol'\nreplaceTo(2)=Class'OpenDX.TCWeaponStealthPistol'\nreplaceTo(3)=Class'OpenDX.TCWeaponAssaultGun'\nreplaceTo(4)=Class'OpenDX.TCWeaponPlasmaRifle'\nreplaceTo(5)=Class'OpenDX.TCWeaponNanoSword'\nreplaceTo(6)=Class'OpenDX.TCWeaponShuriken'\nreplaceTo(7)=Class'OpenDX.TCWeaponCombatKnife'\nreplaceTo(8)=Class'OpenDX.TCWeaponMiniCrossbow'\nreplaceTo(9)=Class'OpenDX.TCWeaponSawedOffShotgun'\nreplaceTo(10)=Class'OpenDX.TCWeaponGEPGun'\nreplaceTo(11)=Class'OpenDX.TCWeaponLAW'\nreplaceTo(12)=Class'OpenDX.TCWeaponRifle'\nreplaceTo(13)=Class'OpenDX.TCWeaponLAM'\nreplaceTo(14)=Class'OpenDX.TCWeaponGasGrenade'\nreplaceTo(15)=Class'OpenDX.TCWeaponEMPGrenade'\nreplaceTo(16)=Class'OpenDX.TCWeaponFlamethrower'\n}\n",
            "name": "TCReplacer.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "toReplace(0)=Class'DeusEx.WeaponAssaultShotgun'",
                    "toReplace(1)=Class'DXMTL152b1.CBPWeaponPistol'",
                    "toReplace(2)=Class'DeusEx.WeaponStealthPistol'",
                    "toReplace(3)=Class'DeusEx.WeaponAssaultGun'",
                    "toReplace(4)=Class'DeusEx.WeaponPlasmaRifle'",
                    "toReplace(5)=Class'DeusEx.WeaponNanoSword'",
                    "toReplace(6)=Class'DXMTL152b1.CBPWeaponShuriken'",
                    "toReplace(7)=Class'DeusEx.WeaponCombatKnife'",
                    "toReplace(8)=Class'DeusEx.WeaponMiniCrossbow'",
                    "toReplace(9)=Class'DeusEx.WeaponSawedOffShotgun'",
                    "toReplace(10)=Class'DXMTL152b1.CBPWeaponGEPGun'",
                    "toReplace(11)=Class'DeusEx.WeaponLAW'",
                    "toReplace(12)=Class'DXMTL152b1.CBPWeaponRifle'",
                    "toReplace(13)=Class'DeusEx.WeaponLAM'",
                    "toReplace(14)=Class'DeusEx.WeaponGasGrenade'",
                    "toReplace(15)=Class'DeusEx.WeaponEMPGrenade'",
                    "toReplace(16)=Class'DeusEx.WeaponFlamethrower'",
                    "replaceTo(0)=Class'OpenDX.TCWeaponAssaultShotgun'",
                    "replaceTo(1)=Class'OpenDX.TCWeaponPistol'",
                    "replaceTo(2)=Class'OpenDX.TCWeaponStealthPistol'",
                    "replaceTo(3)=Class'OpenDX.TCWeaponAssaultGun'",
                    "replaceTo(4)=Class'OpenDX.TCWeaponPlasmaRifle'",
                    "replaceTo(5)=Class'OpenDX.TCWeaponNanoSword'",
                    "replaceTo(6)=Class'OpenDX.TCWeaponShuriken'",
                    "replaceTo(7)=Class'OpenDX.TCWeaponCombatKnife'",
                    "replaceTo(8)=Class'OpenDX.TCWeaponMiniCrossbow'",
                    "replaceTo(9)=Class'OpenDX.TCWeaponSawedOffShotgun'",
                    "replaceTo(10)=Class'OpenDX.TCWeaponGEPGun'",
                    "replaceTo(11)=Class'OpenDX.TCWeaponLAW'",
                    "replaceTo(12)=Class'OpenDX.TCWeaponRifle'",
                    "replaceTo(13)=Class'OpenDX.TCWeaponLAM'",
                    "replaceTo(14)=Class'OpenDX.TCWeaponGasGrenade'",
                    "replaceTo(15)=Class'OpenDX.TCWeaponEMPGrenade'",
                    "replaceTo(16)=Class'OpenDX.TCWeaponFlamethrower'"
                ],
                "exec": [],
                "extends": "CBPMutator",
                "functions": {
                    "AddMutator": {
                        "body": "{\n    if(M.Class != class)\n      super.AddMutator(M);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AddMutator",
                        "native": false,
                        "param": [
                            [
                                "Mutator",
                                "M"
                            ]
                        ],
                        "return": ""
                    },
                    "DelTG": {
                        "body": "{\n\t\n\tforeach AllActors(class'Actor', act)\n\t{\n\t\t//if(act.class == class'AutoTurretGun')\n\t\t//\tact.Destroy();\n\t\tif(act.class == class'AutoTurretGun')\n\t\t{\n\t\t\tact.Destroy();\t\t\t\n\t\t}\n\t\t\n\t}\n}",
                        "locals": [
                            "local Actor act, oldact;"
                        ],
                        "modifiers": [],
                        "name": "DelTG",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ImportSecParams": {
                        "body": "{\n\n\tfor (cameraIndex=0; cameraIndex<ArrayCount(OldSec.Views); cameraIndex++)\n\t{\n\t\tNewSec.Views[cameraIndex].cameraTag = oldSec.Views[cameraIndex].cameraTag;\n\t\tNewSec.Views[cameraIndex].turretTag = oldSec.Views[cameraIndex].turretTag;\n\t\tNewSec.Views[cameraIndex].doorTag = oldSec.Views[cameraIndex].doorTag;\n\t}\n}",
                        "locals": [
                            "local int cameraIndex;"
                        ],
                        "modifiers": [],
                        "name": "ImportSecParams",
                        "native": false,
                        "param": [
                            [
                                "TCComputerSecurity",
                                "NewSec"
                            ],
                            [
                                "ComputerSecurity",
                                "OldSec"
                            ]
                        ],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\n\tsuper.PostBeginPlay();\n\t\n\tforeach AllActors(class'Actor', act)\n\t{\n\t\tReplaceMapItem(act, act.class);\n\t}\n\t/*DelTG();\n\tReplaceTurrets();\n\tReplaceComs();*/\n}",
                        "locals": [
                            "local Actor act;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ReplaceComs": {
                        "body": "{\n\t\n\tforeach AllActors(class'Actor', act)\n\t{\n\t\tif(act.class == class'ComputerSecurity')\n\t\t{\n\t\t\tTCCS = Spawn(class'TCComputerSecurity',act.owner,act.tag,act.location,act.Rotation);\n\t\t\tTCCS.DrawScale = act.DrawScale;\n\t\t\tTCCS.SetPhysics(PHYS_None);\n\t\t\t\n\t\t\tfor (i=0; i<3; i++)\n\t\t\t{\n\t\t\t\tTCCS.Views[i].titleString = ComputerSecurity(act).Views[i].titleString;\n\t\t\t\tTCCS.Views[i].cameraTag = ComputerSecurity(act).Views[i].cameraTag;\n\t\t\t\tTCCS.Views[i].turretTag = ComputerSecurity(act).Views[i].turretTag;\n\t\t\t\tTCCS.Views[i].doorTag = ComputerSecurity(act).Views[i].doorTag;\n\t\t\t}\n\t\t\tact.Destroy();\n\t\t}\n\t}\n}",
                        "locals": [
                            "local Actor act;",
                            "local Inventory inv;",
                            "local int i;",
                            "local bool bFound;",
                            "local TCComputerSecurity TCCS;",
                            "local ComputerSecurity CS;"
                        ],
                        "modifiers": [],
                        "name": "ReplaceComs",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ReplaceMapItem": {
                        "body": "{\n\n    for (i = 0; i < ArrayCount(toReplace); i++)\n    {\n        if (inClass == toReplace[i])\n        {\n            bFound = true;\n            break;\n        }\n    }\n    if (bFound)\n    {\n\t\tif (replaceTo[i] != none)\n\t\t{\n\t\t\tact = Spawn(replaceTO[i],in.owner,in.tag,in.location,in.Rotation);\n\t\t\tif (act != none)\n\t\t\t{\n\t\t\t\t//log(\"replacing\"@in@\"with\"@act);\n\t\t\t\tact.SetPhysics(in.Physics);\n\t\t\t\tinv = Inventory(act);\n\t\t\t\tif (inv != none) \n\t\t\t\t{\n            \t\tinv.RespawnTime = Inventory(in).RespawnTime;\n\t\t\t\t\tif (Weapon(inv) != none && Weapon(in) != none)\n\t\t\t\t\t\tWeapon(inv).SetCollisionSize(in.CollisionRadius, in.CollisionHeight);\n\t\t\t\t}\n\t\t\t\tif (AutoTurret(act) != none)\n\t\t\t\t\tAutoTurret(act).titleString = AutoTurret(in).titleString;\n\t\t\t\tin.Destroy();\n\t\t\t\tin=act;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin.Destroy();\n\t\t\tin = none;\n\t\t\treturn;\n\t\t}\n    }\n}",
                        "locals": [
                            "local Actor act;",
                            "local Inventory inv;",
                            "local int i;",
                            "local bool bFound;"
                        ],
                        "modifiers": [],
                        "name": "ReplaceMapItem",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "Actor",
                                "in"
                            ],
                            [
                                "Class<Actor>",
                                "inClass"
                            ]
                        ],
                        "return": ""
                    },
                    "ReplaceTurrets": {
                        "body": "{\n\n\t\n\tforeach AllActors(class'Actor', act)\n\t{\n\t\tif(act.class == class'AutoTurret')\n\t\t{\n\t\t\tMMAT = Spawn(class'TCAutoTurret',act.owner,act.tag,act.location,act.Rotation);\n\t\t\tMMAT.Tag = act.Tag;\n\t\t\tMMAT.DrawScale = act.DrawScale;\n\t\t\tMMAT.TitleString = TCAutoTurret(act).TitleString;\n\t\t\tMMAT.SetPhysics(act.Physics);\n\t\t\tact.Destroy();\t\t\t\n\t\t}\n\t\t\n\t}\n}",
                        "locals": [
                            "local Actor act, oldact;",
                            "local Inventory inv;",
                            "local int i;",
                            "local bool bFound;",
                            "local TCAutoTurret MMAT;"
                        ],
                        "modifiers": [],
                        "name": "ReplaceTurrets",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpawnNotification": {
                        "body": "{\n\tReplaceMapItem(in, inClass);\n\tsuper.ReplaceMapItem(in, inClass);\n    super.SpawnNotification(in, inClass);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SpawnNotification",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "Actor",
                                "in"
                            ],
                            [
                                "Class<Actor>",
                                "inClass"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 198,
                "replication": "",
                "states": [],
                "variables": [
                    "var config class<Actor> toReplace[32];",
                    "var config class<Actor> replaceTo[32];"
                ]
            }
        },
        "TCRocket.uc": {
            "body": "class TCRocket extends Rocket;\n\n\ndefaultproperties\n{\n\tmpBlastRadius=80.000000\n\tBlastRadius=80.000000\n\tDamage=70\n}\n",
            "name": "TCRocket.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "mpBlastRadius=80.000000",
                    "BlastRadius=80.000000",
                    "Damage=70"
                ],
                "exec": [],
                "extends": "Rocket",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 10,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCScoreBoard.uc": {
            "body": "class TCScoreBoard extends ScoreBoard;\n\nstruct PlayerInfo\n{\n    var int playerID;\n    var string playerName;\n    var float score;\n    var float deaths;\n    var float streak;\n    var int team;\n    var int ping;\n    var int fps;\n    var int dt;\n    var bool bSpectator;\n    var bool bAdmin;\n};\nvar PlayerInfo playerList[32];\n\nstruct TeamInfo\n{\n    var float score;\n    var float deaths;\n    var float streak;\n    var int playerCount;\n};\n\nvar TeamInfo teamList[2];\n\nvar int playerCount, spectatorCount;\n\n// CONSTANTS\nconst IDX = 0.14;\nconst PlayerX   = 0.17;\t\t// Multiplier of screenWidth\nconst KillsX    = 0.48;\nconst DeathsX   = 0.56;\nconst StreakX   = 0.64;\nconst FPSX      = 0.75;\nconst DTX       = 0.80;\nconst PINGX     = 0.85;\n\nconst PlayerY   = 0.25;\nconst WinY      = 0.15;\t\t// Mutliplier of screenHeight\nconst FireContY = 0.80;\n\nvar color WhiteColor, SilverColor, RedColor, GreenColor, GoldColor;\nvar localized String EnemiesString, AlliesString, VictoryConString1, VictoryConStringPlayer1, VictoryConString2, TimeLimitString1, TimeLimitString2;\nvar TCPlayer Player;\nvar DeusExMPGame Game;\n\n/**\n  Time for us to display a scoreboard!\n*/\nsimulated function ShowScoreboard(GC gc, float screenWidth, float screenHeight)\n{\n    local float xlen, ylen, yoffset, ystart, w, h, w2, maxLength;\n    local PlayerInfo fakeSE;\n    local int teamID, barLen, i, p, k;\n    local string teamStr, str, str2, spectators[10];\n\n    if(gc == None)\n        return;\n\n    Game = DeusExMPGame(Level.Game);\n    if(Game == None)\n        return;\n\n    Player = TCPlayer(Owner);\n    if(Player == None || Player.PlayerReplicationInfo == None || !Player.PlayerIsClient())\n        return;\n\n    populateList();\n\n    gc.SetFont(Font'FontMenuSmall');\n    gc.GetTextExtent(0, xlen, ylen, \"TEST\");\n\n    yoffset = screenHeight * PlayerY;\n    ystart = yoffset;\n\n    gc.SetTextColor(WhiteColor);\n    ShowVictoryConditions(gc, screenWidth, ystart);\n    yoffset += (ylen * 2.0);\n    DrawHeaders(gc, screenWidth, yoffset);\n    yoffset += (ylen * 1.5);\n    gc.GetTextExtent(0, w, h, \"Ping\");\n    barLen = (screenWidth * PINGX + w)-(IDX*screenWidth);\n\n    if(DeathMatchGame(Game) != None)\n    {\n        for(i = 0; i < playerCount; i++)\n        {\n            if(!playerList[i].bSpectator)\n            {\n                if(playerList[i].PlayerID == Player.PlayerReplicationInfo.PlayerID)\n                    gc.SetTextColor(GoldColor);\n                else\n                    gc.SetTextColor(WhiteColor);\n\n                yoffset += ylen;\n                DrawNameAndScore(gc, playerList[i], screenWidth, yoffset);\n            }\n        }\n    }\n    else if(TeamDMGame(Game) != None)\n    {\n        if(Player.PlayerReplicationInfo.Team == 0) // TEAM_UNATCO\n        {\n            teamStr = Game.TeamUnatcoString;\n            teamID = 0;\n        }\n        else\n        {\n            teamStr = Game.TeamNsfString;\n            teamID = 1;\n        }\n\n        // Allies\n        gc.SetTextColor(GreenColor);\n\n        fakeSE.PlayerName = AlliesString $ \" (\" $ teamStr $ \")\";\n        fakeSE.score = teamList[teamID].score;\n        fakeSE.deaths = teamList[teamID].deaths;\n        fakeSE.streak = teamList[teamID].streak;\n\n        DrawNameAndScore(gc, fakeSE, screenWidth, yoffset, true);\n\n        gc.SetTileColorRGB(0,255,0);\n        gc.DrawBox(IDX * screenWidth, yoffset+h, barLen, 1, 0, 0, 1, Texture'Solid');\n        yoffset += (h * 0.25);\n        for(i = 0; i < playerCount; i++)\n        {\n            if(playerList[i].Team == teamID && !playerList[i].bSpectator)\n            {\n                if (playerList[i].PlayerID == Player.PlayerReplicationInfo.PlayerID)\n                    gc.SetTextColor(GoldColor);\n                else\n                    gc.SetTextColor(GreenColor);\n\n                yoffset += ylen;\n                DrawNameAndScore(gc, playerList[i], screenWidth, yoffset);\n            }\n        }\n\n        yoffset += (ylen*2);\n\n        if(Player.PlayerReplicationInfo.team == 0) // TEAM_UNATCO\n        {\n            teamStr = Game.TeamNsfString;\n            teamID = 1;\n        }\n        else\n        {\n            teamStr = Game.TeamUnatcoString;\n            teamID = 0;\n        }\n\n        // Enemies\n        gc.SetTextColor(RedColor);\n        gc.GetTextExtent(0, w, h, EnemiesString);\n        gc.DrawText(PlayerX * screenWidth, yoffset, w,h, EnemiesString);\n        fakeSE.PlayerName = EnemiesString $ \" (\" $ teamStr $ \")\";\n\n        fakeSE.score = teamList[teamID].score;\n        fakeSE.deaths = teamList[teamID].deaths;\n        fakeSE.streak = teamList[teamID].streak;\n\n        DrawNameAndScore(gc, fakeSE, screenWidth, yoffset, true);\n        gc.SetTileColorRGB(255,0,0);\n        gc.DrawBox(IDX * screenWidth, yoffset+h, barLen, 1, 0, 0, 1, Texture'Solid');\n        yoffset += (h * 0.25);\n\n        for(i = 0; i < playerCount; i++)\n        {\n            if(playerList[i].Team == teamID && !playerList[i].bSpectator)\n            {\n                yoffset += ylen;\n                DrawNameAndScore(gc, playerList[i], screenWidth, yoffset);\n            }\n        }\n    }\n\n        yoffset += (ylen*3);\n\n        gc.SetTileColorRGB(255, 255, 255);\n        gc.DrawBox(IDX * screenWidth, yoffset+h, barLen, 1, 0, 0, 1, Texture'Solid');\n        yoffset += (h * 0.25) + ylen;\n\n        gc.SetTextColorRGB(255, 255, 255);\n\n        k = 0;\n        if(spectatorCount == 0)\n            str = \"Spectators: None\";\n        else\n        {\n            maxLength = (screenWidth * PINGX + w)-(IDX*screenWidth);\n            str = \"Spectators: \";\n            for(i = 0; i < playerCount; i++)\n            {\n                if(playerList[i].bSpectator)\n                {\n                    str2 = playerList[i].PlayerName$\"(\"$playerList[i].PlayerID$\")\";\n                    if((p+1) < spectatorCount)\n                        str2 = str2$\", \";\n\n                    gc.GetTextExtent(0, w, h, str$str2);\n\n                    if(w > maxLength)\n                    {\n                        spectators[k] = str;\n                        str = \"\";\n                        k++;\n                    }\n                    str = str$str2;\n                    p++;\n                }\n            }\n        }\n        spectators[k] = str;\n\n        for(i = 0; i < 10; i++)\n        {\n            str = spectators[i];\n            if(len(str) > 0)\n            {\n                gc.GetTextExtent(0, w, h, str);\n                gc.DrawText(screenWidth * PlayerX, yoffset, w, h, str);\n                yoffset += ylen;\n            }\n        }\n\n}\n\nsimulated function DrawHeaders(GC gc, float screenWidth, float yoffset)\n{\n    local float x, w, h;\n\n    if(Game == None)\n        return;\n\n    // Player header\n    gc.GetTextExtent(0, w, h, Game.PlayerString);\n    x = screenWidth * PlayerX;\n    gc.DrawText(x, yoffset, w, h, Game.PlayerString);\n\n    gc.GetTextExtent(0, w,h, \"ID\");\n    x = screenWidth * IDX;\n    gc.DrawText(x, yOffset, w, h, \"ID\");\n\n    gc.GetTextExtent(0, w, h, Game.KillsString);\n    x = screenWidth * KillsX;\n    gc.DrawText(x, yoffset, w, h, Game.KillsString);\n\n    gc.GetTextExtent(0, w, h, Game.DeathsString);\n    x = screenWidth * DeathsX;\n    gc.DrawText(x, yoffset, w, h, Game.DeathsString);\n\n    gc.GetTextExtent(0, w, h, Game.StreakString);\n    x = screenWidth * StreakX;\n    gc.DrawText(x, yoffset, w, h, Game.StreakString);\n    \n    gc.GetTextExtent(0, w, h, \"FPS\");\n    x = screenWidth * FPSX;\n    gc.DrawText(x, yoffset, w, h, \"FPS\");\n    gc.GetTextExtent(0, w, h, \"DT\");\n    x = screenWidth * DTX;\n    gc.DrawText(x, yoffset, w, h, \"DT\");\n    gc.GetTextExtent(0, w, h, \"Ping\");\n    x = screenWidth * PINGX;\n    gc.DrawText(x, yoffset, w, h, \"Ping\");\n\n    gc.SetTileColorRGB(255,255,255);\n    gc.DrawBox(IDX * screenWidth, yoffset+h, (x + w)-(IDX*screenWidth), 1, 0, 0, 1, Texture'Solid');\n}\n\n\n/**\n  Populate the array of players & cumulative team data.\n*/\nsimulated function populateList()\n{\n    local TCPRI PRI;\n    local int i;\n    local TCPlayer TCPlayer;\n\n    if(Player == None || Player.GameReplicationInfo == None)\n        return;\n\n\n    // Reset team scores.\n    teamList[0].score = 0;\n    teamList[0].deaths = 0;\n    teamList[0].streak = 0;\n    teamList[0].playerCount = 0;\n\n    teamList[1].score = 0;\n    teamList[1].deaths = 0;\n    teamList[1].streak = 0;\n    teamList[1].playerCount = 0;\n\n    playerCount = 0;\n    spectatorCount = 0;\n\n    for(i = 0; i < 32; i++)\n    {\n        if(Player.GameReplicationInfo.PRIArray[i] != None)\n        {\n            PRI = TCPRI(Player.GameReplicationInfo.PRIArray[i]);\n            if(PRI != None)\n            {\n                playerList[playerCount].PlayerID = PRI.PlayerID;\n                playerList[playerCount].PlayerName = PRI.PlayerName;\n                playerList[playerCount].score = PRI.Score;\n                playerList[playerCount].deaths = PRI.Deaths;\n                playerList[playerCount].streak = PRI.Streak;\n                playerList[playerCount].team = PRI.Team;\n                playerList[playerCount].ping = PRI.PingPRI;\n                playerList[playerCount].fps = PRI.FPS;\n                playerList[playerCount].dt = PRI.DT;\n                playerList[playerCount].bAdmin = PRI.bAdmin;\n                playerList[playerCount].bSpectator = PRI.bIsSpectator;\n\n                if(PRI.bIsSpectator)\n                    spectatorCount++;\n\n                if((PRI.Team == 0 || PRI.Team == 1) && Level.Game.bTeamGame && !PRI.bIsSpectator)\n                {\n                    teamList[PRI.Team].score += PRI.Score;\n                    teamList[PRI.Team].deaths += PRI.Deaths;\n                    teamList[PRI.Team].streak += PRI.Streak;\n                    teamList[PRI.Team].playerCount++;\n                }\n            }\n            playerCount++;\n            if(playerCount == ArrayCount(playerList))\n                break;\n        }\n    }\n\n    sortList();\n}\n\n/**\n  Sort the playerlist on score and alternatively deaths.\n  We ignore team for now, we will filter it later on when displaying the data.\n*/\nsimulated function sortList()\n{\n    local PlayerInfo tmpSE;\n    local int i, j, max;\n\n    for(i = 0; i < playerCount-1; i++)\n    {\n        max = i;\n        for(j = i+1; j < playerCount; j++)\n        {\n            if(playerList[j].Score > playerList[max].Score)\n                max = j;\n            else if((playerList[j].Score == playerList[max].Score) && (playerList[j].Deaths < playerList[max].Deaths))\n                max = j;\n        }\n        tmpSE = playerList[max];\n        playerList[max] = playerList[i];\n        playerList[i] = tmpSE;\n    }\n}\n\nsimulated function DrawNameAndScore(GC gc, PlayerInfo se, float screenWidth, float yoffset, optional bool fakeSE)\n{\n    local float x, w, h, w2, xoffset, killcx, deathcx, streakcx;\n    local String str, dtstr;\n\n    if(Game == None)\n        return;\n\n    if(!fakeSE)\n    {\n        // Draw PlayerID\n        gc.GetTextExtent(0, w, h, string(se.PlayerID));\n        gc.DrawText(screenWidth * IDX, yOffset, w, h, string(se.PlayerID));\n    }\n\n    // Draw Name\n    str = se.PlayerName;\n    gc.GetTextExtent(0, w, h, str);\n    x = screenWidth * PlayerX;\n    gc.DrawText(x, yoffset, w, h, str);\n\n    // Draw Kills\n    str = \"00\";\n    gc.GetTextExtent(0, w, h, Game.KillsString);\n    killcx = screenWidth * KillsX + w * 0.5;\n    gc.GetTextExtent(0, w, h, str);\n    str = int(se.Score) $ \"\";\n    gc.GetTextExtent(0, w2, h, str);\n    x = killcx + (w * 0.5) - w2;\n    gc.DrawText(x, yoffset, w2, h, str);\n\n    // Draw Deaths\n    str = \"00\";\n    gc.GetTextExtent(0, w, h, Game.DeathsString);\n    deathcx = screenWidth * DeathsX + w * 0.5;\n    gc.GetTextExtent(0, w, h, str);\n    str = int(se.Deaths) $ \"\";\n    gc.GetTextExtent(0, w2, h, str);\n    x = deathcx + (w * 0.5) - w2;\n    gc.DrawText(x, yoffset, w2, h, str);\n\n    // Draw Streak\n    str = \"00\";\n    gc.GetTextExtent(0, w, h, Game.StreakString);\n    streakcx = screenWidth * StreakX + w * 0.5;\n    gc.GetTextExtent(0, w, h, str);\n    str = int(se.Streak) $ \"\";\n    gc.GetTextExtent(0, w2, h, str);\n    x = streakcx + (w * 0.5) - w2;\n    gc.DrawText(x, yoffset, w2, h, str);\n\n    if(!fakeSE)\n    {\n        // Draw FPS\n        gc.GetTextExtent(0, w2, h, \"FPS\");\n        gc.GetTextExtent(0, w, h, string(se.fps));\n        gc.DrawText(screenWidth * FPSX + (w2 - w) * 0.5, yOffset, w, h, string(se.fps));\n\n        // Draw DT\n        gc.GetTextExtent(0, w2, h, \"DT\");\n        dtstr = \"\";\n        if(se.dt != -1)\n            dtstr = string(se.dt)$\"%\";\n\n        gc.GetTextExtent(0, w, h, dtstr);\n        gc.DrawText(screenWidth * DTX + (w2 - w) * 0.5, yOffset, w, h, dtstr);\n    \n        // Draw Ping\n        gc.GetTextExtent(0, w2, h, \"Ping\");\n        gc.GetTextExtent(0, w, h, string(se.ping));\n        gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, string(se.ping));\n    }\n}\n\nsimulated function ShowVictoryConditions(GC gc, float screenWidth, float yoffset)\n{\n    local String str, secStr;\n    local float x, y, w, h;\n    local int timeLeft, minutesLeft, secondsLeft;\n    local float ftimeLeft;\n\n    if(Game == None)\n        return;\n\n    if(Game.VictoryCondition ~= \"Frags\")\n    {\n        if(DeathMatchGame(Game) != None)\n            str = VictoryConStringPlayer1 $ Game.ScoreToWin $ VictoryConString2;\n        else if(TeamDMGame(Game) != None)\n            str = VictoryConString1 $ Game.ScoreToWin $ VictoryConString2;\n    }\n    else if(Game.VictoryCondition ~= \"Time\")\n    {\n        timeLeft = Game.ScoreToWin * 60 - Level.Timeseconds - Player.ServerTimeDiff;\n        if(timeLeft < 0)\n            timeleft = 0;\n        minutesLeft = timeLeft/60;\n        ftimeLeft = float(timeLeft);\n        secondsLeft = int(ftimeLeft%60);\n        if(secondsLeft < 10)\n            secStr = \"0\" $ secondsLeft;\n        else\n            secStr = \"\" $ secondsLeft;\n\n        str = TimeLimitString1 $ minutesLeft $ \":\" $ secStr $ TimeLimitString2;\n    }\n    else\n        log(\"Warning: Unknown victory type:\"@Game.VictoryCondition);\n\n    gc.GetTextExtent(0, w, h, str);\n    x = (screenWidth * 0.5) - (w * 0.5);\n    gc.DrawText(x, yoffset, w, h, str);\n}\n\nsimulated function ShowWinScreen(GC gc, float screenWidth, float screenHeight, int winningTeam, String winnerName, String killerStr, String killeeStr, String methodStr)\n{\n    local String str;\n    local float x, y, w, h;\n\n    Game = DeusExMPGame(Level.Game);\n    if(Game == None)\n        return;\n\n    Player = TCPlayer(Owner);\n    if(Player == None || !Player.PlayerIsClient())\n        return;\n\n    gc.SetFont(Font'FontMenuExtraLarge');\n    if(DeathMatchGame(Game) != None)\n    {\n        gc.SetTextColor(GoldColor);\n\n        if(winningTeam == 2) // TEAM_DRAW\n            str = Game.TeamDrawString;\n        else\n            str = winnerName $ Game.WonMatchString;\n    }\n    else if(TeamDMGame(Game) != None)\n    {\n        if(Player.PlayerReplicationInfo.team == winningTeam)\n            gc.SetTextColor(GreenColor);\n        else\n            gc.SetTextColor(RedColor);\n\n        switch(winningTeam)\n        {\n            case 1: // TEAM_NSF\n                str = Game.TeamNsfString $ Game.WonMatchString;\n                break;\n            case 0: // TEAM_UNATCO\n                str = Game.TeamUnatcoString $ Game.WonMatchString;\n                break;\n            case 2: // TEAM_DRAW\n                str = Game.TeamDrawString;\n                break;\n        }\n    }\n\n    gc.GetTextExtent(0, w, h, str);\n    x = (screenWidth * 0.5) - (w * 0.5);\n    y = screenHeight * WinY;\n    gc.DrawText(x, y, w, h, str);\n\n    y += h;\n\n    // Show who won it and who got killed\n    if(Game.VictoryCondition ~= \"Frags\")\n    {\n        gc.SetFont(Font'FontMenuTitle');\n        if((killerStr ~= \"\") || (killeeStr ~= \"\") || (methodStr ~=\"\"))\n            log(\"Warning: Bad kill string in final death message.\");\n        else\n        {\n            str = Game.MatchEnd1String $ killerStr $ Game.MatchEnd2String $ killeeStr $ methodStr;\n            gc.GetTextExtent(0, w, h, str);\n            if(w >= screenWidth)\n            {\n                y -= (h * 0.5);\n                str = Game.MatchEnd1String $ killerStr $ Game.MatchEnd2String $ killeeStr;\n                gc.GetTextExtent(0, w, h, str);\n                x = (screenWidth * 0.5) - (w * 0.5);\n                gc.DrawText(x, y, w, h, str);\n                y += h;\n                str = methodStr;\n                gc.GetTextExtent(0, w, h, str);\n                x = (screenWidth * 0.5) - (w * 0.5);\n                gc.DrawText(x, y, w, h, str);\n            }\n            else\n            {\n                x = (screenWidth * 0.5) - (w * 0.5);\n                gc.DrawText(x, y, w, h, str);\n            }\n        }\n    }\n\n    ShowScoreboard(gc, screenWidth, screenHeight);\n\n    ContinueMsg(gc, screenWidth, screenHeight);\n}\n\nsimulated function ContinueMsg(GC gc, float screenWidth, float screenHeight)\n{\n    local String str;\n    local float x, y, w, h;\n    local int t;\n\n    if(Game.bNewMap && !Game.bClientNewMap)\n    {\n        Game.NewMapTime = Level.Timeseconds + Game.NewMapDelay - 0.5;\n        Game.bClientNewMap = True;\n    }\n    t = int(Game.NewMapTime - Level.Timeseconds);\n    if(t < 0)\n        t = 0;\n\n    str = t $ Game.NewMapSecondsString;\n\n    gc.SetTextColor(WhiteColor);\n    gc.SetFont(Font'FontMenuTitle');\n    gc.GetTextExtent(0, w, h, str);\n    x = (screenWidth * 0.5) - (w * 0.5);\n    y = screenHeight * FireContY;\n    gc.DrawText(x, y, w, h, str);\n\n    y += (h*2.0);\n    str = Game.EscapeString;\n    gc.GetTextExtent(0, w, h, str);\n    x = (screenWidth * 0.5) - (w * 0.5);\n    gc.DrawText(x, y, w, h, str);\n}\n\ndefaultproperties\n{\n    WhiteColor=(R=255,G=255,B=255,A=0),\n    SilverColor=(R=138,G=164,B=166,A=0),\n    RedColor=(R=255,G=0,B=0,A=0),\n    GreenColor=(R=0,G=255,B=0,A=0),\n    GoldColor=(R=255,G=255,B=0,A=0),\n    EnemiesString=\"Enemies\"\n    AlliesString=\"Allies\"\n    VictoryConString1=\"Objective: First team that reaches \"\n    VictoryConString2=\" kills wins the match.\"\n    TimeLimitString1=\"Objective: Score the most kills before the clock ( \"\n    TimeLimitString2=\" ) runs out!\"\n    VictoryConStringPlayer1=\"Objective: First player that reaches \"\n    bHidden=True\n}\n",
            "name": "TCScoreBoard.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "WhiteColor=(R=255,G=255,B=255,A=0),",
                    "SilverColor=(R=138,G=164,B=166,A=0),",
                    "RedColor=(R=255,G=0,B=0,A=0),",
                    "GreenColor=(R=0,G=255,B=0,A=0),",
                    "GoldColor=(R=255,G=255,B=0,A=0),",
                    "EnemiesString=\"Enemies\"",
                    "AlliesString=\"Allies\"",
                    "VictoryConString1=\"Objective: First team that reaches \"",
                    "VictoryConString2=\" kills wins the match.\"",
                    "TimeLimitString1=\"Objective: Score the most kills before the clock ( \"",
                    "TimeLimitString2=\" ) runs out!\"",
                    "VictoryConStringPlayer1=\"Objective: First player that reaches \"",
                    "bHidden=True"
                ],
                "exec": [],
                "extends": "ScoreBoard",
                "functions": {
                    "ContinueMsg": {
                        "body": "{\n\n    if(Game.bNewMap && !Game.bClientNewMap)\n    {\n        Game.NewMapTime = Level.Timeseconds + Game.NewMapDelay - 0.5;\n        Game.bClientNewMap = True;\n    }\n    t = int(Game.NewMapTime - Level.Timeseconds);\n    if(t < 0)\n        t = 0;\n\n    str = t $ Game.NewMapSecondsString;\n\n    gc.SetTextColor(WhiteColor);\n    gc.SetFont(Font'FontMenuTitle');\n    gc.GetTextExtent(0, w, h, str);\n    x = (screenWidth * 0.5) - (w * 0.5);\n    y = screenHeight * FireContY;\n    gc.DrawText(x, y, w, h, str);\n\n    y += (h*2.0);\n    str = Game.EscapeString;\n    gc.GetTextExtent(0, w, h, str);\n    x = (screenWidth * 0.5) - (w * 0.5);\n    gc.DrawText(x, y, w, h, str);\n}",
                        "locals": [
                            "local String str;",
                            "local float x, y, w, h;",
                            "local int t;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ContinueMsg",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ],
                            [
                                "float",
                                "screenHeight"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawHeaders": {
                        "body": "{\n\n    if(Game == None)\n        return;\n\n    // Player header\n    gc.GetTextExtent(0, w, h, Game.PlayerString);\n    x = screenWidth * PlayerX;\n    gc.DrawText(x, yoffset, w, h, Game.PlayerString);\n\n    gc.GetTextExtent(0, w,h, \"ID\");\n    x = screenWidth * IDX;\n    gc.DrawText(x, yOffset, w, h, \"ID\");\n\n    gc.GetTextExtent(0, w, h, Game.KillsString);\n    x = screenWidth * KillsX;\n    gc.DrawText(x, yoffset, w, h, Game.KillsString);\n\n    gc.GetTextExtent(0, w, h, Game.DeathsString);\n    x = screenWidth * DeathsX;\n    gc.DrawText(x, yoffset, w, h, Game.DeathsString);\n\n    gc.GetTextExtent(0, w, h, Game.StreakString);\n    x = screenWidth * StreakX;\n    gc.DrawText(x, yoffset, w, h, Game.StreakString);\n    \n    gc.GetTextExtent(0, w, h, \"FPS\");\n    x = screenWidth * FPSX;\n    gc.DrawText(x, yoffset, w, h, \"FPS\");\n    gc.GetTextExtent(0, w, h, \"DT\");\n    x = screenWidth * DTX;\n    gc.DrawText(x, yoffset, w, h, \"DT\");\n    gc.GetTextExtent(0, w, h, \"Ping\");\n    x = screenWidth * PINGX;\n    gc.DrawText(x, yoffset, w, h, \"Ping\");\n\n    gc.SetTileColorRGB(255,255,255);\n    gc.DrawBox(IDX * screenWidth, yoffset+h, (x + w)-(IDX*screenWidth), 1, 0, 0, 1, Texture'Solid');\n}",
                        "locals": [
                            "local float x, w, h;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DrawHeaders",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ],
                            [
                                "float",
                                "yoffset"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawNameAndScore": {
                        "body": "{\n\n    if(Game == None)\n        return;\n\n    if(!fakeSE)\n    {\n        // Draw PlayerID\n        gc.GetTextExtent(0, w, h, string(se.PlayerID));\n        gc.DrawText(screenWidth * IDX, yOffset, w, h, string(se.PlayerID));\n    }\n\n    // Draw Name\n    str = se.PlayerName;\n    gc.GetTextExtent(0, w, h, str);\n    x = screenWidth * PlayerX;\n    gc.DrawText(x, yoffset, w, h, str);\n\n    // Draw Kills\n    str = \"00\";\n    gc.GetTextExtent(0, w, h, Game.KillsString);\n    killcx = screenWidth * KillsX + w * 0.5;\n    gc.GetTextExtent(0, w, h, str);\n    str = int(se.Score) $ \"\";\n    gc.GetTextExtent(0, w2, h, str);\n    x = killcx + (w * 0.5) - w2;\n    gc.DrawText(x, yoffset, w2, h, str);\n\n    // Draw Deaths\n    str = \"00\";\n    gc.GetTextExtent(0, w, h, Game.DeathsString);\n    deathcx = screenWidth * DeathsX + w * 0.5;\n    gc.GetTextExtent(0, w, h, str);\n    str = int(se.Deaths) $ \"\";\n    gc.GetTextExtent(0, w2, h, str);\n    x = deathcx + (w * 0.5) - w2;\n    gc.DrawText(x, yoffset, w2, h, str);\n\n    // Draw Streak\n    str = \"00\";\n    gc.GetTextExtent(0, w, h, Game.StreakString);\n    streakcx = screenWidth * StreakX + w * 0.5;\n    gc.GetTextExtent(0, w, h, str);\n    str = int(se.Streak) $ \"\";\n    gc.GetTextExtent(0, w2, h, str);\n    x = streakcx + (w * 0.5) - w2;\n    gc.DrawText(x, yoffset, w2, h, str);\n\n    if(!fakeSE)\n    {\n        // Draw FPS\n        gc.GetTextExtent(0, w2, h, \"FPS\");\n        gc.GetTextExtent(0, w, h, string(se.fps));\n        gc.DrawText(screenWidth * FPSX + (w2 - w) * 0.5, yOffset, w, h, string(se.fps));\n\n        // Draw DT\n        gc.GetTextExtent(0, w2, h, \"DT\");\n        dtstr = \"\";\n        if(se.dt != -1)\n            dtstr = string(se.dt)$\"%\";\n\n        gc.GetTextExtent(0, w, h, dtstr);\n        gc.DrawText(screenWidth * DTX + (w2 - w) * 0.5, yOffset, w, h, dtstr);\n    \n        // Draw Ping\n        gc.GetTextExtent(0, w2, h, \"Ping\");\n        gc.GetTextExtent(0, w, h, string(se.ping));\n        gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, string(se.ping));\n    }\n}",
                        "locals": [
                            "local float x, w, h, w2, xoffset, killcx, deathcx, streakcx;",
                            "local String str, dtstr;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DrawNameAndScore",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "PlayerInfo",
                                "se"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ],
                            [
                                "float",
                                "yoffset"
                            ],
                            [
                                "optional",
                                "bool",
                                "fakeSE"
                            ]
                        ],
                        "return": ""
                    },
                    "ShowScoreboard": {
                        "body": "{\n\n    if(gc == None)\n        return;\n\n    Game = DeusExMPGame(Level.Game);\n    if(Game == None)\n        return;\n\n    Player = TCPlayer(Owner);\n    if(Player == None || Player.PlayerReplicationInfo == None || !Player.PlayerIsClient())\n        return;\n\n    populateList();\n\n    gc.SetFont(Font'FontMenuSmall');\n    gc.GetTextExtent(0, xlen, ylen, \"TEST\");\n\n    yoffset = screenHeight * PlayerY;\n    ystart = yoffset;\n\n    gc.SetTextColor(WhiteColor);\n    ShowVictoryConditions(gc, screenWidth, ystart);\n    yoffset += (ylen * 2.0);\n    DrawHeaders(gc, screenWidth, yoffset);\n    yoffset += (ylen * 1.5);\n    gc.GetTextExtent(0, w, h, \"Ping\");\n    barLen = (screenWidth * PINGX + w)-(IDX*screenWidth);\n\n    if(DeathMatchGame(Game) != None)\n    {\n        for(i = 0; i < playerCount; i++)\n        {\n            if(!playerList[i].bSpectator)\n            {\n                if(playerList[i].PlayerID == Player.PlayerReplicationInfo.PlayerID)\n                    gc.SetTextColor(GoldColor);\n                else\n                    gc.SetTextColor(WhiteColor);\n\n                yoffset += ylen;\n                DrawNameAndScore(gc, playerList[i], screenWidth, yoffset);\n            }\n        }\n    }\n    else if(TeamDMGame(Game) != None)\n    {\n        if(Player.PlayerReplicationInfo.Team == 0) // TEAM_UNATCO\n        {\n            teamStr = Game.TeamUnatcoString;\n            teamID = 0;\n        }\n        else\n        {\n            teamStr = Game.TeamNsfString;\n            teamID = 1;\n        }\n\n        // Allies\n        gc.SetTextColor(GreenColor);\n\n        fakeSE.PlayerName = AlliesString $ \" (\" $ teamStr $ \")\";\n        fakeSE.score = teamList[teamID].score;\n        fakeSE.deaths = teamList[teamID].deaths;\n        fakeSE.streak = teamList[teamID].streak;\n\n        DrawNameAndScore(gc, fakeSE, screenWidth, yoffset, true);\n\n        gc.SetTileColorRGB(0,255,0);\n        gc.DrawBox(IDX * screenWidth, yoffset+h, barLen, 1, 0, 0, 1, Texture'Solid');\n        yoffset += (h * 0.25);\n        for(i = 0; i < playerCount; i++)\n        {\n            if(playerList[i].Team == teamID && !playerList[i].bSpectator)\n            {\n                if (playerList[i].PlayerID == Player.PlayerReplicationInfo.PlayerID)\n                    gc.SetTextColor(GoldColor);\n                else\n                    gc.SetTextColor(GreenColor);\n\n                yoffset += ylen;\n                DrawNameAndScore(gc, playerList[i], screenWidth, yoffset);\n            }\n        }\n\n        yoffset += (ylen*2);\n\n        if(Player.PlayerReplicationInfo.team == 0) // TEAM_UNATCO\n        {\n            teamStr = Game.TeamNsfString;\n            teamID = 1;\n        }\n        else\n        {\n            teamStr = Game.TeamUnatcoString;\n            teamID = 0;\n        }\n\n        // Enemies\n        gc.SetTextColor(RedColor);\n        gc.GetTextExtent(0, w, h, EnemiesString);\n        gc.DrawText(PlayerX * screenWidth, yoffset, w,h, EnemiesString);\n        fakeSE.PlayerName = EnemiesString $ \" (\" $ teamStr $ \")\";\n\n        fakeSE.score = teamList[teamID].score;\n        fakeSE.deaths = teamList[teamID].deaths;\n        fakeSE.streak = teamList[teamID].streak;\n\n        DrawNameAndScore(gc, fakeSE, screenWidth, yoffset, true);\n        gc.SetTileColorRGB(255,0,0);\n        gc.DrawBox(IDX * screenWidth, yoffset+h, barLen, 1, 0, 0, 1, Texture'Solid');\n        yoffset += (h * 0.25);\n\n        for(i = 0; i < playerCount; i++)\n        {\n            if(playerList[i].Team == teamID && !playerList[i].bSpectator)\n            {\n                yoffset += ylen;\n                DrawNameAndScore(gc, playerList[i], screenWidth, yoffset);\n            }\n        }\n    }\n\n        yoffset += (ylen*3);\n\n        gc.SetTileColorRGB(255, 255, 255);\n        gc.DrawBox(IDX * screenWidth, yoffset+h, barLen, 1, 0, 0, 1, Texture'Solid');\n        yoffset += (h * 0.25) + ylen;\n\n        gc.SetTextColorRGB(255, 255, 255);\n\n        k = 0;\n        if(spectatorCount == 0)\n            str = \"Spectators: None\";\n        else\n        {\n            maxLength = (screenWidth * PINGX + w)-(IDX*screenWidth);\n            str = \"Spectators: \";\n            for(i = 0; i < playerCount; i++)\n            {\n                if(playerList[i].bSpectator)\n                {\n                    str2 = playerList[i].PlayerName$\"(\"$playerList[i].PlayerID$\")\";\n                    if((p+1) < spectatorCount)\n                        str2 = str2$\", \";\n\n                    gc.GetTextExtent(0, w, h, str$str2);\n\n                    if(w > maxLength)\n                    {\n                        spectators[k] = str;\n                        str = \"\";\n                        k++;\n                    }\n                    str = str$str2;\n                    p++;\n                }\n            }\n        }\n        spectators[k] = str;\n\n        for(i = 0; i < 10; i++)\n        {\n            str = spectators[i];\n            if(len(str) > 0)\n            {\n                gc.GetTextExtent(0, w, h, str);\n                gc.DrawText(screenWidth * PlayerX, yoffset, w, h, str);\n                yoffset += ylen;\n            }\n        }\n\n}",
                        "locals": [
                            "local float xlen, ylen, yoffset, ystart, w, h, w2, maxLength;",
                            "local PlayerInfo fakeSE;",
                            "local int teamID, barLen, i, p, k;",
                            "local string teamStr, str, str2, spectators[10];"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ShowScoreboard",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ],
                            [
                                "float",
                                "screenHeight"
                            ]
                        ],
                        "return": ""
                    },
                    "ShowVictoryConditions": {
                        "body": "{\n\n    if(Game == None)\n        return;\n\n    if(Game.VictoryCondition ~= \"Frags\")\n    {\n        if(DeathMatchGame(Game) != None)\n            str = VictoryConStringPlayer1 $ Game.ScoreToWin $ VictoryConString2;\n        else if(TeamDMGame(Game) != None)\n            str = VictoryConString1 $ Game.ScoreToWin $ VictoryConString2;\n    }\n    else if(Game.VictoryCondition ~= \"Time\")\n    {\n        timeLeft = Game.ScoreToWin * 60 - Level.Timeseconds - Player.ServerTimeDiff;\n        if(timeLeft < 0)\n            timeleft = 0;\n        minutesLeft = timeLeft/60;\n        ftimeLeft = float(timeLeft);\n        secondsLeft = int(ftimeLeft%60);\n        if(secondsLeft < 10)\n            secStr = \"0\" $ secondsLeft;\n        else\n            secStr = \"\" $ secondsLeft;\n\n        str = TimeLimitString1 $ minutesLeft $ \":\" $ secStr $ TimeLimitString2;\n    }\n    else\n        log(\"Warning: Unknown victory type:\"@Game.VictoryCondition);\n\n    gc.GetTextExtent(0, w, h, str);\n    x = (screenWidth * 0.5) - (w * 0.5);\n    gc.DrawText(x, yoffset, w, h, str);\n}",
                        "locals": [
                            "local String str, secStr;",
                            "local float x, y, w, h;",
                            "local int timeLeft, minutesLeft, secondsLeft;",
                            "local float ftimeLeft;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ShowVictoryConditions",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ],
                            [
                                "float",
                                "yoffset"
                            ]
                        ],
                        "return": ""
                    },
                    "ShowWinScreen": {
                        "body": "{\n\n    Game = DeusExMPGame(Level.Game);\n    if(Game == None)\n        return;\n\n    Player = TCPlayer(Owner);\n    if(Player == None || !Player.PlayerIsClient())\n        return;\n\n    gc.SetFont(Font'FontMenuExtraLarge');\n    if(DeathMatchGame(Game) != None)\n    {\n        gc.SetTextColor(GoldColor);\n\n        if(winningTeam == 2) // TEAM_DRAW\n            str = Game.TeamDrawString;\n        else\n            str = winnerName $ Game.WonMatchString;\n    }\n    else if(TeamDMGame(Game) != None)\n    {\n        if(Player.PlayerReplicationInfo.team == winningTeam)\n            gc.SetTextColor(GreenColor);\n        else\n            gc.SetTextColor(RedColor);\n\n        switch(winningTeam)\n        {\n            case 1: // TEAM_NSF\n                str = Game.TeamNsfString $ Game.WonMatchString;\n                break;\n            case 0: // TEAM_UNATCO\n                str = Game.TeamUnatcoString $ Game.WonMatchString;\n                break;\n            case 2: // TEAM_DRAW\n                str = Game.TeamDrawString;\n                break;\n        }\n    }\n\n    gc.GetTextExtent(0, w, h, str);\n    x = (screenWidth * 0.5) - (w * 0.5);\n    y = screenHeight * WinY;\n    gc.DrawText(x, y, w, h, str);\n\n    y += h;\n\n    // Show who won it and who got killed\n    if(Game.VictoryCondition ~= \"Frags\")\n    {\n        gc.SetFont(Font'FontMenuTitle');\n        if((killerStr ~= \"\") || (killeeStr ~= \"\") || (methodStr ~=\"\"))\n            log(\"Warning: Bad kill string in final death message.\");\n        else\n        {\n            str = Game.MatchEnd1String $ killerStr $ Game.MatchEnd2String $ killeeStr $ methodStr;\n            gc.GetTextExtent(0, w, h, str);\n            if(w >= screenWidth)\n            {\n                y -= (h * 0.5);\n                str = Game.MatchEnd1String $ killerStr $ Game.MatchEnd2String $ killeeStr;\n                gc.GetTextExtent(0, w, h, str);\n                x = (screenWidth * 0.5) - (w * 0.5);\n                gc.DrawText(x, y, w, h, str);\n                y += h;\n                str = methodStr;\n                gc.GetTextExtent(0, w, h, str);\n                x = (screenWidth * 0.5) - (w * 0.5);\n                gc.DrawText(x, y, w, h, str);\n            }\n            else\n            {\n                x = (screenWidth * 0.5) - (w * 0.5);\n                gc.DrawText(x, y, w, h, str);\n            }\n        }\n    }\n\n    ShowScoreboard(gc, screenWidth, screenHeight);\n\n    ContinueMsg(gc, screenWidth, screenHeight);\n}",
                        "locals": [
                            "local String str;",
                            "local float x, y, w, h;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ShowWinScreen",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ],
                            [
                                "float",
                                "screenHeight"
                            ],
                            [
                                "int",
                                "winningTeam"
                            ],
                            [
                                "String",
                                "winnerName"
                            ],
                            [
                                "String",
                                "killerStr"
                            ],
                            [
                                "String",
                                "killeeStr"
                            ],
                            [
                                "String",
                                "methodStr"
                            ]
                        ],
                        "return": ""
                    },
                    "populateList": {
                        "body": "{\n\n    if(Player == None || Player.GameReplicationInfo == None)\n        return;\n\n\n    // Reset team scores.\n    teamList[0].score = 0;\n    teamList[0].deaths = 0;\n    teamList[0].streak = 0;\n    teamList[0].playerCount = 0;\n\n    teamList[1].score = 0;\n    teamList[1].deaths = 0;\n    teamList[1].streak = 0;\n    teamList[1].playerCount = 0;\n\n    playerCount = 0;\n    spectatorCount = 0;\n\n    for(i = 0; i < 32; i++)\n    {\n        if(Player.GameReplicationInfo.PRIArray[i] != None)\n        {\n            PRI = TCPRI(Player.GameReplicationInfo.PRIArray[i]);\n            if(PRI != None)\n            {\n                playerList[playerCount].PlayerID = PRI.PlayerID;\n                playerList[playerCount].PlayerName = PRI.PlayerName;\n                playerList[playerCount].score = PRI.Score;\n                playerList[playerCount].deaths = PRI.Deaths;\n                playerList[playerCount].streak = PRI.Streak;\n                playerList[playerCount].team = PRI.Team;\n                playerList[playerCount].ping = PRI.PingPRI;\n                playerList[playerCount].fps = PRI.FPS;\n                playerList[playerCount].dt = PRI.DT;\n                playerList[playerCount].bAdmin = PRI.bAdmin;\n                playerList[playerCount].bSpectator = PRI.bIsSpectator;\n\n                if(PRI.bIsSpectator)\n                    spectatorCount++;\n\n                if((PRI.Team == 0 || PRI.Team == 1) && Level.Game.bTeamGame && !PRI.bIsSpectator)\n                {\n                    teamList[PRI.Team].score += PRI.Score;\n                    teamList[PRI.Team].deaths += PRI.Deaths;\n                    teamList[PRI.Team].streak += PRI.Streak;\n                    teamList[PRI.Team].playerCount++;\n                }\n            }\n            playerCount++;\n            if(playerCount == ArrayCount(playerList))\n                break;\n        }\n    }\n\n    sortList();\n}",
                        "locals": [
                            "local TCPRI PRI;",
                            "local int i;",
                            "local TCPlayer TCPlayer;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "populateList",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "sortList": {
                        "body": "{\n\n    for(i = 0; i < playerCount-1; i++)\n    {\n        max = i;\n        for(j = i+1; j < playerCount; j++)\n        {\n            if(playerList[j].Score > playerList[max].Score)\n                max = j;\n            else if((playerList[j].Score == playerList[max].Score) && (playerList[j].Deaths < playerList[max].Deaths))\n                max = j;\n        }\n        tmpSE = playerList[max];\n        playerList[max] = playerList[i];\n        playerList[i] = tmpSE;\n    }\n}",
                        "locals": [
                            "local PlayerInfo tmpSE;",
                            "local int i, j, max;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "sortList",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 614,
                "replication": "",
                "states": [],
                "variables": [
                    "var int playerID;",
                    "var string playerName;",
                    "var float score;",
                    "var float deaths;",
                    "var float streak;",
                    "var int team;",
                    "var int ping;",
                    "var int fps;",
                    "var int dt;",
                    "var bool bSpectator;",
                    "var bool bAdmin;",
                    "var PlayerInfo playerList[32];",
                    "var float score;",
                    "var float deaths;",
                    "var float streak;",
                    "var int playerCount;",
                    "var TeamInfo teamList[2];",
                    "var int playerCount, spectatorCount;",
                    "var color WhiteColor, SilverColor, RedColor, GreenColor, GoldColor;",
                    "var localized String EnemiesString, AlliesString, VictoryConString1, VictoryConStringPlayer1, VictoryConString2, TimeLimitString1, TimeLimitString2;",
                    "var TCPlayer Player;",
                    "var DeusExMPGame Game;"
                ]
            }
        },
        "TCSpectatorStartPoints.uc": {
            "body": "class TCSpectatorStartPoints extends Actor;\n\nstruct MapIndex\n{\n\tvar string MapName;\n\tvar int index;\n};\n\nstruct DefSpecPosAndRot\n{\n    var vector Location;\n    var int RotSlope;\n};\n\nvar MapIndex Indexes[10];\nvar config DefSpecPosAndRot MapSpecs[7];\n\nstatic function bool GetSpectatorStartPoint(string map, out vector vect, out rotator rot)\n{\n\tlocal int i;\n\n    for (i = 0; i < arrayCount(default.Indexes); i++)\n    {\n        if (default.Indexes[i].MapName ~= map)\n        {\n\t\t\tvect = default.MapSpecs[default.Indexes[i].index].Location;\n\t\t\trot.Pitch = (-3200) * default.MapSpecs[default.Indexes[i].index].RotSlope;\n            return true;\n        }\n    }\n\n\treturn false;\n}\n\ndefaultproperties\n{\n    Indexes(0)=(MapName=\"DXMP_Smuggler\",index=0),\n    Indexes(1)=(MapName=\"DXMP_Cmd\",index=1),\n    Indexes(2)=(MapName=\"DXMP_TunnelNetwork\",index=2),\n    Indexes(3)=(MapName=\"DXMP_Area51Bunker\",index=3),\n    Indexes(4)=(MapName=\"DXMP_Silo\",index=4),\n    Indexes(5)=(MapName=\"DXMP_Smuggles\",index=5),\n    Indexes(6)=(MapName=\"DXMP_Cathedral_GOTY\",index=6),\n    Indexes(7)=(MapName=\"DXMP_Paris_Cathedral\",index=6),\n    Indexes(8)=(MapName=\"DXMP_Cathedral\",index=6),\n    Indexes(9)=(MapName=\"DXMP_Smuggles_Ed\",index=5),\n    MapSpecs(0)=(Location=(X=-300.00,Y=-700.00,Z=100.00),,RotSlope=1),\n    MapSpecs(1)=(Location=(X=-1000.00,Y=3000.00,Z=0.00),,RotSlope=2),\n    MapSpecs(2)=(Location=(X=-900.00,Y=0.00,Z=0.00),,RotSlope=1),\n    MapSpecs(3)=(Location=(X=-2500.00,Y=2000.00,Z=800.00),,RotSlope=2),\n    MapSpecs(4)=(Location=(X=-2000.00,Y=-4000.00,Z=2500.00),,RotSlope=2),\n    MapSpecs(5)=(Location=(X=-3500.00,Y=-800.00,Z=400.00),,RotSlope=2),\n    MapSpecs(6)=(Location=(X=1000.00,Y=-2000.00,Z=1500.00),,RotSlope=2),\n    bHidden=True\n}\n",
            "name": "TCSpectatorStartPoints.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Indexes(0)=(MapName=\"DXMP_Smuggler\",index=0),",
                    "Indexes(1)=(MapName=\"DXMP_Cmd\",index=1),",
                    "Indexes(2)=(MapName=\"DXMP_TunnelNetwork\",index=2),",
                    "Indexes(3)=(MapName=\"DXMP_Area51Bunker\",index=3),",
                    "Indexes(4)=(MapName=\"DXMP_Silo\",index=4),",
                    "Indexes(5)=(MapName=\"DXMP_Smuggles\",index=5),",
                    "Indexes(6)=(MapName=\"DXMP_Cathedral_GOTY\",index=6),",
                    "Indexes(7)=(MapName=\"DXMP_Paris_Cathedral\",index=6),",
                    "Indexes(8)=(MapName=\"DXMP_Cathedral\",index=6),",
                    "Indexes(9)=(MapName=\"DXMP_Smuggles_Ed\",index=5),",
                    "MapSpecs(0)=(Location=(X=-300.00,Y=-700.00,Z=100.00),,RotSlope=1),",
                    "MapSpecs(1)=(Location=(X=-1000.00,Y=3000.00,Z=0.00),,RotSlope=2),",
                    "MapSpecs(2)=(Location=(X=-900.00,Y=0.00,Z=0.00),,RotSlope=1),",
                    "MapSpecs(3)=(Location=(X=-2500.00,Y=2000.00,Z=800.00),,RotSlope=2),",
                    "MapSpecs(4)=(Location=(X=-2000.00,Y=-4000.00,Z=2500.00),,RotSlope=2),",
                    "MapSpecs(5)=(Location=(X=-3500.00,Y=-800.00,Z=400.00),,RotSlope=2),",
                    "MapSpecs(6)=(Location=(X=1000.00,Y=-2000.00,Z=1500.00),,RotSlope=2),",
                    "bHidden=True"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "GetSpectatorStartPoint": {
                        "body": "{\n\n    for (i = 0; i < arrayCount(default.Indexes); i++)\n    {\n        if (default.Indexes[i].MapName ~= map)\n        {\n\t\t\tvect = default.MapSpecs[default.Indexes[i].index].Location;\n\t\t\trot.Pitch = (-3200) * default.MapSpecs[default.Indexes[i].index].RotSlope;\n            return true;\n        }\n    }\n\n\treturn false;\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [
                            "static"
                        ],
                        "name": "GetSpectatorStartPoint",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "map"
                            ],
                            [
                                "out",
                                "vector",
                                "vect"
                            ],
                            [
                                "out",
                                "rotator",
                                "rot"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 56,
                "replication": "",
                "states": [],
                "variables": [
                    "var string MapName;",
                    "var int index;",
                    "var vector Location;",
                    "var int RotSlope;",
                    "var MapIndex Indexes[10];",
                    "var config DefSpecPosAndRot MapSpecs[7];"
                ]
            }
        },
        "TCStorageBox.uc": {
            "body": "//=============================================================================\n// DeusExCarcass.\n//=============================================================================\nclass TCStorageBox extends Containers;\n\nstruct InventoryItemCarcass  {\n\tvar() class<Inventory> Inventory;\n\tvar() int              count;\n};\n\nvar(Inventory) InventoryItemCarcass InitialInventory[8];  // Initial inventory items held in the carcass\nvar bool bQueuedDestroy;\n\nvar string OwnerName, myName;\nvar bool bLocked;\n\nreplication\n{\n    reliable if (ROLE == ROLE_Authority)\n\t\tOwnerName, myName;\n}\nfunction PostBeginPlay()\n{\n\tlocal int i, j;\n\tlocal Inventory inv;\n\n\tbCollideWorld = true;\n\t// Add initial inventory items\n\tfor (i=0; i<8; i++)\n\t{\n\t\tif ((InitialInventory[i].inventory != None) && (InitialInventory[i].count > 0))\n\t\t{\n\t\t\tfor (j=0; j<InitialInventory[i].count; j++)\n\t\t\t{\n\t\t\t\tinv = spawn(InitialInventory[i].inventory, self);\n\t\t\t\tif (inv != None)\n\t\t\t\t{\n\t\t\t\t\tinv.bHidden = True;\n\t\t\t\t\tinv.SetPhysics(PHYS_None);\n\t\t\t\t\tAddInventory(inv);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tSuper.PostBeginPlay();\n}\n\n\nfunction Frob(Actor Frobber, Inventory frobWith)\n{\n\tlocal Inventory item, nextItem, startItem;\n\tlocal Pawn P;\n\tlocal DeusExWeapon W;\n\tlocal bool bFoundSomething;\n\tlocal DeusExPlayer player;\n\tlocal ammo AmmoType;\n\tlocal bool bPickedItemUp;\n\tlocal POVCorpse corpse;\n\tlocal DeusExPickup invItem;\n\tlocal int itemCount;\n\tlocal bool bDontDestroy;\n\t\n\tplayer = DeusExPlayer(Frobber);\n\n\tif (bQueuedDestroy)\n\t\treturn;\n\n\tif(bLocked)\n\t{\n\t\tplayer.ClientMessage(\"It's locked.\");\n\t\treturn;\n\t}\n\tbFoundSomething = False;\n\t//bSearchMsgPrinted = False;\n\tP = Pawn(Frobber);\n\tif (P != None)\n\t{\n\n\t\tif (Inventory != None)\n\t\t{\n\n\t\t\titem = Inventory;\n\t\t\tstartItem = item;\n\n\t\t\tdo\n\t\t\t{\n\n\t\t\t\tnextItem = item.Inventory;\n\n\t\t\t\tbPickedItemUp = False;\n\n\t\t\t\tif (item.IsA('Ammo'))\n\t\t\t\t{\n\t\t\t\t\t// Only let the player pick up ammo that's already in a weapon\n\t\t\t\t\tDeleteInventory(item);\n\t\t\t\t\titem.Destroy();\n\t\t\t\t\titem = None;\n\t\t\t\t}\n\t\t\t\telse if ( (item.IsA('DeusExWeapon')) )\n\t\t\t\t{\n               // Any weapons have their ammo set to a random number of rounds (1-4)\n               // unless it's a grenade, in which case we only want to dole out one.\n               // DEUS_EX AMSD In multiplayer, give everything away.\n               W = DeusExWeapon(item);\n               \n               // Grenades and LAMs always pickup 1\n               if (W.IsA('WeaponNanoVirusGrenade') || \n                  W.IsA('WeaponGasGrenade') || \n                  W.IsA('WeaponEMPGrenade') ||\n                  W.IsA('WeaponLAM'))\n                  W.PickupAmmoCount = 1;\n               else if (Level.NetMode == NM_Standalone)\n                  W.PickupAmmoCount = Rand(4) + 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (item != None)\n\t\t\t\t{\n\t\t\t\t\tbFoundSomething = True;\n\n\t\t\t\t\tif (item.IsA('DeusExWeapon'))   // I *really* hate special cases\n\t\t\t\t\t{\n\t\t\t\t\t\t// Okay, check to see if the player already has this weapon.  If so,\n\t\t\t\t\t\t// then just give the ammo and not the weapon.  Otherwise give\n\t\t\t\t\t\t// the weapon normally. \n\t\t\t\t\t\tW = DeusExWeapon(player.FindInventoryType(item.Class));\n\n\t\t\t\t\t\t// If the player already has this item in his inventory, piece of cake,\n\t\t\t\t\t\t// we just give him the ammo.  However, if the Weapon is *not* in the \n\t\t\t\t\t\t// player's inventory, first check to see if there's room for it.  If so,\n\t\t\t\t\t\t// then we'll give it to him normally.  If there's *NO* room, then we \n\t\t\t\t\t\t// want to give the player the AMMO only (as if the player already had \n\t\t\t\t\t\t// the weapon).\n\n\t\t\t\t\t\tif ((W != None) || ((W == None) && (!player.FindInventorySlot(item, True))))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Don't bother with this is there's no ammo\n\t\t\t\t\t\t\tif ((Weapon(item).AmmoType != None) && (Weapon(item).AmmoType.AmmoAmount > 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAmmoType = Ammo(player.FindInventoryType(Weapon(item).AmmoName));\n\n                        if ((AmmoType != None) && (AmmoType.AmmoAmount < AmmoType.MaxAmmo))\n\t\t\t\t\t\t\t\t{\n                           AmmoType.AddAmmo(Weapon(item).PickupAmmoCount);\n                           AddReceivedItem(player, AmmoType, Weapon(item).PickupAmmoCount);\n                           \n\t\t\t\t\t\t\t\t\t// Update the ammo display on the object belt\n\t\t\t\t\t\t\t\t\tplayer.UpdateAmmoBeltText(AmmoType);\n\n\t\t\t\t\t\t\t\t\t// if this is an illegal ammo type, use the weapon name to print the message\n\t\t\t\t\t\t\t\t\tif (AmmoType.PickupViewMesh == Mesh'TestBox')\n\t\t\t\t\t\t\t\t\t\tP.ClientMessage(item.PickupMessage @ item.itemArticle @ item.itemName, 'Pickup');\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tP.ClientMessage(AmmoType.PickupMessage @ AmmoType.itemArticle @ AmmoType.itemName, 'Pickup');\n\n\t\t\t\t\t\t\t\t\t// Mark it as 0 to prevent it from being added twice\n\t\t\t\t\t\t\t\t\tWeapon(item).AmmoType.AmmoAmount = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Print a message \"Cannot pickup blah blah blah\" if inventory is full\n\t\t\t\t\t\t\t// and the player can't pickup this weapon, so the player at least knows\n\t\t\t\t\t\t\t// if he empties some inventory he can get something potentially cooler\n\t\t\t\t\t\t\t// than he already has. \n\t\t\t\t\t\t\tif ((W == None) && (!player.FindInventorySlot(item, True)))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbDontDestroy=True;\n\t\t\t\t\t\t\t\t\tP.ClientMessage(Sprintf(Player.InventoryFull, item.itemName));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Only destroy the weapon if the player already has it.\n\t\t\t\t\t\t\tif (W != None)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Destroy the weapon, baby!\n\t\t\t\t\t\t\t\tDeleteInventory(item);\n\t\t\t\t\t\t\t\titem.Destroy();\n\t\t\t\t\t\t\t\titem = None;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbPickedItemUp = True;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse if (item.IsA('DeusExAmmo'))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (DeusExAmmo(item).AmmoAmount == 0)\n\t\t\t\t\t\t\tbPickedItemUp = True;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!bPickedItemUp)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Special case if this is a DeusExPickup(), it can have multiple copies\n\t\t\t\t\t\t// and the player already has it.\n\n\t\t\t\t\t\tif ((item.IsA('DeusExPickup')) && (DeusExPickup(item).bCanHaveMultipleCopies) && (player.FindInventoryType(item.class) != None))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinvItem   = DeusExPickup(player.FindInventoryType(item.class));\n\t\t\t\t\t\t\titemCount = DeusExPickup(item).numCopies;\n\n\t\t\t\t\t\t\t// Make sure the player doesn't have too many copies\n\t\t\t\t\t\t\tif ((invItem.MaxCopies > 0) && (DeusExPickup(item).numCopies + invItem.numCopies > invItem.MaxCopies))\n\t\t\t\t\t\t\t{\t\n\t\t\t\t\t\t\t\t// Give the player the max #\n\t\t\t\t\t\t\t\tif ((invItem.MaxCopies - invItem.numCopies) > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\titemCount = (invItem.MaxCopies - invItem.numCopies);\n\t\t\t\t\t\t\t\t\tDeusExPickup(item).numCopies -= itemCount;\n\t\t\t\t\t\t\t\t\tinvItem.numCopies = invItem.MaxCopies;\n\t\t\t\t\t\t\t\t\tP.ClientMessage(invItem.PickupMessage @ invItem.itemArticle @ invItem.itemName, 'Pickup');\n\t\t\t\t\t\t\t\t\tAddReceivedItem(player, invItem, itemCount);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbDontDestroy=True;\n\t\t\t\t\t\t\t\t\tP.ClientMessage(\"No room for \"$invItem.itemName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinvItem.numCopies += itemCount;\n\t\t\t\t\t\t\t\tDeleteInventory(item);\n\n\t\t\t\t\t\t\t\tP.ClientMessage(invItem.PickupMessage @ invItem.itemArticle @ invItem.itemName, 'Pickup');\n\t\t\t\t\t\t\t\tAddReceivedItem(player, invItem, itemCount);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// check if the pawn is allowed to pick this up\n\t\t\t\t\t\t\tif ((P.Inventory == None) || (Level.Game.PickupQuery(P, item)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDeusExPlayer(P).FrobTarget = item;\n\t\t\t\t\t\t\t\tif (DeusExPlayer(P).HandleItemPickup(Item) != False)\n\t\t\t\t\t\t\t\t{\n                           DeleteInventory(item);\n\n                           // DEUS_EX AMSD Belt info isn't always getting cleaned up.  Clean it up.\n                           item.bInObjectBelt=False;\n                           item.BeltPos=-1;\n\t\t\t\t\t\t\t\t\t\n                           item.SpawnCopy(P);\n\n\t\t\t\t\t\t\t\t\t// Show the item received in the ReceivedItems window and also \n\t\t\t\t\t\t\t\t\t// display a line in the Log\n\t\t\t\t\t\t\t\t\tAddReceivedItem(player, item, 1);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tP.ClientMessage(Item.PickupMessage @ Item.itemArticle @ Item.itemName, 'Pickup');\n\t\t\t\t\t\t\t\t\tPlaySound(Item.PickupSound);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDeleteInventory(item);\n\t\t\t\t\t\t\t\titem.Destroy();\n\t\t\t\t\t\t\t\titem = None;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\titem = nextItem;\n\t\t\t}\n\t\t\tuntil ((item == None) || (item == startItem));\n\t\t}\n\n//log(\"  bFoundSomething = \" $ bFoundSomething);\n\n\t\tif (!bFoundSomething)\n\t\t\tP.ClientMessage(\"Empty...\");\n\t}\n\n\tSuper.Frob(Frobber, frobWith);\n\n   if ((Level.Netmode != NM_Standalone) && (Player != None) && !bDontDestroy)   \n   {\n\t   bQueuedDestroy = true;\n\t   //Destroy();\t \n\t   bInvincible=False;\n\t   TakeDamage(1000,P, vect(0,0,0), vect(0,0,0),'Tantalus');\n   }\n}\n\n// ----------------------------------------------------------------------\n// AddReceivedItem()\n// ----------------------------------------------------------------------\n\nfunction AddReceivedItem(DeusExPlayer player, Inventory item, int count)\n{\n\tlocal DeusExWeapon w;\n\tlocal Inventory altAmmo;\n\n   DeusExRootWindow(player.rootWindow).hud.receivedItems.AddItem(item, 1);\n\n\t// Make sure the object belt is updated\n\tif (item.IsA('Ammo'))\n\t\tplayer.UpdateAmmoBeltText(Ammo(item));\n\telse\n\t\tplayer.UpdateBeltText(item);\n\n\t// Deny 20mm and WP rockets off of bodies in multiplayer\n\tif ( Level.NetMode != NM_Standalone )\n\t{\n\t\tif ( item.IsA('WeaponAssaultGun') || item.IsA('WeaponGEPGun') )\n\t\t{\n\t\t\tw = DeusExWeapon(player.FindInventoryType(item.Class));\n\t\t\tif (( Ammo20mm(w.AmmoType) != None ) || ( AmmoRocketWP(w.AmmoType) != None ))\n\t\t\t{\n\t\t\t\taltAmmo = Spawn( w.AmmoNames[0] );\n\t\t\t\tDeusExAmmo(altAmmo).AmmoAmount = w.PickupAmmoCount;\n\t\t\t\taltAmmo.Frob(player,None);\n\t\t\t\taltAmmo.Destroy();\n\t\t\t\tw.AmmoType.Destroy();\n\t\t\t\tw.LoadAmmo( 0 );\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ----------------------------------------------------------------------\n// AddInventory()\n//\n// copied from Engine.Pawn\n// Add Item to this carcasses inventory. \n// Returns true if successfully added, false if not.\n// ----------------------------------------------------------------------\n\nfunction bool AddInventory( inventory NewItem )\n{\n\t// Skip if already in the inventory.\n\tlocal inventory Inv;\n\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )\n\t\tif( Inv == NewItem )\n\t\t\treturn false;\n\n\t// The item should not have been destroyed if we get here.\n\tassert(NewItem!=None);\n\n\t// Add to front of inventory chain.\n\tNewItem.SetOwner(Self);\n\tNewItem.Inventory = Inventory;\n\tNewItem.InitialState = 'Idle2';\n\tInventory = NewItem;\n\n\treturn true;\n}\n\n// ----------------------------------------------------------------------\n// DeleteInventory()\n// \n// copied from Engine.Pawn\n// Remove Item from this pawn's inventory, if it exists.\n// Returns true if it existed and was deleted, false if it did not exist.\n// ----------------------------------------------------------------------\n\nfunction bool DeleteInventory( inventory Item )\n{\n\t// If this item is in our inventory chain, unlink it.\n\tlocal actor Link;\n\n\tfor( Link = Self; Link!=None; Link=Link.Inventory )\n\t{\n\t\tif( Link.Inventory == Item )\n\t\t{\n\t\t\tLink.Inventory = Item.Inventory;\n\t\t\tbreak;\n\t\t}\n\t}\n   Item.SetOwner(None);\n}\n\ndefaultproperties\n{\n\t bPushable=False\n FragType=Class'DeusEx.WoodFragment'\n bInvincible=True\n     ItemName=\"Storage Crate\"\n     bBlockSight=True\n     Skin=Texture'DeusExDeco.Skins.CrateBreakableMedTex3'\n     Mesh=LodMesh'DeusExDeco.CrateBreakableMed'\n     CollisionRadius=34.000000\n     CollisionHeight=24.000000\n     Mass=50.000000\n     Buoyancy=60.000000\n}\n",
            "name": "TCStorageBox.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bPushable=False",
                    "FragType=Class'DeusEx.WoodFragment'",
                    "bInvincible=True",
                    "ItemName=\"Storage Crate\"",
                    "bBlockSight=True",
                    "Skin=Texture'DeusExDeco.Skins.CrateBreakableMedTex3'",
                    "Mesh=LodMesh'DeusExDeco.CrateBreakableMed'",
                    "CollisionRadius=34.000000",
                    "CollisionHeight=24.000000",
                    "Mass=50.000000",
                    "Buoyancy=60.000000"
                ],
                "exec": [],
                "extends": "Containers",
                "functions": {
                    "AddInventory": {
                        "body": "{\n\t// Skip if already in the inventory.\n\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )\n\t\tif( Inv == NewItem )\n\t\t\treturn false;\n\n\t// The item should not have been destroyed if we get here.\n\tassert(NewItem!=None);\n\n\t// Add to front of inventory chain.\n\tNewItem.SetOwner(Self);\n\tNewItem.Inventory = Inventory;\n\tNewItem.InitialState = 'Idle2';\n\tInventory = NewItem;\n\n\treturn true;\n}",
                        "locals": [
                            "local inventory Inv;"
                        ],
                        "modifiers": [],
                        "name": "AddInventory",
                        "native": false,
                        "param": [
                            [
                                "inventory",
                                "NewItem"
                            ]
                        ],
                        "return": "bool"
                    },
                    "AddReceivedItem": {
                        "body": "{\n\n   DeusExRootWindow(player.rootWindow).hud.receivedItems.AddItem(item, 1);\n\n\t// Make sure the object belt is updated\n\tif (item.IsA('Ammo'))\n\t\tplayer.UpdateAmmoBeltText(Ammo(item));\n\telse\n\t\tplayer.UpdateBeltText(item);\n\n\t// Deny 20mm and WP rockets off of bodies in multiplayer\n\tif ( Level.NetMode != NM_Standalone )\n\t{\n\t\tif ( item.IsA('WeaponAssaultGun') || item.IsA('WeaponGEPGun') )\n\t\t{\n\t\t\tw = DeusExWeapon(player.FindInventoryType(item.Class));\n\t\t\tif (( Ammo20mm(w.AmmoType) != None ) || ( AmmoRocketWP(w.AmmoType) != None ))\n\t\t\t{\n\t\t\t\taltAmmo = Spawn( w.AmmoNames[0] );\n\t\t\t\tDeusExAmmo(altAmmo).AmmoAmount = w.PickupAmmoCount;\n\t\t\t\taltAmmo.Frob(player,None);\n\t\t\t\taltAmmo.Destroy();\n\t\t\t\tw.AmmoType.Destroy();\n\t\t\t\tw.LoadAmmo( 0 );\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local DeusExWeapon w;",
                            "local Inventory altAmmo;"
                        ],
                        "modifiers": [],
                        "name": "AddReceivedItem",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "player"
                            ],
                            [
                                "Inventory",
                                "item"
                            ],
                            [
                                "int",
                                "count"
                            ]
                        ],
                        "return": ""
                    },
                    "DeleteInventory": {
                        "body": "{\n\t// If this item is in our inventory chain, unlink it.\n\n\tfor( Link = Self; Link!=None; Link=Link.Inventory )\n\t{\n\t\tif( Link.Inventory == Item )\n\t\t{\n\t\t\tLink.Inventory = Item.Inventory;\n\t\t\tbreak;\n\t\t}\n\t}\n   Item.SetOwner(None);\n}",
                        "locals": [
                            "local actor Link;"
                        ],
                        "modifiers": [],
                        "name": "DeleteInventory",
                        "native": false,
                        "param": [
                            [
                                "inventory",
                                "Item"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Frob": {
                        "body": "{\n\t\n\tplayer = DeusExPlayer(Frobber);\n\n\tif (bQueuedDestroy)\n\t\treturn;\n\n\tif(bLocked)\n\t{\n\t\tplayer.ClientMessage(\"It's locked.\");\n\t\treturn;\n\t}\n\tbFoundSomething = False;\n\t//bSearchMsgPrinted = False;\n\tP = Pawn(Frobber);\n\tif (P != None)\n\t{\n\n\t\tif (Inventory != None)\n\t\t{\n\n\t\t\titem = Inventory;\n\t\t\tstartItem = item;\n\n\t\t\tdo\n\t\t\t{\n\n\t\t\t\tnextItem = item.Inventory;\n\n\t\t\t\tbPickedItemUp = False;\n\n\t\t\t\tif (item.IsA('Ammo'))\n\t\t\t\t{\n\t\t\t\t\t// Only let the player pick up ammo that's already in a weapon\n\t\t\t\t\tDeleteInventory(item);\n\t\t\t\t\titem.Destroy();\n\t\t\t\t\titem = None;\n\t\t\t\t}\n\t\t\t\telse if ( (item.IsA('DeusExWeapon')) )\n\t\t\t\t{\n               // Any weapons have their ammo set to a random number of rounds (1-4)\n               // unless it's a grenade, in which case we only want to dole out one.\n               // DEUS_EX AMSD In multiplayer, give everything away.\n               W = DeusExWeapon(item);\n               \n               // Grenades and LAMs always pickup 1\n               if (W.IsA('WeaponNanoVirusGrenade') || \n                  W.IsA('WeaponGasGrenade') || \n                  W.IsA('WeaponEMPGrenade') ||\n                  W.IsA('WeaponLAM'))\n                  W.PickupAmmoCount = 1;\n               else if (Level.NetMode == NM_Standalone)\n                  W.PickupAmmoCount = Rand(4) + 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (item != None)\n\t\t\t\t{\n\t\t\t\t\tbFoundSomething = True;\n\n\t\t\t\t\tif (item.IsA('DeusExWeapon'))   // I *really* hate special cases\n\t\t\t\t\t{\n\t\t\t\t\t\t// Okay, check to see if the player already has this weapon.  If so,\n\t\t\t\t\t\t// then just give the ammo and not the weapon.  Otherwise give\n\t\t\t\t\t\t// the weapon normally. \n\t\t\t\t\t\tW = DeusExWeapon(player.FindInventoryType(item.Class));\n\n\t\t\t\t\t\t// If the player already has this item in his inventory, piece of cake,\n\t\t\t\t\t\t// we just give him the ammo.  However, if the Weapon is *not* in the \n\t\t\t\t\t\t// player's inventory, first check to see if there's room for it.  If so,\n\t\t\t\t\t\t// then we'll give it to him normally.  If there's *NO* room, then we \n\t\t\t\t\t\t// want to give the player the AMMO only (as if the player already had \n\t\t\t\t\t\t// the weapon).\n\n\t\t\t\t\t\tif ((W != None) || ((W == None) && (!player.FindInventorySlot(item, True))))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Don't bother with this is there's no ammo\n\t\t\t\t\t\t\tif ((Weapon(item).AmmoType != None) && (Weapon(item).AmmoType.AmmoAmount > 0))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tAmmoType = Ammo(player.FindInventoryType(Weapon(item).AmmoName));\n\n                        if ((AmmoType != None) && (AmmoType.AmmoAmount < AmmoType.MaxAmmo))\n\t\t\t\t\t\t\t\t{\n                           AmmoType.AddAmmo(Weapon(item).PickupAmmoCount);\n                           AddReceivedItem(player, AmmoType, Weapon(item).PickupAmmoCount);\n                           \n\t\t\t\t\t\t\t\t\t// Update the ammo display on the object belt\n\t\t\t\t\t\t\t\t\tplayer.UpdateAmmoBeltText(AmmoType);\n\n\t\t\t\t\t\t\t\t\t// if this is an illegal ammo type, use the weapon name to print the message\n\t\t\t\t\t\t\t\t\tif (AmmoType.PickupViewMesh == Mesh'TestBox')\n\t\t\t\t\t\t\t\t\t\tP.ClientMessage(item.PickupMessage @ item.itemArticle @ item.itemName, 'Pickup');\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tP.ClientMessage(AmmoType.PickupMessage @ AmmoType.itemArticle @ AmmoType.itemName, 'Pickup');\n\n\t\t\t\t\t\t\t\t\t// Mark it as 0 to prevent it from being added twice\n\t\t\t\t\t\t\t\t\tWeapon(item).AmmoType.AmmoAmount = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Print a message \"Cannot pickup blah blah blah\" if inventory is full\n\t\t\t\t\t\t\t// and the player can't pickup this weapon, so the player at least knows\n\t\t\t\t\t\t\t// if he empties some inventory he can get something potentially cooler\n\t\t\t\t\t\t\t// than he already has. \n\t\t\t\t\t\t\tif ((W == None) && (!player.FindInventorySlot(item, True)))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbDontDestroy=True;\n\t\t\t\t\t\t\t\t\tP.ClientMessage(Sprintf(Player.InventoryFull, item.itemName));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Only destroy the weapon if the player already has it.\n\t\t\t\t\t\t\tif (W != None)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Destroy the weapon, baby!\n\t\t\t\t\t\t\t\tDeleteInventory(item);\n\t\t\t\t\t\t\t\titem.Destroy();\n\t\t\t\t\t\t\t\titem = None;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbPickedItemUp = True;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telse if (item.IsA('DeusExAmmo'))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (DeusExAmmo(item).AmmoAmount == 0)\n\t\t\t\t\t\t\tbPickedItemUp = True;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!bPickedItemUp)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Special case if this is a DeusExPickup(), it can have multiple copies\n\t\t\t\t\t\t// and the player already has it.\n\n\t\t\t\t\t\tif ((item.IsA('DeusExPickup')) && (DeusExPickup(item).bCanHaveMultipleCopies) && (player.FindInventoryType(item.class) != None))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinvItem   = DeusExPickup(player.FindInventoryType(item.class));\n\t\t\t\t\t\t\titemCount = DeusExPickup(item).numCopies;\n\n\t\t\t\t\t\t\t// Make sure the player doesn't have too many copies\n\t\t\t\t\t\t\tif ((invItem.MaxCopies > 0) && (DeusExPickup(item).numCopies + invItem.numCopies > invItem.MaxCopies))\n\t\t\t\t\t\t\t{\t\n\t\t\t\t\t\t\t\t// Give the player the max #\n\t\t\t\t\t\t\t\tif ((invItem.MaxCopies - invItem.numCopies) > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\titemCount = (invItem.MaxCopies - invItem.numCopies);\n\t\t\t\t\t\t\t\t\tDeusExPickup(item).numCopies -= itemCount;\n\t\t\t\t\t\t\t\t\tinvItem.numCopies = invItem.MaxCopies;\n\t\t\t\t\t\t\t\t\tP.ClientMessage(invItem.PickupMessage @ invItem.itemArticle @ invItem.itemName, 'Pickup');\n\t\t\t\t\t\t\t\t\tAddReceivedItem(player, invItem, itemCount);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tbDontDestroy=True;\n\t\t\t\t\t\t\t\t\tP.ClientMessage(\"No room for \"$invItem.itemName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tinvItem.numCopies += itemCount;\n\t\t\t\t\t\t\t\tDeleteInventory(item);\n\n\t\t\t\t\t\t\t\tP.ClientMessage(invItem.PickupMessage @ invItem.itemArticle @ invItem.itemName, 'Pickup');\n\t\t\t\t\t\t\t\tAddReceivedItem(player, invItem, itemCount);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// check if the pawn is allowed to pick this up\n\t\t\t\t\t\t\tif ((P.Inventory == None) || (Level.Game.PickupQuery(P, item)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDeusExPlayer(P).FrobTarget = item;\n\t\t\t\t\t\t\t\tif (DeusExPlayer(P).HandleItemPickup(Item) != False)\n\t\t\t\t\t\t\t\t{\n                           DeleteInventory(item);\n\n                           // DEUS_EX AMSD Belt info isn't always getting cleaned up.  Clean it up.\n                           item.bInObjectBelt=False;\n                           item.BeltPos=-1;\n\t\t\t\t\t\t\t\t\t\n                           item.SpawnCopy(P);\n\n\t\t\t\t\t\t\t\t\t// Show the item received in the ReceivedItems window and also \n\t\t\t\t\t\t\t\t\t// display a line in the Log\n\t\t\t\t\t\t\t\t\tAddReceivedItem(player, item, 1);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tP.ClientMessage(Item.PickupMessage @ Item.itemArticle @ Item.itemName, 'Pickup');\n\t\t\t\t\t\t\t\t\tPlaySound(Item.PickupSound);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tDeleteInventory(item);\n\t\t\t\t\t\t\t\titem.Destroy();\n\t\t\t\t\t\t\t\titem = None;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\titem = nextItem;\n\t\t\t}\n\t\t\tuntil ((item == None) || (item == startItem));\n\t\t}\n\n//log(\"  bFoundSomething = \" $ bFoundSomething);\n\n\t\tif (!bFoundSomething)\n\t\t\tP.ClientMessage(\"Empty...\");\n\t}\n\n\tSuper.Frob(Frobber, frobWith);\n\n   if ((Level.Netmode != NM_Standalone) && (Player != None) && !bDontDestroy)   \n   {\n\t   bQueuedDestroy = true;\n\t   //Destroy();\t \n\t   bInvincible=False;\n\t   TakeDamage(1000,P, vect(0,0,0), vect(0,0,0),'Tantalus');\n   }\n}",
                        "locals": [
                            "local Inventory item, nextItem, startItem;",
                            "local Pawn P;",
                            "local DeusExWeapon W;",
                            "local bool bFoundSomething;",
                            "local DeusExPlayer player;",
                            "local ammo AmmoType;",
                            "local bool bPickedItemUp;",
                            "local POVCorpse corpse;",
                            "local DeusExPickup invItem;",
                            "local int itemCount;",
                            "local bool bDontDestroy;"
                        ],
                        "modifiers": [],
                        "name": "Frob",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Frobber"
                            ],
                            [
                                "Inventory",
                                "frobWith"
                            ]
                        ],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\n\tbCollideWorld = true;\n\t// Add initial inventory items\n\tfor (i=0; i<8; i++)\n\t{\n\t\tif ((InitialInventory[i].inventory != None) && (InitialInventory[i].count > 0))\n\t\t{\n\t\t\tfor (j=0; j<InitialInventory[i].count; j++)\n\t\t\t{\n\t\t\t\tinv = spawn(InitialInventory[i].inventory, self);\n\t\t\t\tif (inv != None)\n\t\t\t\t{\n\t\t\t\t\tinv.bHidden = True;\n\t\t\t\t\tinv.SetPhysics(PHYS_None);\n\t\t\t\t\tAddInventory(inv);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tSuper.PostBeginPlay();\n}",
                        "locals": [
                            "local int i, j;",
                            "local Inventory inv;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 386,
                "replication": "",
                "states": [],
                "variables": [
                    "var() class<Inventory> Inventory;",
                    "var() int              count;",
                    "var(Inventory) InventoryItemCarcass InitialInventory[8];  // Initial inventory items held in the carcass",
                    "var bool bQueuedDestroy;",
                    "var string OwnerName, myName;",
                    "var bool bLocked;"
                ]
            }
        },
        "TCTeam.uc": {
            "body": "class TCTeam extends MTLTeam;\n\nvar bool bCBP;\nvar string GTName;\nvar bool bDisableDefaultScoring; //Manual override for custom gametype extentions that use their own scoring system\nvar class<TCPlayer> Team0PlayerClass;\nvar class<TCPlayer> Team1PlayerClass;\nvar int InitialTeam;\nvar int ReplMaxPlayers;\nvar bool bShowAdmins, bShowMods, bShowStatus, bShowFPS, bShowPing, bDrawServerInfo, bShowDT;\nvar texture ScoreboardTex;\nvar string ScoreboardExtStr;\nvar int spectatorCount, playerCount;\nvar TCControls Settings;\nvar string SDStr;\nvar bool bSDFound;\nvar string rVer;\nvar bool bSpectatorStart;\n\nstruct ScoreBoardInfo\n{\n\tvar string GameType;\n    var string ServerName;\n    var int NumPlayers;\n    var int MaxPlayers;\n    var string Map;\n};\n\nvar ScoreBoardInfo SBInfo;\nvar int SpecCountUNATCO;\nvar int SpecCountNSF;\n\nstruct PlayerInfo\n{\n\tvar bool bDead;\n     var bool bAdmin;\n     var int ping;\n     var bool bIsSpectator;\n\t var int SpectatedPlayerID;\n\t var string SpectatedPlayerName;\n\t var bool bModerator;\n\t var bool bKaiz0r;\n\t var bool bSuperAdmin;\n\t var bool bServerOwner;\n\t var bool bMuted;\n\t var bool bBot;\n\t var string Status;\n\t var bool bAway;\n\t var int FPS;\n\t var int DT;\n\t var bool bSilentAdmin;\n\t var bool bRealPlayer;\n\t var bool bJuggernaut;\n};\n\nvar PlayerInfo PInfo[32]; //Array of the additional structure for 32 players\n/** @ignore */\nvar PlayerInfo PI[32];\n\nconst IDX       = 0.22;\nconst PlayerX\t= 0.27;\nconst KillsX\t= 0.53;\nconst DeathsX\t= 0.60;\nconst StreakX\t= 0.67;\n//const PINGX     = 0.74;\nconst FPSX      = 0.72;\nconst DTX       = 0.75;\nconst PINGX     = 0.83;\n\nconst ADMINX_OFFSET = 130;\nconst SPECTX_OFFSET = 200;\n\nvar string NextMapText;\nvar bool bReflectiveDamage;\n\nreplication\n{\n    reliable if (Role == ROLE_Authority)\n \t\tReplMaxPlayers, bShowStatus, bShowAdmins, bShowMods, bShowFPS, bShowPing, ScoreboardTex, ScoreboardExtStr, bDrawServerInfo, bSDFound, SDStr, rVer;\n\n\tunreliable if (Role == ROLE_Authority)\n\t\tNextMapText;\n}\n\nfunction PlayEnterBarks(TCPlayer P)\n{\n\tlocal int r;\n\tlocal TCPlayer TCP;\n\n\tr = Rand(7);\n\tif(r == 0)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_121\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 1)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_155\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 2)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_179\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 3)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_354\", class'Sound', true)),SLOT_Talk);\t\n\telse if(r == 4)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_229\", class'Sound', true)),SLOT_Talk);\t\n\telse if(r == 5)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_217\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 6)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_226\", class'Sound', true)),SLOT_Talk);\n\tforeach AllActors(class'TCPlayer', TCP)\n\t\tif(TCP.PlayerReplicationInfo.Team == P.PlayerReplicationInfo.Team && TCP != P)\n\t\t\tTCP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_596\", class'Sound', true)),SLOT_Talk);\n}\n\nexec function ConsoleKick(int playerID)\n{\n    Settings.serverKick(playerID);\n}\n\nexec function ConsoleKickBan(int playerID)\n{\n    Settings.serverBan(playerID);\n}\n\nexec function ConsolePlayerList()\n{\n    Settings.serverPlayerList();\n}\n\nexec function CUpdate()\n{\n    Settings.UpdateCheck();\n}\n\nexec function Say2(string str)\n{\n    Settings.serverSay2(str);\n}\n\nexec function Say3(string str)\n{\n\tSettings.serverSay3(str);\n}\n\nexec function Athena(string str)\n{\n\tSettings.ServerSayAthena(str);\n}\n\nexec function st(string str)\n{\n    ConsoleCommand(\"servertravel \"$str);\n}\n\nexec function SetSD(int sdHours, int sdMins)\n{\n\tSettings.SetShutdownTime(sdHours, sdMins);\n}\n\nexec function SDIn(int mins)\n{\n\tSettings.SetShutdownIn(mins);\n}\n\nexec function CheckSD()\n{\n\tSettings.CheckSD();\n}\n\nexec function AbortSD()\n{\n\tSettings.CancelSD();\n}\n\nsimulated function ContinueMsg( GC gc, float screenWidth, float screenHeight )\n{\n\tlocal String str;\n\tlocal float x, y, w, h;\n\tlocal int t;\n\n\tif ( bNewMap && !bClientNewMap)\n\t{\n\t\tNewMapTime = Level.Timeseconds + NewMapDelay - 0.5;\n\t\tbClientNewMap = True;\n\t}\n\tt = int(NewMapTime - Level.Timeseconds);\n\tif ( t < 0 )\n\t\tt = 0;\n\n\tstr = t $ NewMapSecondsString;\n\n\tif (NextMapText != \"\")\n\t{\n\t\tstr = Left(str, Len(str) - 1);\n\t\tstr = str $ \": \" $ NextMapText;\n\t}\n\n\tgc.SetTextColor( WhiteColor );\n\tgc.SetFont(Font'FontMenuTitle');\n\tgc.GetTextExtent( 0, w, h, str );\n\tx = (screenWidth * 0.5) - (w * 0.5);\n\ty = screenHeight * FireContY;\n\tgc.DrawText( x, y, w, h, str );\n\n\ty += (h*2.0);\n\tstr = EscapeString;\n\tgc.GetTextExtent( 0, w, h, str );\n\tx = (screenWidth * 0.5) - (w * 0.5);\n\tgc.DrawText( x, y, w, h, str );\n}\n\nevent InitGame( string Options, out string Error )\n{\n    super.InitGame(Options,Error); \n\tReplMaxPlayers = MaxPlayers;\n}\n\nfunction Timer()\n{\n   local string URLstr;\n\tlocal DXMapList mapList;\n\tlocal string gtv;\n\tif ( bCycleMap )\n\t{\n      mapList = Spawn(class'DXMapList');\n      URLstr = mapList.GetNextMap();\n      mapList.Destroy();\n      bCycleMap = False;\n      \n      gtv = Settings.Votez.FinalVoteStr;\n      \n      if(gtv != \"\")\n\t\tLevel.ServerTravel( URLstr$\"?Game=OpenDX.\"$gtv, False );\n\telse\n\t\tLevel.ServerTravel( URLstr, False );\n\t\t\n      bFreezeScores = False;\n\t}\n}\n\nfunction GameOver()\n{\t\t\t\n   super.GameOver();\n}\n\nevent PlayerPawn Login(string Portal, string URL, out string Error, Class<PlayerPawn> SpawnClass)\n{\n\tlocal MTLPlayer newPlayer;\n\tlocal int Z5C;\n\tlocal string Z5D;\n\tlocal TCPlayer mmplayer;\n\tlocal class<TCPlayer> Skins[2];\n\n\tif ( (MaxPlayers > 0) && (NumPlayers >= MaxPlayers) )\n\t{\n\t\tError=TooManyPlayers;\n\t\treturn None;\n\t}\n\n\tZ5C = 128;\n\tif (HasOption(URL, \"Team\"))\n\t{\n\t\tZ5D = ParseOption(URL, \"Team\");\n\t\tif (Z5D != \"\") Z5C = int(Z5D);\n\t}\n\tif (Z5C != 1 && Z5C != 0) Z5C = GetAutoTeam();\n\tif (Z5C == 1) SpawnClass = Team1PlayerClass;\n\telse SpawnClass = Team0PlayerClass;\n\tInitialTeam = Z5C;\n\n\tChangeOption(URL, \"Class\", string(SpawnClass));\n\tChangeOption(URL, \"Team\", string(Z5C));\n\tnewPlayer = MTLPlayer(Super(DeusExMPGame).Login(Portal, URL, Error, SpawnClass));\n\tmmplayer = TCPlayer(newPlayer);\n\tif (mmplayer != None)\n\t{\n\t\tmmplayer.FixName(mmplayer.PlayerReplicationInfo.PlayerName);\n\t}\n\treturn newPlayer;\n}\n\nfunction PostBeginPlay()\n{\n    super.PostBeginPlay();\n    ReplMaxPlayers = MaxPlayers;\n    Settings = Spawn(class'TCControls', self);\n    bShowStatus = Settings.bShowStatus;\n\tbShowAdmins = Settings.bShowAdmins;\n\tbShowMods = Settings.bShowMods;\n\tScoreboardTex = Settings.ScoreboardTex;\n\tScoreboardExtStr = Settings.ScoreboardExtStr;\n\tbDrawServerInfo = Settings.bDrawServerInfo;\n\tbSpectatorStart = Settings.bSpectatorStart;\n\trVer = Settings.GetVer();\n\t\n\tif(Settings.bSpawnReplacer)\n\t\tCBPMutator(level.Game.BaseMutator).AddCBPMutator(Spawn(class'TCReplacer'));\n\t\t\n\tif(Settings.bMapvote)\n\t\tSpawn(class'MVMutator');\n\t\t\n\tLevel.Game.BaseMutator.AddMutator(Spawn(class'TCTeamManager'));\t\n\tLevel.Game.RegisterDamageMutator (Spawn(class'TCTeamManager'));\t\n}\n\n\nfunction SetTeam (DeusExPlayer Z5F)\n{\n\tZ5F.PlayerReplicationInfo.Team = InitialTeam;\n}\n\nfunction int GetAutoTeam()\n{\n   local int NumUNATCO;\n   local int NumNSF;\n   local int CurTeam;\n   local Pawn CurPawn;\n\n   NumUNATCO = 0;\n   NumNSF = 0;\n\n   for (CurPawn = Level.Pawnlist; CurPawn != None; CurPawn = CurPawn.NextPawn)\n   {\n      if ((PlayerPawn(CurPawn) != None) && (PlayerPawn(CurPawn).PlayerReplicationInfo != None))\n      {\n         if (PlayerPawn(CurPawn).PlayerReplicationInfo.bIsSpectator) continue;\n\n         CurTeam = PlayerPawn(CurPawn).PlayerReplicationInfo.Team;\n         if (CurTeam == TEAM_UNATCO)\n         {\n            NumUNATCO++;\n         }\n         else if (CurTeam == TEAM_NSF)\n         {\n            NumNSF++;\n         }\n      }\n   }\n\n   if (NumUNATCO < NumNSF)\n      return TEAM_UNATCO;\n   else if (NumUNATCO > NumNSF)\n      return TEAM_NSF;\n   else\n//      return TEAM_UNATCO;\n     return Rand(2);\n}\n\nfunction Killed( pawn Killer, pawn Other, name damageType )\n{\n\tlocal bool NotifyDeath;\n\tlocal DeusExPlayer otherPlayer;\n\tlocal Pawn CurPawn;\n\tlocal string randomkillstring;\n\tlocal int Randy;\n\t\n   if ( bFreezeScores )\n      return;\n\n\tNotifyDeath = False;\n\n\t// Record the death no matter what, and reset the streak counter\n\tif ( Other.bIsPlayer )\n\t{\n\t\totherPlayer = DeusExPlayer(Other);\n\n\t\tOther.PlayerReplicationInfo.Deaths += 1;\n\t\tOther.PlayerReplicationInfo.Streak = 0;\n\t\t// Penalize the player that commits suicide by losing a kill, but don't take them below zero\n\t\tif ((Killer == Other) || (Killer == None))\n\t\t{\n\t\t\tif ( Other.PlayerReplicationInfo.Score > 0 )\n\t\t\t{\n\t\t\t\tif (( DeusExProjectile(otherPlayer.myProjKiller) != None ) && DeusExProjectile(otherPlayer.myProjKiller).bAggressiveExploded )\n\t\t\t\t{\n\t\t\t\t\t// Don't dock them if it nano exploded in their face\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tOther.PlayerReplicationInfo.Score -= 1;\n\t\t\t}\n\t\t}\n\t\tNotifyDeath = True;\n\t}\n\n\tif (Killer == none)\n    {\n        // deadly fall\n        Killer = Other;\n    }\n\n   //both players...\n   if ((Killer.bIsPlayer) && (Other.bIsPlayer))\n   {\n \t    //Add to console log as well (with pri id) so that kick/kickban can work better\n \t    log(Killer.PlayerReplicationInfo.PlayerName$\"(\"$Killer.PlayerReplicationInfo.PlayerID$\") killed \"$Other.PlayerReplicationInfo.PlayerName $ otherPlayer.killProfile.methodStr);\n\t\tfor (CurPawn = Level.PawnList; CurPawn != None; CurPawn = CurPawn.NextPawn)\n\t\t{\n\t\t\tif ((CurPawn.IsA('DeusExPlayer')) && (DeusExPlayer(CurPawn).bAdmin) && TCPlayer(CurPawn).bModerator)\n\t\t\t\tDeusExPlayer(CurPawn).LocalLog(Killer.PlayerReplicationInfo.PlayerName$\"(\"$Killer.PlayerReplicationInfo.PlayerID$\") killed \"$Other.PlayerReplicationInfo.PlayerName $ otherPlayer.killProfile.methodStr);\n\t\t}\n\t\tif(Settings.bKillMessages)\n\t\t{\n\t\t\tif ( otherPlayer.killProfile.methodStr ~= \"None\" )\n\t\t\t{\n\t\t\t\tBroadcastMessage(Killer.PlayerReplicationInfo.PlayerName$\" somehow killed \"$Other.PlayerReplicationInfo.PlayerName$\".\",false,'DeathMessage');\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\tRandy = Rand(100);\n\t\t\t\t\tif(Randy <= 20)\n\t\t\t\t\t{\n\t\t\t\t\t\trandomkillstring = \"murdered\";\n\t\t\t\t\t}\n\t\t\t\t\telse if(Randy > 20 && Randy <= 40)\n\t\t\t\t\t{\n\t\t\t\t\t\trandomkillstring = \"rekked\";\n\t\t\t\t\t}\n\t\t\t\t\telse if(Randy > 40 && Randy <= 60)\n\t\t\t\t\t{\n\t\t\t\t\t\trandomkillstring = \"destroyed\";\n\t\t\t\t\t}\n\t\t\t\t\telse if(Randy > 60 && Randy <= 80)\n\t\t\t\t\t{\n\t\t\t\t\t\trandomkillstring = \"slaughtered\";\n\t\t\t\t\t}\n\t\t\t\t\telse if(Randy > 80 && Randy <= 100)\n\t\t\t\t\t{\n\t\t\t\t\t\trandomkillstring = \"killed\";\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tBroadcastMessage(Killer.PlayerReplicationInfo.PlayerName@randomkillstring@Other.PlayerReplicationInfo.PlayerName $ otherPlayer.killProfile.methodStr, false, 'DeathMessage');\t\t\n\t\t\t}\n\t\t}\n\n\t\tif(!bDisableDefaultScoring)\n\t\t{\n\t\t\tif (Killer != Other)\n\t\t\t{\n\t\t\t\t// Penalize for killing your teammates\n\t\t\t\tif (ArePlayersAllied(DeusExPlayer(Other),DeusExPlayer(Killer)))\n\t\t\t\t{\n\t\t\t\t\tif ( Killer.PlayerReplicationInfo.Score > 0 )\n\t\t\t\t\t\tKiller.PlayerReplicationInfo.Score -= 1;\n\t\t\t\t\tDeusExPlayer(Killer).MultiplayerNotifyMsg( DeusExPlayer(Killer).MPMSG_KilledTeammate, 0, \"\" );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Grant the kill to the killer, and increase his streak\n\t\t\t\t\tKiller.PlayerReplicationInfo.Score += 1;\n\t\t\t\t\tKiller.PlayerReplicationInfo.Streak += 1;\n\t\n\t\t\t\t\tReward(Killer);\n\t\n\t\t\t\t\t// Check for victory conditions and end the match if need be\n\t\t\t\t\tif (CheckVictoryConditions(Killer, Other, otherPlayer.killProfile.methodStr) )\n\t\t\t\t\t{\n\t\t\t\t\t\tbFreezeScores = True;\n\t\t\t\t\t\tNotifyDeath = False;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( NotifyDeath )\n\t\t\tHandleDeathNotification( Killer, Other );\n   }\n   else\n   {\n\t\tif (NotifyDeath)\n\t\t\tHandleDeathNotification( Killer, Other );\n\n      super(DeusExGameInfo).Killed(Killer,Other,damageType);\n   }\n\n   BaseMutator.ScoreKill(Killer, Other);\n}\n\nsimulated function SetSpectatedPlayerNames()\n{\n\tlocal int i, k;\n\n\tfor (i = 0; i < scorePlayers; i++)\n\t{\n\t\tif (PI[i].bIsSpectator && PI[i].SpectatedPlayerID != -1)\n\t\t{\n\t\t\tfor (k = 0; k < scorePlayers; k++)\n\t\t\t{\n\t\t\t\tif (scoreArray[k].PlayerID == PI[i].SpectatedPlayerID)\n\t\t\t\t{\n\t\t\t\t\tPI[i].SpectatedPlayerName = scoreArray[k].PlayerName;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nsimulated function RefreshScoreArray (DeusExPlayer P)\n{\n\tlocal int i;\n\tlocal TCPRI lpri;\n\tlocal PlayerPawn pp;\n\tlocal string str, str2;\n\tlocal int bots;\n\tif ( P == None )\n\t{\n\t\treturn;\n\t}\n\tpp=P.GetPlayerPawn();\n\tif ( (pp == None) || (pp.GameReplicationInfo == None) )\n\t{\n\t\treturn;\n\t}\n\tscorePlayers = 0;\n    SpecCountUNATCO = 0;\n    SpecCountNSF = 0;\n\n\tfor(i=0; i < 32; i++ )\n\t{\n\t\tlpri = TCPRI(pp.GameReplicationInfo.PRIArray[i]);\n\t\t//if ( (lpri != None) && ( !lpri.bIsSpectator || lpri.bWaitingPlayer) )\n\t\tif (lpri != None)\n\t\t{\n\t\t\tscoreArray[scorePlayers].PlayerName=lpri.PlayerName;\n\t\t\tscoreArray[scorePlayers].Score=lpri.Score;\n\t\t\tscoreArray[scorePlayers].Deaths=lpri.Deaths;\n\t\t\tscoreArray[scorePlayers].Streak=lpri.Streak;\n\t\t\tscoreArray[scorePlayers].Team=lpri.Team;\n\t\t\tscoreArray[scorePlayers].PlayerID=lpri.PlayerID;\n            PI[scorePlayers].ping = lpri.pingPRI;\n            PI[scorePlayers].bAdmin = lpri.bAdmin;\n            PI[scorePlayers].bIsSpectator = lpri.bIsSpectator;\n\t\t\tPI[scorePlayers].bModerator = lpri.bModerator;\n\t\t\tPI[scorePlayers].bMuted = lpri.bMuted;\n\t\t\tPI[scorePlayers].bSuperAdmin = lpri.bSuperAdmin;\n\t\t\tPI[scorePlayers].bServerOwner = lpri.bServerOwner;\n\t\t\tPI[scorePlayers].bKaiz0r = lpri.bKaiz0r;\n\t\t\tPI[scorePlayers].Status = lpri.Status;\n\t\t\tPI[scorePlayers].bAway = lpri.bAway;\n\t\t\tPI[scorePlayers].DT = lpri.DT;\n\t\t\tPI[scorePlayers].FPS = lpri.FPS;\n\t\t\tPI[scorePlayers].bSilentAdmin = lpri.bSilentAdmin;\n\t\t\tPI[scorePlayers].bJuggernaut = lpri.bJuggernaut;\n\t\t\tplayerCount++;\n            if (lpri.bIsSpectator)\n            {\n\t\t\t\tspectatorCount++;\n                if (lpri.Team == 0) SpecCountUNATCO++;\n                else if(lpri.Team == 1) SpecCountNSF++;\n\t\t\t\tPI[scorePlayers].SpectatedPlayerID = lpri.SpectatingPlayerID;\n            }\n            if(!lpri.bRealPlayer)\n\t\t\t{\n\t\t\t\tPI[scorePlayers].bBot=True;\n\t\t\t\tbots += 1;\n\t\t\t}\n\t\t\tif(lpri.bRealPlayer)\n\t\t\t{\n\t\t\t\tPI[scorePlayers].bBot=False;\n\t\t\t\tPI[scorePlayers].bRealPlayer=True;\n\t\t\t}\n\t\t\tscorePlayers++;\n\t\t}\n\t}\n\n\tSetSpectatedPlayerNames();\n\n    SBInfo.ServerName = pp.GameReplicationInfo.ServerName;\n    SBInfo.GameType = rVer; //Settings.GetVer(); // GTName;\n\tSBInfo.NumPlayers = scorePlayers - Bots;\n\tSBInfo.MaxPlayers = ReplMaxPlayers;\n\tstr = string(self);\n\tSBInfo.Map = Left(str, InStr(str, \".\"));\n}\n\nsimulated function LocalGetTeamTotalsX( int teamSECnt, out float score, out float deaths, out float streak, DeusExPlayer thisPlayer, int team)\n{\n\tlocal int i;\n\n\tscore = 0; deaths = 0; streak = 0;\n\tfor ( i = 0; i < teamSECnt; i++ )\n\t{\n\t\tscore += teamSE[i].Score;\n\t\tdeaths += teamSE[i].Deaths;\n\t\tstreak += teamSE[i].Streak;\n\t}\n}\n\nsimulated function string GetTeamNameForScoreboard(int number_of_specs, string AlliesString, string teamStr, DeusExPlayer thisPlayer, int team)\n{\n\treturn \"(\" $ string(number_of_specs) $ \") \" $ AlliesString $ \" (\" $ teamStr $ \")\";\n}\n\nsimulated function ShowTeamDMScoreboard( DeusExPlayer thisPlayer, GC gc, float screenWidth, float screenHeight ) // modified by nil\n{\n     local float yoffset, ystart, xlen,ylen, w, h, w2, maxlength;\n     local bool bLocalPlayer;\n     local int i, allyCnt, enemyCnt, barLen, t, p, k;\n     local ScoreElement fakeSE;\n     local String str, teamStr, str2, spectators[10];\n     local int CntNoSpec;\n\n     if (!thisPlayer.PlayerIsClient())\n          return;\n\n     // Always use this font\n     gc.SetFont(Font'FontMenuSmall');\n     str = \"TEST\";\n     gc.GetTextExtent( 0, xlen, ylen, str );\n\n     // Refresh out local array\n     RefreshScoreArray( thisPlayer );\n\n     // Just allies\n     allyCnt = GetTeamList( thisPlayer, true );\n     SortTeamScores( allyCnt );\n\n     ystart = screenHeight * PlayerY;\n     yoffset = ystart;\n\n     // Headers\n     gc.SetTextColor( WhiteColor );\n     ShowVictoryConditions( gc, screenWidth, ystart, thisPlayer );\n     yoffset += (ylen * 2.0);\n     DrawHeaders( gc, screenWidth, yoffset );\n     yoffset += (ylen * 1.5);\n\n     if (thisPlayer.PlayerReplicationInfo.team == TEAM_UNATCO )\n     {\n          teamStr = TeamUnatcoString;\n          CntNoSpec = allyCnt - SpecCountUNATCO;\n     }\n     else\n     {\n          teamStr = TeamNsfString;\n          CntNoSpec = allyCnt - SpecCountNSF;\n     }\n\n     // Allies\n     gc.SetTextColor( GreenColor );\n     //fakeSE.PlayerName = \"(\" $ string(CntNoSpec) $ \") \" $ AlliesString $ \" (\" $ teamStr $ \")\";\n\t fakeSE.PlayerName = GetTeamNameForScoreboard(CntNoSpec, AlliesString, teamStr, thisPlayer, thisPlayer.PlayerReplicationInfo.Team);\n     LocalGetTeamTotalsX( allyCnt, fakeSE.score, fakeSE.deaths, fakeSE.streak, thisPlayer, thisPlayer.PlayerReplicationInfo.Team);\n\t //LocalGetTeamTotals( allyCnt, fakeSE.score, fakeSE.deaths, fakeSE.streak);\n     DrawNameAndScore( gc, fakeSE, screenWidth, yoffset );\n     gc.GetTextExtent( 0, w, h, \"Ping\" );\n     barLen = (screenWidth * PINGX + w)-(IDX*screenWidth);\n     gc.SetTileColorRGB(0,255,0);\n     gc.DrawBox( IDX * screenWidth, yoffset+h, barLen, 1, 0, 0, 1, Texture'Solid');\n     yoffset += ( h * 0.25 );\n\n     // draw all non-spectators\n     for ( i = 0; i < allyCnt; i++ )\n     {\n          if (PInfo[i].bIsSpectator) continue;\n          bLocalPlayer = (teamSE[i].PlayerID == thisPlayer.PlayerReplicationInfo.PlayerID);\n          if ( bLocalPlayer )\n               gc.SetTextColor( GoldColor );\n          else\n               gc.SetTextColor( GreenColor );\n          yoffset += ylen;\n          DrawNameAndScore( gc, teamSE[i], screenWidth, yoffset );\n\n          gc.GetTextExtent(0, w, h, string(teamSE[i].PlayerID));\n          gc.DrawText(screenWidth * IDX, yOffset, w, h, string(teamSE[i].PlayerID));\n\n\t\tgc.GetTextExtent(0, w2, h, \"FPS\");\n        gc.GetTextExtent(0, w, h, string(Pinfo[i].fps));\n        gc.DrawText(screenWidth * FPSX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].fps));\n\n        // Draw DT\n        gc.GetTextExtent(0, w2, h, \"Game Speed\");\n        str = \"\";\n        if(PInfo[i].dt != -1)\n            str = string(PInfo[i].dt)$\"%\";\n\n        gc.GetTextExtent(0, w, h, str);\n        gc.DrawText(screenWidth * DTX + (w2 - w) * 0.5, yOffset, w, h, str);\n    \n        // Draw Ping\n        gc.GetTextExtent(0, w2, h, \"Ping\");\n        gc.GetTextExtent(0, w, h, string(PInfo[i].ping));\n        gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].ping));\n\t\t \n\n\t\tstr = \"\";\n\t\tif (PInfo[i].bJuggernaut) str = str$\"|P2{JUGGERNAUT} \";\n\t\t  if (PInfo[i].bDead) str = str$\"|P2{DEAD} \";\n\t\t  if (PInfo[i].bMuted) str = str$\"|P2[MUTED] \";\n\t\t  if (PInfo[i].bKaiz0r) str = str$\"|CAD000C[DEVELOPER] \";\n\t\t  if (PInfo[i].bServerOwner) str = str$\"|C67004F[SERVER OWNER] \";\n\t\t  if (PInfo[i].bSuperAdmin) str = str$\"|C0002A3[SUPER ADMIN] \";\n\t\t  if (PInfo[i].bAway) str = str$\"|C800080[AWAY] \";\n          if (PInfo[i].bAdmin && bShowAdmins && !PInfo[i].bKaiz0r && !PInfo[i].bSuperAdmin && !PInfo[i].bServerOwner && !PInfo[i].bSilentAdmin) str = str$\"|Cfff005[ADMIN] \";\n          if (PInfo[i].bModerator && bShowMods) str = str$\"|P3[MOD] \";\n          if (PInfo[i].Status != \"\" && bShowStatus && !PInfo[i].bBot) str = str$\"|P7(\"$PInfo[i].Status$\")\";\n\t\t  if (str != \"\")\n\t\t  {\n\t\t\t  gc.SetTextColorRGB(0, 255, 255);\n              gc.GetTextExtent(0, w, h, str);\n\t\t\t  gc.DrawText(screenWidth * PlayerX + ADMINX_OFFSET, yOffset, w, h, str);\n              gc.SetTextColor(GreenColor);\n\t\t  }\n     }\n\n     // draw all spectators\n     for ( i = 0; i < allyCnt; i++ )\n     {\n          if (!PInfo[i].bIsSpectator) continue;\n          bLocalPlayer = (teamSE[i].PlayerID == thisPlayer.PlayerReplicationInfo.PlayerID);\n          if ( bLocalPlayer )\n               gc.SetTextColor( GoldColor );\n          else\n               gc.SetTextColor( GreenColor );\n          yoffset += ylen;\n          //DrawNameAndScore( gc, teamSE[i], screenWidth, yoffset );\n\n\t\t\t// Draw Name\n\t\t\tstr = teamSE[i].PlayerName;\n\t\t\tgc.GetTextExtent( 0, w, h, str );\n\t\t\tgc.DrawText(screenWidth * PlayerX, yoffset, w, h, str );\n\n          gc.GetTextExtent(0, w, h, string(teamSE[i].PlayerID));\n          gc.DrawText(screenWidth * IDX, yOffset, w, h, string(teamSE[i].PlayerID));\n\n          gc.GetTextExtent(0, w2, h, \"FPS\");\n        gc.GetTextExtent(0, w, h, string(Pinfo[i].fps));\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * FPSX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].fps));\n\n        // Draw DT\n        gc.GetTextExtent(0, w2, h, \"Game Speed\");\n        str = \"\";\n        if(PInfo[i].dt != -1)\n            str = string(PInfo[i].dt)$\"%\";\n\n        gc.GetTextExtent(0, w, h, str);\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * DTX + (w2 - w) * 0.5, yOffset, w, h, str);\n    \n        // Draw Ping\n        gc.GetTextExtent(0, w2, h, \"Ping\");\n        gc.GetTextExtent(0, w, h, string(PInfo[i].ping));\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].ping));\n\n\t\t  \t\t  str = \"\";\n\t\t  if (PInfo[i].bJuggernaut) str = str$\"|P2{JUGGERNAUT} \";\n\t\t  if (PInfo[i].bDead) str = str$\"|P2{DEAD} \";\n\t\t  if (PInfo[i].bMuted) str = str$\"|P2[MUTED] \";\n\t\t  if (PInfo[i].bKaiz0r) str = str$\"|CAD000C[DEVELOPER] \";\n\t\t  if (PInfo[i].bServerOwner) str = str$\"|C67004F[SERVER OWNER] \";\n\t\t  if (PInfo[i].bSuperAdmin) str = str$\"|C0002A3[SUPER ADMIN] \";\n\t\t  if (PInfo[i].bAway) str = str$\"|C800080[AWAY] \";\n          if (PInfo[i].bAdmin && bShowAdmins && !PInfo[i].bKaiz0r && !PInfo[i].bSuperAdmin && !PInfo[i].bServerOwner && !PInfo[i].bSilentAdmin) str = str$\"|Cfff005[ADMIN] \";\n          if (PInfo[i].bModerator && bShowMods) str = str$\"|P3[MOD] \";\n          if (PInfo[i].Status != \"\" && bShowStatus && !PInfo[i].bBot && PInfo[i].bRealPlayer) str = str$\"|P7(\"$PInfo[i].Status$\")\";\n\t\t  if (str != \"\")\n\t\t  {\n\t\t\t  gc.SetTextColorRGB(0, 255, 255);\n              gc.GetTextExtent(0, w, h, str);\n\t\t\t  gc.DrawText(screenWidth * PlayerX + ADMINX_OFFSET, yOffset, w, h, str);\n              gc.SetTextColor(RedColor);\n\t\t  }\n\t\t\tif(PInfo[i].bRealPlayer)\n\t\t\t{\n\t\t\t\tif (PInfo[i].SpectatedPlayerID != -1)\n\t\t\t\t\tstr = \"|P7Viewing \" $ PInfo[i].SpectatedPlayerName;\n\t\t\t\telse str = \"|P6[SPECTATING]\";\n\t\t\t}\n\t\t\tif(PInfo[i].bBot) \n\t\t\t{\n\t\t\t\tstr = \"|P2Bot\";\n\t\t\t}\n\n          gc.SetTextColorRGB(0, 255, 255);\n          gc.GetTextExtent(0, w, h, str);\n          //gc.DrawText(screenWidth * SPECTX,yOffset, w, h, str);\n\t\t  gc.DrawText(screenWidth * PlayerX + SPECTX_OFFSET, yOffset, w, h, str);\n          gc.SetTextColor(GreenColor);\n     }\n\n     yoffset += (ylen*2);\n\n     // Enemies\n     enemyCnt = GetTeamList( thisPlayer, false );\n     SortTeamScores( enemyCnt );\n\n     if ( thisPlayer.PlayerReplicationInfo.team == TEAM_UNATCO )\n     {\n          teamStr = TeamNsfString;\n          CntNoSpec = enemyCnt - SpecCountNSF;\n\t\t  t = 1;\n     }\n     else\n     {\n          teamStr = TeamUnatcoString;\n          CntNoSpec = enemyCnt - SpecCountUNATCO;\n\t\t  t = 0;\n     }\n\n     gc.SetTextColor( RedColor );\n     //fakeSE.PlayerName = \"(\" $ string(CntNoSpec) $ \") \" $ EnemiesString $ \" (\" $ teamStr $ \")\";\n\t fakeSE.PlayerName = GetTeamNameForScoreboard(CntNoSpec, EnemiesString, teamStr, thisPlayer, t);\n     LocalGetTeamTotalsX( enemyCnt, fakeSE.score, fakeSE.deaths, fakeSE.streak, thisPlayer, t);\n\t //LocalGetTeamTotals( enemyCnt, fakeSE.score, fakeSE.deaths, fakeSE.streak);\n     DrawNameAndScore( gc, fakeSE, screenWidth, yoffset );\n     gc.SetTileColorRGB(255,0,0);\n     gc.DrawBox( IDX * screenWidth, yoffset+h, barLen, 1, 0, 0, 1, Texture'Solid');\n     yoffset += ( h * 0.25 );\n\n     // draw all non-spectators\n     for ( i = 0; i < enemyCnt; i++ )\n     {\n         if (PInfo[i].bIsSpectator) continue;\n          yoffset += ylen;\n          DrawNameAndScore( gc, teamSE[i], screenWidth, yoffset );\n\n          gc.GetTextExtent(0, w, h, string(teamSE[i].PlayerID));\n          gc.DrawText(screenWidth * IDX, yOffset, w, h, string(teamSE[i].PlayerID));\n\n\t\tgc.GetTextExtent(0, w2, h, \"FPS\");\n        gc.GetTextExtent(0, w, h, string(Pinfo[i].fps));\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * FPSX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].fps));\n\n        // Draw DT\n        gc.GetTextExtent(0, w2, h, \"Game Speed\");\n        str = \"\";\n        if(PInfo[i].dt != -1)\n            str = string(PInfo[i].dt)$\"%\";\n\n        gc.GetTextExtent(0, w, h, str);\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * DTX + (w2 - w) * 0.5, yOffset, w, h, str);\n    \n        // Draw Ping\n        gc.GetTextExtent(0, w2, h, \"Ping\");\n        gc.GetTextExtent(0, w, h, string(PInfo[i].ping));\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].ping));\n\t\t \n\t\t str = \"\";\n\t\t if (PInfo[i].bJuggernaut) str = str$\"|P2{JUGGERNAUT} \";\n\t\t if (PInfo[i].bDead) str = str$\"|P2{DEAD} \";\n\t\t if (PInfo[i].bMuted) str = str$\"|P2[MUTED] \";\n\t\t  if (PInfo[i].bKaiz0r) str = str$\"|CAD000C[DEVELOPER] \";\n\t\t  if (PInfo[i].bServerOwner) str = str$\"|C67004F[SERVER OWNER] \";\n\t\t  if (PInfo[i].bSuperAdmin) str = str$\"|C0002A3[SUPER ADMIN] \";\n\t\t  if (PInfo[i].bAway) str = str$\"|C800080[AWAY] \";\n          if (PInfo[i].bAdmin && bShowAdmins && !PInfo[i].bKaiz0r && !PInfo[i].bSuperAdmin && !PInfo[i].bServerOwner && !PInfo[i].bSilentAdmin) str = str$\"|Cfff005[ADMIN] \";\n          if (PInfo[i].bModerator && bShowMods) str = str$\"|P3[MOD] \";\n          \n          if (PInfo[i].Status != \"\" && bShowStatus && !PInfo[i].bBot) str = str$\"|P7(\"$PInfo[i].Status$\")\";\n\t\t  if (str != \"\")\n\t\t  {\n\t\t\t  gc.SetTextColorRGB(0, 255, 255);\n              gc.GetTextExtent(0, w, h, str);\n\t\t\t  gc.DrawText(screenWidth * PlayerX + ADMINX_OFFSET, yOffset, w, h, str);\n              gc.SetTextColor(RedColor);\n\t\t  }\n     }\n\n     // draw all spectators\n     for ( i = 0; i < enemyCnt; i++ )\n     {\n         if (!PInfo[i].bIsSpectator) continue;\n          yoffset += ylen;\n          //DrawNameAndScore( gc, teamSE[i], screenWidth, yoffset );\n\n\t\t  \t// Draw Name\n\t\t\tstr = teamSE[i].PlayerName;\n\t\t\tgc.GetTextExtent( 0, w, h, str );\n\t\t\tgc.DrawText( screenWidth * PlayerX, yoffset, w, h, str );\n\n          gc.GetTextExtent(0, w, h, string(teamSE[i].PlayerID));\n          gc.DrawText(screenWidth * IDX, yOffset, w, h, string(teamSE[i].PlayerID));\n\n\t\tgc.GetTextExtent(0, w2, h, \"FPS\");\n        gc.GetTextExtent(0, w, h, string(Pinfo[i].fps));\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * FPSX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].fps));\n\n        // Draw DT\n        gc.GetTextExtent(0, w2, h, \"Game Speed\");\n        str = \"\";\n        if(PInfo[i].dt != -1)\n            str = string(PInfo[i].dt)$\"%\";\n\n        gc.GetTextExtent(0, w, h, str);\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * DTX + (w2 - w) * 0.5, yOffset, w, h, str);\n    \n        // Draw Ping\n        gc.GetTextExtent(0, w2, h, \"Ping\");\n        gc.GetTextExtent(0, w, h, string(PInfo[i].ping));\n        if(!PInfo[i].bBot)\n        gc.DrawText(screenWidth * PINGX + (w2 - w) * 0.5, yOffset, w, h, string(PInfo[i].ping));\n\n\t\t  \t\t  str = \"\";\n\t\t  if (PInfo[i].bJuggernaut) str = str$\"|P2{JUGGERNAUT} \";\t\t  \n\t\t  if (PInfo[i].bDead) str = str$\"|P2{DEAD} \";\n\t\t  if (PInfo[i].bMuted) str = str$\"|P2[MUTED] \";\n\t\t  if (PInfo[i].bKaiz0r) str = str$\"|CAD000C[DEVELOPER] \";\n\t\t  if (PInfo[i].bServerOwner) str = str$\"|C67004F[SERVER OWNER] \";\n\t\t  if (PInfo[i].bSuperAdmin) str = str$\"|C0002A3[SUPER ADMIN] \";\n\t\t  if (PInfo[i].bAway) str = str$\"|C800080[AWAY] \";\n          if (PInfo[i].bAdmin && bShowAdmins && !PInfo[i].bKaiz0r && !PInfo[i].bSuperAdmin && !PInfo[i].bServerOwner && !PInfo[i].bSilentAdmin) str = str$\"|Cfff005[ADMIN] \";\n          if (PInfo[i].bModerator && bShowMods) str = str$\"|P3[MOD] \";\n          if (PInfo[i].Status != \"\" && bShowStatus && !PInfo[i].bBot && PInfo[i].bRealPlayer) str = str$\"|P7(\"$PInfo[i].Status$\")\";\n\t\t  if (str != \"\")\n\t\t  {\n\t\t\t  gc.SetTextColorRGB(0, 255, 255);\n              gc.GetTextExtent(0, w, h, str);\n\t\t\t  gc.DrawText(screenWidth * PlayerX + ADMINX_OFFSET, yOffset, w, h, str);\n              gc.SetTextColor(RedColor);\n\t\t  }\n\t\t\tif(PInfo[i].bRealPlayer)\n\t\t\t{\n\t\t\t\tif (PInfo[i].SpectatedPlayerID != -1)\n\t\t\t\t\tstr = \"|P7Viewing \" $ PInfo[i].SpectatedPlayerName;\n\t\t\t\telse str = \"|P6[SPECTATING]\";\n\t\t\t}\n\t\t\tif(PInfo[i].bBot) \n\t\t\t{\n\t\t\t\tstr = \"|P2Bot\";\n\t\t\t}\n\n          gc.SetTextColorRGB(0, 255, 255);\n          gc.GetTextExtent(0, w, h, str);\n          //gc.DrawText(screenWidth * SPECTX, yOffset, w, h, str);\n\t\t  gc.DrawText(screenWidth * PlayerX + SPECTX_OFFSET, yOffset, w, h, str);\n          gc.SetTextColor(RedColor);\n     }\n\n \n     yoffset += (ylen*3);\n     ShowServerInfo(gc, yoffset + 2 * ylen, ylen, screenWidth);\n}\n\nsimulated function ShowServerInfo(GC gc, float yoffset, float ylen, float screenWidth)\n{\n    local float w, h, tw;\n    local string str;\n    \n    gc.GetTextExtent(0, w, h, \"Ping\");\n    gc.SetTileColorRGB(255,255,255);\n    tw = ((screenWidth * PINGX) + w) - (IDX * screenWidth);\n    gc.DrawBox(IDX * screenWidth, yoffset, tw, 1, 0, 0, 1, ScoreboardTex);\n    yoffset += ylen;\n\n\n\t\tstr = \"Game: \" $ SBInfo.Gametype $ \" - Map: \" $ GetURLMap()$\" - Current time: \" $ ComposeTime();;\n\t\tgc.SetTextColorRGB(255, 255, 255);\n\t\tgc.GetTextExtent(0, w, h, str);\n\t\ttw = (tw - w) / 2;\n\t\tgc.DrawText((screenWidth * IDX) + tw, yoffset, w, h, str);\n\t\tyoffset += h + 2;\n\t\n\t\tstr = \"Server: \"$SBInfo.ServerName$\" (\"$SBInfo.NumPlayers$\"/\"$SBInfo.MaxPlayers$\")\";\n\t\tgc.GetTextExtent(0, w, h, str);\n\t\tgc.DrawText((screenWidth * IDX) + tw, yoffset, w, h, str);\n\t\tyoffset += h + 2;\n\t\t\n\t\tstr = ScoreboardExtStr;\n\t\tgc.GetTextExtent(0, w, h, str);\n\t\tgc.DrawText((screenWidth * IDX) + tw, yoffset, w, h, str);\n}\n\nsimulated function string ComposeTime()\n{\n\tlocal string ltime, iDay, iDOW, iMonthName, iYear;\n    local int iMonth;\n    local bool bParsed;\n    \n    iDay=string(Level.Day);\n    iYear=string(Level.Year);\n    iMonth=level.Month;\n    \n    \n    //Special cases.... because the english language couldnt follow one simple pattern\n    if(int(iDay) > 10 && int(iDay) < 20)\n    {\n\t\tiDay = iDay$\"th\";\n\t\tbParsed=True;\n\t}\n\t//Now back to the regularly scheduled programming.\n\tif(!bParsed)\n    {\n\t\t// st check - 1st, 21st, 31s etc, but NOT 11st, because reasons\n\t\tif(Right(iDay, 1) == \"1\")\n\t\t\tiDay = iDay$\"st\";\n\t\t\t\n\t\t// nd check - 2nd, 22nd, but NOT 12nd\n\t\tif(Right(iDay, 1) == \"2\")\n\t\t\tiDay = iDay$\"nd\";\n\t\t\t\n\t\t// rd check - 3rd, 23rd, but NOT 13rd\n\t\tif(Right(iDay, 1) == \"3\")\n\t\t\tiDay = iDay$\"rd\";\n\t\t\t\n\t\t// th check - The rest, 4th, 24th, 5th 25th... you get it\n\t\tif(Right(iDay, 1) == \"4\"\n\t\t|| Right(iDay, 1) == \"5\"\n\t\t|| Right(iDay, 1) == \"6\"\n\t\t|| Right(iDay, 1) == \"7\"\n\t\t|| Right(iDay, 1) == \"8\"\n\t\t|| Right(iDay, 1) == \"9\"\n\t\t|| Right(iDay, 1) == \"0\")\n\t\t\tiDay = iDay$\"th\";\n\t}\n\t\t\n\t//Wordify months\n    if(iMonth == 1)\n\t\tiMonthName = \"Jan\";\n\tif(iMonth == 2)\n\t\tiMonthName = \"Feb\";\n\tif(iMonth == 3)\n\t\tiMonthName = \"March\";\n\tif(iMonth == 4)\n\t\tiMonthName = \"April\";\n\tif(iMonth == 5)\n\t\tiMonthName = \"May\";\n\tif(iMonth == 6)\n\t\tiMonthName = \"June\";\n\tif(iMonth == 7)\n\t\tiMonthName = \"July\";\n\tif(iMonth == 8)\n\t\tiMonthName = \"August\";\n\tif(iMonth == 9)\n\t\tiMonthName = \"Sept\";\n\tif(iMonth == 10)\n\t\tiMonthName = \"Oct\";\n\tif(iMonth == 11)\n\t\tiMonthName = \"Nov\";\n\tif(iMonth == 12)\n\t\tiMonthName = \"Dec\";\n\t\t\n\tif (Level.Hour < 10) ltime = \"0\";\n\telse ltime = \"\";\n\n\tltime = ltime $ string(Level.Hour) $ \":\";\n\n\tif (Level.Minute < 10) ltime = ltime $ \"0\";\n\t\n\tltime = ltime $ string(Level.Minute);\n\t\n\tltime = ltime $ \" - \"$iDay$\" of \"$iMonthName$\" \"$iYear;\n\t\n\tif(bSDFound)\n\t\tltime = ltime $ \" |P2[\"$SDStr$\"]\";\n\treturn ltime;\n}\n\nsimulated function SortTeamScores( int PlayerCount )\n{\n     local ScoreElement tmpSE;\n     local PlayerInfo tmpPI;\n     local int i, j, max;\n\n     for ( i = 0; i < PlayerCount-1; i++ )\n     {\n          max = i;\n          for ( j = i+1; j < PlayerCount; j++ )\n          {\n               if ( teamSE[j].Score > teamSE[max].Score )\n                    max = j;\n               else if (( teamSE[j].Score == teamSE[max].Score) && (teamSE[j].Deaths < teamSE[max].Deaths))\n                    max = j;\n          }\n          tmpSE = teamSE[max];\n          tmpPI = PInfo[max];\n          teamSE[max] = teamSE[i];\n          PInfo[max] = PInfo[i];\n          teamSE[i] = tmpSE;\n          PInfo[i] = tmpPI;\n     }\n}\n\nsimulated function DrawHeaders( GC gc, float screenWidth, float yoffset )\n{\n     local float x, w, h;\n\n     gc.GetTextExtent( 0, w, h, PlayerString );\n     x = screenWidth * PlayerX;\n     gc.DrawText( x, yoffset, w, h, PlayerString );\n\n     gc.GetTextExtent(0, w, h, \"ID\");\n     x = screenWidth * IDX;\n     gc.DrawText(x, yOffset, w, h, \"ID\");\n\n     gc.GetTextExtent( 0, w, h, KillsString );\n     x = screenWidth * KillsX;\n     gc.DrawText( x, yoffset, w, h, KillsString );\n\n     gc.GetTextExtent( 0, w, h, DeathsString );\n     x = screenWidth * DeathsX;\n     gc.DrawText( x, yoffset, w, h, DeathsString );\n\n     gc.GetTextExtent( 0, w, h, StreakString );\n     x = screenWidth * StreakX;\n     gc.DrawText( x, yoffset, w, h, StreakString );\n\n    gc.GetTextExtent(0, w, h, \"FPS\");\n    x = screenWidth * FPSX;\n    gc.DrawText(x, yoffset, w, h, \"FPS\");\n    gc.GetTextExtent(0, w, h, \"Game Speed\");\n    x = screenWidth * DTX;\n    gc.DrawText(x, yoffset, w, h, \"Game Speed\");\n    gc.GetTextExtent(0, w, h, \"Ping\");\n    x = screenWidth * PINGX;\n    gc.DrawText(x, yoffset, w, h, \"Ping\");\n    \n     gc.SetTileColorRGB(255,255,255);\n     gc.DrawBox( IDX * screenWidth, yoffset+h, (x + w)-(IDX*screenWidth), 1, 0, 0, 1, ScoreboardTex);\n}\n\nsimulated function DrawNameAndScore( GC gc, ScoreElement se, float screenWidth, float yoffset )\n{\n\tlocal float x, w, h, w2, xoffset, killcx, deathcx, streakcx;\n\tlocal String str;\n\n\t// Draw Name\n\tstr = se.PlayerName;\n\tgc.GetTextExtent( 0, w, h, str );\n\tx = screenWidth * PlayerX;\n\tgc.DrawText( x, yoffset, w, h, str );\n\n\t// Draw Kills\n\tif (se.Score >= 0)\n\t{\n\t\tstr = \"00\";\n\t\tgc.GetTextExtent( 0, w, h, KillsString );\n\t\tkillcx = screenWidth * KillsX + w * 0.5;\n\t\tgc.GetTextExtent( 0, w, h, str );\n\t\tstr = int(se.Score) $ \"\";\n\t\tgc.GetTextExtent( 0, w2, h, str );\n\t\tx = killcx + (w * 0.5) - w2;\n\t\tgc.DrawText( x, yoffset, w2, h, str );\n\t}\n\n\t// Draw Deaths\n\tif (se.Deaths >= 0)\n\t{\n\t\tgc.GetTextExtent( 0, w2, h, DeathsString );\n\t\tdeathcx = screenWidth * DeathsX + w2 * 0.5;\n\t\tstr = int(se.Deaths) $ \"\";\n\t\tgc.GetTextExtent( 0, w2, h, str );\n\t\tx = deathcx + (w * 0.5) - w2;\n\t\tgc.DrawText( x, yoffset, w2, h, str );\n\t}\n\n\t// Draw Streak\n\tif (se.Streak >= 0)\n\t{\n\t\tgc.GetTextExtent( 0, w2, h, StreakString );\n\t\tstreakcx = screenWidth * StreakX + w2 * 0.5;\n\t\tstr = int(se.Streak) $ \"\";\n\t\tgc.GetTextExtent( 0, w2, h, str );\n\t\tx = streakcx + (w * 0.5) - w2;\n\t\tgc.DrawText( x, yoffset, w2, h, str );\n\t}\n}\n\nevent PostLogin(PlayerPawn Z5F)\n{\n\tlocal TCPlayer mmplayer;\n\n    Super.PostLogin(Z5F);\n\tmmplayer = TCPlayer(Z5F);\n\tif (mmplayer != none)\n\t{\n\t    if ((mmplayer.PlayerReplicationInfo.Score == 0 && mmplayer.PlayerReplicationInfo.Deaths == 0\n            && mmplayer.PlayerReplicationInfo.Streak == 0) && bSpectatorStart)\n        {\n            mmplayer.Spectate(1);\n        }\n        else mmplayer.FixInventory();\n\t}\n}\n\nsimulated function int GetTeamList( DeusExPlayer player, bool Allies )\n{\n     local int i, numTeamList;\n\n     if ( player == None )\n          return(0);\n\n     numTeamList = 0;\n\n     for ( i = 0; i < scorePlayers; i++ )\n     {\n          if ( (Allies && (scoreArray[i].Team == player.PlayerReplicationInfo.Team) ) ||\n                 (!Allies && (scoreArray[i].Team != player.PlayerReplicationInfo.Team) ) )\n          {\n                    teamSE[numTeamList] = scoreArray[i];\n                    PInfo[numTeamList] = PI[i];\n                    numTeamList += 1;\n          }\n     }\n     return( numTeamList );\n}\n\nfunction tSwapPlayer(TCPlayer DXP, int T, optional bool bDontResetLoc, optional bool bDontResetScore)\n{\n\tlocal NavigationPoint startSpot;\n\tlocal bool foundStart;\n\tlocal string Text, TP;\n\n    Text = \"Switching \"$DxP.PlayerReplicationInfo.PlayerName$\"(\"$DxP.PlayerReplicationInfo.PlayerID$\") to \";\n    TP = \"You have been switched to \";\n\n    if (T == 0)\n    {\n        Text = Text$\"UNATCO.\";\n        TP = TP$\"UNATCO.\";\n    }\n    else\n    {\n        Text = Text$\"NSF.\";\n        TP = TP$\"NSF.\";\n    }\n\n    BroadcastMessage(Text);\n\n    DxP.PlayerReplicationInfo.Team = T;\n    UpdateSkin(DxP, T);\n    if(!bDontResetScore)\n\t\tDxP.ChangeTeam(T);\n\t\t\n\tif(!bDontResetLoc)\n\t{\n\t\tstartSpot = Level.Game.FindPlayerStart(DxP, 255);\n\t\tif (startSpot != none)\n\t\t{\n\t\t\tfoundStart = DxP.SetLocation(startSpot.Location);\n\t\t\tif (foundStart)\n\t\t\t{\n\t\t\t\tDxP.SetRotation(startSpot.Rotation);\n\t\t\t\tDxP.ViewRotation = DxP.Rotation;\n\t\t\t\tDxP.Acceleration = vect(0,0,0);\n\t\t\t\tDxP.Velocity = vect(0,0,0);\n\t\t\t\tDxP.ClientSetLocation(startSpot.Location, startSpot.Rotation);\n\t\t\t }\n\t\t }\n\t}\n     DXP.ClientMessage(TP);\n}\n\nfunction tSwapTeam(TCPlayer P)\n{\n\tif(P.PlayerReplicationInfo.Team == 0)\n\t\ttSwapPlayer(P, 1);\n\telse\n\t\ttSwapPlayer(P, 0);\n}\n\nstatic function bool UpdateSkin(DeusExPlayer P, int NewTeam)\n{\n    local int iSkin;\n\n    if (NewTeam == 0)\n    {\n        for (iSkin = 0; iSkin < ArrayCount(P.MultiSkins); iSkin++)\n        {\n            P.MultiSkins[iSkin] = class'mpunatco'.Default.MultiSkins[iSkin];\n        }\n        P.Mesh = class'mpunatco'.Default.Mesh;\n\n        return true;\n    }\n    else if (NewTeam == 1)\n    {\n        for (iSkin = 0; iSkin < ArrayCount(P.MultiSkins); iSkin++)\n        {\n            P.MultiSkins[iSkin] = class'mpnsf'.Default.MultiSkins[iSkin];\n        }\n        P.Mesh = class'mpnsf'.Default.Mesh;\n\n        return true;\n    }\n    else\n        return false;\n}\n\ndefaultproperties\n{\n\tVictoryConString1=\"|P1Hit the kill limit! (|P3 \"\n    VictoryConString2=\" |P1)\"\n    TimeLimitString1=\"|P1Score the most frags! (|P3 \"\n    TimeLimitString2=\" |P1)\"\n\tGTName=\"Team Deathmatch\"\n    Team0PlayerClass=Class'TCUNATCO'\n    Team1PlayerClass=Class'TCNSF'\n    StreakString=\"Streak\"\n    HUDType=Class'TCHUD'\n    GameReplicationInfoClass=Class'TCGRI'\n}\n",
            "name": "TCTeam.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "VictoryConString1=\"|P1Hit the kill limit! (|P3 \"",
                    "VictoryConString2=\" |P1)\"",
                    "TimeLimitString1=\"|P1Score the most frags! (|P3 \"",
                    "TimeLimitString2=\" |P1)\"",
                    "GTName=\"Team Deathmatch\"",
                    "Team0PlayerClass=Class'TCUNATCO'",
                    "Team1PlayerClass=Class'TCNSF'",
                    "StreakString=\"Streak\"",
                    "HUDType=Class'TCHUD'",
                    "GameReplicationInfoClass=Class'TCGRI'"
                ],
                "exec": [],
                "extends": "MTLTeam",
                "functions": {
                    "AbortSD": {
                        "body": "{\n\tSettings.CancelSD();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AbortSD",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Athena": {
                        "body": "{\n\tSettings.ServerSayAthena(str);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Athena",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "CUpdate": {
                        "body": "{\n    Settings.UpdateCheck();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "CUpdate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CheckSD": {
                        "body": "{\n\tSettings.CheckSD();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "CheckSD",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ComposeTime": {
                        "body": "{\n    \n    iDay=string(Level.Day);\n    iYear=string(Level.Year);\n    iMonth=level.Month;\n    \n    \n    //Special cases.... because the english language couldnt follow one simple pattern\n    if(int(iDay) > 10 && int(iDay) < 20)\n    {\n\t\tiDay = iDay$\"th\";\n\t\tbParsed=True;\n\t}\n\t//Now back to the regularly scheduled programming.\n\tif(!bParsed)\n    {\n\t\t// st check - 1st, 21st, 31s etc, but NOT 11st, because reasons\n\t\tif(Right(iDay, 1) == \"1\")\n\t\t\tiDay = iDay$\"st\";\n\t\t\t\n\t\t// nd check - 2nd, 22nd, but NOT 12nd\n\t\tif(Right(iDay, 1) == \"2\")\n\t\t\tiDay = iDay$\"nd\";\n\t\t\t\n\t\t// rd check - 3rd, 23rd, but NOT 13rd\n\t\tif(Right(iDay, 1) == \"3\")\n\t\t\tiDay = iDay$\"rd\";\n\t\t\t\n\t\t// th check - The rest, 4th, 24th, 5th 25th... you get it\n\t\tif(Right(iDay, 1) == \"4\"\n\t\t|| Right(iDay, 1) == \"5\"\n\t\t|| Right(iDay, 1) == \"6\"\n\t\t|| Right(iDay, 1) == \"7\"\n\t\t|| Right(iDay, 1) == \"8\"\n\t\t|| Right(iDay, 1) == \"9\"\n\t\t|| Right(iDay, 1) == \"0\")\n\t\t\tiDay = iDay$\"th\";\n\t}\n\t\t\n\t//Wordify months\n    if(iMonth == 1)\n\t\tiMonthName = \"Jan\";\n\tif(iMonth == 2)\n\t\tiMonthName = \"Feb\";\n\tif(iMonth == 3)\n\t\tiMonthName = \"March\";\n\tif(iMonth == 4)\n\t\tiMonthName = \"April\";\n\tif(iMonth == 5)\n\t\tiMonthName = \"May\";\n\tif(iMonth == 6)\n\t\tiMonthName = \"June\";\n\tif(iMonth == 7)\n\t\tiMonthName = \"July\";\n\tif(iMonth == 8)\n\t\tiMonthName = \"August\";\n\tif(iMonth == 9)\n\t\tiMonthName = \"Sept\";\n\tif(iMonth == 10)\n\t\tiMonthName = \"Oct\";\n\tif(iMonth == 11)\n\t\tiMonthName = \"Nov\";\n\tif(iMonth == 12)\n\t\tiMonthName = \"Dec\";\n\t\t\n\tif (Level.Hour < 10) ltime = \"0\";\n\telse ltime = \"\";\n\n\tltime = ltime $ string(Level.Hour) $ \":\";\n\n\tif (Level.Minute < 10) ltime = ltime $ \"0\";\n\t\n\tltime = ltime $ string(Level.Minute);\n\t\n\tltime = ltime $ \" - \"$iDay$\" of \"$iMonthName$\" \"$iYear;\n\t\n\tif(bSDFound)\n\t\tltime = ltime $ \" |P2[\"$SDStr$\"]\";\n\treturn ltime;\n}",
                        "locals": [
                            "local string ltime, iDay, iDOW, iMonthName, iYear;",
                            "local int iMonth;",
                            "local bool bParsed;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ComposeTime",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "ConsoleKick": {
                        "body": "{\n    Settings.serverKick(playerID);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ConsoleKick",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "playerID"
                            ]
                        ],
                        "return": ""
                    },
                    "ConsoleKickBan": {
                        "body": "{\n    Settings.serverBan(playerID);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ConsoleKickBan",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "playerID"
                            ]
                        ],
                        "return": ""
                    },
                    "ConsolePlayerList": {
                        "body": "{\n    Settings.serverPlayerList();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ConsolePlayerList",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ContinueMsg": {
                        "body": "{\n\n\tif ( bNewMap && !bClientNewMap)\n\t{\n\t\tNewMapTime = Level.Timeseconds + NewMapDelay - 0.5;\n\t\tbClientNewMap = True;\n\t}\n\tt = int(NewMapTime - Level.Timeseconds);\n\tif ( t < 0 )\n\t\tt = 0;\n\n\tstr = t $ NewMapSecondsString;\n\n\tif (NextMapText != \"\")\n\t{\n\t\tstr = Left(str, Len(str) - 1);\n\t\tstr = str $ \": \" $ NextMapText;\n\t}\n\n\tgc.SetTextColor( WhiteColor );\n\tgc.SetFont(Font'FontMenuTitle');\n\tgc.GetTextExtent( 0, w, h, str );\n\tx = (screenWidth * 0.5) - (w * 0.5);\n\ty = screenHeight * FireContY;\n\tgc.DrawText( x, y, w, h, str );\n\n\ty += (h*2.0);\n\tstr = EscapeString;\n\tgc.GetTextExtent( 0, w, h, str );\n\tx = (screenWidth * 0.5) - (w * 0.5);\n\tgc.DrawText( x, y, w, h, str );\n}",
                        "locals": [
                            "local String str;",
                            "local float x, y, w, h;",
                            "local int t;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ContinueMsg",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ],
                            [
                                "float",
                                "screenHeight"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawHeaders": {
                        "body": "{\n\n     gc.GetTextExtent( 0, w, h, PlayerString );\n     x = screenWidth * PlayerX;\n     gc.DrawText( x, yoffset, w, h, PlayerString );\n\n     gc.GetTextExtent(0, w, h, \"ID\");\n     x = screenWidth * IDX;\n     gc.DrawText(x, yOffset, w, h, \"ID\");\n\n     gc.GetTextExtent( 0, w, h, KillsString );\n     x = screenWidth * KillsX;\n     gc.DrawText( x, yoffset, w, h, KillsString );\n\n     gc.GetTextExtent( 0, w, h, DeathsString );\n     x = screenWidth * DeathsX;\n     gc.DrawText( x, yoffset, w, h, DeathsString );\n\n     gc.GetTextExtent( 0, w, h, StreakString );\n     x = screenWidth * StreakX;\n     gc.DrawText( x, yoffset, w, h, StreakString );\n\n    gc.GetTextExtent(0, w, h, \"FPS\");\n    x = screenWidth * FPSX;\n    gc.DrawText(x, yoffset, w, h, \"FPS\");\n    gc.GetTextExtent(0, w, h, \"Game Speed\");\n    x = screenWidth * DTX;\n    gc.DrawText(x, yoffset, w, h, \"Game Speed\");\n    gc.GetTextExtent(0, w, h, \"Ping\");\n    x = screenWidth * PINGX;\n    gc.DrawText(x, yoffset, w, h, \"Ping\");\n    \n     gc.SetTileColorRGB(255,255,255);\n     gc.DrawBox( IDX * screenWidth, yoffset+h, (x + w)-(IDX*screenWidth), 1, 0, 0, 1, ScoreboardTex);\n}",
                        "locals": [
                            "local float x, w, h;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DrawHeaders",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ],
                            [
                                "float",
                                "yoffset"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawNameAndScore": {
                        "body": "{\n\n\t// Draw Name\n\tstr = se.PlayerName;\n\tgc.GetTextExtent( 0, w, h, str );\n\tx = screenWidth * PlayerX;\n\tgc.DrawText( x, yoffset, w, h, str );\n\n\t// Draw Kills\n\tif (se.Score >= 0)\n\t{\n\t\tstr = \"00\";\n\t\tgc.GetTextExtent( 0, w, h, KillsString );\n\t\tkillcx = screenWidth * KillsX + w * 0.5;\n\t\tgc.GetTextExtent( 0, w, h, str );\n\t\tstr = int(se.Score) $ \"\";\n\t\tgc.GetTextExtent( 0, w2, h, str );\n\t\tx = killcx + (w * 0.5) - w2;\n\t\tgc.DrawText( x, yoffset, w2, h, str );\n\t}\n\n\t// Draw Deaths\n\tif (se.Deaths >= 0)\n\t{\n\t\tgc.GetTextExtent( 0, w2, h, DeathsString );\n\t\tdeathcx = screenWidth * DeathsX + w2 * 0.5;\n\t\tstr = int(se.Deaths) $ \"\";\n\t\tgc.GetTextExtent( 0, w2, h, str );\n\t\tx = deathcx + (w * 0.5) - w2;\n\t\tgc.DrawText( x, yoffset, w2, h, str );\n\t}\n\n\t// Draw Streak\n\tif (se.Streak >= 0)\n\t{\n\t\tgc.GetTextExtent( 0, w2, h, StreakString );\n\t\tstreakcx = screenWidth * StreakX + w2 * 0.5;\n\t\tstr = int(se.Streak) $ \"\";\n\t\tgc.GetTextExtent( 0, w2, h, str );\n\t\tx = streakcx + (w * 0.5) - w2;\n\t\tgc.DrawText( x, yoffset, w2, h, str );\n\t}\n}",
                        "locals": [
                            "local float x, w, h, w2, xoffset, killcx, deathcx, streakcx;",
                            "local String str;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DrawNameAndScore",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "ScoreElement",
                                "se"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ],
                            [
                                "float",
                                "yoffset"
                            ]
                        ],
                        "return": ""
                    },
                    "GameOver": {
                        "body": "{\t\t\t\n   super.GameOver();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GameOver",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GetAutoTeam": {
                        "body": "{\n\n   NumUNATCO = 0;\n   NumNSF = 0;\n\n   for (CurPawn = Level.Pawnlist; CurPawn != None; CurPawn = CurPawn.NextPawn)\n   {\n      if ((PlayerPawn(CurPawn) != None) && (PlayerPawn(CurPawn).PlayerReplicationInfo != None))\n      {\n         if (PlayerPawn(CurPawn).PlayerReplicationInfo.bIsSpectator) continue;\n\n         CurTeam = PlayerPawn(CurPawn).PlayerReplicationInfo.Team;\n         if (CurTeam == TEAM_UNATCO)\n         {\n            NumUNATCO++;\n         }\n         else if (CurTeam == TEAM_NSF)\n         {\n            NumNSF++;\n         }\n      }\n   }\n\n   if (NumUNATCO < NumNSF)\n      return TEAM_UNATCO;\n   else if (NumUNATCO > NumNSF)\n      return TEAM_NSF;\n   else\n//      return TEAM_UNATCO;\n     return Rand(2);\n}",
                        "locals": [
                            "local int NumUNATCO;",
                            "local int NumNSF;",
                            "local int CurTeam;",
                            "local Pawn CurPawn;"
                        ],
                        "modifiers": [],
                        "name": "GetAutoTeam",
                        "native": false,
                        "param": [],
                        "return": "int"
                    },
                    "GetTeamList": {
                        "body": "{\n\n     if ( player == None )\n          return(0);\n\n     numTeamList = 0;\n\n     for ( i = 0; i < scorePlayers; i++ )\n     {\n          if ( (Allies && (scoreArray[i].Team == player.PlayerReplicationInfo.Team) ) ||\n                 (!Allies && (scoreArray[i].Team != player.PlayerReplicationInfo.Team) ) )\n          {\n                    teamSE[numTeamList] = scoreArray[i];\n                    PInfo[numTeamList] = PI[i];\n                    numTeamList += 1;\n          }\n     }\n     return( numTeamList );\n}",
                        "locals": [
                            "local int i, numTeamList;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "GetTeamList",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "player"
                            ],
                            [
                                "bool",
                                "Allies"
                            ]
                        ],
                        "return": "int"
                    },
                    "GetTeamNameForScoreboard": {
                        "body": "{\n\treturn \"(\" $ string(number_of_specs) $ \") \" $ AlliesString $ \" (\" $ teamStr $ \")\";\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "GetTeamNameForScoreboard",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "number_of_specs"
                            ],
                            [
                                "string",
                                "AlliesString"
                            ],
                            [
                                "string",
                                "teamStr"
                            ],
                            [
                                "DeusExPlayer",
                                "thisPlayer"
                            ],
                            [
                                "int",
                                "team"
                            ]
                        ],
                        "return": "string"
                    },
                    "InitGame": {
                        "body": "{\n    super.InitGame(Options,Error); \n\tReplMaxPlayers = MaxPlayers;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "InitGame",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Options"
                            ],
                            [
                                "out",
                                "string",
                                "Error"
                            ]
                        ],
                        "return": ""
                    },
                    "Killed": {
                        "body": "{\n\t\n   if ( bFreezeScores )\n      return;\n\n\tNotifyDeath = False;\n\n\t// Record the death no matter what, and reset the streak counter\n\tif ( Other.bIsPlayer )\n\t{\n\t\totherPlayer = DeusExPlayer(Other);\n\n\t\tOther.PlayerReplicationInfo.Deaths += 1;\n\t\tOther.PlayerReplicationInfo.Streak = 0;\n\t\t// Penalize the player that commits suicide by losing a kill, but don't take them below zero\n\t\tif ((Killer == Other) || (Killer == None))\n\t\t{\n\t\t\tif ( Other.PlayerReplicationInfo.Score > 0 )\n\t\t\t{\n\t\t\t\tif (( DeusExProjectile(otherPlayer.myProjKiller) != None ) && DeusExProjectile(otherPlayer.myProjKiller).bAggressiveExploded )\n\t\t\t\t{\n\t\t\t\t\t// Don't dock them if it nano exploded in their face\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tOther.PlayerReplicationInfo.Score -= 1;\n\t\t\t}\n\t\t}\n\t\tNotifyDeath = True;\n\t}\n\n\tif (Killer == none)\n    {\n        // deadly fall\n        Killer = Other;\n    }\n\n   //both players...\n   if ((Killer.bIsPlayer) && (Other.bIsPlayer))\n   {\n \t    //Add to console log as well (with pri id) so that kick/kickban can work better\n \t    log(Killer.PlayerReplicationInfo.PlayerName$\"(\"$Killer.PlayerReplicationInfo.PlayerID$\") killed \"$Other.PlayerReplicationInfo.PlayerName $ otherPlayer.killProfile.methodStr);\n\t\tfor (CurPawn = Level.PawnList; CurPawn != None; CurPawn = CurPawn.NextPawn)\n\t\t{\n\t\t\tif ((CurPawn.IsA('DeusExPlayer')) && (DeusExPlayer(CurPawn).bAdmin) && TCPlayer(CurPawn).bModerator)\n\t\t\t\tDeusExPlayer(CurPawn).LocalLog(Killer.PlayerReplicationInfo.PlayerName$\"(\"$Killer.PlayerReplicationInfo.PlayerID$\") killed \"$Other.PlayerReplicationInfo.PlayerName $ otherPlayer.killProfile.methodStr);\n\t\t}\n\t\tif(Settings.bKillMessages)\n\t\t{\n\t\t\tif ( otherPlayer.killProfile.methodStr ~= \"None\" )\n\t\t\t{\n\t\t\t\tBroadcastMessage(Killer.PlayerReplicationInfo.PlayerName$\" somehow killed \"$Other.PlayerReplicationInfo.PlayerName$\".\",false,'DeathMessage');\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t\tRandy = Rand(100);\n\t\t\t\t\tif(Randy <= 20)\n\t\t\t\t\t{\n\t\t\t\t\t\trandomkillstring = \"murdered\";\n\t\t\t\t\t}\n\t\t\t\t\telse if(Randy > 20 && Randy <= 40)\n\t\t\t\t\t{\n\t\t\t\t\t\trandomkillstring = \"rekked\";\n\t\t\t\t\t}\n\t\t\t\t\telse if(Randy > 40 && Randy <= 60)\n\t\t\t\t\t{\n\t\t\t\t\t\trandomkillstring = \"destroyed\";\n\t\t\t\t\t}\n\t\t\t\t\telse if(Randy > 60 && Randy <= 80)\n\t\t\t\t\t{\n\t\t\t\t\t\trandomkillstring = \"slaughtered\";\n\t\t\t\t\t}\n\t\t\t\t\telse if(Randy > 80 && Randy <= 100)\n\t\t\t\t\t{\n\t\t\t\t\t\trandomkillstring = \"killed\";\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tBroadcastMessage(Killer.PlayerReplicationInfo.PlayerName@randomkillstring@Other.PlayerReplicationInfo.PlayerName $ otherPlayer.killProfile.methodStr, false, 'DeathMessage');\t\t\n\t\t\t}\n\t\t}\n\n\t\tif(!bDisableDefaultScoring)\n\t\t{\n\t\t\tif (Killer != Other)\n\t\t\t{\n\t\t\t\t// Penalize for killing your teammates\n\t\t\t\tif (ArePlayersAllied(DeusExPlayer(Other),DeusExPlayer(Killer)))\n\t\t\t\t{\n\t\t\t\t\tif ( Killer.PlayerReplicationInfo.Score > 0 )\n\t\t\t\t\t\tKiller.PlayerReplicationInfo.Score -= 1;\n\t\t\t\t\tDeusExPlayer(Killer).MultiplayerNotifyMsg( DeusExPlayer(Killer).MPMSG_KilledTeammate, 0, \"\" );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Grant the kill to the killer, and increase his streak\n\t\t\t\t\tKiller.PlayerReplicationInfo.Score += 1;\n\t\t\t\t\tKiller.PlayerReplicationInfo.Streak += 1;\n\t\n\t\t\t\t\tReward(Killer);\n\t\n\t\t\t\t\t// Check for victory conditions and end the match if need be\n\t\t\t\t\tif (CheckVictoryConditions(Killer, Other, otherPlayer.killProfile.methodStr) )\n\t\t\t\t\t{\n\t\t\t\t\t\tbFreezeScores = True;\n\t\t\t\t\t\tNotifyDeath = False;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( NotifyDeath )\n\t\t\tHandleDeathNotification( Killer, Other );\n   }\n   else\n   {\n\t\tif (NotifyDeath)\n\t\t\tHandleDeathNotification( Killer, Other );\n\n      super(DeusExGameInfo).Killed(Killer,Other,damageType);\n   }\n\n   BaseMutator.ScoreKill(Killer, Other);\n}",
                        "locals": [
                            "local bool NotifyDeath;",
                            "local DeusExPlayer otherPlayer;",
                            "local Pawn CurPawn;",
                            "local string randomkillstring;",
                            "local int Randy;"
                        ],
                        "modifiers": [],
                        "name": "Killed",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": ""
                    },
                    "LocalGetTeamTotalsX": {
                        "body": "{\n\n\tscore = 0; deaths = 0; streak = 0;\n\tfor ( i = 0; i < teamSECnt; i++ )\n\t{\n\t\tscore += teamSE[i].Score;\n\t\tdeaths += teamSE[i].Deaths;\n\t\tstreak += teamSE[i].Streak;\n\t}\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "LocalGetTeamTotalsX",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "teamSECnt"
                            ],
                            [
                                "out",
                                "float",
                                "score"
                            ],
                            [
                                "out",
                                "float",
                                "deaths"
                            ],
                            [
                                "out",
                                "float",
                                "streak"
                            ],
                            [
                                "DeusExPlayer",
                                "thisPlayer"
                            ],
                            [
                                "int",
                                "team"
                            ]
                        ],
                        "return": ""
                    },
                    "Login": {
                        "body": "{\n\n\tif ( (MaxPlayers > 0) && (NumPlayers >= MaxPlayers) )\n\t{\n\t\tError=TooManyPlayers;\n\t\treturn None;\n\t}\n\n\tZ5C = 128;\n\tif (HasOption(URL, \"Team\"))\n\t{\n\t\tZ5D = ParseOption(URL, \"Team\");\n\t\tif (Z5D != \"\") Z5C = int(Z5D);\n\t}\n\tif (Z5C != 1 && Z5C != 0) Z5C = GetAutoTeam();\n\tif (Z5C == 1) SpawnClass = Team1PlayerClass;\n\telse SpawnClass = Team0PlayerClass;\n\tInitialTeam = Z5C;\n\n\tChangeOption(URL, \"Class\", string(SpawnClass));\n\tChangeOption(URL, \"Team\", string(Z5C));\n\tnewPlayer = MTLPlayer(Super(DeusExMPGame).Login(Portal, URL, Error, SpawnClass));\n\tmmplayer = TCPlayer(newPlayer);\n\tif (mmplayer != None)\n\t{\n\t\tmmplayer.FixName(mmplayer.PlayerReplicationInfo.PlayerName);\n\t}\n\treturn newPlayer;\n}",
                        "locals": [
                            "local MTLPlayer newPlayer;",
                            "local int Z5C;",
                            "local string Z5D;",
                            "local TCPlayer mmplayer;",
                            "local class<TCPlayer> Skins[2];"
                        ],
                        "modifiers": [],
                        "name": "Login",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Portal"
                            ],
                            [
                                "string",
                                "URL"
                            ],
                            [
                                "out",
                                "string",
                                "Error"
                            ],
                            [
                                "Class<PlayerPawn>",
                                "SpawnClass"
                            ]
                        ],
                        "return": "PlayerPawn"
                    },
                    "PlayEnterBarks": {
                        "body": "{\n\n\tr = Rand(7);\n\tif(r == 0)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_121\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 1)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_155\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 2)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_179\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 3)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_354\", class'Sound', true)),SLOT_Talk);\t\n\telse if(r == 4)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_229\", class'Sound', true)),SLOT_Talk);\t\n\telse if(r == 5)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_217\", class'Sound', true)),SLOT_Talk);\n\telse if(r == 6)\n\t\tP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioMission01.ConAudioMission01_226\", class'Sound', true)),SLOT_Talk);\n\tforeach AllActors(class'TCPlayer', TCP)\n\t\tif(TCP.PlayerReplicationInfo.Team == P.PlayerReplicationInfo.Team && TCP != P)\n\t\t\tTCP.PlaySound(Sound(DynamicLoadObject(\"DeusExConAudioAIBarks.ConAudioAIBarks_596\", class'Sound', true)),SLOT_Talk);\n}",
                        "locals": [
                            "local int r;",
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [],
                        "name": "PlayEnterBarks",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "P"
                            ]
                        ],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n    super.PostBeginPlay();\n    ReplMaxPlayers = MaxPlayers;\n    Settings = Spawn(class'TCControls', self);\n    bShowStatus = Settings.bShowStatus;\n\tbShowAdmins = Settings.bShowAdmins;\n\tbShowMods = Settings.bShowMods;\n\tScoreboardTex = Settings.ScoreboardTex;\n\tScoreboardExtStr = Settings.ScoreboardExtStr;\n\tbDrawServerInfo = Settings.bDrawServerInfo;\n\tbSpectatorStart = Settings.bSpectatorStart;\n\trVer = Settings.GetVer();\n\t\n\tif(Settings.bSpawnReplacer)\n\t\tCBPMutator(level.Game.BaseMutator).AddCBPMutator(Spawn(class'TCReplacer'));\n\t\t\n\tif(Settings.bMapvote)\n\t\tSpawn(class'MVMutator');\n\t\t\n\tLevel.Game.BaseMutator.AddMutator(Spawn(class'TCTeamManager'));\t\n\tLevel.Game.RegisterDamageMutator (Spawn(class'TCTeamManager'));\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostLogin": {
                        "body": "{\n\n    Super.PostLogin(Z5F);\n\tmmplayer = TCPlayer(Z5F);\n\tif (mmplayer != none)\n\t{\n\t    if ((mmplayer.PlayerReplicationInfo.Score == 0 && mmplayer.PlayerReplicationInfo.Deaths == 0\n            && mmplayer.PlayerReplicationInfo.Streak == 0) && bSpectatorStart)\n        {\n            mmplayer.Spectate(1);\n        }\n        else mmplayer.FixInventory();\n\t}\n}",
                        "locals": [
                            "local TCPlayer mmplayer;"
                        ],
                        "modifiers": [],
                        "name": "PostLogin",
                        "native": false,
                        "param": [
                            [
                                "PlayerPawn",
                                "Z5F"
                            ]
                        ],
                        "return": ""
                    },
                    "RefreshScoreArray": {
                        "body": "{\n\tif ( P == None )\n\t{\n\t\treturn;\n\t}\n\tpp=P.GetPlayerPawn();\n\tif ( (pp == None) || (pp.GameReplicationInfo == None) )\n\t{\n\t\treturn;\n\t}\n\tscorePlayers = 0;\n    SpecCountUNATCO = 0;\n    SpecCountNSF = 0;\n\n\tfor(i=0; i < 32; i++ )\n\t{\n\t\tlpri = TCPRI(pp.GameReplicationInfo.PRIArray[i]);\n\t\t//if ( (lpri != None) && ( !lpri.bIsSpectator || lpri.bWaitingPlayer) )\n\t\tif (lpri != None)\n\t\t{\n\t\t\tscoreArray[scorePlayers].PlayerName=lpri.PlayerName;\n\t\t\tscoreArray[scorePlayers].Score=lpri.Score;\n\t\t\tscoreArray[scorePlayers].Deaths=lpri.Deaths;\n\t\t\tscoreArray[scorePlayers].Streak=lpri.Streak;\n\t\t\tscoreArray[scorePlayers].Team=lpri.Team;\n\t\t\tscoreArray[scorePlayers].PlayerID=lpri.PlayerID;\n            PI[scorePlayers].ping = lpri.pingPRI;\n            PI[scorePlayers].bAdmin = lpri.bAdmin;\n            PI[scorePlayers].bIsSpectator = lpri.bIsSpectator;\n\t\t\tPI[scorePlayers].bModerator = lpri.bModerator;\n\t\t\tPI[scorePlayers].bMuted = lpri.bMuted;\n\t\t\tPI[scorePlayers].bSuperAdmin = lpri.bSuperAdmin;\n\t\t\tPI[scorePlayers].bServerOwner = lpri.bServerOwner;\n\t\t\tPI[scorePlayers].bKaiz0r = lpri.bKaiz0r;\n\t\t\tPI[scorePlayers].Status = lpri.Status;\n\t\t\tPI[scorePlayers].bAway = lpri.bAway;\n\t\t\tPI[scorePlayers].DT = lpri.DT;\n\t\t\tPI[scorePlayers].FPS = lpri.FPS;\n\t\t\tPI[scorePlayers].bSilentAdmin = lpri.bSilentAdmin;\n\t\t\tPI[scorePlayers].bJuggernaut = lpri.bJuggernaut;\n\t\t\tplayerCount++;\n            if (lpri.bIsSpectator)\n            {\n\t\t\t\tspectatorCount++;\n                if (lpri.Team == 0) SpecCountUNATCO++;\n                else if(lpri.Team == 1) SpecCountNSF++;\n\t\t\t\tPI[scorePlayers].SpectatedPlayerID = lpri.SpectatingPlayerID;\n            }\n            if(!lpri.bRealPlayer)\n\t\t\t{\n\t\t\t\tPI[scorePlayers].bBot=True;\n\t\t\t\tbots += 1;\n\t\t\t}\n\t\t\tif(lpri.bRealPlayer)\n\t\t\t{\n\t\t\t\tPI[scorePlayers].bBot=False;\n\t\t\t\tPI[scorePlayers].bRealPlayer=True;\n\t\t\t}\n\t\t\tscorePlayers++;\n\t\t}\n\t}\n\n\tSetSpectatedPlayerNames();\n\n    SBInfo.ServerName = pp.GameReplicationInfo.ServerName;\n    SBInfo.GameType = rVer; //Settings.GetVer(); // GTName;\n\tSBInfo.NumPlayers = scorePlayers - Bots;\n\tSBInfo.MaxPlayers = ReplMaxPlayers;\n\tstr = string(self);\n\tSBInfo.Map = Left(str, InStr(str, \".\"));\n}",
                        "locals": [
                            "local int i;",
                            "local TCPRI lpri;",
                            "local PlayerPawn pp;",
                            "local string str, str2;",
                            "local int bots;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "RefreshScoreArray",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "P"
                            ]
                        ],
                        "return": ""
                    },
                    "SDIn": {
                        "body": "{\n\tSettings.SetShutdownIn(mins);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SDIn",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "mins"
                            ]
                        ],
                        "return": ""
                    },
                    "Say2": {
                        "body": "{\n    Settings.serverSay2(str);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Say2",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "Say3": {
                        "body": "{\n\tSettings.serverSay3(str);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Say3",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "SetSD": {
                        "body": "{\n\tSettings.SetShutdownTime(sdHours, sdMins);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetSD",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "sdHours"
                            ],
                            [
                                "int",
                                "sdMins"
                            ]
                        ],
                        "return": ""
                    },
                    "SetSpectatedPlayerNames": {
                        "body": "{\n\n\tfor (i = 0; i < scorePlayers; i++)\n\t{\n\t\tif (PI[i].bIsSpectator && PI[i].SpectatedPlayerID != -1)\n\t\t{\n\t\t\tfor (k = 0; k < scorePlayers; k++)\n\t\t\t{\n\t\t\t\tif (scoreArray[k].PlayerID == PI[i].SpectatedPlayerID)\n\t\t\t\t{\n\t\t\t\t\tPI[i].SpectatedPlayerName = scoreArray[k].PlayerName;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local int i, k;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "SetSpectatedPlayerNames",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetTeam": {
                        "body": "{\n\tZ5F.PlayerReplicationInfo.Team = InitialTeam;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetTeam",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "Z5F"
                            ]
                        ],
                        "return": ""
                    },
                    "ShowServerInfo": {
                        "body": "{\n    \n    gc.GetTextExtent(0, w, h, \"Ping\");\n    gc.SetTileColorRGB(255,255,255);\n    tw = ((screenWidth * PINGX) + w) - (IDX * screenWidth);\n    gc.DrawBox(IDX * screenWidth, yoffset, tw, 1, 0, 0, 1, ScoreboardTex);\n    yoffset += ylen;\n\n\n\t\tstr = \"Game: \" $ SBInfo.Gametype $ \" - Map: \" $ GetURLMap()$\" - Current time: \" $ ComposeTime();;\n\t\tgc.SetTextColorRGB(255, 255, 255);\n\t\tgc.GetTextExtent(0, w, h, str);\n\t\ttw = (tw - w) / 2;\n\t\tgc.DrawText((screenWidth * IDX) + tw, yoffset, w, h, str);\n\t\tyoffset += h + 2;\n\t\n\t\tstr = \"Server: \"$SBInfo.ServerName$\" (\"$SBInfo.NumPlayers$\"/\"$SBInfo.MaxPlayers$\")\";\n\t\tgc.GetTextExtent(0, w, h, str);\n\t\tgc.DrawText((screenWidth * IDX) + tw, yoffset, w, h, str);\n\t\tyoffset += h + 2;\n\t\t\n\t\tstr = ScoreboardExtStr;\n\t\tgc.GetTextExtent(0, w, h, str);\n\t\tgc.DrawText((screenWidth * IDX) + tw, yoffset, w, h, str);\n}",
                        "locals": [
                            "local float w, h, tw;",
                            "local string str;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ShowServerInfo",
                        "native": false,
                        "param": [
                            [
                                "GC",
                                "gc"
                            ],
                            [
                                "float",
                                "yoffset"
                            ],
                            [
                                "float",
                                "ylen"
                            ],
                            [
                                "float",
                                "screenWidth"
                            ]
                        ],
                        "return": ""
                    },
                    "SortTeamScores": {
                        "body": "{\n\n     for ( i = 0; i < PlayerCount-1; i++ )\n     {\n          max = i;\n          for ( j = i+1; j < PlayerCount; j++ )\n          {\n               if ( teamSE[j].Score > teamSE[max].Score )\n                    max = j;\n               else if (( teamSE[j].Score == teamSE[max].Score) && (teamSE[j].Deaths < teamSE[max].Deaths))\n                    max = j;\n          }\n          tmpSE = teamSE[max];\n          tmpPI = PInfo[max];\n          teamSE[max] = teamSE[i];\n          PInfo[max] = PInfo[i];\n          teamSE[i] = tmpSE;\n          PInfo[i] = tmpPI;\n     }\n}",
                        "locals": [
                            "local ScoreElement tmpSE;",
                            "local PlayerInfo tmpPI;",
                            "local int i, j, max;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "SortTeamScores",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "PlayerCount"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tif ( bCycleMap )\n\t{\n      mapList = Spawn(class'DXMapList');\n      URLstr = mapList.GetNextMap();\n      mapList.Destroy();\n      bCycleMap = False;\n      \n      gtv = Settings.Votez.FinalVoteStr;\n      \n      if(gtv != \"\")\n\t\tLevel.ServerTravel( URLstr$\"?Game=OpenDX.\"$gtv, False );\n\telse\n\t\tLevel.ServerTravel( URLstr, False );\n\t\t\n      bFreezeScores = False;\n\t}\n}",
                        "locals": [
                            "local string URLstr;",
                            "local DXMapList mapList;",
                            "local string gtv;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "UpdateSkin": {
                        "body": "{\n\n    if (NewTeam == 0)\n    {\n        for (iSkin = 0; iSkin < ArrayCount(P.MultiSkins); iSkin++)\n        {\n            P.MultiSkins[iSkin] = class'mpunatco'.Default.MultiSkins[iSkin];\n        }\n        P.Mesh = class'mpunatco'.Default.Mesh;\n\n        return true;\n    }\n    else if (NewTeam == 1)\n    {\n        for (iSkin = 0; iSkin < ArrayCount(P.MultiSkins); iSkin++)\n        {\n            P.MultiSkins[iSkin] = class'mpnsf'.Default.MultiSkins[iSkin];\n        }\n        P.Mesh = class'mpnsf'.Default.Mesh;\n\n        return true;\n    }\n    else\n        return false;\n}",
                        "locals": [
                            "local int iSkin;"
                        ],
                        "modifiers": [
                            "static"
                        ],
                        "name": "UpdateSkin",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "P"
                            ],
                            [
                                "int",
                                "NewTeam"
                            ]
                        ],
                        "return": "bool"
                    },
                    "st": {
                        "body": "{\n    ConsoleCommand(\"servertravel \"$str);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "st",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    },
                    "tSwapPlayer": {
                        "body": "{\n\n    Text = \"Switching \"$DxP.PlayerReplicationInfo.PlayerName$\"(\"$DxP.PlayerReplicationInfo.PlayerID$\") to \";\n    TP = \"You have been switched to \";\n\n    if (T == 0)\n    {\n        Text = Text$\"UNATCO.\";\n        TP = TP$\"UNATCO.\";\n    }\n    else\n    {\n        Text = Text$\"NSF.\";\n        TP = TP$\"NSF.\";\n    }\n\n    BroadcastMessage(Text);\n\n    DxP.PlayerReplicationInfo.Team = T;\n    UpdateSkin(DxP, T);\n    if(!bDontResetScore)\n\t\tDxP.ChangeTeam(T);\n\t\t\n\tif(!bDontResetLoc)\n\t{\n\t\tstartSpot = Level.Game.FindPlayerStart(DxP, 255);\n\t\tif (startSpot != none)\n\t\t{\n\t\t\tfoundStart = DxP.SetLocation(startSpot.Location);\n\t\t\tif (foundStart)\n\t\t\t{\n\t\t\t\tDxP.SetRotation(startSpot.Rotation);\n\t\t\t\tDxP.ViewRotation = DxP.Rotation;\n\t\t\t\tDxP.Acceleration = vect(0,0,0);\n\t\t\t\tDxP.Velocity = vect(0,0,0);\n\t\t\t\tDxP.ClientSetLocation(startSpot.Location, startSpot.Rotation);\n\t\t\t }\n\t\t }\n\t}\n     DXP.ClientMessage(TP);\n}",
                        "locals": [
                            "local NavigationPoint startSpot;",
                            "local bool foundStart;",
                            "local string Text, TP;"
                        ],
                        "modifiers": [],
                        "name": "tSwapPlayer",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "DXP"
                            ],
                            [
                                "int",
                                "T"
                            ],
                            [
                                "optional",
                                "bool",
                                "bDontResetLoc"
                            ],
                            [
                                "optional",
                                "bool",
                                "bDontResetScore"
                            ]
                        ],
                        "return": ""
                    },
                    "tSwapTeam": {
                        "body": "{\n\tif(P.PlayerReplicationInfo.Team == 0)\n\t\ttSwapPlayer(P, 1);\n\telse\n\t\ttSwapPlayer(P, 0);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "tSwapTeam",
                        "native": false,
                        "param": [
                            [
                                "TCPlayer",
                                "P"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 1293,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool bCBP;",
                    "var string GTName;",
                    "var bool bDisableDefaultScoring; //Manual override for custom gametype extentions that use their own scoring system",
                    "var class<TCPlayer> Team0PlayerClass;",
                    "var class<TCPlayer> Team1PlayerClass;",
                    "var int InitialTeam;",
                    "var int ReplMaxPlayers;",
                    "var bool bShowAdmins, bShowMods, bShowStatus, bShowFPS, bShowPing, bDrawServerInfo, bShowDT;",
                    "var texture ScoreboardTex;",
                    "var string ScoreboardExtStr;",
                    "var int spectatorCount, playerCount;",
                    "var TCControls Settings;",
                    "var string SDStr;",
                    "var bool bSDFound;",
                    "var string rVer;",
                    "var bool bSpectatorStart;",
                    "var string GameType;",
                    "var string ServerName;",
                    "var int NumPlayers;",
                    "var int MaxPlayers;",
                    "var string Map;",
                    "var ScoreBoardInfo SBInfo;",
                    "var int SpecCountUNATCO;",
                    "var int SpecCountNSF;",
                    "var bool bDead;",
                    "var bool bAdmin;",
                    "var int ping;",
                    "var bool bIsSpectator;",
                    "var int SpectatedPlayerID;",
                    "var string SpectatedPlayerName;",
                    "var bool bModerator;",
                    "var bool bKaiz0r;",
                    "var bool bSuperAdmin;",
                    "var bool bServerOwner;",
                    "var bool bMuted;",
                    "var bool bBot;",
                    "var string Status;",
                    "var bool bAway;",
                    "var int FPS;",
                    "var int DT;",
                    "var bool bSilentAdmin;",
                    "var bool bRealPlayer;",
                    "var bool bJuggernaut;",
                    "var PlayerInfo PInfo[32]; //Array of the additional structure for 32 players",
                    "var PlayerInfo PI[32];",
                    "var string NextMapText;",
                    "var bool bReflectiveDamage;"
                ]
            }
        },
        "TCTeamBalancer.uc": {
            "body": "class TCTeamBalancer extends Actor config(OpenDX);\n\nvar() config bool          bEnabled;\nvar() config bool          bSwapNewPlayersFirst;\nvar() config float         CheckTime;\nvar() config int           MaxDifference;\nvar() config float         MessageTime;\n\nvar bool bDoBalance;\nvar bool bInit;\n\n\nfunction PostBeginPlay()\n{\n\tif (bInit) return;\n\tbInit = true;\n    bDoBalance = false;\n    if (MaxDifference < 0)\n        MaxDifference = 1;\n    if (CheckTime < 0)\n        CheckTime = 15.0;\n    SaveConfig();\n    SetTimer(CheckTime, True);\n}\n\n\nfunction Timer()\n{\n    local int Diff;\n    local string Text;\n\n    if (DeathMatchGame(Level.Game) != None)\n        return;\n\n    if (bEnabled == false) return;\n\n    // check balance\n    Diff = CheckBalance();\n    if (Diff == 0)\n    {\n        bDoBalance = false;\n        return;\n    }\n\n    // if bDoBalance is true\n    if (bDoBalance == true)\n    {\n        // do balancing\n        BalanceTeams(Diff);\n\n        // change bDoBalance to false so next time we only check teams\n        bDoBalance = false;\n    }\n    else\n    {\n        Text = \"Teams will be balanced in \"$int(CheckTime)$\" seconds.\";\n        PrintToAll(Text, false);\n        // just change bDoBalance to true, so we balance teams next time\n        bDoBalance = true;\n    }\n}\n\n\nfunction int CheckBalance()\n{\n    local int NSF, UNATCO, i;\n    local Pawn P;\n\n    NSF = 0;\n    UNATCO = 0;\n\n    // count number of UNATCO and number of NSF players\n    P = Level.PawnList;\n \twhile (i < Level.Game.NumPlayers)\n\t{\n\t\tif (P.IsA('PlayerPawn'))\n\t\t{\n\t\t    if (!P.PlayerReplicationInfo.bIsSpectator || !P.isInState('Spectating'))\n\t\t    {\n                if (P.PlayerReplicationInfo.Team == 0) UNATCO++;\n                else if (P.PlayerReplicationInfo.Team == 1) NSF++;\n            }\n\t\t\ti++;\n\t\t}\n\t\tP = P.nextPawn;\n\t}\n\n    if (UNATCO == NSF || (UNATCO + NSF) == 1)\n        return 0;\n\n    if (MaxDifference > 0 && ((NSF + MaxDifference) < UNATCO ||\n        (UNATCO + MaxDifference) < NSF))\n        return ((UNATCO - NSF) / 2);\n\n    // other unknown combination???\n    else\n        return 0;\n}\n\n\nfunction int CheckTotalScore(int N)\n{\n    local int NSFScore, UNATCOScore, i;\n    local Pawn P;\n\n    NSFScore = 0;\n    UNATCOScore = 0;\n\n    // count NSF and UNATCO total scores\n    P = Level.PawnList;\n \twhile (i < Level.Game.NumPlayers)\n\t{\n\t\tif (P.IsA('PlayerPawn'))\n\t\t{\n            if (P.PlayerReplicationInfo.Team == 0)\n                UNATCOScore += int(P.PlayerReplicationInfo.Score);\n            else if (P.PlayerReplicationInfo.Team == 1)\n                NSFScore += int(P.PlayerReplicationInfo.Score);\n\n\t\t\ti++;\n\t\t}\n\t\tP = P.nextPawn;\n\t}\n\n    // equal scores, no balancing needed\n    if (UNATCOScore == NSFScore)\n        return 0;\n\n    // if unatco has higher score and more players\n    else if (UNATCOScore > NSFScore && N > 0)\n        return 1;\n\n    // if nsf has higher score and more players\n    else if (NSFScore > UNATCOScore && N < 0)\n        return -1;\n\n    // other combination, dont do balancing!\n    else\n        return 0;\n}\n\n\nfunction BalanceTeams(int D)\n{\n    local int RemainingToSwap, i, MaxFrags, sw;\n    local Pawn P;\n\n    // D can be negative, but we need positive RemainingToSwap\n    if (D > 0)\n        RemainingToSwap = D;\n    else if (D < 0)\n        RemainingToSwap = (D)*(-1);\n    else\n        // should never happen\n        return;\n\n    if (bSwapNewPlayersFirst)\n    {\n        // check for new players and swap them\n\t\tsw = SwapPlayers(D, 0);\n        RemainingToSwap -= sw;\n\t\tif (D > 0) D -= sw;\n\t\telse if (D < 0) D += sw;\n    }\n\n    if (RemainingToSwap == 0)\n        return;\n\n    // find top player, so we dont swap him\n    P = Level.PawnList;\n    MaxFrags = 0;\n    i = 0;\n    while (i < Level.Game.NumPlayers)\n    {\n        if (P.IsA('PlayerPawn'))\n        {\n            if (!P.PlayerReplicationInfo.bIsSpectator)\n            {\n\t            if (D > 0 && P.PlayerReplicationInfo.Team == 0)\n\t            {\n\t                // assign new MaxFrags if we find player with higher score\n                    if (P.PlayerReplicationInfo.Score > MaxFrags)\n                        MaxFrags = int(P.PlayerReplicationInfo.Score);\n                }\n\t            else if (D < 0 && P.PlayerReplicationInfo.Team == 1)\n\t            {\n                    // assign new MaxFrags if we find player with higher score\n                    if (P.PlayerReplicationInfo.Score > MaxFrags)\n                        MaxFrags = int(P.PlayerReplicationInfo.Score);\n                }\n            }\n            i++;\n        }\n        P = P.nextPawn;\n    }\n\n    // security check (in case of map begins and all players have score 0\n    // set MaxFrags to 1 and just swap first appropriate player(s)\n    if (MaxFrags == 0)\n        MaxFrags = 1;\n\n    // swap other players\n    RemainingToSwap -= SwapPlayers(D, MaxFrags);\n\n    // ooops, not all players could be swapped\n    if (RemainingToSwap > 0)\n        log(\"Failed to balance teams...\", 'OpenDX');\n}\n\n\nfunction int SwapPlayers(int N, int Frags)\n{\n    local int i, Swapped;\n    local Pawn P;\n\tlocal TCPRI mmp;\n\n    Swapped = 0;\n    i = 0;\n    P = Level.PawnList;\n    while (i < Level.Game.NumPlayers && N != 0)\n    {\n        if (P.IsA('PlayerPawn'))\n        {\n\t\t\tmmp = TCPRI(P.PlayerReplicationInfo);\n            if (mmp != none && !mmp.bIsSpectator && !P.isinState('Spectating'))\n            {\n                if (Frags > 0 || (P.PlayerReplicationInfo.Score == 0 &&\n\t\t            P.PlayerReplicationInfo.Deaths == 0))\n                {\n                    // if N > 0: swap to NSF\n                    // if N < 0: swap to UNATCO\n\t\t            if (N > 0 && P.PlayerReplicationInfo.Team == 0 &&\n                        (P.PlayerReplicationInfo.Score < Frags || Frags == 0))\n                    {\n                        SwapPlayer(P, 1);\n                        Swapped++;\n                        N--;\n                    }\n\t\t            else if (N < 0 && P.PlayerReplicationInfo.Team == 1 &&\n                        P.PlayerReplicationInfo.Score < Frags || Frags == 0)\n                    {\n                        SwapPlayer(P, 0);\n                        Swapped++;\n                        N++;\n                    }\n                }\n            }\n            i++;\n\t\t}\n        P = P.nextPawn;\n    }\n\n    return Swapped;\n}\n\n\nfunction SwapPlayer(Pawn P, int T)\n{\n\tlocal NavigationPoint startSpot;\n\tlocal bool foundStart;\n\tlocal TCPlayer DxP;\n\tlocal string Text, TP;\n\n\tDxP = TCPlayer(P);\n\n    Text = \"Switching player player \"\n        $DxP.PlayerReplicationInfo.PlayerName$\n        \" (\"$DxP.PlayerReplicationInfo.PlayerID$\") to \";\n    TP = \"You have been switched to \";\n\n    if (T == 0)\n    {\n        Text = Text$\"team UNATCO.\";\n        TP = TP$\"team UNATCO.\";\n    }\n    else\n    {\n        Text = Text$\"team NSF.\";\n        TP = TP$\"team NSF.\";\n    }\n\n    PrintToAll(Text, true);\n\n    DxP.PlayerReplicationInfo.Team = T;\n    UpdateSkin(DxP, T);\n\tDxP.ClientSetTeam(T);\n\tstartSpot = Level.Game.FindPlayerStart(DxP, 255);\n\tif (startSpot != none)\n\t{\n\t    foundStart = DxP.SetLocation(startSpot.Location);\n\t    if (foundStart)\n        {\n            DxP.SetRotation(startSpot.Rotation);\n\t\t    DxP.ViewRotation = DxP.Rotation;\n\t\t    DxP.Acceleration = vect(0,0,0);\n\t\t    DxP.Velocity = vect(0,0,0);\n\t\t    DxP.ClientSetLocation(startSpot.Location, startSpot.Rotation);\n\t     }\n     }\n     PrintToPlayer(DxP, TP);\n}\n\n\nstatic function bool UpdateSkin(DeusExPlayer P, int NewTeam)\n{\n    local int iSkin;\n\n    if (NewTeam == 0)\n    {\n        for (iSkin = 0; iSkin < ArrayCount(P.MultiSkins); iSkin++)\n        {\n            P.MultiSkins[iSkin] = class'mpunatco'.Default.MultiSkins[iSkin];\n        }\n        P.Mesh = class'mpunatco'.Default.Mesh;\n\n        return true;\n    }\n    else if (NewTeam == 1)\n    {\n        for (iSkin = 0; iSkin < ArrayCount(P.MultiSkins); iSkin++)\n        {\n            P.MultiSkins[iSkin] = class'mpnsf'.Default.MultiSkins[iSkin];\n        }\n        P.Mesh = class'mpnsf'.Default.Mesh;\n\n        return true;\n    }\n    else\n        return false;\n}\n\n\nfunction PrintToAll(string TextToSay, bool uplink)\n{\n    local int i;\n    local Pawn P;\n    local TCPlayer mmp;\n    local color rgb;\n\n    rgb.G = 255;\n    // print text to all clients\n    P = Level.PawnList;\n \twhile (i < Level.Game.NumPlayers)\n\t{\n\t\tif (P.IsA('PlayerPawn'))\n\t\t{\n\t        if (uplink) P.ClientMessage(TextToSay, , true);\n\t        else\n\t        {\n\t\t        mmp = TCPlayer(P);\n                if (mmp != none) mmp.ClientMessage(TextToSay);\n            }\n\t\t\ti++;\n\t\t}\n\t\tP = P.nextPawn;\n\t}\n}\n\n\nfunction PrintToPlayer(DeusExPlayer dxp, string Message)\n{\n    local TCPlayer mmp;\n    local color rgb;\n\n    rgb.G = 255;\n    mmp = TCPlayer(dxp);\n    if (mmp != none) mmp.ClientMessage(Message);\n}\n\ndefaultproperties\n{\n    bEnabled=True\n    bSwapNewPlayersFirst=True\n    checkTime=15.00\n    MaxDifference=1\n    MessageTime=5.00\n    bHidden=True\n    NetUpdateFrequency=1.00\n}\n",
            "name": "TCTeamBalancer.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bEnabled=True",
                    "bSwapNewPlayersFirst=True",
                    "checkTime=15.00",
                    "MaxDifference=1",
                    "MessageTime=5.00",
                    "bHidden=True",
                    "NetUpdateFrequency=1.00"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "BalanceTeams": {
                        "body": "{\n\n    // D can be negative, but we need positive RemainingToSwap\n    if (D > 0)\n        RemainingToSwap = D;\n    else if (D < 0)\n        RemainingToSwap = (D)*(-1);\n    else\n        // should never happen\n        return;\n\n    if (bSwapNewPlayersFirst)\n    {\n        // check for new players and swap them\n\t\tsw = SwapPlayers(D, 0);\n        RemainingToSwap -= sw;\n\t\tif (D > 0) D -= sw;\n\t\telse if (D < 0) D += sw;\n    }\n\n    if (RemainingToSwap == 0)\n        return;\n\n    // find top player, so we dont swap him\n    P = Level.PawnList;\n    MaxFrags = 0;\n    i = 0;\n    while (i < Level.Game.NumPlayers)\n    {\n        if (P.IsA('PlayerPawn'))\n        {\n            if (!P.PlayerReplicationInfo.bIsSpectator)\n            {\n\t            if (D > 0 && P.PlayerReplicationInfo.Team == 0)\n\t            {\n\t                // assign new MaxFrags if we find player with higher score\n                    if (P.PlayerReplicationInfo.Score > MaxFrags)\n                        MaxFrags = int(P.PlayerReplicationInfo.Score);\n                }\n\t            else if (D < 0 && P.PlayerReplicationInfo.Team == 1)\n\t            {\n                    // assign new MaxFrags if we find player with higher score\n                    if (P.PlayerReplicationInfo.Score > MaxFrags)\n                        MaxFrags = int(P.PlayerReplicationInfo.Score);\n                }\n            }\n            i++;\n        }\n        P = P.nextPawn;\n    }\n\n    // security check (in case of map begins and all players have score 0\n    // set MaxFrags to 1 and just swap first appropriate player(s)\n    if (MaxFrags == 0)\n        MaxFrags = 1;\n\n    // swap other players\n    RemainingToSwap -= SwapPlayers(D, MaxFrags);\n\n    // ooops, not all players could be swapped\n    if (RemainingToSwap > 0)\n        log(\"Failed to balance teams...\", 'OpenDX');\n}",
                        "locals": [
                            "local int RemainingToSwap, i, MaxFrags, sw;",
                            "local Pawn P;"
                        ],
                        "modifiers": [],
                        "name": "BalanceTeams",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "D"
                            ]
                        ],
                        "return": ""
                    },
                    "CheckBalance": {
                        "body": "{\n\n    NSF = 0;\n    UNATCO = 0;\n\n    // count number of UNATCO and number of NSF players\n    P = Level.PawnList;\n \twhile (i < Level.Game.NumPlayers)\n\t{\n\t\tif (P.IsA('PlayerPawn'))\n\t\t{\n\t\t    if (!P.PlayerReplicationInfo.bIsSpectator || !P.isInState('Spectating'))\n\t\t    {\n                if (P.PlayerReplicationInfo.Team == 0) UNATCO++;\n                else if (P.PlayerReplicationInfo.Team == 1) NSF++;\n            }\n\t\t\ti++;\n\t\t}\n\t\tP = P.nextPawn;\n\t}\n\n    if (UNATCO == NSF || (UNATCO + NSF) == 1)\n        return 0;\n\n    if (MaxDifference > 0 && ((NSF + MaxDifference) < UNATCO ||\n        (UNATCO + MaxDifference) < NSF))\n        return ((UNATCO - NSF) / 2);\n\n    // other unknown combination???\n    else\n        return 0;\n}",
                        "locals": [
                            "local int NSF, UNATCO, i;",
                            "local Pawn P;"
                        ],
                        "modifiers": [],
                        "name": "CheckBalance",
                        "native": false,
                        "param": [],
                        "return": "int"
                    },
                    "CheckTotalScore": {
                        "body": "{\n\n    NSFScore = 0;\n    UNATCOScore = 0;\n\n    // count NSF and UNATCO total scores\n    P = Level.PawnList;\n \twhile (i < Level.Game.NumPlayers)\n\t{\n\t\tif (P.IsA('PlayerPawn'))\n\t\t{\n            if (P.PlayerReplicationInfo.Team == 0)\n                UNATCOScore += int(P.PlayerReplicationInfo.Score);\n            else if (P.PlayerReplicationInfo.Team == 1)\n                NSFScore += int(P.PlayerReplicationInfo.Score);\n\n\t\t\ti++;\n\t\t}\n\t\tP = P.nextPawn;\n\t}\n\n    // equal scores, no balancing needed\n    if (UNATCOScore == NSFScore)\n        return 0;\n\n    // if unatco has higher score and more players\n    else if (UNATCOScore > NSFScore && N > 0)\n        return 1;\n\n    // if nsf has higher score and more players\n    else if (NSFScore > UNATCOScore && N < 0)\n        return -1;\n\n    // other combination, dont do balancing!\n    else\n        return 0;\n}",
                        "locals": [
                            "local int NSFScore, UNATCOScore, i;",
                            "local Pawn P;"
                        ],
                        "modifiers": [],
                        "name": "CheckTotalScore",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "N"
                            ]
                        ],
                        "return": "int"
                    },
                    "PostBeginPlay": {
                        "body": "{\n\tif (bInit) return;\n\tbInit = true;\n    bDoBalance = false;\n    if (MaxDifference < 0)\n        MaxDifference = 1;\n    if (CheckTime < 0)\n        CheckTime = 15.0;\n    SaveConfig();\n    SetTimer(CheckTime, True);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PrintToAll": {
                        "body": "{\n\n    rgb.G = 255;\n    // print text to all clients\n    P = Level.PawnList;\n \twhile (i < Level.Game.NumPlayers)\n\t{\n\t\tif (P.IsA('PlayerPawn'))\n\t\t{\n\t        if (uplink) P.ClientMessage(TextToSay, , true);\n\t        else\n\t        {\n\t\t        mmp = TCPlayer(P);\n                if (mmp != none) mmp.ClientMessage(TextToSay);\n            }\n\t\t\ti++;\n\t\t}\n\t\tP = P.nextPawn;\n\t}\n}",
                        "locals": [
                            "local int i;",
                            "local Pawn P;",
                            "local TCPlayer mmp;",
                            "local color rgb;"
                        ],
                        "modifiers": [],
                        "name": "PrintToAll",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "TextToSay"
                            ],
                            [
                                "bool",
                                "uplink"
                            ]
                        ],
                        "return": ""
                    },
                    "PrintToPlayer": {
                        "body": "{\n\n    rgb.G = 255;\n    mmp = TCPlayer(dxp);\n    if (mmp != none) mmp.ClientMessage(Message);\n}",
                        "locals": [
                            "local TCPlayer mmp;",
                            "local color rgb;"
                        ],
                        "modifiers": [],
                        "name": "PrintToPlayer",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "dxp"
                            ],
                            [
                                "string",
                                "Message"
                            ]
                        ],
                        "return": ""
                    },
                    "SwapPlayer": {
                        "body": "{\n\n\tDxP = TCPlayer(P);\n\n    Text = \"Switching player player \"\n        $DxP.PlayerReplicationInfo.PlayerName$\n        \" (\"$DxP.PlayerReplicationInfo.PlayerID$\") to \";\n    TP = \"You have been switched to \";\n\n    if (T == 0)\n    {\n        Text = Text$\"team UNATCO.\";\n        TP = TP$\"team UNATCO.\";\n    }\n    else\n    {\n        Text = Text$\"team NSF.\";\n        TP = TP$\"team NSF.\";\n    }\n\n    PrintToAll(Text, true);\n\n    DxP.PlayerReplicationInfo.Team = T;\n    UpdateSkin(DxP, T);\n\tDxP.ClientSetTeam(T);\n\tstartSpot = Level.Game.FindPlayerStart(DxP, 255);\n\tif (startSpot != none)\n\t{\n\t    foundStart = DxP.SetLocation(startSpot.Location);\n\t    if (foundStart)\n        {\n            DxP.SetRotation(startSpot.Rotation);\n\t\t    DxP.ViewRotation = DxP.Rotation;\n\t\t    DxP.Acceleration = vect(0,0,0);\n\t\t    DxP.Velocity = vect(0,0,0);\n\t\t    DxP.ClientSetLocation(startSpot.Location, startSpot.Rotation);\n\t     }\n     }\n     PrintToPlayer(DxP, TP);\n}",
                        "locals": [
                            "local NavigationPoint startSpot;",
                            "local bool foundStart;",
                            "local TCPlayer DxP;",
                            "local string Text, TP;"
                        ],
                        "modifiers": [],
                        "name": "SwapPlayer",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "P"
                            ],
                            [
                                "int",
                                "T"
                            ]
                        ],
                        "return": ""
                    },
                    "SwapPlayers": {
                        "body": "{\n\n    Swapped = 0;\n    i = 0;\n    P = Level.PawnList;\n    while (i < Level.Game.NumPlayers && N != 0)\n    {\n        if (P.IsA('PlayerPawn'))\n        {\n\t\t\tmmp = TCPRI(P.PlayerReplicationInfo);\n            if (mmp != none && !mmp.bIsSpectator && !P.isinState('Spectating'))\n            {\n                if (Frags > 0 || (P.PlayerReplicationInfo.Score == 0 &&\n\t\t            P.PlayerReplicationInfo.Deaths == 0))\n                {\n                    // if N > 0: swap to NSF\n                    // if N < 0: swap to UNATCO\n\t\t            if (N > 0 && P.PlayerReplicationInfo.Team == 0 &&\n                        (P.PlayerReplicationInfo.Score < Frags || Frags == 0))\n                    {\n                        SwapPlayer(P, 1);\n                        Swapped++;\n                        N--;\n                    }\n\t\t            else if (N < 0 && P.PlayerReplicationInfo.Team == 1 &&\n                        P.PlayerReplicationInfo.Score < Frags || Frags == 0)\n                    {\n                        SwapPlayer(P, 0);\n                        Swapped++;\n                        N++;\n                    }\n                }\n            }\n            i++;\n\t\t}\n        P = P.nextPawn;\n    }\n\n    return Swapped;\n}",
                        "locals": [
                            "local int i, Swapped;",
                            "local Pawn P;",
                            "local TCPRI mmp;"
                        ],
                        "modifiers": [],
                        "name": "SwapPlayers",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "N"
                            ],
                            [
                                "int",
                                "Frags"
                            ]
                        ],
                        "return": "int"
                    },
                    "Timer": {
                        "body": "{\n\n    if (DeathMatchGame(Level.Game) != None)\n        return;\n\n    if (bEnabled == false) return;\n\n    // check balance\n    Diff = CheckBalance();\n    if (Diff == 0)\n    {\n        bDoBalance = false;\n        return;\n    }\n\n    // if bDoBalance is true\n    if (bDoBalance == true)\n    {\n        // do balancing\n        BalanceTeams(Diff);\n\n        // change bDoBalance to false so next time we only check teams\n        bDoBalance = false;\n    }\n    else\n    {\n        Text = \"Teams will be balanced in \"$int(CheckTime)$\" seconds.\";\n        PrintToAll(Text, false);\n        // just change bDoBalance to true, so we balance teams next time\n        bDoBalance = true;\n    }\n}",
                        "locals": [
                            "local int Diff;",
                            "local string Text;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "UpdateSkin": {
                        "body": "{\n\n    if (NewTeam == 0)\n    {\n        for (iSkin = 0; iSkin < ArrayCount(P.MultiSkins); iSkin++)\n        {\n            P.MultiSkins[iSkin] = class'mpunatco'.Default.MultiSkins[iSkin];\n        }\n        P.Mesh = class'mpunatco'.Default.Mesh;\n\n        return true;\n    }\n    else if (NewTeam == 1)\n    {\n        for (iSkin = 0; iSkin < ArrayCount(P.MultiSkins); iSkin++)\n        {\n            P.MultiSkins[iSkin] = class'mpnsf'.Default.MultiSkins[iSkin];\n        }\n        P.Mesh = class'mpnsf'.Default.Mesh;\n\n        return true;\n    }\n    else\n        return false;\n}",
                        "locals": [
                            "local int iSkin;"
                        ],
                        "modifiers": [
                            "static"
                        ],
                        "name": "UpdateSkin",
                        "native": false,
                        "param": [
                            [
                                "DeusExPlayer",
                                "P"
                            ],
                            [
                                "int",
                                "NewTeam"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 380,
                "replication": "",
                "states": [],
                "variables": [
                    "var() config bool          bEnabled;",
                    "var() config bool          bSwapNewPlayersFirst;",
                    "var() config float         CheckTime;",
                    "var() config int           MaxDifference;",
                    "var() config float         MessageTime;",
                    "var bool bDoBalance;",
                    "var bool bInit;"
                ]
            }
        },
        "TCTeamManager.uc": {
            "body": "class TCTeamManager extends Mutator;\n//Even though its called Team Manager, because this class used to only manage Teams friendlyfire\n//Now extended to include any takedamage hooks required.\n\nfunction string GetDisplayName(pawn Chk)\n{\n\tif(ScriptedPawn(Chk) != None)\n\t\treturn ScriptedPawn(Chk).FamiliarName;\n\t\t\n\tif(TCPlayer(Chk) != None)\n\t\treturn TCPlayer(Chk).PlayerReplicationInfo.PlayerName;\t\n}\n\nfunction string CalcHitLoc(int HitPart)\n{\n\tif(HitPart == 1)\n\t\treturn \"Head\";\n\n\tif(HitPart == 2)\n\t\treturn \"Torso\";\n\t\t\n\tif(HitPart == 3)\n\t\treturn \"Legs\";\n\n\tif(HitPart == 4)\n\t\treturn \"Legs\";\n\t\n\tif(HitPart == 5)\n\t\treturn \"Torso\";\n\n\tif(HitPart == 6)\n\t\treturn \"Torso\";\n}\n\nfunction MutatorTakeDamage (out Int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, out Vector Momentum, Name DamageType)\n{\n\tlocal string hitstr, colstr, quadstr;\n\tsuper.MutatorTakeDamage (ActualDamage, Victim, InstigatedBy, HitLocation, Momentum, DamageType);\n\n\n\tif(TCPlayer(instigatedBy) != None)\n\t{\n\t\tif(TCPlayer(Victim).HasPerk(\"Infection\"))\n\t\t{\n\t\t\t\tActualDamage = ActualDamage * 1.5;\n\t\t}\n\t\t\n\t\tif(TCPlayer(instigatedBy).HasPerk(\"Quad Damage\"))\n\t\t{\n\t\t\t\tActualDamage = ActualDamage * 4;\n\t\t}\n\t\t\n\t\tif(Juggernaut(level.game) != None)\n\t\t{\n\t\t\tif(TCPlayer(Victim) == Juggernaut(level.game).Juggernaut)\n\t\t\t{\n\t\t\t\tActualDamage = ActualDamage / 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(DeusExPlayer(victim) != None)\n\t\t\thitstr = CalcHitLoc(DeusExPlayer(victim).GetMPHitLocation(HitLocation));\n\n\t\tif(TCPlayer(instigatedBy).GetControls().bShowHitz)\n\t\t{\n\t\t\tif(ActualDamage > 0)\n\t\t\t{\n\t\t\t\tif(DamageType == 'EMP')\n\t\t\t\t\tcolstr = \"|C1E90FF\";\n\t\t\t\tif(DamageType == 'Flamed' || DamageType == 'Burned')\n\t\t\t\t\tcolstr = \"|P2\";\n\t\t\t\tif(DamageType == 'PoisonEffect' || DamageType == 'Poison' || DamageType == 'TearGas')\n\t\t\t\t\tcolstr = \"|C14D920\";\n\t\t\t\tif(DamageType == 'KnockedOut' || DamageType == 'exploded' || DamageType == 'Stunned' || DamageType == 'stomped')\n\t\t\t\t\tcolstr = \"|CEEF600\";\n\t\t\t\tif(DamageType == 'SpecialDamage' || DamageType == 'Tantalus' || DamageType == 'Nanovirus')\n\t\t\t\t\tcolstr = \"|P7\";\n\t\t\t\tif(DamageType == 'shot')\n\t\t\t\t\tcolstr = \"|P1\";\n\t\t\t\t\n\t\t\t\tif(TCPlayer(instigatedBy).HasPerk(\"Quad Damage\"))\n\t\t\t\t{\n\t\t\t\t\tif(hitstr == \"\")\n\t\t\t\t\t\tTCPlayer(instigatedBy).ShowHitz(colstr$\"(\"$ActualDamage / 4$\" x4)\");\n\t\t\t\t\telse\n\t\t\t\t\t\tTCPlayer(instigatedBy).ShowHitz(colstr$\"(\"$ActualDamage / 4$\" x4) >> \"$hitstr$\") \");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(hitstr == \"\")\n\t\t\t\t\t\tTCPlayer(instigatedBy).ShowHitz(colstr$\"(\"$ActualDamage$\")\");\n\t\t\t\t\telse\n\t\t\t\t\t\tTCPlayer(instigatedBy).ShowHitz(colstr$\"(\"$ActualDamage$\" >> \"$hitstr$\") \");\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(TCDeathmatch(level.game) == None)\n\t\t\treturn;\n\t\tif(TCPlayer(InstigatedBy).TeamName == \"\")\n\t\treturn;\n\t\tif(TCPlayer(Victim) != None && Victim != InstigatedBy)\n\t\t{\n\t\t\tif(TCPlayer(Victim).TeamName == \"\")\n\t\t\treturn;\t\n\t\t\t\t\tif(TCPlayer(InstigatedBy).TeamName ~= TCPlayer(Victim).TeamName)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!TCDeathMatch(Level.Game).Settings.bTCFriendlyFire)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tActualDamage /= TCDeathMatch(Level.Game).Settings.ffReduction;\n\t\t\t\t\t\t\t\treturn;\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t}\n\t\t}\n\t}\n}\n\nfunction ModifyPlayer(Pawn Other)\n{\n\tlocal TCPlayer P;\n\tlocal class<Inventory> GiveClass;\n\tlocal int Passes, r;\n\tlocal Inventory anItem, anItem2, i;\n   local Class<Inventory> w;\n   \n\tsuper.ModifyPlayer(Other);\n\tp = TCPlayer(Other);\n\t\n\tif(GunGame(Level.Game) != None)\n\t{\t\t\t \n\t\t   r = TCPRI(P.PlayerReplicationInfo).Rank;\n\n\t\t if (r == 1)\n\t\t   w = class'WeaponStealthPistol';\n\t\t   \n\t\t if (r == 2)\n\t\t   w = class'WeaponPistol';\n\t\t   \n\t\t if (r == 3)\n\t\t   w = class'WeaponFlamethrower';\n\t\t   \n\t\t if (r == 4)\n\t\t   w = class'WeaponMiniCrossbow';\n\t\t   \n\t\t if (r == 5)\n\t\t   w = class'WeaponShuriken';\n\t\t   \n\t\t if (r == 6)\n\t\t   w = class'WeaponSawedOffShotgun';\n\t\t   \n\t\t if (r == 7)\n\t\t   w = class'WeaponAssaultShotgun';\n\t\t   \n\t\t if (r == 8)\n\t\t   w = class'WeaponAssaultgun';\n\n\t\t if (r == 9)\n\t\t   w = class'WeaponPlasmaRifle';\n\t\t   \n\t\t if (r == 10)\n\t\t   w = class'WeaponGepGun';\n\t\t   \n\t\t if (r == 11)\n\t\t   w = class'Weaponrifle';\n\t\t   \n\t\t if (r == 12)\n\t\t   w = class'WeaponNanoSword';\n\t\t   \n\t\tanItem = Spawn(w);\n\t\tanItem.Frob(P,None);\t  \n\t\tInventory.bInObjectBelt = True;\n\t\tanItem.Destroy();\n\t\t\t \n\t\tanItem = Spawn(class'WeaponCombatKnife');\n\t\tanItem.Frob(P,None);\t  \n\t\tInventory.bInObjectBelt = True;\n\t\tanItem.Destroy();\n\t}\n\t\n\telse if(Sharpshooter(Level.Game) != None)\n\t{\n\t\twhile(Passes < 3)\n\t\t{\n\t\t\t\n\t\t\tif(Passes == 0) r = RandRange(0,10);\n\t\t\tif(Passes == 1) r = RandRange(11, 20);\n\t\t\tif(Passes == 2) r = RandRange(21,29);\n\t\t\tPasses++;\n\t\t\tGiveClass = class<inventory>( DynamicLoadObject( p.GetControls().SSWeapons[r], class'Class' ) );\n\t\t\tif( GiveClass!=None )\n\t\t\t{\n\t\t\t\tanItem = Spawn(GiveClass,,,p.Location); \n\t\t\t\tanItem.SpawnCopy(P);\n\t\t\t\tanItem.Destroy();\n\t\t\t}\n\t\t\telse\n\t\t\t\tLog(\"Error in TCControls.SSWeapons array: \"$r$\" slot could not be spawned. (PLAYER)\");\n\t\t}\n\t}\n\n}\n\n// ----------------------------------------------------------------------\n// ----------------------------------------------------------------------\ndefaultproperties\n{\n}\n",
            "name": "TCTeamManager.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Mutator",
                "functions": {
                    "CalcHitLoc": {
                        "body": "{\n\tif(HitPart == 1)\n\t\treturn \"Head\";\n\n\tif(HitPart == 2)\n\t\treturn \"Torso\";\n\t\t\n\tif(HitPart == 3)\n\t\treturn \"Legs\";\n\n\tif(HitPart == 4)\n\t\treturn \"Legs\";\n\t\n\tif(HitPart == 5)\n\t\treturn \"Torso\";\n\n\tif(HitPart == 6)\n\t\treturn \"Torso\";\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CalcHitLoc",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "HitPart"
                            ]
                        ],
                        "return": "string"
                    },
                    "GetDisplayName": {
                        "body": "{\n\tif(ScriptedPawn(Chk) != None)\n\t\treturn ScriptedPawn(Chk).FamiliarName;\n\t\t\n\tif(TCPlayer(Chk) != None)\n\t\treturn TCPlayer(Chk).PlayerReplicationInfo.PlayerName;\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetDisplayName",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Chk"
                            ]
                        ],
                        "return": "string"
                    },
                    "ModifyPlayer": {
                        "body": "{\n   \n\tsuper.ModifyPlayer(Other);\n\tp = TCPlayer(Other);\n\t\n\tif(GunGame(Level.Game) != None)\n\t{\t\t\t \n\t\t   r = TCPRI(P.PlayerReplicationInfo).Rank;\n\n\t\t if (r == 1)\n\t\t   w = class'WeaponStealthPistol';\n\t\t   \n\t\t if (r == 2)\n\t\t   w = class'WeaponPistol';\n\t\t   \n\t\t if (r == 3)\n\t\t   w = class'WeaponFlamethrower';\n\t\t   \n\t\t if (r == 4)\n\t\t   w = class'WeaponMiniCrossbow';\n\t\t   \n\t\t if (r == 5)\n\t\t   w = class'WeaponShuriken';\n\t\t   \n\t\t if (r == 6)\n\t\t   w = class'WeaponSawedOffShotgun';\n\t\t   \n\t\t if (r == 7)\n\t\t   w = class'WeaponAssaultShotgun';\n\t\t   \n\t\t if (r == 8)\n\t\t   w = class'WeaponAssaultgun';\n\n\t\t if (r == 9)\n\t\t   w = class'WeaponPlasmaRifle';\n\t\t   \n\t\t if (r == 10)\n\t\t   w = class'WeaponGepGun';\n\t\t   \n\t\t if (r == 11)\n\t\t   w = class'Weaponrifle';\n\t\t   \n\t\t if (r == 12)\n\t\t   w = class'WeaponNanoSword';\n\t\t   \n\t\tanItem = Spawn(w);\n\t\tanItem.Frob(P,None);\t  \n\t\tInventory.bInObjectBelt = True;\n\t\tanItem.Destroy();\n\t\t\t \n\t\tanItem = Spawn(class'WeaponCombatKnife');\n\t\tanItem.Frob(P,None);\t  \n\t\tInventory.bInObjectBelt = True;\n\t\tanItem.Destroy();\n\t}\n\t\n\telse if(Sharpshooter(Level.Game) != None)\n\t{\n\t\twhile(Passes < 3)\n\t\t{\n\t\t\t\n\t\t\tif(Passes == 0) r = RandRange(0,10);\n\t\t\tif(Passes == 1) r = RandRange(11, 20);\n\t\t\tif(Passes == 2) r = RandRange(21,29);\n\t\t\tPasses++;\n\t\t\tGiveClass = class<inventory>( DynamicLoadObject( p.GetControls().SSWeapons[r], class'Class' ) );\n\t\t\tif( GiveClass!=None )\n\t\t\t{\n\t\t\t\tanItem = Spawn(GiveClass,,,p.Location); \n\t\t\t\tanItem.SpawnCopy(P);\n\t\t\t\tanItem.Destroy();\n\t\t\t}\n\t\t\telse\n\t\t\t\tLog(\"Error in TCControls.SSWeapons array: \"$r$\" slot could not be spawned. (PLAYER)\");\n\t\t}\n\t}\n\n}",
                        "locals": [
                            "local TCPlayer P;",
                            "local class<Inventory> GiveClass;",
                            "local int Passes, r;",
                            "local Inventory anItem, anItem2, i;",
                            "local Class<Inventory> w;"
                        ],
                        "modifiers": [],
                        "name": "ModifyPlayer",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "MutatorTakeDamage": {
                        "body": "{\n\tsuper.MutatorTakeDamage (ActualDamage, Victim, InstigatedBy, HitLocation, Momentum, DamageType);\n\n\n\tif(TCPlayer(instigatedBy) != None)\n\t{\n\t\tif(TCPlayer(Victim).HasPerk(\"Infection\"))\n\t\t{\n\t\t\t\tActualDamage = ActualDamage * 1.5;\n\t\t}\n\t\t\n\t\tif(TCPlayer(instigatedBy).HasPerk(\"Quad Damage\"))\n\t\t{\n\t\t\t\tActualDamage = ActualDamage * 4;\n\t\t}\n\t\t\n\t\tif(Juggernaut(level.game) != None)\n\t\t{\n\t\t\tif(TCPlayer(Victim) == Juggernaut(level.game).Juggernaut)\n\t\t\t{\n\t\t\t\tActualDamage = ActualDamage / 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(DeusExPlayer(victim) != None)\n\t\t\thitstr = CalcHitLoc(DeusExPlayer(victim).GetMPHitLocation(HitLocation));\n\n\t\tif(TCPlayer(instigatedBy).GetControls().bShowHitz)\n\t\t{\n\t\t\tif(ActualDamage > 0)\n\t\t\t{\n\t\t\t\tif(DamageType == 'EMP')\n\t\t\t\t\tcolstr = \"|C1E90FF\";\n\t\t\t\tif(DamageType == 'Flamed' || DamageType == 'Burned')\n\t\t\t\t\tcolstr = \"|P2\";\n\t\t\t\tif(DamageType == 'PoisonEffect' || DamageType == 'Poison' || DamageType == 'TearGas')\n\t\t\t\t\tcolstr = \"|C14D920\";\n\t\t\t\tif(DamageType == 'KnockedOut' || DamageType == 'exploded' || DamageType == 'Stunned' || DamageType == 'stomped')\n\t\t\t\t\tcolstr = \"|CEEF600\";\n\t\t\t\tif(DamageType == 'SpecialDamage' || DamageType == 'Tantalus' || DamageType == 'Nanovirus')\n\t\t\t\t\tcolstr = \"|P7\";\n\t\t\t\tif(DamageType == 'shot')\n\t\t\t\t\tcolstr = \"|P1\";\n\t\t\t\t\n\t\t\t\tif(TCPlayer(instigatedBy).HasPerk(\"Quad Damage\"))\n\t\t\t\t{\n\t\t\t\t\tif(hitstr == \"\")\n\t\t\t\t\t\tTCPlayer(instigatedBy).ShowHitz(colstr$\"(\"$ActualDamage / 4$\" x4)\");\n\t\t\t\t\telse\n\t\t\t\t\t\tTCPlayer(instigatedBy).ShowHitz(colstr$\"(\"$ActualDamage / 4$\" x4) >> \"$hitstr$\") \");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(hitstr == \"\")\n\t\t\t\t\t\tTCPlayer(instigatedBy).ShowHitz(colstr$\"(\"$ActualDamage$\")\");\n\t\t\t\t\telse\n\t\t\t\t\t\tTCPlayer(instigatedBy).ShowHitz(colstr$\"(\"$ActualDamage$\" >> \"$hitstr$\") \");\t\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(TCDeathmatch(level.game) == None)\n\t\t\treturn;\n\t\tif(TCPlayer(InstigatedBy).TeamName == \"\")\n\t\treturn;\n\t\tif(TCPlayer(Victim) != None && Victim != InstigatedBy)\n\t\t{\n\t\t\tif(TCPlayer(Victim).TeamName == \"\")\n\t\t\treturn;\t\n\t\t\t\t\tif(TCPlayer(InstigatedBy).TeamName ~= TCPlayer(Victim).TeamName)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!TCDeathMatch(Level.Game).Settings.bTCFriendlyFire)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tActualDamage /= TCDeathMatch(Level.Game).Settings.ffReduction;\n\t\t\t\t\t\t\t\treturn;\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local string hitstr, colstr, quadstr;"
                        ],
                        "modifiers": [],
                        "name": "MutatorTakeDamage",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "Int",
                                "ActualDamage"
                            ],
                            [
                                "Pawn",
                                "Victim"
                            ],
                            [
                                "Pawn",
                                "InstigatedBy"
                            ],
                            [
                                "out",
                                "Vector",
                                "HitLocation"
                            ],
                            [
                                "out",
                                "Vector",
                                "Momentum"
                            ],
                            [
                                "Name",
                                "DamageType"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 210,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCTimerActor.uc": {
            "body": "class TCTimerActor extends Actor;\n\nvar bool bRunning;\nvar int min, sec;\n\nfunction ToggleTimer()\n{\n\tif(bRunning)\n\t\tStopTimer();\n\telse\n\t\tStartTimer();\n}\n\nfunction StartTimer()\n{\n\tlocal TCPlayer TCP;\n\t\n\tmin = 0;\n\tsec = 0;\n\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t\tTCP.StartTimer();\n\t\n\tLog(\"Timer started.\",'OpenDX');\n\tbRunning=True;\n\tSetTimer(1,True);\n}\n\nfunction StopTimer()\n{\n\tlocal TCPlayer TCP;\n\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t\tTCP.StopTimer();\n\t\n\tLog(\"Timer stopped.\",'OpenDX');\n\tbRunning=false;\n}\n\nfunction UpdateTimer(string str)\n{\n\tlocal TCPlayer TCP;\n\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t{\n\t\tTCP.UpdateTimer(str);\n\t\tTCP.TimerString=str;\n\t}\n\n\tif(!bRunning)\n\tSetTimer(1,False);\n}\n\nfunction Timer()\n{\n\tlocal string finaltime, localsec;\n\t\n\tsec++;\n\t\n\tif(sec < 10)\n\t\tlocalsec = \"0\"$sec;\n\t\t\n\tif(sec > 60)\n\t{\n\t\tsec = 1;\n\t\tlocalsec = \"01\";\n\t\tmin++;\n\t}\n\t\n\tif(localsec == \"\")\n\t\tlocalsec = string(sec);\n\tfinaltime = min$\":\"$localsec;\n\t\n\tUpdateTimer(finaltime);\n}\n\ndefaultproperties\n{\n\tbHidden=True;\n}\n",
            "name": "TCTimerActor.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=True;"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "StartTimer": {
                        "body": "{\n\t\n\tmin = 0;\n\tsec = 0;\n\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t\tTCP.StartTimer();\n\t\n\tLog(\"Timer started.\",'OpenDX');\n\tbRunning=True;\n\tSetTimer(1,True);\n}",
                        "locals": [
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [],
                        "name": "StartTimer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StopTimer": {
                        "body": "{\n\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t\tTCP.StopTimer();\n\t\n\tLog(\"Timer stopped.\",'OpenDX');\n\tbRunning=false;\n}",
                        "locals": [
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [],
                        "name": "StopTimer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\t\n\tsec++;\n\t\n\tif(sec < 10)\n\t\tlocalsec = \"0\"$sec;\n\t\t\n\tif(sec > 60)\n\t{\n\t\tsec = 1;\n\t\tlocalsec = \"01\";\n\t\tmin++;\n\t}\n\t\n\tif(localsec == \"\")\n\t\tlocalsec = string(sec);\n\tfinaltime = min$\":\"$localsec;\n\t\n\tUpdateTimer(finaltime);\n}",
                        "locals": [
                            "local string finaltime, localsec;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ToggleTimer": {
                        "body": "{\n\tif(bRunning)\n\t\tStopTimer();\n\telse\n\t\tStartTimer();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ToggleTimer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "UpdateTimer": {
                        "body": "{\n\t\n\tforeach AllActors(class'TCPlayer', TCP)\n\t{\n\t\tTCP.UpdateTimer(str);\n\t\tTCP.TimerString=str;\n\t}\n\n\tif(!bRunning)\n\tSetTimer(1,False);\n}",
                        "locals": [
                            "local TCPlayer TCP;"
                        ],
                        "modifiers": [],
                        "name": "UpdateTimer",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "str"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 81,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool bRunning;",
                    "var int min, sec;"
                ]
            }
        },
        "TCUNATCO.uc": {
            "body": "//================================================================================\n// MTLUNATCO.\n//================================================================================\nclass TCUNATCO extends TCPlayer\n\tConfig(User);\n\ndefaultproperties\n{\n    Mesh=LodMesh'MPCharacters.mp_jumpsuit'\n    DrawScale=0.93\n    MultiSkins(0)=Texture'DeusExCharacters.Skins.MiscTex1'\n    MultiSkins(1)=Texture'DeusExCharacters.Skins.UNATCOTroopTex1'\n    MultiSkins(2)=Texture'DeusExCharacters.Skins.UNATCOTroopTex2'\n    MultiSkins(3)=Texture'DeusExCharacters.Skins.MiscTex1'\n    MultiSkins(4)=Texture'DeusExCharacters.Skins.MiscTex1'\n    MultiSkins(5)=Texture'DeusExItems.Skins.PinkMaskTex'\n    MultiSkins(6)=Texture'DeusExCharacters.Skins.UNATCOTroopTex3'\n    MultiSkins(7)=Texture'DeusExItems.Skins.PinkMaskTex'\n}\n",
            "name": "TCUNATCO.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Mesh=LodMesh'MPCharacters.mp_jumpsuit'",
                    "DrawScale=0.93",
                    "MultiSkins(0)=Texture'DeusExCharacters.Skins.MiscTex1'",
                    "MultiSkins(1)=Texture'DeusExCharacters.Skins.UNATCOTroopTex1'",
                    "MultiSkins(2)=Texture'DeusExCharacters.Skins.UNATCOTroopTex2'",
                    "MultiSkins(3)=Texture'DeusExCharacters.Skins.MiscTex1'",
                    "MultiSkins(4)=Texture'DeusExCharacters.Skins.MiscTex1'",
                    "MultiSkins(5)=Texture'DeusExItems.Skins.PinkMaskTex'",
                    "MultiSkins(6)=Texture'DeusExCharacters.Skins.UNATCOTroopTex3'",
                    "MultiSkins(7)=Texture'DeusExItems.Skins.PinkMaskTex'"
                ],
                "exec": [],
                "extends": "TCPlayer",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 20,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponAssaultGun.uc": {
            "body": "class TCWeaponAssaultGun extends WeaponAssaultGun;\n\n// fix bug related to firing when having no weapon in hand\nsimulated function bool ClientFire( float value )\n{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}\n\ndefaultproperties\n{\n    ProjectileNames(1)=Class'TCHECannister20mm'\n}\n",
            "name": "TCWeaponAssaultGun.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "ProjectileNames(1)=Class'TCHECannister20mm'"
                ],
                "exec": [],
                "extends": "WeaponAssaultGun",
                "functions": {
                    "ClientFire": {
                        "body": "{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "value"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 14,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponAssaultShotgun.uc": {
            "body": "class TCWeaponAssaultShotgun extends WeaponAssaultShotgun;\n\n// fix bug related to firing when having no weapon in hand\nsimulated function bool ClientFire( float value )\n{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}\n\ndefaultproperties\n{\n}\n",
            "name": "TCWeaponAssaultShotgun.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "WeaponAssaultShotgun",
                "functions": {
                    "ClientFire": {
                        "body": "{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "value"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 13,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponCombatKnife.uc": {
            "body": "class TCWeaponCombatKnife extends WeaponCombatKnife;\n\n// fix bug related to firing when having no weapon in hand\nsimulated function bool ClientFire( float value )\n{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}\n\ndefaultproperties\n{\n}\n",
            "name": "TCWeaponCombatKnife.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "WeaponCombatKnife",
                "functions": {
                    "ClientFire": {
                        "body": "{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "value"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 13,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponEMPGrenade.uc": {
            "body": "class TCWeaponEMPGrenade extends WeaponEMPGrenade;\n\nfunction PlaceGrenade()\n{\n\tif (AmmoType.AmmoAmount <= 0) \n\t{\n\t\tDestroy();\n\t\treturn;\n\t}\n\tsuper.PlaceGrenade();\n\tif (AmmoType.AmmoAmount <= 0) Destroy();\n}\n\nstate NormalFire\n{\n\tfunction AnimEnd()\n\t{\n\t\tif (bAutomatic)\n\t\t{\n\t\t\tif ((Pawn(Owner).bFire != 0) && (AmmoType.AmmoAmount > 0))\n\t\t\t{\n\t\t\t\tif (PlayerPawn(Owner) != None)\n\t\t\t\t\tGlobal.Fire(0);\n\t\t\t\telse \n\t\t\t\t\tGotoState('FinishFire');\n\t\t\t}\n\t\t\telse \n\t\t\t\tGotoState('FinishFire');\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// if we are a thrown weapon and we run out of ammo, destroy the weapon\n\t\t\tif (bHandToHand && (ReloadCount > 0) && (AmmoType.AmmoAmount <= 0))\n\t\t\t{\n\t\t\t\t// fix disappear bug:\n\t\t\t\t//Destroy();\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction Fire(float Value)\n{\n\tlocal float sndVolume;\n\tlocal bool bListenClient;\n\n\tif (Pawn(Owner) != None)\n\t{\n\t\tif (bNearWall)\n\t\t{\n\t\t\tbReadyToFire = False;\n\t\t\tGotoState('NormalFire');\n\t\t\tbPointing = True;\n\t\t\tPlayAnim('Place',, 0.1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbListenClient = (Owner.IsA('DeusExPlayer') && DeusExPlayer(Owner).PlayerIsListenClient());\n\n\tsndVolume = TransientSoundVolume;\n\n\tif ( Level.NetMode != NM_Standalone )  // Turn up the sounds a bit in mulitplayer\n\t{\n\t\tsndVolume = TransientSoundVolume * 2.0;\n\t\tif ( Owner.IsA('DeusExPlayer') && (DeusExPlayer(Owner).NintendoImmunityTimeLeft > 0.01) || (!bClientReady && (!bListenClient)) )\n\t\t{\n\t\t\tDeusExPlayer(Owner).bJustFired = False;\n\t\t\tbReadyToFire = True;\n\t\t\tbPointing = False;\n\t\t\tbFiring = False;\n\t\t\treturn;\n\t\t}\n\t}\n\t// check for surrounding environment\n\tif ((EnviroEffective == ENVEFF_Air) || (EnviroEffective == ENVEFF_Vacuum) || (EnviroEffective == ENVEFF_AirVacuum))\n\t{\n\t\tif (Region.Zone.bWaterZone)\n\t\t{\n\t\t\tif (Pawn(Owner) != None)\n\t\t\t{\n\t\t\t\tPawn(Owner).ClientMessage(msgNotWorking);\n\t\t\t\tif (!bHandToHand)\n\t\t\t\t\tPlaySimSound( Misc1Sound, SLOT_None, sndVolume, 1024 );\t\t// play dry fire sound\n\t\t\t}\n\t\t\tGotoState('Idle');\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (bHandToHand)\n\t{\n\t\tif (( Level.NetMode != NM_Standalone ) && !bListenClient )\n\t\t\tbClientReady = False;\n\t\tbReadyToFire = False;\n\t\tGotoState('NormalFire');\n\t\tbPointing=True;\n\t\tif ( Owner.IsA('PlayerPawn') )\n\t\t\tPlayerPawn(Owner).PlayFiring();\n\t\tPlaySelectiveFiring();\n\t\tPlayFiringSound();\n\t}\n}\n\nsimulated function Projectile ProjectileFire(class<projectile> ProjClass, float ProjSpeed, bool bWarn)\n{\n\tlocal Projectile proj;\n\n\tif (AmmoType.AmmoAmount <= 0)\n\t{\n\t\tbDestroyOnFinish = true;\n\t\treturn none;\n\t}\n\t\n\tproj = super(DeusExWeapon).ProjectileFire(ProjClass, ProjSpeed, bWarn);\n\tif (proj != none)\n\t{\n\t\tproj.PlayAnim('Open');\n\t\tif (ReloadCount > 0) AmmoType.UseAmmo(1);\n\n\t\tif ( AmmoType.AmmoAmount <= 0 )\n\t\t\tbDestroyOnFinish = True;\n\n\t\t// Update ammo count on object belt\n\t\tif (DeusExPlayer(Owner) != None)\n\t\t\tDeusExPlayer(Owner).UpdateBeltText(Self);\n\t}\n\n\treturn proj;\n}\n\nsimulated function bool ClientFire( float value )\n{\n    //servernotify(\"clientFire - netmode:\"@level.NetMode);\n    if(ReloadCount <= 0)\n        ReloadCount=1;\n\n    return Super.ClientFire(value);\n}\n\n\ndefaultproperties\n{\n   // ProjectileClass=Class'TCEMPGrenade'\n}\n",
            "name": "TCWeaponEMPGrenade.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "// ProjectileClass=Class'TCEMPGrenade'"
                ],
                "exec": [],
                "extends": "WeaponEMPGrenade",
                "functions": {
                    "AnimEnd": {
                        "body": "{\n\t\tif (bAutomatic)\n\t\t{\n\t\t\tif ((Pawn(Owner).bFire != 0) && (AmmoType.AmmoAmount > 0))\n\t\t\t{\n\t\t\t\tif (PlayerPawn(Owner) != None)\n\t\t\t\t\tGlobal.Fire(0);\n\t\t\t\telse \n\t\t\t\t\tGotoState('FinishFire');\n\t\t\t}\n\t\t\telse \n\t\t\t\tGotoState('FinishFire');\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// if we are a thrown weapon and we run out of ammo, destroy the weapon\n\t\t\tif (bHandToHand && (ReloadCount > 0) && (AmmoType.AmmoAmount <= 0))\n\t\t\t{\n\t\t\t\t// fix disappear bug:\n\t\t\t\t//Destroy();\n\t\t\t}\n\t\t}\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AnimEnd",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ClientFire": {
                        "body": "{\n    //servernotify(\"clientFire - netmode:\"@level.NetMode);\n    if(ReloadCount <= 0)\n        ReloadCount=1;\n\n    return Super.ClientFire(value);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "value"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Fire": {
                        "body": "{\n\n\tif (Pawn(Owner) != None)\n\t{\n\t\tif (bNearWall)\n\t\t{\n\t\t\tbReadyToFire = False;\n\t\t\tGotoState('NormalFire');\n\t\t\tbPointing = True;\n\t\t\tPlayAnim('Place',, 0.1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbListenClient = (Owner.IsA('DeusExPlayer') && DeusExPlayer(Owner).PlayerIsListenClient());\n\n\tsndVolume = TransientSoundVolume;\n\n\tif ( Level.NetMode != NM_Standalone )  // Turn up the sounds a bit in mulitplayer\n\t{\n\t\tsndVolume = TransientSoundVolume * 2.0;\n\t\tif ( Owner.IsA('DeusExPlayer') && (DeusExPlayer(Owner).NintendoImmunityTimeLeft > 0.01) || (!bClientReady && (!bListenClient)) )\n\t\t{\n\t\t\tDeusExPlayer(Owner).bJustFired = False;\n\t\t\tbReadyToFire = True;\n\t\t\tbPointing = False;\n\t\t\tbFiring = False;\n\t\t\treturn;\n\t\t}\n\t}\n\t// check for surrounding environment\n\tif ((EnviroEffective == ENVEFF_Air) || (EnviroEffective == ENVEFF_Vacuum) || (EnviroEffective == ENVEFF_AirVacuum))\n\t{\n\t\tif (Region.Zone.bWaterZone)\n\t\t{\n\t\t\tif (Pawn(Owner) != None)\n\t\t\t{\n\t\t\t\tPawn(Owner).ClientMessage(msgNotWorking);\n\t\t\t\tif (!bHandToHand)\n\t\t\t\t\tPlaySimSound( Misc1Sound, SLOT_None, sndVolume, 1024 );\t\t// play dry fire sound\n\t\t\t}\n\t\t\tGotoState('Idle');\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (bHandToHand)\n\t{\n\t\tif (( Level.NetMode != NM_Standalone ) && !bListenClient )\n\t\t\tbClientReady = False;\n\t\tbReadyToFire = False;\n\t\tGotoState('NormalFire');\n\t\tbPointing=True;\n\t\tif ( Owner.IsA('PlayerPawn') )\n\t\t\tPlayerPawn(Owner).PlayFiring();\n\t\tPlaySelectiveFiring();\n\t\tPlayFiringSound();\n\t}\n}",
                        "locals": [
                            "local float sndVolume;",
                            "local bool bListenClient;"
                        ],
                        "modifiers": [],
                        "name": "Fire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Value"
                            ]
                        ],
                        "return": ""
                    },
                    "PlaceGrenade": {
                        "body": "{\n\tif (AmmoType.AmmoAmount <= 0) \n\t{\n\t\tDestroy();\n\t\treturn;\n\t}\n\tsuper.PlaceGrenade();\n\tif (AmmoType.AmmoAmount <= 0) Destroy();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlaceGrenade",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ProjectileFire": {
                        "body": "{\n\n\tif (AmmoType.AmmoAmount <= 0)\n\t{\n\t\tbDestroyOnFinish = true;\n\t\treturn none;\n\t}\n\t\n\tproj = super(DeusExWeapon).ProjectileFire(ProjClass, ProjSpeed, bWarn);\n\tif (proj != none)\n\t{\n\t\tproj.PlayAnim('Open');\n\t\tif (ReloadCount > 0) AmmoType.UseAmmo(1);\n\n\t\tif ( AmmoType.AmmoAmount <= 0 )\n\t\t\tbDestroyOnFinish = True;\n\n\t\t// Update ammo count on object belt\n\t\tif (DeusExPlayer(Owner) != None)\n\t\t\tDeusExPlayer(Owner).UpdateBeltText(Self);\n\t}\n\n\treturn proj;\n}",
                        "locals": [
                            "local Projectile proj;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ProjectileFire",
                        "native": false,
                        "param": [
                            [
                                "class<projectile>",
                                "ProjClass"
                            ],
                            [
                                "float",
                                "ProjSpeed"
                            ],
                            [
                                "bool",
                                "bWarn"
                            ]
                        ],
                        "return": "Projectile"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 146,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponFlamethrower.uc": {
            "body": "class TCWeaponFlamethrower extends WeaponFlamethrower;\n\ndefaultproperties\n{\n    //ProjectileClass=Class'TCFireball'\n}\n",
            "name": "TCWeaponFlamethrower.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "//ProjectileClass=Class'TCFireball'"
                ],
                "exec": [],
                "extends": "WeaponFlamethrower",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 7,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponGEPGun.uc": {
            "body": "class TCWeaponGEPGun extends CBPWeaponGEPGun;\n\ndefaultproperties\n{\n\tProjectileNames(0)=Class'TCRocket'\n    ProjectileClass=Class'TCRocket'\n}\n",
            "name": "TCWeaponGEPGun.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "ProjectileNames(0)=Class'TCRocket'",
                    "ProjectileClass=Class'TCRocket'"
                ],
                "exec": [],
                "extends": "CBPWeaponGEPGun",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 8,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponGasGrenade.uc": {
            "body": "class TCWeaponGasGrenade extends WeaponGasGrenade;\n\nfunction PlaceGrenade()\n{\n\tif (AmmoType.AmmoAmount <= 0) \n\t{\n\t\tDestroy();\n\t\treturn;\n\t}\n\tsuper.PlaceGrenade();\n\tif (AmmoType.AmmoAmount <= 0) Destroy();\n}\n\nstate NormalFire\n{\n\tfunction AnimEnd()\n\t{\n\t\tif (bAutomatic)\n\t\t{\n\t\t\tif ((Pawn(Owner).bFire != 0) && (AmmoType.AmmoAmount > 0))\n\t\t\t{\n\t\t\t\tif (PlayerPawn(Owner) != None)\n\t\t\t\t\tGlobal.Fire(0);\n\t\t\t\telse \n\t\t\t\t\tGotoState('FinishFire');\n\t\t\t}\n\t\t\telse \n\t\t\t\tGotoState('FinishFire');\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// if we are a thrown weapon and we run out of ammo, destroy the weapon\n\t\t\tif (bHandToHand && (ReloadCount > 0) && (AmmoType.AmmoAmount <= 0))\n\t\t\t{\n\t\t\t\t// fix disappear bug:\n\t\t\t\t//Destroy();\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction Fire(float Value)\n{\n\tlocal float sndVolume;\n\tlocal bool bListenClient;\n\n\tif (Pawn(Owner) != None)\n\t{\n\t\tif (bNearWall)\n\t\t{\n\t\t\tbReadyToFire = False;\n\t\t\tGotoState('NormalFire');\n\t\t\tbPointing = True;\n\t\t\tPlayAnim('Place',, 0.1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbListenClient = (Owner.IsA('DeusExPlayer') && DeusExPlayer(Owner).PlayerIsListenClient());\n\n\tsndVolume = TransientSoundVolume;\n\n\tif ( Level.NetMode != NM_Standalone )  // Turn up the sounds a bit in mulitplayer\n\t{\n\t\tsndVolume = TransientSoundVolume * 2.0;\n\t\tif ( Owner.IsA('DeusExPlayer') && (DeusExPlayer(Owner).NintendoImmunityTimeLeft > 0.01) || (!bClientReady && (!bListenClient)) )\n\t\t{\n\t\t\tDeusExPlayer(Owner).bJustFired = False;\n\t\t\tbReadyToFire = True;\n\t\t\tbPointing = False;\n\t\t\tbFiring = False;\n\t\t\treturn;\n\t\t}\n\t}\n\t// check for surrounding environment\n\tif ((EnviroEffective == ENVEFF_Air) || (EnviroEffective == ENVEFF_Vacuum) || (EnviroEffective == ENVEFF_AirVacuum))\n\t{\n\t\tif (Region.Zone.bWaterZone)\n\t\t{\n\t\t\tif (Pawn(Owner) != None)\n\t\t\t{\n\t\t\t\tPawn(Owner).ClientMessage(msgNotWorking);\n\t\t\t\tif (!bHandToHand)\n\t\t\t\t\tPlaySimSound( Misc1Sound, SLOT_None, sndVolume, 1024 );\t\t// play dry fire sound\n\t\t\t}\n\t\t\tGotoState('Idle');\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (bHandToHand)\n\t{\n\t\tif (( Level.NetMode != NM_Standalone ) && !bListenClient )\n\t\t\tbClientReady = False;\n\t\tbReadyToFire = False;\n\t\tGotoState('NormalFire');\n\t\tbPointing=True;\n\t\tif ( Owner.IsA('PlayerPawn') )\n\t\t\tPlayerPawn(Owner).PlayFiring();\n\t\tPlaySelectiveFiring();\n\t\tPlayFiringSound();\n\t}\n}\n\nsimulated function Projectile ProjectileFire(class<projectile> ProjClass, float ProjSpeed, bool bWarn)\n{\n\tlocal Projectile proj;\n\n\tif (AmmoType.AmmoAmount <= 0)\n\t{\n\t\tbDestroyOnFinish = true;\n\t\treturn none;\n\t}\n\t\n\tproj = super.ProjectileFire(ProjClass, ProjSpeed, bWarn);\n\tif (proj != none)\n\t{\n\t\tif (ReloadCount > 0) AmmoType.UseAmmo(1);\n\n\t\tif ( AmmoType.AmmoAmount <= 0 )\n\t\t\tbDestroyOnFinish = True;\n\n\t\t// Update ammo count on object belt\n\t\tif (DeusExPlayer(Owner) != None)\n\t\t\tDeusExPlayer(Owner).UpdateBeltText(Self);\n\t}\n\n\treturn proj;\n}\n\nsimulated function bool ClientFire( float value )\n{\n    //servernotify(\"clientFire - netmode:\"@level.NetMode);\n    if(ReloadCount <= 0)\n        ReloadCount=1;\n\n    return Super.ClientFire(value);\n}\n\n\ndefaultproperties\n{\n    //ProjectileClass=Class'TCGasGrenade'\n}\n",
            "name": "TCWeaponGasGrenade.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "//ProjectileClass=Class'TCGasGrenade'"
                ],
                "exec": [],
                "extends": "WeaponGasGrenade",
                "functions": {
                    "AnimEnd": {
                        "body": "{\n\t\tif (bAutomatic)\n\t\t{\n\t\t\tif ((Pawn(Owner).bFire != 0) && (AmmoType.AmmoAmount > 0))\n\t\t\t{\n\t\t\t\tif (PlayerPawn(Owner) != None)\n\t\t\t\t\tGlobal.Fire(0);\n\t\t\t\telse \n\t\t\t\t\tGotoState('FinishFire');\n\t\t\t}\n\t\t\telse \n\t\t\t\tGotoState('FinishFire');\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// if we are a thrown weapon and we run out of ammo, destroy the weapon\n\t\t\tif (bHandToHand && (ReloadCount > 0) && (AmmoType.AmmoAmount <= 0))\n\t\t\t{\n\t\t\t\t// fix disappear bug:\n\t\t\t\t//Destroy();\n\t\t\t}\n\t\t}\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AnimEnd",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ClientFire": {
                        "body": "{\n    //servernotify(\"clientFire - netmode:\"@level.NetMode);\n    if(ReloadCount <= 0)\n        ReloadCount=1;\n\n    return Super.ClientFire(value);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "value"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Fire": {
                        "body": "{\n\n\tif (Pawn(Owner) != None)\n\t{\n\t\tif (bNearWall)\n\t\t{\n\t\t\tbReadyToFire = False;\n\t\t\tGotoState('NormalFire');\n\t\t\tbPointing = True;\n\t\t\tPlayAnim('Place',, 0.1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbListenClient = (Owner.IsA('DeusExPlayer') && DeusExPlayer(Owner).PlayerIsListenClient());\n\n\tsndVolume = TransientSoundVolume;\n\n\tif ( Level.NetMode != NM_Standalone )  // Turn up the sounds a bit in mulitplayer\n\t{\n\t\tsndVolume = TransientSoundVolume * 2.0;\n\t\tif ( Owner.IsA('DeusExPlayer') && (DeusExPlayer(Owner).NintendoImmunityTimeLeft > 0.01) || (!bClientReady && (!bListenClient)) )\n\t\t{\n\t\t\tDeusExPlayer(Owner).bJustFired = False;\n\t\t\tbReadyToFire = True;\n\t\t\tbPointing = False;\n\t\t\tbFiring = False;\n\t\t\treturn;\n\t\t}\n\t}\n\t// check for surrounding environment\n\tif ((EnviroEffective == ENVEFF_Air) || (EnviroEffective == ENVEFF_Vacuum) || (EnviroEffective == ENVEFF_AirVacuum))\n\t{\n\t\tif (Region.Zone.bWaterZone)\n\t\t{\n\t\t\tif (Pawn(Owner) != None)\n\t\t\t{\n\t\t\t\tPawn(Owner).ClientMessage(msgNotWorking);\n\t\t\t\tif (!bHandToHand)\n\t\t\t\t\tPlaySimSound( Misc1Sound, SLOT_None, sndVolume, 1024 );\t\t// play dry fire sound\n\t\t\t}\n\t\t\tGotoState('Idle');\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (bHandToHand)\n\t{\n\t\tif (( Level.NetMode != NM_Standalone ) && !bListenClient )\n\t\t\tbClientReady = False;\n\t\tbReadyToFire = False;\n\t\tGotoState('NormalFire');\n\t\tbPointing=True;\n\t\tif ( Owner.IsA('PlayerPawn') )\n\t\t\tPlayerPawn(Owner).PlayFiring();\n\t\tPlaySelectiveFiring();\n\t\tPlayFiringSound();\n\t}\n}",
                        "locals": [
                            "local float sndVolume;",
                            "local bool bListenClient;"
                        ],
                        "modifiers": [],
                        "name": "Fire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Value"
                            ]
                        ],
                        "return": ""
                    },
                    "PlaceGrenade": {
                        "body": "{\n\tif (AmmoType.AmmoAmount <= 0) \n\t{\n\t\tDestroy();\n\t\treturn;\n\t}\n\tsuper.PlaceGrenade();\n\tif (AmmoType.AmmoAmount <= 0) Destroy();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlaceGrenade",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ProjectileFire": {
                        "body": "{\n\n\tif (AmmoType.AmmoAmount <= 0)\n\t{\n\t\tbDestroyOnFinish = true;\n\t\treturn none;\n\t}\n\t\n\tproj = super.ProjectileFire(ProjClass, ProjSpeed, bWarn);\n\tif (proj != none)\n\t{\n\t\tif (ReloadCount > 0) AmmoType.UseAmmo(1);\n\n\t\tif ( AmmoType.AmmoAmount <= 0 )\n\t\t\tbDestroyOnFinish = True;\n\n\t\t// Update ammo count on object belt\n\t\tif (DeusExPlayer(Owner) != None)\n\t\t\tDeusExPlayer(Owner).UpdateBeltText(Self);\n\t}\n\n\treturn proj;\n}",
                        "locals": [
                            "local Projectile proj;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ProjectileFire",
                        "native": false,
                        "param": [
                            [
                                "class<projectile>",
                                "ProjClass"
                            ],
                            [
                                "float",
                                "ProjSpeed"
                            ],
                            [
                                "bool",
                                "bWarn"
                            ]
                        ],
                        "return": "Projectile"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 145,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponLAM.uc": {
            "body": "class TCWeaponLAM extends WeaponLAM;\n\nfunction PlaceGrenade()\n{\n\tif (AmmoType.AmmoAmount <= 0) \n\t{\n\t\tDestroy();\n\t\treturn;\n\t}\n\tsuper.PlaceGrenade();\n\tif (AmmoType.AmmoAmount <= 0) Destroy();\n}\n\nstate NormalFire\n{\n\tfunction AnimEnd()\n\t{\n\t\tif (bAutomatic)\n\t\t{\n\t\t\tif ((Pawn(Owner).bFire != 0) && (AmmoType.AmmoAmount > 0))\n\t\t\t{\n\t\t\t\tif (PlayerPawn(Owner) != None)\n\t\t\t\t\tGlobal.Fire(0);\n\t\t\t\telse \n\t\t\t\t\tGotoState('FinishFire');\n\t\t\t}\n\t\t\telse \n\t\t\t\tGotoState('FinishFire');\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// if we are a thrown weapon and we run out of ammo, destroy the weapon\n\t\t\tif (bHandToHand && (ReloadCount > 0) && (AmmoType.AmmoAmount <= 0))\n\t\t\t{\n\t\t\t\t// fix disappear bug:\n\t\t\t\t//Destroy();\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction Fire(float Value)\n{\n\tlocal float sndVolume;\n\tlocal bool bListenClient;\n\n\tif (Pawn(Owner) != None)\n\t{\n\t\tif (bNearWall)\n\t\t{\n\t\t\tbReadyToFire = False;\n\t\t\tGotoState('NormalFire');\n\t\t\tbPointing = True;\n\t\t\tPlayAnim('Place',, 0.1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbListenClient = (Owner.IsA('DeusExPlayer') && DeusExPlayer(Owner).PlayerIsListenClient());\n\n\tsndVolume = TransientSoundVolume;\n\n\tif ( Level.NetMode != NM_Standalone )  // Turn up the sounds a bit in mulitplayer\n\t{\n\t\tsndVolume = TransientSoundVolume * 2.0;\n\t\tif ( Owner.IsA('DeusExPlayer') && (DeusExPlayer(Owner).NintendoImmunityTimeLeft > 0.01) || (!bClientReady && (!bListenClient)) )\n\t\t{\n\t\t\tDeusExPlayer(Owner).bJustFired = False;\n\t\t\tbReadyToFire = True;\n\t\t\tbPointing = False;\n\t\t\tbFiring = False;\n\t\t\treturn;\n\t\t}\n\t}\n\t// check for surrounding environment\n\tif ((EnviroEffective == ENVEFF_Air) || (EnviroEffective == ENVEFF_Vacuum) || (EnviroEffective == ENVEFF_AirVacuum))\n\t{\n\t\tif (Region.Zone.bWaterZone)\n\t\t{\n\t\t\tif (Pawn(Owner) != None)\n\t\t\t{\n\t\t\t\tPawn(Owner).ClientMessage(msgNotWorking);\n\t\t\t\tif (!bHandToHand)\n\t\t\t\t\tPlaySimSound( Misc1Sound, SLOT_None, sndVolume, 1024 );\t\t// play dry fire sound\n\t\t\t}\n\t\t\tGotoState('Idle');\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (bHandToHand)\n\t{\n\t\tif (( Level.NetMode != NM_Standalone ) && !bListenClient )\n\t\t\tbClientReady = False;\n\t\tbReadyToFire = False;\n\t\tGotoState('NormalFire');\n\t\tbPointing=True;\n\t\tif ( Owner.IsA('PlayerPawn') )\n\t\t\tPlayerPawn(Owner).PlayFiring();\n\t\tPlaySelectiveFiring();\n\t\tPlayFiringSound();\n\t}\n}\n\nsimulated function Projectile ProjectileFire(class<projectile> ProjClass, float ProjSpeed, bool bWarn)\n{\n\tlocal Projectile proj;\n\n\tif (AmmoType.AmmoAmount <= 0)\n\t{\n\t\tbDestroyOnFinish = true;\n\t\treturn none;\n\t}\n\t\n\tproj = super.ProjectileFire(ProjClass, ProjSpeed, bWarn);\n\tif (proj != none)\n\t{\n\t\tif (ReloadCount > 0) AmmoType.UseAmmo(1);\n\n\t\tif ( AmmoType.AmmoAmount <= 0 )\n\t\t\tbDestroyOnFinish = True;\n\n\t\t// Update ammo count on object belt\n\t\tif (DeusExPlayer(Owner) != None)\n\t\t\tDeusExPlayer(Owner).UpdateBeltText(Self);\n\t}\n\n\treturn proj;\n}\n\nsimulated function bool ClientFire( float value )\n{\n    //servernotify(\"clientFire - netmode:\"@level.NetMode);\n    if(ReloadCount <= 0)\n        ReloadCount = 1;\n\n    return Super.ClientFire(value);\n}\n\ndefaultproperties\n{\n    //ProjectileClass=Class'TCLAM' To be implemented another day\n}\n",
            "name": "TCWeaponLAM.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "//ProjectileClass=Class'TCLAM' To be implemented another day"
                ],
                "exec": [],
                "extends": "WeaponLAM",
                "functions": {
                    "AnimEnd": {
                        "body": "{\n\t\tif (bAutomatic)\n\t\t{\n\t\t\tif ((Pawn(Owner).bFire != 0) && (AmmoType.AmmoAmount > 0))\n\t\t\t{\n\t\t\t\tif (PlayerPawn(Owner) != None)\n\t\t\t\t\tGlobal.Fire(0);\n\t\t\t\telse \n\t\t\t\t\tGotoState('FinishFire');\n\t\t\t}\n\t\t\telse \n\t\t\t\tGotoState('FinishFire');\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// if we are a thrown weapon and we run out of ammo, destroy the weapon\n\t\t\tif (bHandToHand && (ReloadCount > 0) && (AmmoType.AmmoAmount <= 0))\n\t\t\t{\n\t\t\t\t// fix disappear bug:\n\t\t\t\t//Destroy();\n\t\t\t}\n\t\t}\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AnimEnd",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ClientFire": {
                        "body": "{\n    //servernotify(\"clientFire - netmode:\"@level.NetMode);\n    if(ReloadCount <= 0)\n        ReloadCount = 1;\n\n    return Super.ClientFire(value);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "value"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Fire": {
                        "body": "{\n\n\tif (Pawn(Owner) != None)\n\t{\n\t\tif (bNearWall)\n\t\t{\n\t\t\tbReadyToFire = False;\n\t\t\tGotoState('NormalFire');\n\t\t\tbPointing = True;\n\t\t\tPlayAnim('Place',, 0.1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tbListenClient = (Owner.IsA('DeusExPlayer') && DeusExPlayer(Owner).PlayerIsListenClient());\n\n\tsndVolume = TransientSoundVolume;\n\n\tif ( Level.NetMode != NM_Standalone )  // Turn up the sounds a bit in mulitplayer\n\t{\n\t\tsndVolume = TransientSoundVolume * 2.0;\n\t\tif ( Owner.IsA('DeusExPlayer') && (DeusExPlayer(Owner).NintendoImmunityTimeLeft > 0.01) || (!bClientReady && (!bListenClient)) )\n\t\t{\n\t\t\tDeusExPlayer(Owner).bJustFired = False;\n\t\t\tbReadyToFire = True;\n\t\t\tbPointing = False;\n\t\t\tbFiring = False;\n\t\t\treturn;\n\t\t}\n\t}\n\t// check for surrounding environment\n\tif ((EnviroEffective == ENVEFF_Air) || (EnviroEffective == ENVEFF_Vacuum) || (EnviroEffective == ENVEFF_AirVacuum))\n\t{\n\t\tif (Region.Zone.bWaterZone)\n\t\t{\n\t\t\tif (Pawn(Owner) != None)\n\t\t\t{\n\t\t\t\tPawn(Owner).ClientMessage(msgNotWorking);\n\t\t\t\tif (!bHandToHand)\n\t\t\t\t\tPlaySimSound( Misc1Sound, SLOT_None, sndVolume, 1024 );\t\t// play dry fire sound\n\t\t\t}\n\t\t\tGotoState('Idle');\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (bHandToHand)\n\t{\n\t\tif (( Level.NetMode != NM_Standalone ) && !bListenClient )\n\t\t\tbClientReady = False;\n\t\tbReadyToFire = False;\n\t\tGotoState('NormalFire');\n\t\tbPointing=True;\n\t\tif ( Owner.IsA('PlayerPawn') )\n\t\t\tPlayerPawn(Owner).PlayFiring();\n\t\tPlaySelectiveFiring();\n\t\tPlayFiringSound();\n\t}\n}",
                        "locals": [
                            "local float sndVolume;",
                            "local bool bListenClient;"
                        ],
                        "modifiers": [],
                        "name": "Fire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Value"
                            ]
                        ],
                        "return": ""
                    },
                    "PlaceGrenade": {
                        "body": "{\n\tif (AmmoType.AmmoAmount <= 0) \n\t{\n\t\tDestroy();\n\t\treturn;\n\t}\n\tsuper.PlaceGrenade();\n\tif (AmmoType.AmmoAmount <= 0) Destroy();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlaceGrenade",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ProjectileFire": {
                        "body": "{\n\n\tif (AmmoType.AmmoAmount <= 0)\n\t{\n\t\tbDestroyOnFinish = true;\n\t\treturn none;\n\t}\n\t\n\tproj = super.ProjectileFire(ProjClass, ProjSpeed, bWarn);\n\tif (proj != none)\n\t{\n\t\tif (ReloadCount > 0) AmmoType.UseAmmo(1);\n\n\t\tif ( AmmoType.AmmoAmount <= 0 )\n\t\t\tbDestroyOnFinish = True;\n\n\t\t// Update ammo count on object belt\n\t\tif (DeusExPlayer(Owner) != None)\n\t\t\tDeusExPlayer(Owner).UpdateBeltText(Self);\n\t}\n\n\treturn proj;\n}",
                        "locals": [
                            "local Projectile proj;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ProjectileFire",
                        "native": false,
                        "param": [
                            [
                                "class<projectile>",
                                "ProjClass"
                            ],
                            [
                                "float",
                                "ProjSpeed"
                            ],
                            [
                                "bool",
                                "bWarn"
                            ]
                        ],
                        "return": "Projectile"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 144,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponLAW.uc": {
            "body": "class TCWeaponLAW extends WeaponLAW;\n\ndefaultproperties\n{\n}\n",
            "name": "TCWeaponLAW.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "WeaponLAW",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 6,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponMiniCrossbow.uc": {
            "body": "class TCWeaponMiniCrossbow extends WeaponMiniCrossbow;\n\n\n// fix bug related to firing when having no weapon in hand\nsimulated function bool ClientFire( float value )\n{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}\n\ndefaultproperties\n{\n}\n",
            "name": "TCWeaponMiniCrossbow.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "WeaponMiniCrossbow",
                "functions": {
                    "ClientFire": {
                        "body": "{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "value"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 14,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponNanoSword.uc": {
            "body": "class TCWeaponNanoSword extends WeaponNanoSword;\n\ndefaultproperties\n{\n    mpAccurateRange=96\n    mpMaxRange=96\n}\n",
            "name": "TCWeaponNanoSword.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "mpAccurateRange=96",
                    "mpMaxRange=96"
                ],
                "exec": [],
                "extends": "WeaponNanoSword",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 8,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponPistol.uc": {
            "body": "class TCWeaponPistol extends CBPWeaponPistol;\n\n// fix bug related to firing when having no weapon in hand\nsimulated function bool ClientFire( float value )\n{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}\n\ndefaultproperties\n{\n}\n",
            "name": "TCWeaponPistol.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "CBPWeaponPistol",
                "functions": {
                    "ClientFire": {
                        "body": "{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "value"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 13,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponPlasmaRifle.uc": {
            "body": "class TCWeaponPlasmaRifle extends WeaponPlasmaRifle;\n\n// fix bug related to firing when having no weapon in hand\nsimulated function bool ClientFire( float value )\n{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}\n\ndefaultproperties\n{\n}\n",
            "name": "TCWeaponPlasmaRifle.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "WeaponPlasmaRifle",
                "functions": {
                    "ClientFire": {
                        "body": "{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "value"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 13,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponRifle.uc": {
            "body": "class TCWeaponRifle extends CBPWeaponRifle;\n\ndefaultproperties\n{\n}\n",
            "name": "TCWeaponRifle.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "CBPWeaponRifle",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 6,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponSawedOffShotgun.uc": {
            "body": "class TCWeaponSawedOffShotgun extends WeaponSawedOffShotgun;\n\n\n// fix bug related to firing when having no weapon in hand\nsimulated function bool ClientFire( float value )\n{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}\n\ndefaultproperties\n{\n}\n",
            "name": "TCWeaponSawedOffShotgun.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "WeaponSawedOffShotgun",
                "functions": {
                    "ClientFire": {
                        "body": "{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "value"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 14,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponShuriken.uc": {
            "body": "class TCWeaponShuriken extends CBPWeaponShuriken;\n\n// fix bug related to firing when having no weapon in hand\nsimulated function bool ClientFire( float value )\n{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}\n\ndefaultproperties\n{\n}\n",
            "name": "TCWeaponShuriken.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "CBPWeaponShuriken",
                "functions": {
                    "ClientFire": {
                        "body": "{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "value"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 13,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "TCWeaponStealthPistol.uc": {
            "body": "class TCWeaponStealthPistol extends WeaponStealthPistol;\n\n\n// fix bug related to firing when having no weapon in hand\nsimulated function bool ClientFire( float value )\n{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}\n\ndefaultproperties\n{\n}\n",
            "name": "TCWeaponStealthPistol.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "WeaponStealthPistol",
                "functions": {
                    "ClientFire": {
                        "body": "{\n\tif (DeusExPlayer(Owner) != none && DeusExPlayer(Owner).inHand != self) return false;\n\treturn super.ClientFire(value);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "value"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 14,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "ToyMC.uc": {
            "body": "//================================================================================\n// MTLJCDenton.\n//================================================================================\nclass ToyMC extends ToyPlayer\n\tConfig(User);\n\ndefaultproperties\n{\n    V68=1\n    Drawscale=0.18\n    Mesh=LodMesh'DeusExCharacters.GM_Trench'\n    MultiSkins(0)=Texture'DeusExCharacters.Skins.JCDentonTex0'\n    MultiSkins(1)=Texture'DeusExCharacters.Skins.JCDentonTex2'\n    MultiSkins(2)=Texture'DeusExCharacters.Skins.JCDentonTex3'\n    MultiSkins(3)=Texture'DeusExCharacters.Skins.JCDentonTex0'\n    MultiSkins(4)=Texture'DeusExCharacters.Skins.JCDentonTex1'\n    MultiSkins(5)=Texture'DeusExCharacters.Skins.JCDentonTex2'\n    MultiSkins(6)=Texture'DeusExCharacters.Skins.FramesTex4'\n    MultiSkins(7)=Texture'DeusExCharacters.Skins.LensesTex5'\n}\n",
            "name": "ToyMC.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "V68=1",
                    "Drawscale=0.18",
                    "Mesh=LodMesh'DeusExCharacters.GM_Trench'",
                    "MultiSkins(0)=Texture'DeusExCharacters.Skins.JCDentonTex0'",
                    "MultiSkins(1)=Texture'DeusExCharacters.Skins.JCDentonTex2'",
                    "MultiSkins(2)=Texture'DeusExCharacters.Skins.JCDentonTex3'",
                    "MultiSkins(3)=Texture'DeusExCharacters.Skins.JCDentonTex0'",
                    "MultiSkins(4)=Texture'DeusExCharacters.Skins.JCDentonTex1'",
                    "MultiSkins(5)=Texture'DeusExCharacters.Skins.JCDentonTex2'",
                    "MultiSkins(6)=Texture'DeusExCharacters.Skins.FramesTex4'",
                    "MultiSkins(7)=Texture'DeusExCharacters.Skins.LensesTex5'"
                ],
                "exec": [],
                "extends": "ToyPlayer",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 21,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "ToyPlayer.uc": {
            "body": "//=============================================================================\n// SSPlayer\n//=============================================================================\nclass ToyPlayer expands TCPlayer;\n\nfunction bool SetBasedPawnSize(float newRadius, float newHeight)\n{\n\tlocal float  oldRadius, oldHeight;\n\tlocal bool   bSuccess;\n\tlocal vector centerDelta, lookDir, upDir;\n\tlocal float  deltaEyeHeight;\n\tlocal Decoration savedDeco;\n\n\tif (newRadius < 0)\n\t\tnewRadius = 0;\n\tif (newHeight < 0)\n\t\tnewHeight = 0;\n\n\toldRadius = CollisionRadius;\n\toldHeight = CollisionHeight;\n\n\tif ( Level.NetMode == NM_Standalone )\n\t{\n\t\tif ((oldRadius == newRadius) && (oldHeight == newHeight))\n\t\t\treturn true;\n\t}\n\n\tcenterDelta    = vect(0, 0, 1)*(newHeight-oldHeight);\n\tdeltaEyeHeight = GetDefaultCollisionHeight() - Default.BaseEyeHeight;\n\n\tif ( Level.NetMode != NM_Standalone )\n\t{\n\t\tif ((oldRadius == newRadius) && (oldHeight == newHeight) && (BaseEyeHeight == newHeight - deltaEyeHeight))\n\t\t\treturn true;\n\t}\n\n\tif (CarriedDecoration != None)\n\t\tsavedDeco = CarriedDecoration;\n\n\tbSuccess = false;\n\tif ((newHeight <= CollisionHeight) && (newRadius <= CollisionRadius))  // shrink\n\t{\n\t\tSetCollisionSize(newRadius, newHeight);\n\t\tif (Move(centerDelta))\n\t\t\tbSuccess = true;\n\t\telse\n\t\t\tSetCollisionSize(oldRadius, oldHeight);\n\t}\n\telse\n\t{\n\t\tif (Move(centerDelta))\n\t\t{\n\t\t\tSetCollisionSize(newRadius, newHeight);\n\t\t\tbSuccess = true;\n\t\t}\n\t}\n\n\tif (bSuccess)\n\t{\n\t\t// make sure we don't lose our carried decoration\n\t\tif (savedDeco != None)\n\t\t{\n\t\t\tsavedDeco.SetPhysics(PHYS_None);\n\t\t\tsavedDeco.SetBase(Self);\n\t\t\tsavedDeco.SetCollision(False, False, False);\n\n\t\t\t// reset the decoration's location\n\t\t\tlookDir = Vector(Rotation);\n\t\t\tlookDir.Z = 0;\t\t\t\t\n\t\t\tupDir = vect(0,0,0);\n\t\t\tupDir.Z = CollisionHeight / 2;\t\t// put it up near eye level\n\t\t\tsavedDeco.SetLocation(Location + upDir + (0.5 * CollisionRadius + CarriedDecoration.CollisionRadius) * lookDir);\n\t\t}\n\n//\t\tPrePivotOffset  = vect(0, 0, 1)*(GetDefaultCollisionHeight()-newHeight);\n\t\tPrePivot        -= centerDelta;\n//\t\tDesiredPrePivot -= centerDelta;\n\t\tBaseEyeHeight   = newHeight - deltaEyeHeight;\n\n\t\tEyeHeight\t\t-= centerDelta.Z;\n\t}\n\treturn (bSuccess);\n}\n\nstate PlayerWalking\n{\n\tfunction ProcessMove ( float DeltaTime, vector newAccel, eDodgeDir DodgeMove, rotator DeltaRot)\n\t{\n\t\tlocal int newSpeed, defSpeed;\n\t\tlocal name mat;\n\t\tlocal vector HitLocation, HitNormal, checkpoint, downcheck;\n\t\tlocal Actor HitActor, HitActorDown;\n\t\tlocal bool bCantStandUp;\n\t\tlocal Vector loc, traceSize;\n\t\tlocal float alpha, maxLeanDist;\n\t\tlocal float legTotal, weapSkill;\n\t\tlocal vector start, checkNorm, Extent;\n\t\tlocal TCControls TCC;\n\t\t\n\t\tTCC = GetControls();\n\t\tSuper.ProcessMove(DeltaTime, newAccel, DodgeMove, DeltaRot);\n\t\t//Kaiser: Mantling system.\n\t\tif (Physics == PHYS_Falling && velocity.Z != 0 && TCC.bMantling)\n\t\t{\n\t\t\tif (CarriedDecoration == None && Energy >= TCC.MantleBio)\n\t\t\t{\n\t\t\t\tcheckpoint = vector(Rotation);\n\t\t\t\tcheckpoint.Z = 0.0;\n\t\t\t\tcheckNorm = Normal(checkpoint);\n\t\t\t\tcheckPoint = Location + CollisionRadius * checkNorm;\n\t\t\t\t//Extent = CollisionRadius * vect(1,1,0);\n\t\t\t\tExtent = CollisionRadius * vect(0.2,0.2,0);\n\t\t\t\tExtent.Z = CollisionHeight;\n\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, True, Extent);\n\t\t\t\tif ( (HitActor != None) && (Pawn(HitActor) == None) && (HitActor == Level || HitActor.bCollideActors) && !HitActor.IsA('DeusExCarcass'))\n\t\t\t\t{\n\t\t\t\t\tWallNormal = -1 * HitNormal;\n\t\t\t\t\tstart = Location;\n\t\t\t\t\tstart.Z += 1.1 * MaxStepHeight + CollisionHeight;\n\t\t\t\t\tcheckPoint = start + 2 * CollisionRadius * checkNorm;\n\t\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, start, true, Extent);\n\t\t\t\t\tif (HitActor == None)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!isMantling)\t\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tEnergy -= TCC.MantleBio;\n\t\t\t\t\t\t\tisMantling = True;\n\t\t\t\t\t\t\tsetPhysics(PHYS_Falling);\n\t\t\t\t\t\t\tVelocity.Z = TCC.MantleVelocity;\n\t\t\t\t\t\t\tAcceleration = vect(0,0,0);\n\t\t\t\t\t\t\tPlaySound(sound'MaleLand', SLOT_None, 1.5, true, 1200, (1.0 + 0.2*FRand()) * 1.0 );\n\t\t\t\t\t\t\tAcceleration = wallNormal * AccelRate / 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// if the spy drone augmentation is active\n\t\tif (bSpyDroneActive)\n\t\t{\n\t\t\tif ( aDrone != None ) \n\t\t\t{\n\t\t\t\t// put away whatever is in our hand\n\t\t\t\tif (inHand != None)\n\t\t\t\t\tPutInHand(None);\n\n\t\t\t\t// make the drone's rotation match the player's view\n\t\t\t\taDrone.SetRotation(ViewRotation);\n\n\t\t\t\t// move the drone\n\t\t\t\tloc = Normal((aUp * vect(0,0,1) + aForward * vect(1,0,0) + aStrafe * vect(0,1,0)) >> ViewRotation);\n\n\t\t\t\t// opportunity for client to translate movement to server\n\t\t\t\tMoveDrone( DeltaTime, loc );\n\n\t\t\t\t// freeze the player\n\t\t\t\tVelocity = vect(0,0,0);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tdefSpeed = GetCurrentGroundSpeed();\n\n      // crouching makes you two feet tall\n\t\tif (bIsCrouching || bForceDuck)\n\t\t{\n\t\t\tSetBasedPawnSize(Default.CollisionRadius, Default.CollisionHeight);\n\n\t\t\t// check to see if we could stand up if we wanted to\n\t\t\tcheckpoint = Location;\n\t\t\t// check normal standing height\n\t\t\tcheckpoint.Z = checkpoint.Z - CollisionHeight + 2 * GetDefaultCollisionHeight();\n\t\t\ttraceSize.X = CollisionRadius;\n\t\t\ttraceSize.Y = CollisionRadius;\n\t\t\ttraceSize.Z = 1;\n\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, True, traceSize);\n\t\t\tif (HitActor == None)\n\t\t\t\tbCantStandUp = False;\n\t\t\telse\n\t\t\t\tbCantStandUp = True;\n\t\t}\n\t\telse\n\t\t{\n         // DEUS_EX AMSD Changed this to grab defspeed, because GetCurrentGroundSpeed takes 31k cycles to run.\n\t\t\tGroundSpeed = defSpeed;\n\n\t\t\t// make sure the collision height is fudged for the floor problem - CNN\n\t\t\tif (!IsLeaning())\n\t\t\t{\n\t\t\t\tResetBasedPawnSize();\n\t\t\t}\n\t\t}\n\n\t\tif (bCantStandUp)\n\t\t\tbForceDuck = True;\n\t\telse\n\t\t\tbForceDuck = False;\n\n\t\t// if the player's legs are damaged, then reduce our speed accordingly\n\t\tnewSpeed = defSpeed;\n\n\t\tif ( Level.NetMode == NM_Standalone )\n\t\t{\n\t\t\tif (HealthLegLeft < 1)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.25;\n\t\t\telse if (HealthLegLeft < 34)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.15;\n\t\t\telse if (HealthLegLeft < 67)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.10;\n\n\t\t\tif (HealthLegRight < 1)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.25;\n\t\t\telse if (HealthLegRight < 34)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.15;\n\t\t\telse if (HealthLegRight < 67)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.10;\n\n\t\t\tif (HealthTorso < 67)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.05;\n\t\t}\n\n\t\t// let the player pull themselves along with their hands even if both of\n\t\t// their legs are blown off\n\t\tif ((HealthLegLeft < 1) && (HealthLegRight < 1))\n\t\t{\n\t\t\tnewSpeed = defSpeed * 0.8;\n\t\t\tbIsWalking = True;\n\t\t\tbForceDuck = True;\n\t\t}\n\t\t// make crouch speed faster than normal\n\t\telse if (bIsCrouching || bForceDuck)\n\t\t{\n//\t\t\tnewSpeed = defSpeed * 1.8;\t\t// DEUS_EX CNN - uncomment to speed up crouch\n\t\t\tbIsWalking = True;\n\t\t}\n\n\t\tif (CarriedDecoration != None)\n\t\t{\n\t\t\tnewSpeed -= CarriedDecoration.Mass * 2;\n\t\t}\n\t\t// don't slow the player down if he's skilled at the corresponding weapon skill  \n\t\telse if ((DeusExWeapon(Weapon) != None) && (Weapon.Mass > 30) && (DeusExWeapon(Weapon).GetWeaponSkill() > -0.25) && (Level.NetMode==NM_Standalone))\n\t\t{\n\t\t\tbIsWalking = True;\n\t\t\tnewSpeed = defSpeed;\n\t\t}\n\t\telse if ((inHand != None) && inHand.IsA('POVCorpse'))\n\t\t{\n\t\t\tnewSpeed -= inHand.Mass * 3;\n\t\t}\n\n\t\t// Multiplayer movement adjusters\n\t\tif ( Level.NetMode != NM_Standalone )\n\t\t{\n\t\t\tif ( Weapon != None )\n\t\t\t{\n\t\t\t\tweapSkill = DeusExWeapon(Weapon).GetWeaponSkill();\n\t\t\t\t// Slow down heavy weapons in multiplayer\n\t\t\t\tif ((DeusExWeapon(Weapon) != None) && (Weapon.Mass > 30) )\n\t\t\t\t{\n\t\t\t\t\tnewSpeed = defSpeed;\n\t\t\t\t\tnewSpeed -= ((( Weapon.Mass - 30.0 ) / (class'WeaponGEPGun'.Default.Mass - 30.0 )) * (0.70 + weapSkill) * defSpeed );\n\t\t\t\t}\n\t\t\t\t// Slow turn rate of GEP gun in multiplayer to discourage using it as the most effective close quarters weapon\n\t\t\t\tif ((WeaponGEPGun(Weapon) != None) && (!WeaponGEPGun(Weapon).bZoomed))\n\t\t\t\t\tTurnRateAdjuster = FClamp( 0.20 + -(weapSkill*0.5), 0.25, 1.0 );\n\t\t\t\telse\n\t\t\t\t\tTurnRateAdjuster = 1.0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tTurnRateAdjuster = 1.0;\n\t\t}\n\n\t\t// if we are moving really slow, force us to walking\n\t\tif ((newSpeed <= defSpeed / 3) && !bForceDuck)\n\t\t{\n\t\t\tbIsWalking = True;\n\t\t\tnewSpeed = defSpeed;\n\t\t}\n\n\t\t// if we are moving backwards, we should move slower\n      // DEUS_EX AMSD Turns out this wasn't working right in multiplayer, I have a fix\n      // for it, but it would change all our balance.\n\t\tif ((aForward < 0) && (Level.NetMode == NM_Standalone))\n\t\t\tnewSpeed *= 0.65;\n\n\t\tGroundSpeed = FMax(newSpeed, 100);\n\n\t\t// if we are moving or crouching, we can't lean\n\t\t// uncomment below line to disallow leaning during crouch\n\n\t\t\tif ((VSize(Velocity) < 10) && (aForward == 0))\t\t// && !bIsCrouching && !bForceDuck)\n\t\t\t\tbCanLean = True;\n\t\t\telse\n\t\t\t\tbCanLean = False;\n\n\t\t\t// check leaning buttons (axis aExtra0 is used for leaning)\n\t\t\tmaxLeanDist = 40;\n\n\t\t\tif (IsLeaning())\n\t\t\t{\n\t\t\t\tif ( PlayerIsClient() || (Level.NetMode == NM_Standalone) )\n\t\t\t\t\tViewRotation.Roll = curLeanDist * 20;\n\t\t\t\n\t\t\t\tif (!bIsCrouching && !bForceDuck)\n\t\t\t\t\tSetBasedPawnSize(CollisionRadius, GetDefaultCollisionHeight() - Abs(curLeanDist) / 3.0);\n\t\t\t}\n\t\t\tif (bCanLean && (aExtra0 != 0))\n\t\t\t{\n\t\t\t\t// lean\n\t\t\t\tDropDecoration();\t\t// drop the decoration that we are carrying\n\t\t\t\tif (AnimSequence != 'CrouchWalk')\n\t\t\t\t\tPlayCrawling();\n\n\t\t\t\talpha = maxLeanDist * aExtra0 * 2.0 * DeltaTime;\n\n\t\t\t\tloc = vect(0,0,0);\n\t\t\t\tloc.Y = alpha;\n\t\t\t\tif (Abs(curLeanDist + alpha) < maxLeanDist)\n\t\t\t\t{\n\t\t\t\t\t// check to make sure the destination not blocked\n\t\t\t\t\tcheckpoint = (loc >> Rotation) + Location;\n\t\t\t\t\ttraceSize.X = CollisionRadius;\n\t\t\t\t\ttraceSize.Y = CollisionRadius;\n\t\t\t\t\ttraceSize.Z = CollisionHeight;\n\t\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, True, traceSize);\n\n\t\t\t\t\t// check down as well to make sure there's a floor there\n\t\t\t\t\tdowncheck = checkpoint - vect(0,0,1) * CollisionHeight;\n\t\t\t\t\tHitActorDown = Trace(HitLocation, HitNormal, downcheck, checkpoint, True, traceSize);\n\t\t\t\t\tif ((HitActor == None) && (HitActorDown != None))\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( PlayerIsClient() || (Level.NetMode == NM_Standalone))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSetLocation(checkpoint);\n\t\t\t\t\t\t\tServerUpdateLean( checkpoint );\n\t\t\t\t\t\t\tcurLeanDist += alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ( PlayerIsClient() || (Level.NetMode == NM_Standalone) )\n\t\t\t\t\t\tcurLeanDist = aExtra0 * maxLeanDist;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (IsLeaning())\t//if (!bCanLean && IsLeaning())\t// uncomment this to not hold down lean\n\t\t\t{\n\t\t\t\t// un-lean\n\t\t\t\tif (AnimSequence == 'CrouchWalk')\n\t\t\t\t\tPlayRising();\n\n\t\t\t\tif ( PlayerIsClient() || (Level.NetMode == NM_Standalone))\n\t\t\t\t{\n\t\t\t\t\tprevLeanDist = curLeanDist;\n\t\t\t\t\talpha = FClamp(7.0 * DeltaTime, 0.001, 0.9);\n\t\t\t\t\tcurLeanDist *= 1.0 - alpha;\n\t\t\t\t\tif (Abs(curLeanDist) < 1.0)\n\t\t\t\t\t\tcurLeanDist = 0;\n\t\t\t\t}\n\n\t\t\t\tloc = vect(0,0,0);\n\t\t\t\tloc.Y = -(prevLeanDist - curLeanDist);\n\n\t\t\t\t// check to make sure the destination not blocked\n\t\t\t\tcheckpoint = (loc >> Rotation) + Location;\n\t\t\t\ttraceSize.X = CollisionRadius;\n\t\t\t\ttraceSize.Y = CollisionRadius;\n\t\t\t\ttraceSize.Z = CollisionHeight;\n\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, True, traceSize);\n\n\t\t\t\t// check down as well to make sure there's a floor there\n\t\t\t\tdowncheck = checkpoint - vect(0,0,1) * CollisionHeight;\n\t\t\t\tHitActorDown = Trace(HitLocation, HitNormal, downcheck, checkpoint, True, traceSize);\n\t\t\t\tif ((HitActor == None) && (HitActorDown != None))\n\t\t\t\t{\n\t\t\t\t\tif ( PlayerIsClient() || (Level.NetMode == NM_Standalone))\n\t\t\t\t\t{\n\t\t\t\t\t\tSetLocation( checkpoint );\n\t\t\t\t\t\tServerUpdateLean( checkpoint );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t}\n\n\tfunction ZoneChange(ZoneInfo NewZone)\n\t{\n\t\t// if we jump into water, empty our hands\n\t\tif (NewZone.bWaterZone)\n\t\t\tDropDecoration();\n\n\t\tSuper.ZoneChange(NewZone);\n\t}\n\n\tevent PlayerTick(float deltaTime)\n\t{\n        //DEUS_EX AMSD Additional updates\n        //Because of replication delay, aug icons end up being a step behind generally.  So refresh them\n        //every freaking tick.  \n        RefreshSystems(deltaTime);\n\n\t\tDrugEffects(deltaTime);\n\t\tBleed(deltaTime);\n\t\tHighlightCenterObject();\n\n\n\t\tUpdateDynamicMusic(deltaTime);\n\t\tUpdateWarrenEMPField(deltaTime);\n      // DEUS_EX AMSD Move these funcions to a multiplayer tick\n      // so that only that call gets propagated to the server.\n      MultiplayerTick(deltaTime);\n      // DEUS_EX AMSD For multiplayer...\n\t\tFrobTime += deltaTime;\n\n\t\t// save some texture info\n\t\tFloorMaterial = GetFloorMaterial();\n\t\tWallMaterial = GetWallMaterial(WallNormal);\n\n\t\t// Check if player has walked outside a first-person convo.\n\t\tCheckActiveConversationRadius();\n\n\t\t// Check if all the people involved in a conversation are \n\t\t// still within a reasonable radius.\n\t\tCheckActorDistances();\n\n\t\t// handle poison\n      //DEUS_EX AMSD Now handled in multiplayertick\n\t\t//UpdatePoison(deltaTime);\n\n\t\t// Update Time Played\n\t\tUpdateTimePlayed(deltaTime);\n\n\t\tSuper.PlayerTick(deltaTime);\n\t}\n}\n\ndefaultproperties\n{\n\tMass=2\nPlayerReplicationInfoClass=Class'TCPRI'\n     CollisionRadius=5.000000\n     CollisionHeight=10.000000\n     BaseEyeHeight=10.00\n     Drawscale=0.18\n     mpGroundSpeed=30.00\n    mpWaterSpeed=10.00\n    Jumpz=200\n    MaxStepHeight=10.000000\n}\n",
            "name": "ToyPlayer.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Mass=2",
                    "PlayerReplicationInfoClass=Class'TCPRI'",
                    "CollisionRadius=5.000000",
                    "CollisionHeight=10.000000",
                    "BaseEyeHeight=10.00",
                    "Drawscale=0.18",
                    "mpGroundSpeed=30.00",
                    "mpWaterSpeed=10.00",
                    "Jumpz=200",
                    "MaxStepHeight=10.000000"
                ],
                "exec": [],
                "extends": "TCPlayer",
                "functions": {
                    "PlayerTick": {
                        "body": "{\n        //DEUS_EX AMSD Additional updates\n        //Because of replication delay, aug icons end up being a step behind generally.  So refresh them\n        //every freaking tick.  \n        RefreshSystems(deltaTime);\n\n\t\tDrugEffects(deltaTime);\n\t\tBleed(deltaTime);\n\t\tHighlightCenterObject();\n\n\n\t\tUpdateDynamicMusic(deltaTime);\n\t\tUpdateWarrenEMPField(deltaTime);\n      // DEUS_EX AMSD Move these funcions to a multiplayer tick\n      // so that only that call gets propagated to the server.\n      MultiplayerTick(deltaTime);\n      // DEUS_EX AMSD For multiplayer...\n\t\tFrobTime += deltaTime;\n\n\t\t// save some texture info\n\t\tFloorMaterial = GetFloorMaterial();\n\t\tWallMaterial = GetWallMaterial(WallNormal);\n\n\t\t// Check if player has walked outside a first-person convo.\n\t\tCheckActiveConversationRadius();\n\n\t\t// Check if all the people involved in a conversation are \n\t\t// still within a reasonable radius.\n\t\tCheckActorDistances();\n\n\t\t// handle poison\n      //DEUS_EX AMSD Now handled in multiplayertick\n\t\t//UpdatePoison(deltaTime);\n\n\t\t// Update Time Played\n\t\tUpdateTimePlayed(deltaTime);\n\n\t\tSuper.PlayerTick(deltaTime);\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayerTick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "deltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "ProcessMove": {
                        "body": "{\n\t\t\n\t\tTCC = GetControls();\n\t\tSuper.ProcessMove(DeltaTime, newAccel, DodgeMove, DeltaRot);\n\t\t//Kaiser: Mantling system.\n\t\tif (Physics == PHYS_Falling && velocity.Z != 0 && TCC.bMantling)\n\t\t{\n\t\t\tif (CarriedDecoration == None && Energy >= TCC.MantleBio)\n\t\t\t{\n\t\t\t\tcheckpoint = vector(Rotation);\n\t\t\t\tcheckpoint.Z = 0.0;\n\t\t\t\tcheckNorm = Normal(checkpoint);\n\t\t\t\tcheckPoint = Location + CollisionRadius * checkNorm;\n\t\t\t\t//Extent = CollisionRadius * vect(1,1,0);\n\t\t\t\tExtent = CollisionRadius * vect(0.2,0.2,0);\n\t\t\t\tExtent.Z = CollisionHeight;\n\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, True, Extent);\n\t\t\t\tif ( (HitActor != None) && (Pawn(HitActor) == None) && (HitActor == Level || HitActor.bCollideActors) && !HitActor.IsA('DeusExCarcass'))\n\t\t\t\t{\n\t\t\t\t\tWallNormal = -1 * HitNormal;\n\t\t\t\t\tstart = Location;\n\t\t\t\t\tstart.Z += 1.1 * MaxStepHeight + CollisionHeight;\n\t\t\t\t\tcheckPoint = start + 2 * CollisionRadius * checkNorm;\n\t\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, start, true, Extent);\n\t\t\t\t\tif (HitActor == None)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!isMantling)\t\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tEnergy -= TCC.MantleBio;\n\t\t\t\t\t\t\tisMantling = True;\n\t\t\t\t\t\t\tsetPhysics(PHYS_Falling);\n\t\t\t\t\t\t\tVelocity.Z = TCC.MantleVelocity;\n\t\t\t\t\t\t\tAcceleration = vect(0,0,0);\n\t\t\t\t\t\t\tPlaySound(sound'MaleLand', SLOT_None, 1.5, true, 1200, (1.0 + 0.2*FRand()) * 1.0 );\n\t\t\t\t\t\t\tAcceleration = wallNormal * AccelRate / 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// if the spy drone augmentation is active\n\t\tif (bSpyDroneActive)\n\t\t{\n\t\t\tif ( aDrone != None ) \n\t\t\t{\n\t\t\t\t// put away whatever is in our hand\n\t\t\t\tif (inHand != None)\n\t\t\t\t\tPutInHand(None);\n\n\t\t\t\t// make the drone's rotation match the player's view\n\t\t\t\taDrone.SetRotation(ViewRotation);\n\n\t\t\t\t// move the drone\n\t\t\t\tloc = Normal((aUp * vect(0,0,1) + aForward * vect(1,0,0) + aStrafe * vect(0,1,0)) >> ViewRotation);\n\n\t\t\t\t// opportunity for client to translate movement to server\n\t\t\t\tMoveDrone( DeltaTime, loc );\n\n\t\t\t\t// freeze the player\n\t\t\t\tVelocity = vect(0,0,0);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tdefSpeed = GetCurrentGroundSpeed();\n\n      // crouching makes you two feet tall\n\t\tif (bIsCrouching || bForceDuck)\n\t\t{\n\t\t\tSetBasedPawnSize(Default.CollisionRadius, Default.CollisionHeight);\n\n\t\t\t// check to see if we could stand up if we wanted to\n\t\t\tcheckpoint = Location;\n\t\t\t// check normal standing height\n\t\t\tcheckpoint.Z = checkpoint.Z - CollisionHeight + 2 * GetDefaultCollisionHeight();\n\t\t\ttraceSize.X = CollisionRadius;\n\t\t\ttraceSize.Y = CollisionRadius;\n\t\t\ttraceSize.Z = 1;\n\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, True, traceSize);\n\t\t\tif (HitActor == None)\n\t\t\t\tbCantStandUp = False;\n\t\t\telse\n\t\t\t\tbCantStandUp = True;\n\t\t}\n\t\telse\n\t\t{\n         // DEUS_EX AMSD Changed this to grab defspeed, because GetCurrentGroundSpeed takes 31k cycles to run.\n\t\t\tGroundSpeed = defSpeed;\n\n\t\t\t// make sure the collision height is fudged for the floor problem - CNN\n\t\t\tif (!IsLeaning())\n\t\t\t{\n\t\t\t\tResetBasedPawnSize();\n\t\t\t}\n\t\t}\n\n\t\tif (bCantStandUp)\n\t\t\tbForceDuck = True;\n\t\telse\n\t\t\tbForceDuck = False;\n\n\t\t// if the player's legs are damaged, then reduce our speed accordingly\n\t\tnewSpeed = defSpeed;\n\n\t\tif ( Level.NetMode == NM_Standalone )\n\t\t{\n\t\t\tif (HealthLegLeft < 1)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.25;\n\t\t\telse if (HealthLegLeft < 34)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.15;\n\t\t\telse if (HealthLegLeft < 67)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.10;\n\n\t\t\tif (HealthLegRight < 1)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.25;\n\t\t\telse if (HealthLegRight < 34)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.15;\n\t\t\telse if (HealthLegRight < 67)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.10;\n\n\t\t\tif (HealthTorso < 67)\n\t\t\t\tnewSpeed -= (defSpeed/2) * 0.05;\n\t\t}\n\n\t\t// let the player pull themselves along with their hands even if both of\n\t\t// their legs are blown off\n\t\tif ((HealthLegLeft < 1) && (HealthLegRight < 1))\n\t\t{\n\t\t\tnewSpeed = defSpeed * 0.8;\n\t\t\tbIsWalking = True;\n\t\t\tbForceDuck = True;\n\t\t}\n\t\t// make crouch speed faster than normal\n\t\telse if (bIsCrouching || bForceDuck)\n\t\t{\n//\t\t\tnewSpeed = defSpeed * 1.8;\t\t// DEUS_EX CNN - uncomment to speed up crouch\n\t\t\tbIsWalking = True;\n\t\t}\n\n\t\tif (CarriedDecoration != None)\n\t\t{\n\t\t\tnewSpeed -= CarriedDecoration.Mass * 2;\n\t\t}\n\t\t// don't slow the player down if he's skilled at the corresponding weapon skill  \n\t\telse if ((DeusExWeapon(Weapon) != None) && (Weapon.Mass > 30) && (DeusExWeapon(Weapon).GetWeaponSkill() > -0.25) && (Level.NetMode==NM_Standalone))\n\t\t{\n\t\t\tbIsWalking = True;\n\t\t\tnewSpeed = defSpeed;\n\t\t}\n\t\telse if ((inHand != None) && inHand.IsA('POVCorpse'))\n\t\t{\n\t\t\tnewSpeed -= inHand.Mass * 3;\n\t\t}\n\n\t\t// Multiplayer movement adjusters\n\t\tif ( Level.NetMode != NM_Standalone )\n\t\t{\n\t\t\tif ( Weapon != None )\n\t\t\t{\n\t\t\t\tweapSkill = DeusExWeapon(Weapon).GetWeaponSkill();\n\t\t\t\t// Slow down heavy weapons in multiplayer\n\t\t\t\tif ((DeusExWeapon(Weapon) != None) && (Weapon.Mass > 30) )\n\t\t\t\t{\n\t\t\t\t\tnewSpeed = defSpeed;\n\t\t\t\t\tnewSpeed -= ((( Weapon.Mass - 30.0 ) / (class'WeaponGEPGun'.Default.Mass - 30.0 )) * (0.70 + weapSkill) * defSpeed );\n\t\t\t\t}\n\t\t\t\t// Slow turn rate of GEP gun in multiplayer to discourage using it as the most effective close quarters weapon\n\t\t\t\tif ((WeaponGEPGun(Weapon) != None) && (!WeaponGEPGun(Weapon).bZoomed))\n\t\t\t\t\tTurnRateAdjuster = FClamp( 0.20 + -(weapSkill*0.5), 0.25, 1.0 );\n\t\t\t\telse\n\t\t\t\t\tTurnRateAdjuster = 1.0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tTurnRateAdjuster = 1.0;\n\t\t}\n\n\t\t// if we are moving really slow, force us to walking\n\t\tif ((newSpeed <= defSpeed / 3) && !bForceDuck)\n\t\t{\n\t\t\tbIsWalking = True;\n\t\t\tnewSpeed = defSpeed;\n\t\t}\n\n\t\t// if we are moving backwards, we should move slower\n      // DEUS_EX AMSD Turns out this wasn't working right in multiplayer, I have a fix\n      // for it, but it would change all our balance.\n\t\tif ((aForward < 0) && (Level.NetMode == NM_Standalone))\n\t\t\tnewSpeed *= 0.65;\n\n\t\tGroundSpeed = FMax(newSpeed, 100);\n\n\t\t// if we are moving or crouching, we can't lean\n\t\t// uncomment below line to disallow leaning during crouch\n\n\t\t\tif ((VSize(Velocity) < 10) && (aForward == 0))\t\t// && !bIsCrouching && !bForceDuck)\n\t\t\t\tbCanLean = True;\n\t\t\telse\n\t\t\t\tbCanLean = False;\n\n\t\t\t// check leaning buttons (axis aExtra0 is used for leaning)\n\t\t\tmaxLeanDist = 40;\n\n\t\t\tif (IsLeaning())\n\t\t\t{\n\t\t\t\tif ( PlayerIsClient() || (Level.NetMode == NM_Standalone) )\n\t\t\t\t\tViewRotation.Roll = curLeanDist * 20;\n\t\t\t\n\t\t\t\tif (!bIsCrouching && !bForceDuck)\n\t\t\t\t\tSetBasedPawnSize(CollisionRadius, GetDefaultCollisionHeight() - Abs(curLeanDist) / 3.0);\n\t\t\t}\n\t\t\tif (bCanLean && (aExtra0 != 0))\n\t\t\t{\n\t\t\t\t// lean\n\t\t\t\tDropDecoration();\t\t// drop the decoration that we are carrying\n\t\t\t\tif (AnimSequence != 'CrouchWalk')\n\t\t\t\t\tPlayCrawling();\n\n\t\t\t\talpha = maxLeanDist * aExtra0 * 2.0 * DeltaTime;\n\n\t\t\t\tloc = vect(0,0,0);\n\t\t\t\tloc.Y = alpha;\n\t\t\t\tif (Abs(curLeanDist + alpha) < maxLeanDist)\n\t\t\t\t{\n\t\t\t\t\t// check to make sure the destination not blocked\n\t\t\t\t\tcheckpoint = (loc >> Rotation) + Location;\n\t\t\t\t\ttraceSize.X = CollisionRadius;\n\t\t\t\t\ttraceSize.Y = CollisionRadius;\n\t\t\t\t\ttraceSize.Z = CollisionHeight;\n\t\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, True, traceSize);\n\n\t\t\t\t\t// check down as well to make sure there's a floor there\n\t\t\t\t\tdowncheck = checkpoint - vect(0,0,1) * CollisionHeight;\n\t\t\t\t\tHitActorDown = Trace(HitLocation, HitNormal, downcheck, checkpoint, True, traceSize);\n\t\t\t\t\tif ((HitActor == None) && (HitActorDown != None))\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( PlayerIsClient() || (Level.NetMode == NM_Standalone))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSetLocation(checkpoint);\n\t\t\t\t\t\t\tServerUpdateLean( checkpoint );\n\t\t\t\t\t\t\tcurLeanDist += alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ( PlayerIsClient() || (Level.NetMode == NM_Standalone) )\n\t\t\t\t\t\tcurLeanDist = aExtra0 * maxLeanDist;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (IsLeaning())\t//if (!bCanLean && IsLeaning())\t// uncomment this to not hold down lean\n\t\t\t{\n\t\t\t\t// un-lean\n\t\t\t\tif (AnimSequence == 'CrouchWalk')\n\t\t\t\t\tPlayRising();\n\n\t\t\t\tif ( PlayerIsClient() || (Level.NetMode == NM_Standalone))\n\t\t\t\t{\n\t\t\t\t\tprevLeanDist = curLeanDist;\n\t\t\t\t\talpha = FClamp(7.0 * DeltaTime, 0.001, 0.9);\n\t\t\t\t\tcurLeanDist *= 1.0 - alpha;\n\t\t\t\t\tif (Abs(curLeanDist) < 1.0)\n\t\t\t\t\t\tcurLeanDist = 0;\n\t\t\t\t}\n\n\t\t\t\tloc = vect(0,0,0);\n\t\t\t\tloc.Y = -(prevLeanDist - curLeanDist);\n\n\t\t\t\t// check to make sure the destination not blocked\n\t\t\t\tcheckpoint = (loc >> Rotation) + Location;\n\t\t\t\ttraceSize.X = CollisionRadius;\n\t\t\t\ttraceSize.Y = CollisionRadius;\n\t\t\t\ttraceSize.Z = CollisionHeight;\n\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, True, traceSize);\n\n\t\t\t\t// check down as well to make sure there's a floor there\n\t\t\t\tdowncheck = checkpoint - vect(0,0,1) * CollisionHeight;\n\t\t\t\tHitActorDown = Trace(HitLocation, HitNormal, downcheck, checkpoint, True, traceSize);\n\t\t\t\tif ((HitActor == None) && (HitActorDown != None))\n\t\t\t\t{\n\t\t\t\t\tif ( PlayerIsClient() || (Level.NetMode == NM_Standalone))\n\t\t\t\t\t{\n\t\t\t\t\t\tSetLocation( checkpoint );\n\t\t\t\t\t\tServerUpdateLean( checkpoint );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\n\t}",
                        "locals": [
                            "local int newSpeed, defSpeed;",
                            "local name mat;",
                            "local vector HitLocation, HitNormal, checkpoint, downcheck;",
                            "local Actor HitActor, HitActorDown;",
                            "local bool bCantStandUp;",
                            "local Vector loc, traceSize;",
                            "local float alpha, maxLeanDist;",
                            "local float legTotal, weapSkill;",
                            "local vector start, checkNorm, Extent;",
                            "local TCControls TCC;"
                        ],
                        "modifiers": [],
                        "name": "ProcessMove",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ],
                            [
                                "vector",
                                "newAccel"
                            ],
                            [
                                "eDodgeDir",
                                "DodgeMove"
                            ],
                            [
                                "rotator",
                                "DeltaRot"
                            ]
                        ],
                        "return": ""
                    },
                    "SetBasedPawnSize": {
                        "body": "{\n\n\tif (newRadius < 0)\n\t\tnewRadius = 0;\n\tif (newHeight < 0)\n\t\tnewHeight = 0;\n\n\toldRadius = CollisionRadius;\n\toldHeight = CollisionHeight;\n\n\tif ( Level.NetMode == NM_Standalone )\n\t{\n\t\tif ((oldRadius == newRadius) && (oldHeight == newHeight))\n\t\t\treturn true;\n\t}\n\n\tcenterDelta    = vect(0, 0, 1)*(newHeight-oldHeight);\n\tdeltaEyeHeight = GetDefaultCollisionHeight() - Default.BaseEyeHeight;\n\n\tif ( Level.NetMode != NM_Standalone )\n\t{\n\t\tif ((oldRadius == newRadius) && (oldHeight == newHeight) && (BaseEyeHeight == newHeight - deltaEyeHeight))\n\t\t\treturn true;\n\t}\n\n\tif (CarriedDecoration != None)\n\t\tsavedDeco = CarriedDecoration;\n\n\tbSuccess = false;\n\tif ((newHeight <= CollisionHeight) && (newRadius <= CollisionRadius))  // shrink\n\t{\n\t\tSetCollisionSize(newRadius, newHeight);\n\t\tif (Move(centerDelta))\n\t\t\tbSuccess = true;\n\t\telse\n\t\t\tSetCollisionSize(oldRadius, oldHeight);\n\t}\n\telse\n\t{\n\t\tif (Move(centerDelta))\n\t\t{\n\t\t\tSetCollisionSize(newRadius, newHeight);\n\t\t\tbSuccess = true;\n\t\t}\n\t}\n\n\tif (bSuccess)\n\t{\n\t\t// make sure we don't lose our carried decoration\n\t\tif (savedDeco != None)\n\t\t{\n\t\t\tsavedDeco.SetPhysics(PHYS_None);\n\t\t\tsavedDeco.SetBase(Self);\n\t\t\tsavedDeco.SetCollision(False, False, False);\n\n\t\t\t// reset the decoration's location\n\t\t\tlookDir = Vector(Rotation);\n\t\t\tlookDir.Z = 0;\t\t\t\t\n\t\t\tupDir = vect(0,0,0);\n\t\t\tupDir.Z = CollisionHeight / 2;\t\t// put it up near eye level\n\t\t\tsavedDeco.SetLocation(Location + upDir + (0.5 * CollisionRadius + CarriedDecoration.CollisionRadius) * lookDir);\n\t\t}\n\n//\t\tPrePivotOffset  = vect(0, 0, 1)*(GetDefaultCollisionHeight()-newHeight);\n\t\tPrePivot        -= centerDelta;\n//\t\tDesiredPrePivot -= centerDelta;\n\t\tBaseEyeHeight   = newHeight - deltaEyeHeight;\n\n\t\tEyeHeight\t\t-= centerDelta.Z;\n\t}\n\treturn (bSuccess);\n}",
                        "locals": [
                            "local float  oldRadius, oldHeight;",
                            "local bool   bSuccess;",
                            "local vector centerDelta, lookDir, upDir;",
                            "local float  deltaEyeHeight;",
                            "local Decoration savedDeco;"
                        ],
                        "modifiers": [],
                        "name": "SetBasedPawnSize",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "newRadius"
                            ],
                            [
                                "float",
                                "newHeight"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ZoneChange": {
                        "body": "{\n\t\t// if we jump into water, empty our hands\n\t\tif (NewZone.bWaterZone)\n\t\t\tDropDecoration();\n\n\t\tSuper.ZoneChange(NewZone);\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ZoneChange",
                        "native": false,
                        "param": [
                            [
                                "ZoneInfo",
                                "NewZone"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 452,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "Toybox.uc": {
            "body": "//=============================================================================\n// yee\n//=============================================================================\nclass Toybox expands TCDeathmatch;\n\nevent PlayerPawn Login (string Portal, string Z56, out string Z57, Class<PlayerPawn> SpawnClass)\n{\n\tlocal TCPlayer Z5B;\n\tlocal string Z68;\n\tlocal string Z69;\n\tlocal int Z6A;\n\tlocal string myString;\n\tlocal class<scriptedpawn> spawn;\n\tlocal int j,p;\n\t\n\tif ( (MaxPlayers > 0) && (NumPlayers >= MaxPlayers) )\n\t{\n\t\tZ57=TooManyPlayers;\n\t\treturn None;\n\t}\n\tSpawnClass=DefaultPlayerClass;\n\tZ68=ParseOption(Z56,\"Class\");\n\tZ6A=InStr(Z68,\".\");\n\tif ( Z6A != -1 )\n\t{\n\t\tZ69=Mid(Z68,Z6A + 1);\n\t\tZ68=Left(Z68,Z6A);\n\t} else {\n\t\tZ69=Z68;\n\t\tZ68=\"\";\n\t}\n\n\tSpawnClass=Class'ToyMC';\n\t\n\tChangeOption(Z56,\"Class\",string(SpawnClass));\n\tZ5B=TCPlayer(Super.Login(Portal,Z56,Z57,SpawnClass));\n\tif ( Z5B != None )\n\t{\n\t\tZ5B.V52(Z5B.PlayerReplicationInfo.PlayerName);\n\t}\n\t\n\t\tj=Rand(10);\n\t\tZ5B.Mesh = PSKIN[j].default.Mesh;\n\t\tZ5B.DrawScale = 0.18;\n\t\tfor (p = 0; p < 8; p++)\n\t\t{\n\t\t\tZ5B.MultiSkins[p] = PSKIN[j].default.MultiSkins[p];\n\t\t}\n\t\t\t\n\treturn Z5B;\n}\n\ndefaultproperties\n{\n\tbToybox=True\n    DefaultPlayerClass=Class'ToyMC'\n    GameReplicationInfoClass=Class'TCGRI'\n}\n",
            "name": "Toybox.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bToybox=True",
                    "DefaultPlayerClass=Class'ToyMC'",
                    "GameReplicationInfoClass=Class'TCGRI'"
                ],
                "exec": [],
                "extends": "TCDeathmatch",
                "functions": {
                    "Login": {
                        "body": "{\n\t\n\tif ( (MaxPlayers > 0) && (NumPlayers >= MaxPlayers) )\n\t{\n\t\tZ57=TooManyPlayers;\n\t\treturn None;\n\t}\n\tSpawnClass=DefaultPlayerClass;\n\tZ68=ParseOption(Z56,\"Class\");\n\tZ6A=InStr(Z68,\".\");\n\tif ( Z6A != -1 )\n\t{\n\t\tZ69=Mid(Z68,Z6A + 1);\n\t\tZ68=Left(Z68,Z6A);\n\t} else {\n\t\tZ69=Z68;\n\t\tZ68=\"\";\n\t}",
                        "locals": [
                            "local TCPlayer Z5B;",
                            "local string Z68;",
                            "local string Z69;",
                            "local int Z6A;",
                            "local string myString;",
                            "local class<scriptedpawn> spawn;",
                            "local int j,p;"
                        ],
                        "modifiers": [],
                        "name": "Login",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Portal"
                            ],
                            [
                                "string",
                                "Z56"
                            ],
                            [
                                "out",
                                "string",
                                "Z57"
                            ],
                            [
                                "Class<PlayerPawn>",
                                "SpawnClass"
                            ]
                        ],
                        "return": "PlayerPawn"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 59,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "_TCTimer.uc": {
            "body": "//================================================================================\n// Based on ANNA's Timer system\n//================================================================================\nclass _TCTimer extends Actor;\n\nvar vector iLoc;\nvar Rotator iRot;\nvar int cMins;\nvar int cSecs;\n\nfunction TCControls GetControls()\n{\n\tlocal TCControls TCC;\n\t\n\t//if(Role < ROLE_Authority)\n\t//{\n\t\tif(TCDeathmatch(Level.Game) != None) TCC = TCDeathMatch(Level.Game).Settings;\n\t\tif(TCTeam(Level.Game) != None) TCC = TCTeam(Level.Game).Settings;\n\t\t\n\t\treturn TCC;\n\t//}\n}\n\n\nfunction PostBeginPlay()\n{\n\tlocal TCControls TCGet;\n\n\tTCGet = GetControls();\n\tif(TCGet.AutoIdleTime > 0)\n\t\tSetTimer(1,True);\n}\n\nsimulated function Tick(float deltaTime)\n{\n    if(TCPlayer(Owner) == none)\n    {\n        destroy();\n        return;\n    }\n\n    TCPlayer(Owner)._timerSeconds += deltaTime;\n}\n\nfunction Timer()\n{\n\tlocal bool bAutoIdle, bAutoIdleKick;\n\tlocal bool bMinutePassed;\n\t\n\tcSecs++;\n\tif(cSecs == 60)\n\t{\n\t\tbMinutePassed=True;\n\t\tcSecs = 0;\n\t}\n\t\n\tif(GetControls().AutoIdleTime > 0)\n\t\tbAutoIdle=True;\n\t\t\n\tif(GetControls().AutoIdleKickTime > 0)\n\t\tbAutoIdleKick=True;\n\t\t\n\tif(TCPlayer(Owner).Location == iLoc && TCPlayer(Owner).ViewRotation == iRot)\n\t{\n\t\tif(bMinutePassed)\n\t\t\tTCPlayer(Owner).IdleCounter++;\n\t}\n\telse\n\t{\n\t\tif(TCPlayer(Owner).bAway)\n\t\t{\n\t\t\tTCPlayer(Owner).bAway=False;\n\t\t\tTCPRI(TCPlayer(Owner).PlayerReplicationInfo).bAway=False;\n\t\t\tGetControls().Print(TCPlayer(Owner).PlayerReplicationInfo.PlayerName$\" has returned.\");\n\t\t}\n\t\tiLoc = TCPlayer(Owner).Location;\n\t\tiRot = TCPlayer(Owner).ViewRotation;\n\t\tTCPlayer(Owner).IdleCounter=0;\n\t}\n\t\n\tif(TCPlayer(Owner).IsInState('Dying'))\n\t\tTCPRI(TCPlayer(Owner).PlayerReplicationInfo).bDead=True;\n\telse TCPRI(TCPlayer(Owner).PlayerReplicationInfo).bDead=False;\n\t\n\tif(bAutoIdle && TCPlayer(Owner).IdleCounter >= GetControls().AutoIdleTime && !TCPRI(TCPlayer(Owner).PlayerReplicationInfo).bAway)\n\t{\n\t\tTCPlayer(Owner).bAway=True;\n\t\tTCPRI(TCPlayer(Owner).PlayerReplicationInfo).bAway=True;\n\t\tGetControls().Print(TCPlayer(Owner).PlayerReplicationInfo.PlayerName$\" was idle for \"$GetControls().AutoIdleTime$\" minutes and has been set as AWAY.\");\n\t}\n\tif(bAutoIdleKick && TCPlayer(Owner).IdleCounter >= GetControls().AutoIdleKickTime && TCPRI(TCPlayer(Owner).PlayerReplicationInfo).bAway)\n\t{\n\t\tGetControls().Print(TCPlayer(Owner).PlayerReplicationInfo.PlayerName$\" was idle for \"$GetControls().AutoIdleKickTime$\" minutes and removed from the game.\");\n\t\tTCPlayer(Owner).Destroy();\n\t}\n}\n\ndefaultproperties\n{\n    bHidden=true\n}\n",
            "name": "_TCTimer.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=true"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "GetControls": {
                        "body": "{\n\t\n\t//if(Role < ROLE_Authority)\n\t//{\n\t\tif(TCDeathmatch(Level.Game) != None) TCC = TCDeathMatch(Level.Game).Settings;\n\t\tif(TCTeam(Level.Game) != None) TCC = TCTeam(Level.Game).Settings;\n\t\t\n\t\treturn TCC;\n\t//}",
                        "locals": [
                            "local TCControls TCC;"
                        ],
                        "modifiers": [],
                        "name": "GetControls",
                        "native": false,
                        "param": [],
                        "return": "TCControls"
                    },
                    "PostBeginPlay": {
                        "body": "{\n\n\tTCGet = GetControls();\n\tif(TCGet.AutoIdleTime > 0)\n\t\tSetTimer(1,True);\n}",
                        "locals": [
                            "local TCControls TCGet;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n    if(TCPlayer(Owner) == none)\n    {\n        destroy();\n        return;\n    }\n\n    TCPlayer(Owner)._timerSeconds += deltaTime;\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "deltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\t\n\tcSecs++;\n\tif(cSecs == 60)\n\t{\n\t\tbMinutePassed=True;\n\t\tcSecs = 0;\n\t}\n\t\n\tif(GetControls().AutoIdleTime > 0)\n\t\tbAutoIdle=True;\n\t\t\n\tif(GetControls().AutoIdleKickTime > 0)\n\t\tbAutoIdleKick=True;\n\t\t\n\tif(TCPlayer(Owner).Location == iLoc && TCPlayer(Owner).ViewRotation == iRot)\n\t{\n\t\tif(bMinutePassed)\n\t\t\tTCPlayer(Owner).IdleCounter++;\n\t}\n\telse\n\t{\n\t\tif(TCPlayer(Owner).bAway)\n\t\t{\n\t\t\tTCPlayer(Owner).bAway=False;\n\t\t\tTCPRI(TCPlayer(Owner).PlayerReplicationInfo).bAway=False;\n\t\t\tGetControls().Print(TCPlayer(Owner).PlayerReplicationInfo.PlayerName$\" has returned.\");\n\t\t}\n\t\tiLoc = TCPlayer(Owner).Location;\n\t\tiRot = TCPlayer(Owner).ViewRotation;\n\t\tTCPlayer(Owner).IdleCounter=0;\n\t}\n\t\n\tif(TCPlayer(Owner).IsInState('Dying'))\n\t\tTCPRI(TCPlayer(Owner).PlayerReplicationInfo).bDead=True;\n\telse TCPRI(TCPlayer(Owner).PlayerReplicationInfo).bDead=False;\n\t\n\tif(bAutoIdle && TCPlayer(Owner).IdleCounter >= GetControls().AutoIdleTime && !TCPRI(TCPlayer(Owner).PlayerReplicationInfo).bAway)\n\t{\n\t\tTCPlayer(Owner).bAway=True;\n\t\tTCPRI(TCPlayer(Owner).PlayerReplicationInfo).bAway=True;\n\t\tGetControls().Print(TCPlayer(Owner).PlayerReplicationInfo.PlayerName$\" was idle for \"$GetControls().AutoIdleTime$\" minutes and has been set as AWAY.\");\n\t}\n\tif(bAutoIdleKick && TCPlayer(Owner).IdleCounter >= GetControls().AutoIdleKickTime && TCPRI(TCPlayer(Owner).PlayerReplicationInfo).bAway)\n\t{\n\t\tGetControls().Print(TCPlayer(Owner).PlayerReplicationInfo.PlayerName$\" was idle for \"$GetControls().AutoIdleKickTime$\" minutes and removed from the game.\");\n\t\tTCPlayer(Owner).Destroy();\n\t}\n}",
                        "locals": [
                            "local bool bAutoIdle, bAutoIdleKick;",
                            "local bool bMinutePassed;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 102,
                "replication": "",
                "states": [],
                "variables": [
                    "var vector iLoc;",
                    "var Rotator iRot;",
                    "var int cMins;",
                    "var int cSecs;"
                ]
            }
        },
        "wpDummy.uc": {
            "body": "//=============================================================================\n// Way around the relevancy issue...\n//=============================================================================\nclass wpDummy extends Actor;\n\nvar string wpName;\nvar Actor wpActor;\nvar bool bCanDelete;\n\nfunction PostBeginPlay()\n{\n\tSetTimer(0.5,True);\n}\n\nfunction Timer()\n{\n\tlocal TCPlayer TCP;\n\tlocal bool bFound;\n\tlocal vector modv;\n\t\n\tif(bCanDelete)\n\t\tif(wpActor == None)\n\t\t\tDestroy();\n\t\n\tif(wpActor != None)\n\t{\n\t\tmodv = wpActor.location;\n\t\tif(pawn(wpActor) != None)\n\t\t{\n\t\t\tmodv.z += 20;\n\t\t}\n\t\t\n\t\tforeach Allactors(class'TCPlayer', TCP)\n\t\t\tif(TCPRI(TCP.PlayerReplicationInfo).wpTargetPRI == Self)\n\t\t\t\tbFound=True;\n\t\t\t\t\n\t\tif(bFound && wpActor != None)\n\t\t\tSetLocation(modv);\n\t\t\n\t\tif(!bFound)\n\t\t\tDestroy();\n\t}\n}\n\ndefaultproperties\n{\n\tTag='Waypoint'\n\tbHidden=True\n\tbAlwaysRelevant=True\n}\n",
            "name": "wpDummy.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Tag='Waypoint'",
                    "bHidden=True",
                    "bAlwaysRelevant=True"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "PostBeginPlay": {
                        "body": "{\n\tSetTimer(0.5,True);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\t\n\tif(bCanDelete)\n\t\tif(wpActor == None)\n\t\t\tDestroy();\n\t\n\tif(wpActor != None)\n\t{\n\t\tmodv = wpActor.location;\n\t\tif(pawn(wpActor) != None)\n\t\t{\n\t\t\tmodv.z += 20;\n\t\t}\n\t\t\n\t\tforeach Allactors(class'TCPlayer', TCP)\n\t\t\tif(TCPRI(TCP.PlayerReplicationInfo).wpTargetPRI == Self)\n\t\t\t\tbFound=True;\n\t\t\t\t\n\t\tif(bFound && wpActor != None)\n\t\t\tSetLocation(modv);\n\t\t\n\t\tif(!bFound)\n\t\t\tDestroy();\n\t}\n}",
                        "locals": [
                            "local TCPlayer TCP;",
                            "local bool bFound;",
                            "local vector modv;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 51,
                "replication": "",
                "states": [],
                "variables": [
                    "var string wpName;",
                    "var Actor wpActor;",
                    "var bool bCanDelete;"
                ]
            }
        }
    },
    "models": {},
    "sounds": {},
    "textures": {}
}