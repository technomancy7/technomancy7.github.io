{
    "classes": {
        "Actor.uc": {
            "body": "//=============================================================================\n// Actor: The base class of all actors.\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass Actor extends Object\n\tabstract\n\tnative\n\tnativereplication;\n\n// Imported data (during full rebuild).\n#exec Texture Import File=Textures\\S_Actor.pcx Name=S_Actor Mips=Off Flags=2\n\n// DEUS_EX STM\nenum EAIEventState\n{\n\tEAISTATE_Begin,\n\tEAISTATE_End,\n\tEAISTATE_Pulse,\n\tEAISTATE_ChangeBest\n};\nenum EAIEventType\n{\n\tEAITYPE_Visual,\n\tEAITYPE_Audio,\n\tEAITYPE_Olifactory\n};\nstruct XAIParams\n{\n\tvar actor BestActor;\n\tvar float Score;\n\tvar float Visibility;\n\tvar float Volume;\n\tvar float Smell;\n};\n\n// DEUS_EX AJY \nenum EBarkModes \n{\n\tBM_Idle,\n\tBM_CriticalDamage,\n\tBM_AreaSecure,\n\tBM_TargetAcquired,\n\tBM_TargetLost,\n\tBM_GoingForAlarm,\n\tBM_OutOfAmmo,\n\tBM_Scanning,\n\tBM_Futz,\n\tBM_OnFire,\n\tBM_TearGas,\n\tBM_Gore,\n\tBM_Surprise,\n\tBM_PreAttackSearching,\n\tBM_PreAttackSighting,\n\tBM_PostAttackSearching,\n\tBM_SearchGiveUp,\n\tBM_AllianceHostile,\n\tBM_AllianceFriendly\n};\n\n// Flags.\nvar(Advanced) const bool  bStatic;       // Does not move or change over time.\nvar(Advanced) bool        bHidden;       // Is hidden during gameplay.\nvar(Advanced) const bool  bNoDelete;     // Cannot be deleted during play.\nvar bool\t\t\t\t  bAnimFinished; // Unlooped animation sequence has finished.\nvar bool\t\t\t\t  bAnimLoop;     // Whether animation is looping.\nvar bool\t\t\t\t  bAnimNotify;   // Whether a notify is applied to the current sequence.\nvar bool\t\t\t\t  bAnimByOwner;\t // Animation dictated by owner.\nvar const bool            bDeleteMe;     // About to be deleted.\nvar transient const bool  bAssimilated;  // Actor dynamics are assimilated in world geometry.\nvar transient const bool  bTicked;       // Actor has been updated.\nvar transient bool        bLightChanged; // Recalculate this light's lighting now.\nvar bool                  bDynamicLight; // Temporarily treat this as a dynamic light.\nvar bool                  bTimerLoop;    // Timer loops (else is one-shot).\n\n// Other flags.\nvar(Advanced) bool        bCanTeleport;  // This actor can be teleported.\nvar(Advanced) bool        bIsSecretGoal; // This actor counts in the \"secret\" total.\nvar(Advanced) bool        bIsKillGoal;   // This actor counts in the \"death\" toll.\nvar(Advanced) bool        bIsItemGoal;   // This actor counts in the \"item\" count.\nvar(Advanced) bool\t\t  bCollideWhenPlacing; // This actor collides with the world when placing.\nvar(Advanced) bool\t\t  bTravel;       // Actor is capable of travelling among servers.\nvar(Advanced) bool\t\t  bMovable;      // Actor is capable of travelling among servers.\nvar(Advanced) bool        bHighDetail;\t // Only show up on high-detail.\nvar(Advanced) bool\t\t  bStasis;\t\t // In StandAlone games, turn off if not in a recently rendered zone turned off if  bCanStasis  and physics = PHYS_None or PHYS_Rotating.\nvar(Advanced) bool\t\t  bForceStasis;\t // Force stasis when not recently rendered, even if physics not none or rotating.\nvar const\t  bool\t\t  bIsPawn;\t\t // True only for pawns.\nvar(Advanced) const bool  bNetTemporary; // Tear-off simulation in network play.\nvar(Advanced) const bool  bNetOptional;  // Actor should only be replicated if bandwidth available.\nvar\t\t\t  bool\t\t  bReplicateInstigator;\t// Replicate instigator to client (used by bNetTemporary projectiles).\nvar\t\t\t  bool\t\t  bTrailerSameRotation;\t// If PHYS_Trailer and true, have same rotation as owner.\nvar\t\t\t  bool\t\t  bTrailerPrePivot;\t// If PHYS_Trailer and true, offset from owner by PrePivot.\nvar\t\t\t  bool\t\t  bClientAnim;\nvar\t\t\t  bool\t\t  bSimFall;\t\t\t// dumb proxy should simulate fall\n\n// DEUS_EX STM - added new flags\nvar(Advanced) bool        bBlockSight;   // True if pawns can't see through this actor.\nvar(Advanced) bool        bDetectable;   // True if this actor can be detected (by sight, sound, etc).\nvar(Advanced) bool        bTransient;    // True if this actor should be destroyed when it goes into stasis\nvar           bool        bIgnore;       // True if this actor should be generally ignored; compliance is voluntary\n\n// Priority Parameters\n// Actor's current physics mode.\nvar(Movement) const enum EPhysics\n{\n\tPHYS_None,\n\tPHYS_Walking,\n\tPHYS_Falling,\n\tPHYS_Swimming,\n\tPHYS_Flying,\n\tPHYS_Rotating,\n\tPHYS_Projectile,\n\tPHYS_Rolling,\n\tPHYS_Interpolating,\n\tPHYS_MovingBrush,\n\tPHYS_Spider,\n\tPHYS_Trailer\n} Physics;\n\n// Net variables.\nenum ENetRole\n{\n\tROLE_None,              // No role at all.\n\tROLE_DumbProxy,\t\t\t// Dumb proxy of this actor.\n\tROLE_SimulatedProxy,\t// Locally simulated proxy of this actor.\n\tROLE_AutonomousProxy,\t// Locally autonomous proxy of this actor.\n\tROLE_Authority,\t\t\t// Authoritative control over the actor.\n};\nvar ENetRole Role;\nvar(Networking) ENetRole RemoteRole;\n\n// DEUS_EX STM - added for stasis\nvar float LastRenderTime;\nvar float DistanceFromPlayer;\n\n// Owner.\nvar         const Actor   Owner;         // Owner actor.\nvar(Object) name InitialState;\nvar(Object) name Group;\n\n// Execution and timer variables.\nvar float                 TimerRate;     // Timer event, 0=no timer.\nvar const float           TimerCounter;\t // Counts up until it reaches TimerRate.\nvar(Advanced) float\t\t  LifeSpan;      // How old the object lives before dying, 0=forever.\n\n// Animation variables.\nvar(Display) name         AnimSequence;  // Animation sequence we're playing.\nvar(Display) float        AnimFrame;     // Current animation frame, 0.0 to 1.0.\nvar(Display) float        AnimRate;      // Animation rate in frames per second, 0=none, negative=velocity scaled.\nvar          float        TweenRate;     // Tween-into rate.\n\nvar(Display) float\t\t  LODBias;\n\n// Blending animation variables - DEUS_EX CNN\nvar name\tBlendAnimSequence[4];\nvar float\tBlendAnimFrame[4];\nvar float\tBlendAnimRate[4];\nvar float\tBlendTweenRate[4];\n\n//-----------------------------------------------------------------------------\n// Structures.\n\n// Identifies a unique convex volume in the world.\nstruct PointRegion\n{\n\tvar zoneinfo Zone;       // Zone.\n\tvar int      iLeaf;      // Bsp leaf.\n\tvar byte     ZoneNumber; // Zone number.\n};\n\n//-----------------------------------------------------------------------------\n// Major actor properties.\n\n// Scriptable.\nvar       const LevelInfo Level;         // Level this actor is on.\nvar transient const Level XLevel;        // Level object.\nvar(Events) name\t\t  Tag;\t\t\t // Actor's tag name.\nvar(Events) name          Event;         // The event this actor causes.\nvar Actor                 Target;        // Actor we're aiming at (other uses as well).\nvar Pawn                  Instigator;    // Pawn responsible for damage.\nvar travel Inventory      Inventory;     // Inventory chain.  (DEUS_EX STM - added \"travel\")\nvar const Actor           Base;          // Moving brush actor we're standing on.\nvar const PointRegion     Region;        // Region this actor is in.\nvar(Movement)\tname\t  AttachTag;\n\n// Internal.\nvar const byte            StandingCount; // Count of actors standing on this actor.\nvar const byte            MiscNumber;    // Internal use.\nvar const byte            LatentByte;    // Internal latent function use.\nvar const int             LatentInt;     // Internal latent function use.\nvar const float           LatentFloat;   // Internal latent function use.\nvar const actor           LatentActor;   // Internal latent function use.\nvar const actor           Touching[4];   // List of touching actors.\nvar const actor           Deleted;       // Next actor in just-deleted chain.\n\n// Internal tags.\nvar const transient int CollisionTag, LightingTag, NetTag, OtherTag, ExtraTag, SpecialTag;\n\n// The actor's position and rotation.\nvar(Movement) const vector Location;     // Actor's location; use Move to set.\nvar(Movement) const rotator Rotation;    // Rotation.\nvar       const vector    OldLocation;   // Actor's old location one tick ago.\nvar       const vector    ColLocation;   // Actor's old location one move ago.\nvar(Movement) vector      Velocity;      // Velocity.\nvar       vector          Acceleration;  // Acceleration.\n\n//Editing flags\nvar(Advanced) bool        bHiddenEd;     // Is hidden during editing.\nvar(Advanced) bool        bDirectional;  // Actor shows direction arrow during editing.\nvar const bool            bSelected;     // Selected in UnrealEd.\nvar const bool            bMemorized;    // Remembered in UnrealEd.\nvar const bool            bHighlighted;  // Highlighted in UnrealEd.\nvar bool                  bEdLocked;     // Locked in editor (no movement or rotation).\nvar(Advanced) bool        bEdShouldSnap; // Snap to grid in editor.\nvar transient bool        bEdSnap;       // Should snap to grid in UnrealEd.\nvar transient const bool  bTempEditor;   // Internal UnrealEd.\n\n// What kind of gameplay scenarios to appear in.\nvar(Filter) bool          bDifficulty0;  // Appear in difficulty 0.\nvar(Filter) bool          bDifficulty1;  // Appear in difficulty 1.\nvar(Filter) bool          bDifficulty2;  // Appear in difficulty 2.\nvar(Filter) bool          bDifficulty3;  // Appear in difficulty 3.\nvar(Filter) bool          bSinglePlayer; // Appear in single player.\nvar(Filter) bool          bNet;          // Appear in regular network play.\nvar(Filter) bool          bNetSpecial;   // Appear in special network play mode.\nvar(Filter) float\t\t  OddsOfAppearing; // 0-1 - chance actor will appear in relevant game modes.\n\n//-----------------------------------------------------------------------------\n// Display properties.\n\n// Drawing effect.\nvar(Display) enum EDrawType\n{\n\tDT_None,\n\tDT_Sprite,\n\tDT_Mesh,\n\tDT_Brush,\n\tDT_RopeSprite,\n\tDT_VerticalSprite,\n\tDT_Terraform,\n\tDT_SpriteAnimOnce,\n} DrawType;\n\n// Style for rendering sprites, meshes.\nvar(Display) enum ERenderStyle\n{\n\tSTY_None,\n\tSTY_Normal,\n\tSTY_Masked,\n\tSTY_Translucent,\n\tSTY_Modulated,\n} Style;\n\n// Other display properties.\nvar(Display) texture    Sprite;\t\t\t // Sprite texture if DrawType=DT_Sprite.\nvar(Display) texture    Texture;\t\t // Misc texture.\nvar(Display) texture    Skin;            // Special skin or enviro map texture.\nvar(Display) mesh       Mesh;            // Mesh if DrawType=DT_Mesh.\nvar const export model  Brush;           // Brush if DrawType=DT_Brush.\nvar(Display) float      DrawScale;\t\t // Scaling factor, 1.0=normal size.\nvar\t\t\t vector\t\tPrePivot;\t\t // Offset from box center for drawing.\nvar(Display) float      ScaleGlow;\t\t // Multiplies lighting.\nvar(Display) byte       AmbientGlow;     // Ambient brightness, or 255=pulsing.\nvar(Display) byte       Fatness;         // Fatness (mesh distortion).\n\n// Display.\nvar(Display)  bool      bUnlit;          // Lights don't affect actor.\nvar(Display)  bool      bNoSmooth;       // Don't smooth actor's texture.\nvar(Display)  bool      bParticles;      // Mesh is a particle system.\nvar(Display)  bool      bRandomFrame;    // Particles use a random texture from among the default texture and the multiskins textures\nvar(Display)  bool      bMeshEnviroMap;  // Environment-map the mesh.\nvar(Display)  bool      bMeshCurvy;      // Curvy mesh.\nvar(Display)  float     VisibilityRadius;// Actor is drawn if viewer is within its visibility\nvar(Display)  float     VisibilityHeight;// cylinder.  Zero=infinite visibility.\n\n// Not yet implemented.\nvar(Display) bool       bShadowCast;     // Casts shadows.\n\n// Advanced.\nvar(Advanced) bool\t\tbOwnerNoSee;\t // Everything but the owner can see this actor.\nvar(Advanced) bool      bOnlyOwnerSee;   // Only owner can see this actor.\nvar Const     bool\t\tbIsMover;\t\t // Is a mover.\nvar(Advanced) bool\t\tbAlwaysRelevant; // Always relevant for network.\nvar Const\t  bool\t\tbAlwaysTick;     // Update even when players-only.\nvar\t\t\t  bool\t\tbHurtEntry;\t     // keep HurtRadius from being reentrant\nvar(Advanced) bool\t\tbGameRelevant;\t // Always relevant for game\nvar\t\t\t  bool\t\tbCarriedItem;\t // being carried, and not responsible for displaying self, so don't replicated location and rotation\nvar\t\t\t  bool\t\tbForcePhysicsUpdate; // force a physics update for simulated pawns\n\n\n// Multiple skin support.\nvar(Display) texture MultiSkins[8];\n\n//-----------------------------------------------------------------------------\n// Sound.\n\n// Ambient sound.\nvar(Sound) byte         SoundRadius;\t // Radius of ambient sound.\nvar(Sound) byte         SoundVolume;\t // Volume of amient sound.\nvar(Sound) byte         SoundPitch;\t     // Sound pitch shift, 64.0=none.\nvar(Sound) sound        AmbientSound;    // Ambient sound effect.\n\n// Regular sounds.\nvar(Sound) float TransientSoundVolume;\nvar(Sound) float TransientSoundRadius;\n\n// Sound slots for actors.\nenum ESoundSlot\n{\n\tSLOT_None,\n\tSLOT_Misc,\n\tSLOT_Pain,\n\tSLOT_Interact,\n\tSLOT_Ambient,\n\tSLOT_Talk,\n\tSLOT_Interface,\n};\n\n// Music transitions.\nenum EMusicTransition\n{\n\tMTRAN_None,\n\tMTRAN_Instant,\n\tMTRAN_Segue,\n\tMTRAN_Fade,\n\tMTRAN_FastFade,\n\tMTRAN_SlowFade,\n};\n\n//-----------------------------------------------------------------------------\n// Collision.\n\n// Collision size.\nvar(Collision) const float CollisionRadius; // Radius of collision cyllinder.\nvar(Collision) const float CollisionHeight; // Half-height cyllinder.\n\n// Collision flags.\nvar(Collision) const bool bCollideActors;   // Collides with other actors.\nvar(Collision) bool       bCollideWorld;    // Collides with the world.\nvar(Collision) bool       bBlockActors;\t    // Blocks other nonplayer actors.\nvar(Collision) bool       bBlockPlayers;    // Blocks other player actors.\nvar(Collision) bool       bProjTarget;      // Projectiles should potentially target this actor.\n\n//-----------------------------------------------------------------------------\n// Lighting.\n\n// Light modulation.\nvar(Lighting) enum ELightType\n{\n\tLT_None,\n\tLT_Steady,\n\tLT_Pulse,\n\tLT_Blink,\n\tLT_Flicker,\n\tLT_Strobe,\n\tLT_BackdropLight,\n\tLT_SubtlePulse,\n\tLT_TexturePaletteOnce,\n\tLT_TexturePaletteLoop\n} LightType;\n\n// Spatial light effect to use.\nvar(Lighting) enum ELightEffect\n{\n\tLE_None,\n\tLE_TorchWaver,\n\tLE_FireWaver,\n\tLE_WateryShimmer,\n\tLE_Searchlight,\n\tLE_SlowWave,\n\tLE_FastWave,\n\tLE_CloudCast,\n\tLE_StaticSpot,\n\tLE_Shock,\n\tLE_Disco,\n\tLE_Warp,\n\tLE_Spotlight,\n\tLE_NonIncidence,\n\tLE_Shell,\n\tLE_OmniBumpMap,\n\tLE_Interference,\n\tLE_Cylinder,\n\tLE_Rotor,\n\tLE_Unused\n} LightEffect;\n\n// Lighting info.\nvar(LightColor) byte\n\tLightBrightness,\n\tLightHue,\n\tLightSaturation;\n\n// Light properties.\nvar(Lighting) byte\n\tLightRadius,\n\tLightPeriod,\n\tLightPhase,\n\tLightCone,\n\tVolumeBrightness,\n\tVolumeRadius,\n\tVolumeFog;\n\n// Lighting.\nvar(Lighting) bool\t     bSpecialLit;\t // Only affects special-lit surfaces.\nvar(Lighting) bool\t     bActorShadows;  // Light casts actor shadows.\nvar(Lighting) bool\t     bCorona;        // Light uses Skin as a corona.\nvar(Lighting) bool\t     bLensFlare;     // Whether to use zone lens flare.\n\n//-----------------------------------------------------------------------------\n// Physics.\n\n// Options.\nvar(Movement) bool        bBounce;           // Bounces when hits ground fast.\nvar(Movement) bool\t\t  bFixedRotationDir; // Fixed direction of rotation.\nvar(Movement) bool\t\t  bRotateToDesired;  // Rotate to DesiredRotation.\nvar           bool        bInterpolating;    // Performing interpolating.\nvar\t\t\t  const bool  bJustTeleported;   // Used by engine physics - not valid for scripts.\n\n// Dodge move direction.\nvar enum EDodgeDir\n{\n\tDODGE_None,\n\tDODGE_Left,\n\tDODGE_Right,\n\tDODGE_Forward,\n\tDODGE_Back,\n\tDODGE_Active,\n\tDODGE_Done\n} DodgeDir;\n\n// Physics properties.\nvar(Movement) float       Mass;            // Mass of this actor.\nvar(Movement) float       Buoyancy;        // Water buoyancy.\nvar(Movement) rotator\t  RotationRate;    // Change in rotation per second.\nvar(Movement) rotator     DesiredRotation; // Physics will rotate pawn to this if bRotateToDesired.\nvar           float       PhysAlpha;       // Interpolating position, 0.0-1.0.\nvar           float       PhysRate;        // Interpolation rate per second.\nvar\t\t\t  Actor\t\t  PendingTouch;\t\t// Actor touched during move which wants to add an effect after the movement completes \n//-----------------------------------------------------------------------------\n// Animation.\n\n// Animation control.\nvar          float        AnimLast;        // Last frame.\nvar          float        AnimMinRate;     // Minimum rate for velocity-scaled animation.\nvar\t\t\t float\t\t  OldAnimRate;\t   // Animation rate of previous animation (= AnimRate until animation completes).\nvar\t\t\t plane\t\t  SimAnim;\t\t   // replicated to simulated proxies.\n\n// Blending Animation control - DEUS_EX CNN\nvar          float        BlendAnimLast[4];        // Last frame.\nvar          float        BlendAnimMinRate[4];     // Minimum rate for velocity-scaled animation.\nvar\t\t\t float\t\t  OldBlendAnimRate[4];\t   // Animation rate of previous animation (= AnimRate until animation completes).\nvar\t\t\t plane\t\t  SimBlendAnim[4];\t\t   // replicated to simulated proxies.\n\n// Conversation Related Variables - DEUS_EX AJY\nvar(Conversation) String BindName;\t\t\t\t\t// Used to bind conversations\nvar(Conversation) String BarkBindName;\t\t\t\t// Used to bind Barks!\nvar(Conversation) localized String FamiliarName;\t// For display in Conversations\nvar(Conversation) localized String UnfamiliarName;\t// For display in Conversations\nvar transient Object     ConListItems;\t\t\t\t// List of ConListItems for this Actor\nvar\ttravel   float       LastConEndTime;\t\t\t// Time when last conversation ended\nvar(Conversation) float  ConStartInterval;\t\t\t// Amount of time required between two convos.\n\n// Additional variables for AI - DEUS_EX STM\nvar\t\t\t float\t\t  VisUpdateTime;\nvar\t\t\t float\t\t  CurrentVisibility;\nvar\t\t\t float\t\t  LastVisibility;\n\nvar(Smell)   class<SmellNode> SmellClass;\nvar          SmellNode        LastSmellNode;\n\nvar(Advanced) bool            bOwned;\n// End additional variables - DEUS_EX STM\n\n// DEUS_EX AMSD Added to make vision aug run faster.  If true, the vision aug needs to check this object more closely.\n// Used for heat sources as well as things that blind.\nvar bool bVisionImportant;\n\n//-----------------------------------------------------------------------------\n// Networking.\n\n// Network control.\nvar(Networking) float NetPriority; // Higher priorities means update it more frequently.\nvar(Networking) float NetUpdateFrequency; // How many seconds between net updates.\nvar(Networking) float RelevantRadius; //Radius in which things are always relevant.\n\n// Symmetric network flags, valid during replication only.\nvar const bool bNetInitial;       // Initial network update.\nvar const bool bNetOwner;         // Player owns this actor.\nvar const bool bNetRelevant;      // Actor is currently relevant. Only valid server side, only when replicating variables.\nvar const bool bNetSee;           // Player sees it in network play.\nvar const bool bNetHear;          // Player hears it in network play.\nvar const bool bNetFeel;          // Player collides with/feels it in network play.\nvar const bool bSimulatedPawn;\t  // True if Pawn and simulated proxy.\nvar const bool bDemoRecording;\t  // True we are currently demo recording\nvar const bool bClientDemoRecording;// True we are currently recording a client-side demo\nvar const bool bClientDemoNetFunc;// True if we're client-side demo recording and this call originated from the remote.\n\n\n//-----------------------------------------------------------------------------\n// Enums.\n\n// Travelling from server to server.\nenum ETravelType\n{\n\tTRAVEL_Absolute,\t// Absolute URL.\n\tTRAVEL_Partial,\t\t// Partial (carry name, reset server).\n\tTRAVEL_Relative,\t// Relative URL.\n};\n\n// Input system states.\nenum EInputAction\n{\n\tIST_None,    // Not performing special input processing.\n\tIST_Press,   // Handling a keypress or button press.\n\tIST_Hold,    // Handling holding a key or button.\n\tIST_Release, // Handling a key or button release.\n\tIST_Axis,    // Handling analog axis movement.\n};\n\n// Input keys.\nenum EInputKey\n{\n/*00*/\tIK_None\t\t\t,IK_LeftMouse\t,IK_RightMouse\t,IK_Cancel\t\t,\n/*04*/\tIK_MiddleMouse\t,IK_Unknown05\t,IK_Unknown06\t,IK_Unknown07\t,\n/*08*/\tIK_Backspace\t,IK_Tab         ,IK_Unknown0A\t,IK_Unknown0B\t,\n/*0C*/\tIK_Unknown0C\t,IK_Enter\t    ,IK_Unknown0E\t,IK_Unknown0F\t,\n/*10*/\tIK_Shift\t\t,IK_Ctrl\t    ,IK_Alt\t\t\t,IK_Pause       ,\n/*14*/\tIK_CapsLock\t\t,IK_Unknown15\t,IK_Unknown16\t,IK_Unknown17\t,\n/*18*/\tIK_Unknown18\t,IK_Unknown19\t,IK_Unknown1A\t,IK_Escape\t\t,\n/*1C*/\tIK_Unknown1C\t,IK_Unknown1D\t,IK_Unknown1E\t,IK_Unknown1F\t,\n/*20*/\tIK_Space\t\t,IK_PageUp      ,IK_PageDown    ,IK_End         ,\n/*24*/\tIK_Home\t\t\t,IK_Left        ,IK_Up          ,IK_Right       ,\n/*28*/\tIK_Down\t\t\t,IK_Select      ,IK_Print       ,IK_Execute     ,\n/*2C*/\tIK_PrintScrn\t,IK_Insert      ,IK_Delete      ,IK_Help\t\t,\n/*30*/\tIK_0\t\t\t,IK_1\t\t\t,IK_2\t\t\t,IK_3\t\t\t,\n/*34*/\tIK_4\t\t\t,IK_5\t\t\t,IK_6\t\t\t,IK_7\t\t\t,\n/*38*/\tIK_8\t\t\t,IK_9\t\t\t,IK_Unknown3A\t,IK_Unknown3B\t,\n/*3C*/\tIK_Unknown3C\t,IK_Unknown3D\t,IK_Unknown3E\t,IK_Unknown3F\t,\n/*40*/\tIK_Unknown40\t,IK_A\t\t\t,IK_B\t\t\t,IK_C\t\t\t,\n/*44*/\tIK_D\t\t\t,IK_E\t\t\t,IK_F\t\t\t,IK_G\t\t\t,\n/*48*/\tIK_H\t\t\t,IK_I\t\t\t,IK_J\t\t\t,IK_K\t\t\t,\n/*4C*/\tIK_L\t\t\t,IK_M\t\t\t,IK_N\t\t\t,IK_O\t\t\t,\n/*50*/\tIK_P\t\t\t,IK_Q\t\t\t,IK_R\t\t\t,IK_S\t\t\t,\n/*54*/\tIK_T\t\t\t,IK_U\t\t\t,IK_V\t\t\t,IK_W\t\t\t,\n/*58*/\tIK_X\t\t\t,IK_Y\t\t\t,IK_Z\t\t\t,IK_Unknown5B\t,\n/*5C*/\tIK_Unknown5C\t,IK_Unknown5D\t,IK_Unknown5E\t,IK_Unknown5F\t,\n/*60*/\tIK_NumPad0\t\t,IK_NumPad1     ,IK_NumPad2     ,IK_NumPad3     ,\n/*64*/\tIK_NumPad4\t\t,IK_NumPad5     ,IK_NumPad6     ,IK_NumPad7     ,\n/*68*/\tIK_NumPad8\t\t,IK_NumPad9     ,IK_GreyStar    ,IK_GreyPlus    ,\n/*6C*/\tIK_Separator\t,IK_GreyMinus\t,IK_NumPadPeriod,IK_GreySlash   ,\n/*70*/\tIK_F1\t\t\t,IK_F2          ,IK_F3          ,IK_F4          ,\n/*74*/\tIK_F5\t\t\t,IK_F6          ,IK_F7          ,IK_F8          ,\n/*78*/\tIK_F9           ,IK_F10         ,IK_F11         ,IK_F12         ,\n/*7C*/\tIK_F13\t\t\t,IK_F14         ,IK_F15         ,IK_F16         ,\n/*80*/\tIK_F17\t\t\t,IK_F18         ,IK_F19         ,IK_F20         ,\n/*84*/\tIK_F21\t\t\t,IK_F22         ,IK_F23         ,IK_F24         ,\n/*88*/\tIK_Unknown88\t,IK_Unknown89\t,IK_Unknown8A\t,IK_Unknown8B\t,\n/*8C*/\tIK_Unknown8C\t,IK_Unknown8D\t,IK_Unknown8E\t,IK_Unknown8F\t,\n/*90*/\tIK_NumLock\t\t,IK_ScrollLock  ,IK_Unknown92\t,IK_Unknown93\t,\n/*94*/\tIK_Unknown94\t,IK_Unknown95\t,IK_Unknown96\t,IK_Unknown97\t,\n/*98*/\tIK_Unknown98\t,IK_Unknown99\t,IK_Unknown9A\t,IK_Unknown9B\t,\n/*9C*/\tIK_Unknown9C\t,IK_Unknown9D\t,IK_Unknown9E\t,IK_Unknown9F\t,\n/*A0*/\tIK_LShift\t\t,IK_RShift      ,IK_LControl    ,IK_RControl    ,\n/*A4*/\tIK_UnknownA4\t,IK_UnknownA5\t,IK_UnknownA6\t,IK_UnknownA7\t,\n/*A8*/\tIK_UnknownA8\t,IK_UnknownA9\t,IK_UnknownAA\t,IK_UnknownAB\t,\n/*AC*/\tIK_UnknownAC\t,IK_UnknownAD\t,IK_UnknownAE\t,IK_UnknownAF\t,\n/*B0*/\tIK_UnknownB0\t,IK_UnknownB1\t,IK_UnknownB2\t,IK_UnknownB3\t,\n/*B4*/\tIK_UnknownB4\t,IK_UnknownB5\t,IK_UnknownB6\t,IK_UnknownB7\t,\n/*B8*/\tIK_UnknownB8\t,IK_UnknownB9\t,IK_Semicolon\t,IK_Equals\t\t,\n/*BC*/\tIK_Comma\t\t,IK_Minus\t\t,IK_Period\t\t,IK_Slash\t\t,\n/*C0*/\tIK_Tilde\t\t,IK_UnknownC1\t,IK_UnknownC2\t,IK_UnknownC3\t,\n/*C4*/\tIK_UnknownC4\t,IK_UnknownC5\t,IK_UnknownC6\t,IK_UnknownC7\t,\n/*C8*/\tIK_Joy1\t        ,IK_Joy2\t    ,IK_Joy3\t    ,IK_Joy4\t    ,\n/*CC*/\tIK_Joy5\t        ,IK_Joy6\t    ,IK_Joy7\t    ,IK_Joy8\t    ,\n/*D0*/\tIK_Joy9\t        ,IK_Joy10\t    ,IK_Joy11\t    ,IK_Joy12\t\t,\n/*D4*/\tIK_Joy13\t\t,IK_Joy14\t    ,IK_Joy15\t    ,IK_Joy16\t    ,\n/*D8*/\tIK_UnknownD8\t,IK_UnknownD9\t,IK_UnknownDA\t,IK_LeftBracket\t,\n/*DC*/\tIK_Backslash\t,IK_RightBracket,IK_SingleQuote\t,IK_UnknownDF\t,\n/*E0*/  IK_JoyX\t\t\t,IK_JoyY\t\t,IK_JoyZ\t\t,IK_JoyR\t\t,\n/*E4*/\tIK_MouseX\t\t,IK_MouseY\t\t,IK_MouseZ\t\t,IK_MouseW\t\t,\n/*E8*/\tIK_JoyU\t\t\t,IK_JoyV\t\t,IK_UnknownEA\t,IK_UnknownEB\t,\n/*EC*/\tIK_MouseWheelUp ,IK_MouseWheelDown,IK_Unknown10E,UK_Unknown10F  ,\n/*F0*/\tIK_JoyPovUp     ,IK_JoyPovDown\t,IK_JoyPovLeft\t,IK_JoyPovRight\t,\n/*F4*/\tIK_UnknownF4\t,IK_UnknownF5\t,IK_Attn\t\t,IK_CrSel\t\t,\n/*F8*/\tIK_ExSel\t\t,IK_ErEof\t\t,IK_Play\t\t,IK_Zoom\t\t,\n/*FC*/\tIK_NoName\t\t,IK_PA1\t\t\t,IK_OEMClear\n};\n\nvar(Display) class<RenderIterator> RenderIteratorClass;\t// class to instantiate as the actor's RenderInterface\nvar transient RenderIterator RenderInterface;\t\t// abstract iterator initialized in the Rendering engine\n\n//-----------------------------------------------------------------------------\n// natives.\n\n// Execute a console command in the context of the current level and game engine.\nnative function string ConsoleCommand( string Command );\n\n\n//-----------------------------------------------------------------------------\n// Network replication.\n\nreplication\n{\n\t// Relationships.\n\tunreliable if( Role==ROLE_Authority )\n\t\tOwner, Role, RemoteRole;\n\tunreliable if( bNetOwner && Role==ROLE_Authority )\n\t\tbNetOwner, Inventory;\n\tunreliable if( bReplicateInstigator && (RemoteRole>=ROLE_SimulatedProxy) && (Role==ROLE_Authority) )\n\t\tInstigator;\n\n\t// Ambient sound.\n\tunreliable if( (Role==ROLE_Authority) && (!bNetOwner || !bClientAnim) )\n\t\tAmbientSound;\n\tunreliable if( AmbientSound!=None && Role==ROLE_Authority  && (!bNetOwner || !bClientAnim) )\n\t\tSoundRadius, SoundVolume, SoundPitch;\n\tunreliable if( bDemoRecording )\n\t\tDemoPlaySound;\n\n\t// Collision.\n\tunreliable if( Role==ROLE_Authority )\n\t\tbCollideActors, bCollideWorld;\n\tunreliable if( (bCollideActors || bCollideWorld) && Role==ROLE_Authority )\n\t\tbProjTarget, bBlockActors, bBlockPlayers, CollisionRadius, CollisionHeight;\n\n\t// Location.\n\tunreliable if( !bCarriedItem && (bNetInitial || bSimulatedPawn || RemoteRole<ROLE_SimulatedProxy) && Role==ROLE_Authority )\n\t\tLocation;\n\tunreliable if( !bCarriedItem && (DrawType==DT_Mesh || DrawType==DT_Brush) && (bNetInitial || bSimulatedPawn || RemoteRole<ROLE_SimulatedProxy) && Role==ROLE_Authority )\n\t\tRotation;\n\tunreliable if( RemoteRole==ROLE_SimulatedProxy )\n\t\tBase;\n\n   // Events\n   unreliable if( Role==ROLE_authority)\n      Event, Tag;\n\n\t// Velocity.\n\tunreliable if( bSimFall || ((RemoteRole==ROLE_SimulatedProxy && (bNetInitial || bSimulatedPawn)) || bIsMover) )\n\t\tVelocity;\n\n\t// Physics.\n\tunreliable if( bSimFall || (RemoteRole==ROLE_SimulatedProxy && bNetInitial && !bSimulatedPawn) )\n\t\tPhysics, Acceleration, bBounce;\n\tunreliable if( RemoteRole==ROLE_SimulatedProxy && Physics==PHYS_Rotating && bNetInitial )\n\t\tbFixedRotationDir, bRotateToDesired, RotationRate, DesiredRotation;\n\n\t// Animation. \n\tunreliable if( DrawType==DT_Mesh && ((RemoteRole<=ROLE_SimulatedProxy && (!bNetOwner || !bClientAnim)) || bDemoRecording) )\n\t\tAnimSequence, BlendAnimSequence;\t\t\t\t\t\t// blended anims added - DEUS_EX CNN\n\tunreliable if( DrawType==DT_Mesh && (RemoteRole==ROLE_SimulatedProxy))\n\t\tbAnimNotify;\n\tunreliable if( DrawType==DT_Mesh && (RemoteRole<ROLE_SimulatedProxy))\n\t\tSimAnim, AnimMinRate, SimBlendAnim, BlendAnimMinRate;\t// blended anims added - DEUS_EX CNN\n\n\n\t// Rendering.\n\tunreliable if( Role==ROLE_Authority )\n\t\tbHidden, bOnlyOwnerSee;\n\tunreliable if( Role==ROLE_Authority )\n\t\tTexture, DrawScale, PrePivot, DrawType, AmbientGlow, Fatness, ScaleGlow, bUnlit, Style;\n\tunreliable if( DrawType==DT_Sprite && !bHidden && (!bOnlyOwnerSee || bNetOwner) && Role==ROLE_Authority)\n\t\tSprite;\n\tunreliable if( DrawType==DT_Mesh && Role==ROLE_Authority )\n\t\tMesh, bMeshEnviroMap, Skin, MultiSkins;\n\tunreliable if( DrawType==DT_Brush && Role==ROLE_Authority )\n\t\tBrush;\n\n\t// Lighting.\n\tunreliable if( Role==ROLE_Authority )\n\t\tLightType;\n\tunreliable if( LightType!=LT_None && Role==ROLE_Authority )\n\t\tLightEffect, LightBrightness, LightHue, LightSaturation,\n\t\tLightRadius, LightPeriod, LightPhase,\n\t\tVolumeBrightness, VolumeRadius,\n\t\tbSpecialLit;\n\n\t// Messages\n\treliable if( Role<ROLE_Authority )\n\t\tBroadcastMessage, BroadcastLocalizedMessage;\n}\n\n//=============================================================================\n// Actor error handling.\n\n// Handle an error and kill this one actor.\nnative(233) final function Error( coerce string S );\n\n//=============================================================================\n// General functions.\n\n// Latent functions.\nnative(256) final latent function Sleep( float Seconds );\n\n// Collision.\nnative(262) final function SetCollision( optional bool NewColActors, optional bool NewBlockActors, optional bool NewBlockPlayers );\nnative(283) final function bool SetCollisionSize( float NewRadius, float NewHeight );\n\n// Movement.\nnative(266) final function bool Move( vector Delta );\nnative(267) final function bool SetLocation( vector NewLocation );\nnative(299) final function bool SetRotation( rotator NewRotation );\nnative(3969) final function bool MoveSmooth( vector Delta );\nnative(3971) final function AutonomousPhysics(float DeltaSeconds);\n\n// Relations.\nnative(298) final function SetBase( actor NewBase );\nnative(272) final function SetOwner( actor NewOwner );\n\n// AI Functions added DEUS_EX STM\nnative(700) final function float AIGetLightLevel( vector Location );\nnative(701) final function float AIVisibility(optional bool bIncludeVelocity);\nnative(710) final function AISetEventCallback(name eventName, name callback,\n                                              optional name scoreCallback,\n                                              optional bool bCheckVisibility,\n                                              optional bool bCheckDir,\n                                              optional bool bCheckCylinder,\n                                              optional bool bCheckLOS);\nnative(711) final function AIClearEventCallback(name eventName);\nnative(713) final function AISendEvent(name eventName, EAIEventType eventType,\n                                       optional float Value, optional float Radius);\nnative(714) final function AIStartEvent(name eventName, EAIEventType eventType,\n                                        optional float Value, optional float Radius);\nnative(715) final function AIEndEvent(name eventName, EAIEventType eventType);\nnative(716) final function AIClearEvent(name eventName);\nnative(717) final function rotator RandomBiasedRotation(int centralYaw, float yawDistribution,\n                                                        int centralPitch, float pitchDistribution);\nnative(718) final function bool IsOverlapping(actor checkActor);\nnative(720) final function PlayerPawn GetPlayerPawn();\nnative(721) final function bool InStasis();\nnative(722) final function float ParabolicTrace(out      vector finalLocation,\n                                                optional vector startVelocity,\n                                                optional vector startLocation,\n                                                optional bool   bCheckActors,\n                                                optional vector cylinder,\n                                                optional float  maxTime,\n                                                optional float  elasticity,\n                                                optional bool   bBounce,\n                                                optional float  landingSpeed,\n                                                optional float  granularity);\nnative(723) final function float LastRendered();\nnative(724) final function bool GetBoundingBox(out vector MinVect, out vector MaxVect,\n                                               optional bool bExact,\n                                               optional vector testLocation,\n                                               optional rotator testRotation);\n// End of AI functions DEUS_EX STM\n\n//=============================================================================\n// Animation.\n\n// Animation functions.\nnative(259) final function PlayAnim( name Sequence, optional float Rate, optional float TweenTime );\nnative(260) final function LoopAnim( name Sequence, optional float Rate, optional float TweenTime, optional float MinRate );\nnative(294) final function TweenAnim( name Sequence, float Time );\nnative(282) final function bool IsAnimating();\nnative(293) final function name GetAnimGroup( name Sequence );\nnative(261) final latent function FinishAnim();\nnative(263) final function bool HasAnim( name Sequence );\n\n// Blending animation function - DEUS_EX CNN\nnative(1010) final function PlayBlendAnim( name Sequence, optional float Rate, optional float TweenTime, optional int BlendSlot );\nnative(1012) final function TweenBlendAnim( name Sequence, float Time, optional int BlendSlot );\n\n// Gets any numbered texture from a mesh - DEUS_EX CNN\nnative(1013) final function Texture GetMeshTexture( optional int texnum );\n\n// Animation notifications.\nevent AnimEnd();\n\n//=========================================================================\n// Physics.\n\n// Physics control.\nnative(301) final latent function FinishInterpolation();\n// DEUS_EX STM - added optional param to SetPhysics()\n//native(3970) final function SetPhysics( EPhysics newPhysics );\nnative(3970) final function SetPhysics( EPhysics newPhysics, optional Actor newFloor );\n\n//=============================================================================\n// Engine notification functions.\n\n//\n// Major notifications.\n//\nevent Spawned();\nevent Destroyed();\nevent Expired();\nevent GainedChild( Actor Other );\nevent LostChild( Actor Other );\nevent Tick( float DeltaTime );\n\n//\n// Triggers.\n//\nevent Trigger( Actor Other, Pawn EventInstigator );\nevent UnTrigger( Actor Other, Pawn EventInstigator );\nevent BeginEvent();\nevent EndEvent();\n\n//\n// Physics & world interaction.\n//\nevent Timer();\nevent HitWall( vector HitNormal, actor HitWall );\nevent Falling();\nevent Landed( vector HitNormal );\nevent ZoneChange( ZoneInfo NewZone );\nevent Touch( Actor Other );\nevent PostTouch( Actor Other ); // called for PendingTouch actor after physics completes\nevent UnTouch( Actor Other );\nevent Bump( Actor Other );\nevent BaseChange();\nevent Attach( Actor Other );\nevent Detach( Actor Other );\nevent KillCredit( Actor Other );\nevent Actor SpecialHandling(Pawn Other);\nevent bool EncroachingOn( actor Other );\nevent EncroachedBy( actor Other );\nevent InterpolateEnd( actor Other );\nevent EndedRotation();\n\n// DEUS_EX STM -- added\nevent BumpWall( vector HitLocation, vector HitNormal );\nevent SupportActor( actor StandingActor )\n{\n\tStandingActor.SetBase( self );\n}\n\nevent FellOutOfWorld()\n{\n\tSetPhysics(PHYS_None);\n\tDestroy();\n}\t\n\n//\n// Damage and kills.\n//\nevent KilledBy( pawn EventInstigator );\nevent TakeDamage( int Damage, Pawn EventInstigator, vector HitLocation, vector Momentum, name DamageType);\n\n//\n// Trace a line and see what it collides with first.\n// Takes this actor's collision properties into account.\n// Returns first hit actor, Level if hit level, or None if hit nothing.\n//\nnative(277) final function Actor Trace\n(\n\tout vector      HitLocation,\n\tout vector      HitNormal,\n\tvector          TraceEnd,\n\toptional vector TraceStart,\n\toptional bool   bTraceActors,\n\toptional vector Extent\n);\n\n// returns true if did not hit world geometry\nnative(548) final function bool FastTrace\n(\n\tvector          TraceEnd,\n\toptional vector TraceStart\n);\n\n//\n// Spawn an actor. Returns an actor of the specified class, not\n// of class Actor (this is hardcoded in the compiler). Returns None\n// if the actor could not be spawned (either the actor wouldn't fit in\n// the specified location, or the actor list is full).\n// Defaults to spawning at the spawner's location.\n//\nnative(278) final function actor Spawn\n(\n\tclass<actor>      SpawnClass,\n\toptional actor\t  SpawnOwner,\n\toptional name     SpawnTag,\n\toptional vector   SpawnLocation,\n\toptional rotator  SpawnRotation\n);\n\n//\n// Destroy this actor. Returns true if destroyed, false if indestructable.\n// Destruction is latent. It occurs at the end of the tick.\n//\nnative(279) final function bool Destroy();\n\n//=============================================================================\n// Timing.\n\n// Causes Timer() events every NewTimerRate seconds.\nnative(280) final function SetTimer( float NewTimerRate, bool bLoop );\n\n//=============================================================================\n// Sound functions.\n\n// Play a sound effect.\n// DEUS_EX - CNN\n// changed to return the channel ID of the sound so you can call StopSound later\nnative(264) final function int PlaySound\n(\n\tsound\t\t\t\tSound,\n\toptional ESoundSlot Slot,\n\toptional float\t\tVolume,\n\toptional bool\t\tbNoOverride,\n\toptional float\t\tRadius,\n\toptional float\t\tPitch\n);\n\n// play a sound effect, but don't propagate to a remote owner\n// (he is playing the sound clientside\nnative simulated final function PlayOwnedSound\n(\n\tsound\t\t\t\tSound,\n\toptional ESoundSlot Slot,\n\toptional float\t\tVolume,\n\toptional bool\t\tbNoOverride,\n\toptional float\t\tRadius,\n\toptional float\t\tPitch\n);\n\n// DEUS_EX CNN - Stop a sound given the sound's ID\nnative(265) final function StopSound(int Id);\n\n// DEUS_EX CNN - Set the sound system volumes without waiting for a tick event\nnative(268) final function SetInstantSoundVolume(byte newSoundVolume);\nnative(269) final function SetInstantSpeechVolume(byte newSpeechVolume);\nnative(270) final function SetInstantMusicVolume(byte newMusicVolume);\n\nnative simulated event DemoPlaySound\n(\n\tsound\t\t\t\tSound,\n\toptional ESoundSlot Slot,\n\toptional float\t\tVolume,\n\toptional bool\t\tbNoOverride,\n\toptional float\t\tRadius,\n\toptional float\t\tPitch\n);\n\n// Get a sound duration.\nnative final function float GetSoundDuration( sound Sound );\n\n//=============================================================================\n// AI functions.\n\n//\n// Inform other creatures that you've made a noise\n// they might hear (they are sent a HearNoise message)\n// Senders of MakeNoise should have an instigator if they are not pawns.\n//\nnative(512) final function MakeNoise( float Loudness );\n\n//\n// PlayerCanSeeMe returns true if some player has a line of sight to \n// actor's location.\n//\nnative(532) final function bool PlayerCanSeeMe();\n\n//=============================================================================\n// Regular engine functions.\n\n// Teleportation.\nevent bool PreTeleport( Teleporter InTeleporter );\nevent PostTeleport( Teleporter OutTeleporter );\n\n// Level state.\nevent BeginPlay();\n\n//========================================================================\n// Disk access.\n\n// Find files.\nnative(539) final function string GetMapName( string NameEnding, string MapName, int Dir );\nnative(545) final function GetNextSkin( string Prefix, string CurrentSkin, int Dir, out string SkinName, out string SkinDesc );\nnative(547) final function string GetURLMap();\nnative final function string GetNextInt( string ClassName, int Num );\nnative final function GetNextIntDesc( string ClassName, int Num, out string Entry, out string Description );\n\n//=============================================================================\n// Iterator functions.\n\n// Iterator functions for dealing with sets of actors.\nnative(304) final iterator function AllActors     ( class<actor> BaseClass, out actor Actor, optional name MatchTag );\nnative(305) final iterator function ChildActors   ( class<actor> BaseClass, out actor Actor );\nnative(306) final iterator function BasedActors   ( class<actor> BaseClass, out actor Actor );\nnative(307) final iterator function TouchingActors( class<actor> BaseClass, out actor Actor );\nnative(309) final iterator function TraceActors   ( class<actor> BaseClass, out actor Actor, out vector HitLoc, out vector HitNorm, vector End, optional vector Start, optional vector Extent );\nnative(310) final iterator function RadiusActors  ( class<actor> BaseClass, out actor Actor, float Radius, optional vector Loc );\nnative(311) final iterator function VisibleActors ( class<actor> BaseClass, out actor Actor, optional float Radius, optional vector Loc );\nnative(312) final iterator function VisibleCollidingActors ( class<actor> BaseClass, out actor Actor, optional float Radius, optional vector Loc, optional bool bIgnoreHidden );\n\n// added by DEUS_EX CNN\nnative(1000) final iterator function TraceTexture (class<actor> BaseClass, out actor Actor, out name texName, out name texGroup, out int flags, out vector HitLoc, out vector HitNorm, vector End, optional vector Start, optional vector Extent);\n\n// added by DEUS_EX STM\nnative(1002) final iterator function CycleActors (class<actor> BaseClass, out actor Actor, out int Index );\nnative(1003) final iterator function TraceVisibleActors(class<actor> BaseClass, out actor Actor, out vector HitLoc, out vector HitNorm, vector End, optional vector Start, optional vector Extent );\n\n//=============================================================================\n// Color operators\nnative(549) static final operator(20)  color -     ( color A, color B );\nnative(550) static final operator(16) color *     ( float A, color B );\nnative(551) static final operator(20) color +     ( color A, color B );\nnative(552) static final operator(16) color *     ( color A, float B );\n\n//=============================================================================\n// Scripted Actor functions.\n\n// draw on canvas before flash and fog are applied (used for drawing weapons)\nevent RenderOverlays( canvas Canvas );\n\n//\n// Called immediately before gameplay begins.\n//\nevent PreBeginPlay()\n{\n\t// fake shrink to fix faked collision with floor problems - DEUS_EX CNN\n\tif ((IsA('Decoration') || IsA('Inventory')) && (CollisionHeight > 0.75))\n\t\tSetCollisionSize(CollisionRadius, CollisionHeight - 0.75);\n\telse if (IsA('Pawn'))\n\t{\n\t\tif (CollisionHeight > 9)\n\t\t\tSetCollisionSize(CollisionRadius, CollisionHeight - 4.5);\n\t\telse\n\t\t\tSetCollisionSize(CollisionRadius, CollisionHeight*0.5);\n\t}\n\n\t// Handle autodestruction if desired.\n\tif( !bGameRelevant && (Level.NetMode != NM_Client) && !Level.Game.IsRelevant(Self) )\n\t\tDestroy();\n}\n\n//\n// Broadcast a message to all players.\n//\nevent BroadcastMessage( coerce string Msg, optional bool bBeep, optional name Type )\n{\n\tlocal Pawn P;\n\n\tif (Type == '')\n\t\tType = 'Event';\n\n//\tif ( Level.Game.AllowsBroadcast(self, Len(Msg)) )\n\t\tfor( P=Level.PawnList; P!=None; P=P.nextPawn )\n\t\t\tif( P.bIsPlayer || P.IsA('MessagingSpectator') )\n\t\t\t\tP.ClientMessage( Msg, Type, bBeep );\n}\n\n//\n// Broadcast a localized message to all players.\n// Most message deal with 0 to 2 related PRIs.\n// The LocalMessage class defines how the PRI's and optional actor are used.\n//\nevent BroadcastLocalizedMessage( class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject )\n{\n\tlocal Pawn P;\n\n\tfor ( P=Level.PawnList; P != None; P=P.nextPawn )\n\t\tif ( P.bIsPlayer || P.IsA('MessagingSpectator') )\n\t\t\tP.ReceiveLocalizedMessage( Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );\n}\n\n//\n// Called immediately after gameplay begins.\n//\nevent PostBeginPlay();\n\n//\n// DEUS_EX AJY\n//\n// Called immediately after Initial State, and always\n// called when loading a map *AND* when loading savegame\n//\nevent PostPostBeginPlay();\n\n//\n// Called after PostBeginPlay.\n//\nsimulated event SetInitialState()\n{\n\tif( InitialState!='' )\n\t\tGotoState( InitialState );\n\telse\n\t\tGotoState( 'Auto' );\n}\n\n// MBCODE: Stub for PostNetBeginPlay\nsimulated event PostNetBeginPlay();\n\n//\n// Hurt actors within the radius.\n//\nfinal function HurtRadius( float DamageAmount, float DamageRadius, name DamageName, float Momentum, vector HitLocation, optional bool bIgnoreLOS )\n{\n\tlocal actor Victims;\n\tlocal float damageScale, dist;\n\tlocal vector dir;\n\n\t// DEUS_EX CNN\n\tlocal Mover M;\t\t\t\t\n\t\n\tif( bHurtEntry )\n\t\treturn;\n\n\tbHurtEntry = true;\n   if (!bIgnoreLOS)\n   {\n      foreach VisibleCollidingActors( class 'Actor', Victims, DamageRadius, HitLocation )\n      {\n         if( Victims != self )\n         {\n            dir = Victims.Location - HitLocation;\n            dist = FMax(1,VSize(dir));\n            dir = dir/dist; \n            damageScale = 1 - FMax(0,(dist - Victims.CollisionRadius)/DamageRadius);\n            Victims.TakeDamage\n               (\n               damageScale * DamageAmount,\n               Instigator, \n               Victims.Location - 0.5 * (Victims.CollisionHeight + Victims.CollisionRadius) * dir,\n               (damageScale * Momentum * dir),\n               DamageName\n               );\n         } \n      }\n   }\n   else\n   {\n      foreach RadiusActors(class 'Actor', Victims, DamageRadius, HitLocation )\n      {\n         if( Victims != self )\n         {\n            dir = Victims.Location - HitLocation;\n            dist = FMax(1,VSize(dir));\n            dir = dir/dist; \n            damageScale = 1 - FMax(0,(dist - Victims.CollisionRadius)/DamageRadius);\n            Victims.TakeDamage\n               (\n               damageScale * DamageAmount,\n               Instigator, \n               Victims.Location - 0.5 * (Victims.CollisionHeight + Victims.CollisionRadius) * dir,\n               (damageScale * Momentum * dir),\n               DamageName\n               );\n         } \n      }\n   }\n\n\t//\n\t// DEUS_EX - CNN - damage the movers, also\n\t//\n\tforeach RadiusActors(class 'Mover', M, DamageRadius, HitLocation)\n\t{\n\t\tif( M != self )\n\t\t{\n\t\t\tdir = M.Location - HitLocation;\n\t\t\tdist = FMax(1,VSize(dir));\n\t\t\tdir = dir/dist; \n\t\t\tdamageScale = 1 - FMax(0,(dist - M.CollisionRadius)/DamageRadius);\n\t\t\tM.TakeDamage\n\t\t\t(\n\t\t\t\tdamageScale * DamageAmount,\n\t\t\t\tInstigator, \n\t\t\t\tM.Location - 0.5 * (M.CollisionHeight + M.CollisionRadius) * dir,\n\t\t\t\t(damageScale * Momentum * dir),\n\t\t\t\tDamageName\n\t\t\t);\n\t\t} \n\t}\n\n\tbHurtEntry = false;\n}\n\n//\n// Called when carried onto a new level, before AcceptInventory.\n//\nevent TravelPreAccept();\n\n//\n// Called when carried into a new level, after AcceptInventory.\n//\nevent TravelPostAccept();\n\n//\n// DEUS_EX CNN\n// Frob() - called to frob an object\n// the subclass is responsible for implementing this\n//\nfunction Frob(Actor Frobber, Inventory frobWith)\n{\n}\n\n// DEUS_EX CNN\nfunction StopBlendAnims()\n{\n\tlocal int i;\n\n\tfor (i=0; i<ArrayCount(BlendAnimSequence); i++)\n\t\tBlendAnimSequence[i] = '';\n}\n\n//\n// Called when a scripted texture needs rendering\n//\nevent RenderTexture(ScriptedTexture Tex);\n\n//\n// Called by PlayerPawn when this actor becomes its ViewTarget.\n//\nfunction BecomeViewTarget();\n\n//\n// Returns the string representation of the name of an object without the package\n// prefixes.\n//\nfunction String GetItemName( string FullName )\n{\n\tlocal int pos;\n\n\tpos = InStr(FullName, \".\");\n\tWhile ( pos != -1 )\n\t{\n\t\tFullName = Right(FullName, Len(FullName) - pos - 1);\n\t\tpos = InStr(FullName, \".\");\n\t}\n\n\treturn FullName;\n}\n\n//\n// Returns the human readable string representation of an object.\n//\n\nfunction String GetHumanName()\n{\n\treturn GetItemName(string(class));\n}\n\n// Set the display properties of an actor.  By setting them through this function, it allows\n// the actor to modify other components (such as a Pawn's weapon) or to adjust the result\n// based on other factors (such as a Pawn's other inventory wanting to affect the result)\nfunction SetDisplayProperties(ERenderStyle NewStyle, texture NewTexture, bool bLighting, bool bEnviroMap )\n{\n\tStyle = NewStyle;\n\ttexture = NewTexture;\n\tbUnlit = bLighting;\n\tbMeshEnviromap = bEnviromap;\n}\n\nfunction SetDefaultDisplayProperties()\n{\n\tStyle = Default.Style;\n\ttexture = Default.Texture;\n\tbUnlit = Default.bUnlit;\n\tbMeshEnviromap = Default.bMeshEnviromap;\n}\n\n// ----------------------------------------------------------------------\n// EndConversation()\n//\n// Save the time this conversation ended\n//\n// DEUS_EX AJY\n// ----------------------------------------------------------------------\n\nfunction EndConversation()\n{\n\tLastConEndTime = Level.TimeSeconds;\n}\n\ndefaultproperties\n{\n     bMovable=True\n     bDetectable=True\n     Role=ROLE_Authority\n     RemoteRole=ROLE_DumbProxy\n     LastRenderTime=-10.000000\n     LODBias=1.000000\n     bDifficulty0=True\n     bDifficulty1=True\n     bDifficulty2=True\n     bDifficulty3=True\n     bSinglePlayer=True\n     bNet=True\n     bNetSpecial=True\n     OddsOfAppearing=1.000000\n     DrawType=DT_Sprite\n     Style=STY_Normal\n     Texture=Texture'Engine.S_Actor'\n     DrawScale=1.000000\n     ScaleGlow=1.000000\n     Fatness=128\n     SoundRadius=32\n     SoundVolume=128\n     SoundPitch=64\n     TransientSoundVolume=1.000000\n     CollisionRadius=22.000000\n     CollisionHeight=22.000000\n     bJustTeleported=True\n     Mass=100.000000\n     ConStartInterval=5.000000\n     NetPriority=1.000000\n     NetUpdateFrequency=100.000000\n}\n",
            "name": "Actor.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bMovable=True",
                    "bDetectable=True",
                    "Role=ROLE_Authority",
                    "RemoteRole=ROLE_DumbProxy",
                    "LastRenderTime=-10.000000",
                    "LODBias=1.000000",
                    "bDifficulty0=True",
                    "bDifficulty1=True",
                    "bDifficulty2=True",
                    "bDifficulty3=True",
                    "bSinglePlayer=True",
                    "bNet=True",
                    "bNetSpecial=True",
                    "OddsOfAppearing=1.000000",
                    "DrawType=DT_Sprite",
                    "Style=STY_Normal",
                    "Texture=Texture'Engine.S_Actor'",
                    "DrawScale=1.000000",
                    "ScaleGlow=1.000000",
                    "Fatness=128",
                    "SoundRadius=32",
                    "SoundVolume=128",
                    "SoundPitch=64",
                    "TransientSoundVolume=1.000000",
                    "CollisionRadius=22.000000",
                    "CollisionHeight=22.000000",
                    "bJustTeleported=True",
                    "Mass=100.000000",
                    "ConStartInterval=5.000000",
                    "NetPriority=1.000000",
                    "NetUpdateFrequency=100.000000"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\S_Actor.pcx Name=S_Actor Mips=Off Flags=2"
                ],
                "extends": "Object",
                "functions": {
                    "AIClearEvent": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AIClearEvent",
                        "native": true,
                        "param": [
                            [
                                "name",
                                "eventName"
                            ]
                        ],
                        "return": ""
                    },
                    "AIClearEventCallback": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AIClearEventCallback",
                        "native": true,
                        "param": [
                            [
                                "name",
                                "eventName"
                            ]
                        ],
                        "return": ""
                    },
                    "AIEndEvent": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AIEndEvent",
                        "native": true,
                        "param": [
                            [
                                "name",
                                "eventName"
                            ],
                            [
                                "EAIEventType",
                                "eventType"
                            ]
                        ],
                        "return": ""
                    },
                    "AIGetLightLevel": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AIGetLightLevel",
                        "native": true,
                        "param": [
                            [
                                "vector",
                                "Location"
                            ]
                        ],
                        "return": ""
                    },
                    "AIVisibility": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AIVisibility",
                        "native": true,
                        "param": [
                            [
                                "optional",
                                "bool",
                                "bIncludeVelocity"
                            ]
                        ],
                        "return": ""
                    },
                    "AllActors": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AllActors",
                        "native": true,
                        "param": [
                            [
                                "class<actor>",
                                "BaseClass"
                            ],
                            [
                                "out",
                                "actor",
                                "Actor"
                            ],
                            [
                                "optional",
                                "name",
                                "MatchTag"
                            ]
                        ],
                        "return": ""
                    },
                    "AnimEnd": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AnimEnd",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Attach": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Attach",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "AutonomousPhysics": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AutonomousPhysics",
                        "native": true,
                        "param": [
                            [
                                "float",
                                "DeltaSeconds"
                            ]
                        ],
                        "return": ""
                    },
                    "BaseChange": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "BaseChange",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BasedActors": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "BasedActors",
                        "native": true,
                        "param": [
                            [
                                "class<actor>",
                                "BaseClass"
                            ],
                            [
                                "out",
                                "actor",
                                "Actor"
                            ]
                        ],
                        "return": ""
                    },
                    "BecomeViewTarget": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "BecomeViewTarget",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BeginEvent": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginEvent",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BeginPlay": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BroadcastLocalizedMessage": {
                        "body": "{\n\n\tfor ( P=Level.PawnList; P != None; P=P.nextPawn )\n\t\tif ( P.bIsPlayer || P.IsA('MessagingSpectator') )\n\t\t\tP.ReceiveLocalizedMessage( Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );\n}",
                        "locals": [
                            "local Pawn P;"
                        ],
                        "modifiers": [],
                        "name": "BroadcastLocalizedMessage",
                        "native": false,
                        "param": [
                            [
                                "class<LocalMessage>",
                                "Message"
                            ],
                            [
                                "optional",
                                "int",
                                "Switch"
                            ],
                            [
                                "optional",
                                "PlayerReplicationInfo",
                                "RelatedPRI_1"
                            ],
                            [
                                "optional",
                                "PlayerReplicationInfo",
                                "RelatedPRI_2"
                            ],
                            [
                                "optional",
                                "Object",
                                "OptionalObject"
                            ]
                        ],
                        "return": ""
                    },
                    "BroadcastMessage": {
                        "body": "{\n\n\tif (Type == '')\n\t\tType = 'Event';\n\n//\tif ( Level.Game.AllowsBroadcast(self, Len(Msg)) )\n\t\tfor( P=Level.PawnList; P!=None; P=P.nextPawn )\n\t\t\tif( P.bIsPlayer || P.IsA('MessagingSpectator') )\n\t\t\t\tP.ClientMessage( Msg, Type, bBeep );\n}",
                        "locals": [
                            "local Pawn P;"
                        ],
                        "modifiers": [],
                        "name": "BroadcastMessage",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "Msg"
                            ],
                            [
                                "optional",
                                "bool",
                                "bBeep"
                            ],
                            [
                                "optional",
                                "name",
                                "Type"
                            ]
                        ],
                        "return": ""
                    },
                    "Bump": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Bump",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "BumpWall": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "BumpWall",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "HitLocation"
                            ],
                            [
                                "vector",
                                "HitNormal"
                            ]
                        ],
                        "return": ""
                    },
                    "ChildActors": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChildActors",
                        "native": true,
                        "param": [
                            [
                                "class<actor>",
                                "BaseClass"
                            ],
                            [
                                "out",
                                "actor",
                                "Actor"
                            ]
                        ],
                        "return": ""
                    },
                    "ConsoleCommand": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ConsoleCommand",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "Command"
                            ]
                        ],
                        "return": "string"
                    },
                    "CycleActors": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "CycleActors",
                        "native": true,
                        "param": [
                            [
                                "class<actor>",
                                "BaseClass"
                            ],
                            [
                                "out",
                                "actor",
                                "Actor"
                            ],
                            [
                                "out",
                                "int",
                                "Index"
                            ]
                        ],
                        "return": ""
                    },
                    "Destroy": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Destroy",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "Destroyed": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Destroyed",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Detach": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Detach",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "EncroachedBy": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "EncroachedBy",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "EncroachingOn": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "EncroachingOn",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": "bool"
                    },
                    "EndConversation": {
                        "body": "{\n\tLastConEndTime = Level.TimeSeconds;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "EndConversation",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "EndEvent": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "EndEvent",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "EndedRotation": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "EndedRotation",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Error": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Error",
                        "native": true,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "Expired": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Expired",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Falling": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Falling",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FellOutOfWorld": {
                        "body": "{\n\tSetPhysics(PHYS_None);\n\tDestroy();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "FellOutOfWorld",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FinishAnim": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "FinishAnim",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "FinishInterpolation": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "FinishInterpolation",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "Frob": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Frob",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Frobber"
                            ],
                            [
                                "Inventory",
                                "frobWith"
                            ]
                        ],
                        "return": ""
                    },
                    "GainedChild": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "GainedChild",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "GetAnimGroup": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetAnimGroup",
                        "native": true,
                        "param": [
                            [
                                "name",
                                "Sequence"
                            ]
                        ],
                        "return": ""
                    },
                    "GetHumanName": {
                        "body": "{\n\treturn GetItemName(string(class));\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetHumanName",
                        "native": false,
                        "param": [],
                        "return": "String"
                    },
                    "GetItemName": {
                        "body": "{\n\n\tpos = InStr(FullName, \".\");\n\tWhile ( pos != -1 )\n\t{\n\t\tFullName = Right(FullName, Len(FullName) - pos - 1);\n\t\tpos = InStr(FullName, \".\");\n\t}\n\n\treturn FullName;\n}",
                        "locals": [
                            "local int pos;"
                        ],
                        "modifiers": [],
                        "name": "GetItemName",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "FullName"
                            ]
                        ],
                        "return": "String"
                    },
                    "GetMapName": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetMapName",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "NameEnding"
                            ],
                            [
                                "string",
                                "MapName"
                            ],
                            [
                                "int",
                                "Dir"
                            ]
                        ],
                        "return": ""
                    },
                    "GetMeshTexture": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetMeshTexture",
                        "native": true,
                        "param": [
                            [
                                "optional",
                                "int",
                                "texnum"
                            ]
                        ],
                        "return": ""
                    },
                    "GetNextInt": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetNextInt",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "ClassName"
                            ],
                            [
                                "int",
                                "Num"
                            ]
                        ],
                        "return": "string"
                    },
                    "GetNextIntDesc": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetNextIntDesc",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "ClassName"
                            ],
                            [
                                "int",
                                "Num"
                            ],
                            [
                                "out",
                                "string",
                                "Entry"
                            ],
                            [
                                "out",
                                "string",
                                "Description"
                            ]
                        ],
                        "return": ""
                    },
                    "GetNextSkin": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetNextSkin",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "Prefix"
                            ],
                            [
                                "string",
                                "CurrentSkin"
                            ],
                            [
                                "int",
                                "Dir"
                            ],
                            [
                                "out",
                                "string",
                                "SkinName"
                            ],
                            [
                                "out",
                                "string",
                                "SkinDesc"
                            ]
                        ],
                        "return": ""
                    },
                    "GetPlayerPawn": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetPlayerPawn",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "GetSoundDuration": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetSoundDuration",
                        "native": true,
                        "param": [
                            [
                                "sound",
                                "Sound"
                            ]
                        ],
                        "return": "float"
                    },
                    "GetURLMap": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetURLMap",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "HasAnim": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "HasAnim",
                        "native": true,
                        "param": [
                            [
                                "name",
                                "Sequence"
                            ]
                        ],
                        "return": ""
                    },
                    "HitWall": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "HitWall",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "HitNormal"
                            ],
                            [
                                "actor",
                                "HitWall"
                            ]
                        ],
                        "return": ""
                    },
                    "HurtRadius": {
                        "body": "{\n\n\t// DEUS_EX CNN\n\t\n\tif( bHurtEntry )\n\t\treturn;\n\n\tbHurtEntry = true;\n   if (!bIgnoreLOS)\n   {\n      foreach VisibleCollidingActors( class 'Actor', Victims, DamageRadius, HitLocation )\n      {\n         if( Victims != self )\n         {\n            dir = Victims.Location - HitLocation;\n            dist = FMax(1,VSize(dir));\n            dir = dir/dist; \n            damageScale = 1 - FMax(0,(dist - Victims.CollisionRadius)/DamageRadius);\n            Victims.TakeDamage\n               (\n               damageScale * DamageAmount,\n               Instigator, \n               Victims.Location - 0.5 * (Victims.CollisionHeight + Victims.CollisionRadius) * dir,\n               (damageScale * Momentum * dir),\n               DamageName\n               );\n         } \n      }\n   }\n   else\n   {\n      foreach RadiusActors(class 'Actor', Victims, DamageRadius, HitLocation )\n      {\n         if( Victims != self )\n         {\n            dir = Victims.Location - HitLocation;\n            dist = FMax(1,VSize(dir));\n            dir = dir/dist; \n            damageScale = 1 - FMax(0,(dist - Victims.CollisionRadius)/DamageRadius);\n            Victims.TakeDamage\n               (\n               damageScale * DamageAmount,\n               Instigator, \n               Victims.Location - 0.5 * (Victims.CollisionHeight + Victims.CollisionRadius) * dir,\n               (damageScale * Momentum * dir),\n               DamageName\n               );\n         } \n      }\n   }\n\n\t//\n\t// DEUS_EX - CNN - damage the movers, also\n\t//\n\tforeach RadiusActors(class 'Mover', M, DamageRadius, HitLocation)\n\t{\n\t\tif( M != self )\n\t\t{\n\t\t\tdir = M.Location - HitLocation;\n\t\t\tdist = FMax(1,VSize(dir));\n\t\t\tdir = dir/dist; \n\t\t\tdamageScale = 1 - FMax(0,(dist - M.CollisionRadius)/DamageRadius);\n\t\t\tM.TakeDamage\n\t\t\t(\n\t\t\t\tdamageScale * DamageAmount,\n\t\t\t\tInstigator, \n\t\t\t\tM.Location - 0.5 * (M.CollisionHeight + M.CollisionRadius) * dir,\n\t\t\t\t(damageScale * Momentum * dir),\n\t\t\t\tDamageName\n\t\t\t);\n\t\t} \n\t}\n\n\tbHurtEntry = false;\n}",
                        "locals": [
                            "local actor Victims;",
                            "local float damageScale, dist;",
                            "local vector dir;",
                            "local Mover M;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "HurtRadius",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DamageAmount"
                            ],
                            [
                                "float",
                                "DamageRadius"
                            ],
                            [
                                "name",
                                "DamageName"
                            ],
                            [
                                "float",
                                "Momentum"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ],
                            [
                                "optional",
                                "bool",
                                "bIgnoreLOS"
                            ]
                        ],
                        "return": ""
                    },
                    "InStasis": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "InStasis",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "InterpolateEnd": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "InterpolateEnd",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "IsAnimating": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "IsAnimating",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "IsOverlapping": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "IsOverlapping",
                        "native": true,
                        "param": [
                            [
                                "actor",
                                "checkActor"
                            ]
                        ],
                        "return": ""
                    },
                    "KillCredit": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "KillCredit",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "KilledBy": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "KilledBy",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    },
                    "Landed": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Landed",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "HitNormal"
                            ]
                        ],
                        "return": ""
                    },
                    "LastRendered": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "LastRendered",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "LoopAnim": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "LoopAnim",
                        "native": true,
                        "param": [
                            [
                                "name",
                                "Sequence"
                            ],
                            [
                                "optional",
                                "float",
                                "Rate"
                            ],
                            [
                                "optional",
                                "float",
                                "TweenTime"
                            ],
                            [
                                "optional",
                                "float",
                                "MinRate"
                            ]
                        ],
                        "return": ""
                    },
                    "LostChild": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "LostChild",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "MakeNoise": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "MakeNoise",
                        "native": true,
                        "param": [
                            [
                                "float",
                                "Loudness"
                            ]
                        ],
                        "return": ""
                    },
                    "Move": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Move",
                        "native": true,
                        "param": [
                            [
                                "vector",
                                "Delta"
                            ]
                        ],
                        "return": ""
                    },
                    "MoveSmooth": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "MoveSmooth",
                        "native": true,
                        "param": [
                            [
                                "vector",
                                "Delta"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayAnim": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayAnim",
                        "native": true,
                        "param": [
                            [
                                "name",
                                "Sequence"
                            ],
                            [
                                "optional",
                                "float",
                                "Rate"
                            ],
                            [
                                "optional",
                                "float",
                                "TweenTime"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayBlendAnim": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayBlendAnim",
                        "native": true,
                        "param": [
                            [
                                "name",
                                "Sequence"
                            ],
                            [
                                "optional",
                                "float",
                                "Rate"
                            ],
                            [
                                "optional",
                                "float",
                                "TweenTime"
                            ],
                            [
                                "optional",
                                "int",
                                "BlendSlot"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayerCanSeeMe": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayerCanSeeMe",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostNetBeginPlay": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PostNetBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostPostBeginPlay": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostPostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostTeleport": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostTeleport",
                        "native": false,
                        "param": [
                            [
                                "Teleporter",
                                "OutTeleporter"
                            ]
                        ],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\t// fake shrink to fix faked collision with floor problems - DEUS_EX CNN\n\tif ((IsA('Decoration') || IsA('Inventory')) && (CollisionHeight > 0.75))\n\t\tSetCollisionSize(CollisionRadius, CollisionHeight - 0.75);\n\telse if (IsA('Pawn'))\n\t{\n\t\tif (CollisionHeight > 9)\n\t\t\tSetCollisionSize(CollisionRadius, CollisionHeight - 4.5);\n\t\telse\n\t\t\tSetCollisionSize(CollisionRadius, CollisionHeight*0.5);\n\t}\n\n\t// Handle autodestruction if desired.\n\tif( !bGameRelevant && (Level.NetMode != NM_Client) && !Level.Game.IsRelevant(Self) )\n\t\tDestroy();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreTeleport": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreTeleport",
                        "native": false,
                        "param": [
                            [
                                "Teleporter",
                                "InTeleporter"
                            ]
                        ],
                        "return": "bool"
                    },
                    "RadiusActors": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "RadiusActors",
                        "native": true,
                        "param": [
                            [
                                "class<actor>",
                                "BaseClass"
                            ],
                            [
                                "out",
                                "actor",
                                "Actor"
                            ],
                            [
                                "float",
                                "Radius"
                            ],
                            [
                                "optional",
                                "vector",
                                "Loc"
                            ]
                        ],
                        "return": ""
                    },
                    "RenderOverlays": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "RenderOverlays",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "RenderTexture": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "RenderTexture",
                        "native": false,
                        "param": [
                            [
                                "ScriptedTexture",
                                "Tex"
                            ]
                        ],
                        "return": ""
                    },
                    "SetBase": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetBase",
                        "native": true,
                        "param": [
                            [
                                "actor",
                                "NewBase"
                            ]
                        ],
                        "return": ""
                    },
                    "SetCollision": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetCollision",
                        "native": true,
                        "param": [
                            [
                                "optional",
                                "bool",
                                "NewColActors"
                            ],
                            [
                                "optional",
                                "bool",
                                "NewBlockActors"
                            ],
                            [
                                "optional",
                                "bool",
                                "NewBlockPlayers"
                            ]
                        ],
                        "return": ""
                    },
                    "SetCollisionSize": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetCollisionSize",
                        "native": true,
                        "param": [
                            [
                                "float",
                                "NewRadius"
                            ],
                            [
                                "float",
                                "NewHeight"
                            ]
                        ],
                        "return": ""
                    },
                    "SetDefaultDisplayProperties": {
                        "body": "{\n\tStyle = Default.Style;\n\ttexture = Default.Texture;\n\tbUnlit = Default.bUnlit;\n\tbMeshEnviromap = Default.bMeshEnviromap;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetDefaultDisplayProperties",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetDisplayProperties": {
                        "body": "{\n\tStyle = NewStyle;\n\ttexture = NewTexture;\n\tbUnlit = bLighting;\n\tbMeshEnviromap = bEnviromap;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetDisplayProperties",
                        "native": false,
                        "param": [
                            [
                                "ERenderStyle",
                                "NewStyle"
                            ],
                            [
                                "texture",
                                "NewTexture"
                            ],
                            [
                                "bool",
                                "bLighting"
                            ],
                            [
                                "bool",
                                "bEnviroMap"
                            ]
                        ],
                        "return": ""
                    },
                    "SetInitialState": {
                        "body": "{\n\tif( InitialState!='' )\n\t\tGotoState( InitialState );\n\telse\n\t\tGotoState( 'Auto' );\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "SetInitialState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetInstantMusicVolume": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetInstantMusicVolume",
                        "native": true,
                        "param": [
                            [
                                "byte",
                                "newMusicVolume"
                            ]
                        ],
                        "return": ""
                    },
                    "SetInstantSoundVolume": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetInstantSoundVolume",
                        "native": true,
                        "param": [
                            [
                                "byte",
                                "newSoundVolume"
                            ]
                        ],
                        "return": ""
                    },
                    "SetInstantSpeechVolume": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetInstantSpeechVolume",
                        "native": true,
                        "param": [
                            [
                                "byte",
                                "newSpeechVolume"
                            ]
                        ],
                        "return": ""
                    },
                    "SetLocation": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetLocation",
                        "native": true,
                        "param": [
                            [
                                "vector",
                                "NewLocation"
                            ]
                        ],
                        "return": ""
                    },
                    "SetOwner": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetOwner",
                        "native": true,
                        "param": [
                            [
                                "actor",
                                "NewOwner"
                            ]
                        ],
                        "return": ""
                    },
                    "SetPhysics": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetPhysics",
                        "native": true,
                        "param": [
                            [
                                "EPhysics",
                                "newPhysics"
                            ],
                            [
                                "optional",
                                "Actor",
                                "newFloor"
                            ]
                        ],
                        "return": ""
                    },
                    "SetRotation": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetRotation",
                        "native": true,
                        "param": [
                            [
                                "rotator",
                                "NewRotation"
                            ]
                        ],
                        "return": ""
                    },
                    "SetTimer": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetTimer",
                        "native": true,
                        "param": [
                            [
                                "float",
                                "NewTimerRate"
                            ],
                            [
                                "bool",
                                "bLoop"
                            ]
                        ],
                        "return": ""
                    },
                    "Sleep": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Sleep",
                        "native": true,
                        "param": [
                            [
                                "float",
                                "Seconds"
                            ]
                        ],
                        "return": ""
                    },
                    "Spawned": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Spawned",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpecialHandling": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SpecialHandling",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": "Actor"
                    },
                    "StopBlendAnims": {
                        "body": "{\n\n\tfor (i=0; i<ArrayCount(BlendAnimSequence); i++)\n\t\tBlendAnimSequence[i] = '';\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "StopBlendAnims",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StopSound": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "StopSound",
                        "native": true,
                        "param": [
                            [
                                "int",
                                "Id"
                            ]
                        ],
                        "return": ""
                    },
                    "SupportActor": {
                        "body": "{\n\tStandingActor.SetBase( self );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SupportActor",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "StandingActor"
                            ]
                        ],
                        "return": ""
                    },
                    "TakeDamage": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TakeDamage",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Damage"
                            ],
                            [
                                "Pawn",
                                "EventInstigator"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ],
                            [
                                "vector",
                                "Momentum"
                            ],
                            [
                                "name",
                                "DamageType"
                            ]
                        ],
                        "return": ""
                    },
                    "Tick": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Touch": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Touch",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "TouchingActors": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TouchingActors",
                        "native": true,
                        "param": [
                            [
                                "class<actor>",
                                "BaseClass"
                            ],
                            [
                                "out",
                                "actor",
                                "Actor"
                            ]
                        ],
                        "return": ""
                    },
                    "TraceActors": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TraceActors",
                        "native": true,
                        "param": [
                            [
                                "class<actor>",
                                "BaseClass"
                            ],
                            [
                                "out",
                                "actor",
                                "Actor"
                            ],
                            [
                                "out",
                                "vector",
                                "HitLoc"
                            ],
                            [
                                "out",
                                "vector",
                                "HitNorm"
                            ],
                            [
                                "vector",
                                "End"
                            ],
                            [
                                "optional",
                                "vector",
                                "Start"
                            ],
                            [
                                "optional",
                                "vector",
                                "Extent"
                            ]
                        ],
                        "return": ""
                    },
                    "TraceTexture": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TraceTexture",
                        "native": true,
                        "param": [
                            [
                                "class<actor>",
                                "BaseClass"
                            ],
                            [
                                "out",
                                "actor",
                                "Actor"
                            ],
                            [
                                "out",
                                "name",
                                "texName"
                            ],
                            [
                                "out",
                                "name",
                                "texGroup"
                            ],
                            [
                                "out",
                                "int",
                                "flags"
                            ],
                            [
                                "out",
                                "vector",
                                "HitLoc"
                            ],
                            [
                                "out",
                                "vector",
                                "HitNorm"
                            ],
                            [
                                "vector",
                                "End"
                            ],
                            [
                                "optional",
                                "vector",
                                "Start"
                            ],
                            [
                                "optional",
                                "vector",
                                "Extent"
                            ]
                        ],
                        "return": ""
                    },
                    "TraceVisibleActors": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TraceVisibleActors",
                        "native": true,
                        "param": [
                            [
                                "class<actor>",
                                "BaseClass"
                            ],
                            [
                                "out",
                                "actor",
                                "Actor"
                            ],
                            [
                                "out",
                                "vector",
                                "HitLoc"
                            ],
                            [
                                "out",
                                "vector",
                                "HitNorm"
                            ],
                            [
                                "vector",
                                "End"
                            ],
                            [
                                "optional",
                                "vector",
                                "Start"
                            ],
                            [
                                "optional",
                                "vector",
                                "Extent"
                            ]
                        ],
                        "return": ""
                    },
                    "TravelPostAccept": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TravelPostAccept",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TravelPreAccept": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TravelPreAccept",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ],
                            [
                                "Pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    },
                    "TweenAnim": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TweenAnim",
                        "native": true,
                        "param": [
                            [
                                "name",
                                "Sequence"
                            ],
                            [
                                "float",
                                "Time"
                            ]
                        ],
                        "return": ""
                    },
                    "TweenBlendAnim": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TweenBlendAnim",
                        "native": true,
                        "param": [
                            [
                                "name",
                                "Sequence"
                            ],
                            [
                                "float",
                                "Time"
                            ],
                            [
                                "optional",
                                "int",
                                "BlendSlot"
                            ]
                        ],
                        "return": ""
                    },
                    "UnTouch": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "UnTouch",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "UnTrigger": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "UnTrigger",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ],
                            [
                                "Pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    },
                    "VisibleActors": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "VisibleActors",
                        "native": true,
                        "param": [
                            [
                                "class<actor>",
                                "BaseClass"
                            ],
                            [
                                "out",
                                "actor",
                                "Actor"
                            ],
                            [
                                "optional",
                                "float",
                                "Radius"
                            ],
                            [
                                "optional",
                                "vector",
                                "Loc"
                            ]
                        ],
                        "return": ""
                    },
                    "VisibleCollidingActors": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "VisibleCollidingActors",
                        "native": true,
                        "param": [
                            [
                                "class<actor>",
                                "BaseClass"
                            ],
                            [
                                "out",
                                "actor",
                                "Actor"
                            ],
                            [
                                "optional",
                                "float",
                                "Radius"
                            ],
                            [
                                "optional",
                                "vector",
                                "Loc"
                            ],
                            [
                                "optional",
                                "bool",
                                "bIgnoreHidden"
                            ]
                        ],
                        "return": ""
                    },
                    "ZoneChange": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ZoneChange",
                        "native": false,
                        "param": [
                            [
                                "ZoneInfo",
                                "NewZone"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 1301,
                "replication": "",
                "states": [],
                "variables": [
                    "var actor BestActor;",
                    "var float Score;",
                    "var float Visibility;",
                    "var float Volume;",
                    "var float Smell;",
                    "var(Advanced) const bool  bStatic;       // Does not move or change over time.",
                    "var(Advanced) bool        bHidden;       // Is hidden during gameplay.",
                    "var(Advanced) const bool  bNoDelete;     // Cannot be deleted during play.",
                    "var bool\t\t\t\t  bAnimFinished; // Unlooped animation sequence has finished.",
                    "var bool\t\t\t\t  bAnimLoop;     // Whether animation is looping.",
                    "var bool\t\t\t\t  bAnimNotify;   // Whether a notify is applied to the current sequence.",
                    "var bool\t\t\t\t  bAnimByOwner;\t // Animation dictated by owner.",
                    "var const bool            bDeleteMe;     // About to be deleted.",
                    "var transient const bool  bAssimilated;  // Actor dynamics are assimilated in world geometry.",
                    "var transient const bool  bTicked;       // Actor has been updated.",
                    "var transient bool        bLightChanged; // Recalculate this light's lighting now.",
                    "var bool                  bDynamicLight; // Temporarily treat this as a dynamic light.",
                    "var bool                  bTimerLoop;    // Timer loops (else is one-shot).",
                    "var(Advanced) bool        bCanTeleport;  // This actor can be teleported.",
                    "var(Advanced) bool        bIsSecretGoal; // This actor counts in the \"secret\" total.",
                    "var(Advanced) bool        bIsKillGoal;   // This actor counts in the \"death\" toll.",
                    "var(Advanced) bool        bIsItemGoal;   // This actor counts in the \"item\" count.",
                    "var(Advanced) bool\t\t  bCollideWhenPlacing; // This actor collides with the world when placing.",
                    "var(Advanced) bool\t\t  bTravel;       // Actor is capable of travelling among servers.",
                    "var(Advanced) bool\t\t  bMovable;      // Actor is capable of travelling among servers.",
                    "var(Advanced) bool        bHighDetail;\t // Only show up on high-detail.",
                    "var(Advanced) bool\t\t  bStasis;\t\t // In StandAlone games, turn off if not in a recently rendered zone turned off if  bCanStasis  and physics = PHYS_None or PHYS_Rotating.",
                    "var(Advanced) bool\t\t  bForceStasis;\t // Force stasis when not recently rendered, even if physics not none or rotating.",
                    "var const\t  bool\t\t  bIsPawn;\t\t // True only for pawns.",
                    "var(Advanced) const bool  bNetTemporary; // Tear-off simulation in network play.",
                    "var(Advanced) const bool  bNetOptional;  // Actor should only be replicated if bandwidth available.",
                    "var(Advanced) bool        bBlockSight;   // True if pawns can't see through this actor.",
                    "var(Advanced) bool        bDetectable;   // True if this actor can be detected (by sight, sound, etc).",
                    "var(Advanced) bool        bTransient;    // True if this actor should be destroyed when it goes into stasis",
                    "var           bool        bIgnore;       // True if this actor should be generally ignored; compliance is voluntary",
                    "var(Movement) const enum EPhysics",
                    "var ENetRole Role;",
                    "var(Networking) ENetRole RemoteRole;",
                    "var float LastRenderTime;",
                    "var float DistanceFromPlayer;",
                    "var         const Actor   Owner;         // Owner actor.",
                    "var(Object) name InitialState;",
                    "var(Object) name Group;",
                    "var float                 TimerRate;     // Timer event, 0=no timer.",
                    "var const float           TimerCounter;\t // Counts up until it reaches TimerRate.",
                    "var(Advanced) float\t\t  LifeSpan;      // How old the object lives before dying, 0=forever.",
                    "var(Display) name         AnimSequence;  // Animation sequence we're playing.",
                    "var(Display) float        AnimFrame;     // Current animation frame, 0.0 to 1.0.",
                    "var(Display) float        AnimRate;      // Animation rate in frames per second, 0=none, negative=velocity scaled.",
                    "var          float        TweenRate;     // Tween-into rate.",
                    "var(Display) float\t\t  LODBias;",
                    "var name\tBlendAnimSequence[4];",
                    "var float\tBlendAnimFrame[4];",
                    "var float\tBlendAnimRate[4];",
                    "var float\tBlendTweenRate[4];",
                    "var zoneinfo Zone;       // Zone.",
                    "var int      iLeaf;      // Bsp leaf.",
                    "var byte     ZoneNumber; // Zone number.",
                    "var       const LevelInfo Level;         // Level this actor is on.",
                    "var transient const Level XLevel;        // Level object.",
                    "var(Events) name\t\t  Tag;\t\t\t // Actor's tag name.",
                    "var(Events) name          Event;         // The event this actor causes.",
                    "var Actor                 Target;        // Actor we're aiming at (other uses as well).",
                    "var Pawn                  Instigator;    // Pawn responsible for damage.",
                    "var travel Inventory      Inventory;     // Inventory chain.  (DEUS_EX STM - added \"travel\")",
                    "var const Actor           Base;          // Moving brush actor we're standing on.",
                    "var const PointRegion     Region;        // Region this actor is in.",
                    "var(Movement)\tname\t  AttachTag;",
                    "var const byte            StandingCount; // Count of actors standing on this actor.",
                    "var const byte            MiscNumber;    // Internal use.",
                    "var const byte            LatentByte;    // Internal latent function use.",
                    "var const int             LatentInt;     // Internal latent function use.",
                    "var const float           LatentFloat;   // Internal latent function use.",
                    "var const actor           LatentActor;   // Internal latent function use.",
                    "var const actor           Touching[4];   // List of touching actors.",
                    "var const actor           Deleted;       // Next actor in just-deleted chain.",
                    "var const transient int CollisionTag, LightingTag, NetTag, OtherTag, ExtraTag, SpecialTag;",
                    "var(Movement) const vector Location;     // Actor's location; use Move to set.",
                    "var(Movement) const rotator Rotation;    // Rotation.",
                    "var       const vector    OldLocation;   // Actor's old location one tick ago.",
                    "var       const vector    ColLocation;   // Actor's old location one move ago.",
                    "var(Movement) vector      Velocity;      // Velocity.",
                    "var       vector          Acceleration;  // Acceleration.",
                    "var(Advanced) bool        bHiddenEd;     // Is hidden during editing.",
                    "var(Advanced) bool        bDirectional;  // Actor shows direction arrow during editing.",
                    "var const bool            bSelected;     // Selected in UnrealEd.",
                    "var const bool            bMemorized;    // Remembered in UnrealEd.",
                    "var const bool            bHighlighted;  // Highlighted in UnrealEd.",
                    "var bool                  bEdLocked;     // Locked in editor (no movement or rotation).",
                    "var(Advanced) bool        bEdShouldSnap; // Snap to grid in editor.",
                    "var transient bool        bEdSnap;       // Should snap to grid in UnrealEd.",
                    "var transient const bool  bTempEditor;   // Internal UnrealEd.",
                    "var(Filter) bool          bDifficulty0;  // Appear in difficulty 0.",
                    "var(Filter) bool          bDifficulty1;  // Appear in difficulty 1.",
                    "var(Filter) bool          bDifficulty2;  // Appear in difficulty 2.",
                    "var(Filter) bool          bDifficulty3;  // Appear in difficulty 3.",
                    "var(Filter) bool          bSinglePlayer; // Appear in single player.",
                    "var(Filter) bool          bNet;          // Appear in regular network play.",
                    "var(Filter) bool          bNetSpecial;   // Appear in special network play mode.",
                    "var(Filter) float\t\t  OddsOfAppearing; // 0-1 - chance actor will appear in relevant game modes.",
                    "var(Display) enum EDrawType",
                    "var(Display) enum ERenderStyle",
                    "var(Display) texture    Sprite;\t\t\t // Sprite texture if DrawType=DT_Sprite.",
                    "var(Display) texture    Texture;\t\t // Misc texture.",
                    "var(Display) texture    Skin;            // Special skin or enviro map texture.",
                    "var(Display) mesh       Mesh;            // Mesh if DrawType=DT_Mesh.",
                    "var const export model  Brush;           // Brush if DrawType=DT_Brush.",
                    "var(Display) float      DrawScale;\t\t // Scaling factor, 1.0=normal size.",
                    "var(Display) float      ScaleGlow;\t\t // Multiplies lighting.",
                    "var(Display) byte       AmbientGlow;     // Ambient brightness, or 255=pulsing.",
                    "var(Display) byte       Fatness;         // Fatness (mesh distortion).",
                    "var(Display)  bool      bUnlit;          // Lights don't affect actor.",
                    "var(Display)  bool      bNoSmooth;       // Don't smooth actor's texture.",
                    "var(Display)  bool      bParticles;      // Mesh is a particle system.",
                    "var(Display)  bool      bRandomFrame;    // Particles use a random texture from among the default texture and the multiskins textures",
                    "var(Display)  bool      bMeshEnviroMap;  // Environment-map the mesh.",
                    "var(Display)  bool      bMeshCurvy;      // Curvy mesh.",
                    "var(Display)  float     VisibilityRadius;// Actor is drawn if viewer is within its visibility",
                    "var(Display)  float     VisibilityHeight;// cylinder.  Zero=infinite visibility.",
                    "var(Display) bool       bShadowCast;     // Casts shadows.",
                    "var(Advanced) bool\t\tbOwnerNoSee;\t // Everything but the owner can see this actor.",
                    "var(Advanced) bool      bOnlyOwnerSee;   // Only owner can see this actor.",
                    "var Const     bool\t\tbIsMover;\t\t // Is a mover.",
                    "var(Advanced) bool\t\tbAlwaysRelevant; // Always relevant for network.",
                    "var Const\t  bool\t\tbAlwaysTick;     // Update even when players-only.",
                    "var(Advanced) bool\t\tbGameRelevant;\t // Always relevant for game",
                    "var(Display) texture MultiSkins[8];",
                    "var(Sound) byte         SoundRadius;\t // Radius of ambient sound.",
                    "var(Sound) byte         SoundVolume;\t // Volume of amient sound.",
                    "var(Sound) byte         SoundPitch;\t     // Sound pitch shift, 64.0=none.",
                    "var(Sound) sound        AmbientSound;    // Ambient sound effect.",
                    "var(Sound) float TransientSoundVolume;",
                    "var(Sound) float TransientSoundRadius;",
                    "var(Collision) const float CollisionRadius; // Radius of collision cyllinder.",
                    "var(Collision) const float CollisionHeight; // Half-height cyllinder.",
                    "var(Collision) const bool bCollideActors;   // Collides with other actors.",
                    "var(Collision) bool       bCollideWorld;    // Collides with the world.",
                    "var(Collision) bool       bBlockActors;\t    // Blocks other nonplayer actors.",
                    "var(Collision) bool       bBlockPlayers;    // Blocks other player actors.",
                    "var(Collision) bool       bProjTarget;      // Projectiles should potentially target this actor.",
                    "var(Lighting) enum ELightType",
                    "var(Lighting) enum ELightEffect",
                    "var(LightColor) byte",
                    "var(Lighting) byte",
                    "var(Lighting) bool\t     bSpecialLit;\t // Only affects special-lit surfaces.",
                    "var(Lighting) bool\t     bActorShadows;  // Light casts actor shadows.",
                    "var(Lighting) bool\t     bCorona;        // Light uses Skin as a corona.",
                    "var(Lighting) bool\t     bLensFlare;     // Whether to use zone lens flare.",
                    "var(Movement) bool        bBounce;           // Bounces when hits ground fast.",
                    "var(Movement) bool\t\t  bFixedRotationDir; // Fixed direction of rotation.",
                    "var(Movement) bool\t\t  bRotateToDesired;  // Rotate to DesiredRotation.",
                    "var           bool        bInterpolating;    // Performing interpolating.",
                    "var enum EDodgeDir",
                    "var(Movement) float       Mass;            // Mass of this actor.",
                    "var(Movement) float       Buoyancy;        // Water buoyancy.",
                    "var(Movement) rotator\t  RotationRate;    // Change in rotation per second.",
                    "var(Movement) rotator     DesiredRotation; // Physics will rotate pawn to this if bRotateToDesired.",
                    "var           float       PhysAlpha;       // Interpolating position, 0.0-1.0.",
                    "var           float       PhysRate;        // Interpolation rate per second.",
                    "var          float        AnimLast;        // Last frame.",
                    "var          float        AnimMinRate;     // Minimum rate for velocity-scaled animation.",
                    "var          float        BlendAnimLast[4];        // Last frame.",
                    "var          float        BlendAnimMinRate[4];     // Minimum rate for velocity-scaled animation.",
                    "var(Conversation) String BindName;\t\t\t\t\t// Used to bind conversations",
                    "var(Conversation) String BarkBindName;\t\t\t\t// Used to bind Barks!",
                    "var(Conversation) localized String FamiliarName;\t// For display in Conversations",
                    "var(Conversation) localized String UnfamiliarName;\t// For display in Conversations",
                    "var transient Object     ConListItems;\t\t\t\t// List of ConListItems for this Actor",
                    "var(Conversation) float  ConStartInterval;\t\t\t// Amount of time required between two convos.",
                    "var(Smell)   class<SmellNode> SmellClass;",
                    "var          SmellNode        LastSmellNode;",
                    "var(Advanced) bool            bOwned;",
                    "var bool bVisionImportant;",
                    "var(Networking) float NetPriority; // Higher priorities means update it more frequently.",
                    "var(Networking) float NetUpdateFrequency; // How many seconds between net updates.",
                    "var(Networking) float RelevantRadius; //Radius in which things are always relevant.",
                    "var const bool bNetInitial;       // Initial network update.",
                    "var const bool bNetOwner;         // Player owns this actor.",
                    "var const bool bNetRelevant;      // Actor is currently relevant. Only valid server side, only when replicating variables.",
                    "var const bool bNetSee;           // Player sees it in network play.",
                    "var const bool bNetHear;          // Player hears it in network play.",
                    "var const bool bNetFeel;          // Player collides with/feels it in network play.",
                    "var const bool bSimulatedPawn;\t  // True if Pawn and simulated proxy.",
                    "var const bool bDemoRecording;\t  // True we are currently demo recording",
                    "var const bool bClientDemoRecording;// True we are currently recording a client-side demo",
                    "var const bool bClientDemoNetFunc;// True if we're client-side demo recording and this call originated from the remote.",
                    "var(Display) class<RenderIterator> RenderIteratorClass;\t// class to instantiate as the actor's RenderInterface",
                    "var transient RenderIterator RenderInterface;\t\t// abstract iterator initialized in the Rendering engine"
                ]
            }
        },
        "AmbientSound.uc": {
            "body": "//=============================================================================\n// Ambient sound, sits there and emits its sound.  This class is no different \n// than placing any other actor in a level and setting its ambient sound.\n//=============================================================================\nclass AmbientSound extends Keypoint;\n\n// Import the sprite.\n#exec Texture Import File=Textures\\Ambient.pcx Name=S_Ambient Mips=Off Flags=2\n\ndefaultproperties\n{\n     Texture=Texture'Engine.S_Ambient'\n     SoundRadius=64\n     SoundVolume=190\n}\n",
            "name": "AmbientSound.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Texture=Texture'Engine.S_Ambient'",
                    "SoundRadius=64",
                    "SoundVolume=190"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Ambient.pcx Name=S_Ambient Mips=Off Flags=2"
                ],
                "extends": "Keypoint",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 16,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "Ambushpoint.uc": {
            "body": "//=============================================================================\n// Ambushpoint.\n//=============================================================================\nclass AmbushPoint extends NavigationPoint;\n\nvar vector lookdir; //direction to look while ambushing\n//at start, ambushing creatures will pick either their current location, or the location of\n//some ambushpoint belonging to their team\nvar byte survivecount; //used when picking ambushpoint \nvar() float SightRadius; // How far bot at this point should look for enemies\nvar() bool\tbSniping;\t// bots should snipe from this position\n\nfunction PreBeginPlay()\n{\n\tlookdir = 2000 * vector(Rotation);\n\n\tSuper.PreBeginPlay();\n}\n\ndefaultproperties\n{\n     SightRadius=5000.000000\n     bDirectional=True\n     SoundVolume=128\n}\n",
            "name": "Ambushpoint.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "SightRadius=5000.000000",
                    "bDirectional=True",
                    "SoundVolume=128"
                ],
                "exec": [],
                "extends": "NavigationPoint",
                "functions": {
                    "PreBeginPlay": {
                        "body": "{\n\tlookdir = 2000 * vector(Rotation);\n\n\tSuper.PreBeginPlay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 26,
                "replication": "",
                "states": [],
                "variables": [
                    "var vector lookdir; //direction to look while ambushing",
                    "var byte survivecount; //used when picking ambushpoint",
                    "var() float SightRadius; // How far bot at this point should look for enemies",
                    "var() bool\tbSniping;\t// bots should snipe from this position"
                ]
            }
        },
        "Ammo.uc": {
            "body": "//=============================================================================\n// Ammo.\n//=============================================================================\nclass Ammo extends Pickup\n\tabstract;\n\n#exec Texture Import File=Textures\\Ammo.pcx Name=S_Ammo Mips=Off Flags=2\n\nvar() travel int AmmoAmount;\nvar() travel int MaxAmmo;\nvar() class<ammo> ParentAmmo;    // Class of ammo to be represented in inventory\nvar() byte UsedInWeaponSlot[10];\nvar   ammo  PAmmo;\n\n\n\n// Network replication\n//\nreplication\n{\n\t// Things the server should send to the client.\n\treliable if( Role==ROLE_Authority && bNetOwner )\n\t\tAmmoAmount;\n}\n\nevent float BotDesireability(Pawn Bot)\n{\n\tlocal Ammo AlreadyHas;\n\n\tif ( ParentAmmo != None )\n\t\tAlreadyHas = Ammo(Bot.FindInventoryType(ParentAmmo));\n\telse\n\t\tAlreadyHas = Ammo(Bot.FindInventoryType(Class));\n\tif ( AlreadyHas == None )\n\t\treturn (0.35 * MaxDesireability);\n\tif ( AlreadyHas.AmmoAmount == 0 )\n\t\treturn MaxDesireability;\n\tif (AlreadyHas.AmmoAmount >= AlreadyHas.MaxAmmo) \n\t\treturn -1;\n\n\treturn ( MaxDesireability * FMin(1, 0.15 * MaxAmmo/AlreadyHas.AmmoAmount) );\n}\n\nfunction bool HandlePickupQuery( inventory Item )\n{\n\tif ( (class == item.class) || \n\t\t(ClassIsChildOf(item.class, class'Ammo') && (class == Ammo(item).parentammo)) ) \n\t{\n\t\tif (AmmoAmount==MaxAmmo) return true;\n\t\tif (Level.Game.LocalLog != None)\n\t\t\tLevel.Game.LocalLog.LogPickup(Item, Pawn(Owner));\n\t\tif (Level.Game.WorldLog != None)\n\t\t\tLevel.Game.WorldLog.LogPickup(Item, Pawn(Owner));\n\t\tif (Item.PickupMessageClass == None)\n\t\t\t// DEUS_EX CNN - use the itemArticle and itemName\n//\t\t\tPawn(Owner).ClientMessage( Item.PickupMessage, 'Pickup' );\n\t\t\tPawn(Owner).ClientMessage( Item.PickupMessage @ Item.itemArticle @ Item.ItemName, 'Pickup' );\n\t\telse\n\t\t\tPawn(Owner).ReceiveLocalizedMessage( Item.PickupMessageClass, 0, None, None, item.Class );\n\t\titem.PlaySound( item.PickupSound );\n\t\tAddAmmo(Ammo(item).AmmoAmount);\n\t\titem.SetRespawn();\n\t\treturn true;\t\t\t\t\n\t}\n\tif ( Inventory == None )\n\t\treturn false;\n\n\treturn Inventory.HandlePickupQuery(Item);\n}\n\nsimulated function bool SimUseAmmo();\n\n// This function is called by an actor that wants to use ammo.  \n// Return true if ammo exists \n//\nfunction bool UseAmmo(int AmountNeeded)\n{\n\tif (AmmoAmount < AmountNeeded) return False;   // Can't do it\n\tAmmoAmount -= AmountNeeded;\n\treturn True;\n}\n\n// If we can, add ammo and return true.  \n// We we are at max ammo, return false\n//\nfunction bool AddAmmo(int AmmoToAdd)\n{\n\tIf (AmmoAmount >= MaxAmmo) return false;\n\tAmmoAmount += AmmoToAdd;\n\tif (AmmoAmount > MaxAmmo) AmmoAmount = MaxAmmo;\n\treturn true;\n}\n\nfunction inventory SpawnCopy( Pawn Other )\n{\n\tlocal Inventory Copy;\n\n\tif ( parentammo != None )\n\t{\n\t\tCopy = spawn(parentammo,Other,,,rot(0,0,0));\n\t\tCopy.Tag           = Tag;\n\t\tCopy.Event         = Event;\n\t\tCopy.Instigator    = Other;\n\t\tAmmo(Copy).AmmoAmount = AmmoAmount;\n\t\tCopy.BecomeItem();\n\t\tOther.AddInventory( Copy );\n\t\tCopy.GotoState('');\n\t\tif ( Level.Game.ShouldRespawn(self) )\n\t\t\tGotoState('Sleeping');\n\t\telse\n\t\t\tDestroy();\n\t\treturn Copy;\n\t}\n\tCopy = Super.SpawnCopy(Other);\n\tAmmo(Copy).AmmoAmount = AmmoAmount; \n\treturn Copy;\n}\n\ndefaultproperties\n{\n     PickupMessage=\"You picked up some ammo.\"\n     RespawnTime=30.000000\n     MaxDesireability=0.200000\n     Texture=Texture'Engine.S_Ammo'\n     bCollideActors=False\n}\n",
            "name": "Ammo.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "PickupMessage=\"You picked up some ammo.\"",
                    "RespawnTime=30.000000",
                    "MaxDesireability=0.200000",
                    "Texture=Texture'Engine.S_Ammo'",
                    "bCollideActors=False"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Ammo.pcx Name=S_Ammo Mips=Off Flags=2"
                ],
                "extends": "Pickup",
                "functions": {
                    "AddAmmo": {
                        "body": "{\n\tIf (AmmoAmount >= MaxAmmo) return false;\n\tAmmoAmount += AmmoToAdd;\n\tif (AmmoAmount > MaxAmmo) AmmoAmount = MaxAmmo;\n\treturn true;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AddAmmo",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "AmmoToAdd"
                            ]
                        ],
                        "return": "bool"
                    },
                    "BotDesireability": {
                        "body": "{\n\n\tif ( ParentAmmo != None )\n\t\tAlreadyHas = Ammo(Bot.FindInventoryType(ParentAmmo));\n\telse\n\t\tAlreadyHas = Ammo(Bot.FindInventoryType(Class));\n\tif ( AlreadyHas == None )\n\t\treturn (0.35 * MaxDesireability);\n\tif ( AlreadyHas.AmmoAmount == 0 )\n\t\treturn MaxDesireability;\n\tif (AlreadyHas.AmmoAmount >= AlreadyHas.MaxAmmo) \n\t\treturn -1;\n\n\treturn ( MaxDesireability * FMin(1, 0.15 * MaxAmmo/AlreadyHas.AmmoAmount) );\n}",
                        "locals": [
                            "local Ammo AlreadyHas;"
                        ],
                        "modifiers": [],
                        "name": "BotDesireability",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Bot"
                            ]
                        ],
                        "return": "float"
                    },
                    "HandlePickupQuery": {
                        "body": "{\n\tif ( (class == item.class) || \n\t\t(ClassIsChildOf(item.class, class'Ammo') && (class == Ammo(item).parentammo)) ) \n\t{\n\t\tif (AmmoAmount==MaxAmmo) return true;\n\t\tif (Level.Game.LocalLog != None)\n\t\t\tLevel.Game.LocalLog.LogPickup(Item, Pawn(Owner));\n\t\tif (Level.Game.WorldLog != None)\n\t\t\tLevel.Game.WorldLog.LogPickup(Item, Pawn(Owner));\n\t\tif (Item.PickupMessageClass == None)\n\t\t\t// DEUS_EX CNN - use the itemArticle and itemName\n//\t\t\tPawn(Owner).ClientMessage( Item.PickupMessage, 'Pickup' );\n\t\t\tPawn(Owner).ClientMessage( Item.PickupMessage @ Item.itemArticle @ Item.ItemName, 'Pickup' );\n\t\telse\n\t\t\tPawn(Owner).ReceiveLocalizedMessage( Item.PickupMessageClass, 0, None, None, item.Class );\n\t\titem.PlaySound( item.PickupSound );\n\t\tAddAmmo(Ammo(item).AmmoAmount);\n\t\titem.SetRespawn();\n\t\treturn true;\t\t\t\t\n\t}\n\tif ( Inventory == None )\n\t\treturn false;\n\n\treturn Inventory.HandlePickupQuery(Item);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "HandlePickupQuery",
                        "native": false,
                        "param": [
                            [
                                "inventory",
                                "Item"
                            ]
                        ],
                        "return": "bool"
                    },
                    "SimUseAmmo": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "SimUseAmmo",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "SpawnCopy": {
                        "body": "{\n\n\tif ( parentammo != None )\n\t{\n\t\tCopy = spawn(parentammo,Other,,,rot(0,0,0));\n\t\tCopy.Tag           = Tag;\n\t\tCopy.Event         = Event;\n\t\tCopy.Instigator    = Other;\n\t\tAmmo(Copy).AmmoAmount = AmmoAmount;\n\t\tCopy.BecomeItem();\n\t\tOther.AddInventory( Copy );\n\t\tCopy.GotoState('');\n\t\tif ( Level.Game.ShouldRespawn(self) )\n\t\t\tGotoState('Sleeping');\n\t\telse\n\t\t\tDestroy();\n\t\treturn Copy;\n\t}\n\tCopy = Super.SpawnCopy(Other);\n\tAmmo(Copy).AmmoAmount = AmmoAmount; \n\treturn Copy;\n}",
                        "locals": [
                            "local Inventory Copy;"
                        ],
                        "modifiers": [],
                        "name": "SpawnCopy",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": "inventory"
                    },
                    "UseAmmo": {
                        "body": "{\n\tif (AmmoAmount < AmountNeeded) return False;   // Can't do it\n\tAmmoAmount -= AmountNeeded;\n\treturn True;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UseAmmo",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "AmountNeeded"
                            ]
                        ],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 127,
                "replication": "",
                "states": [],
                "variables": [
                    "var() travel int AmmoAmount;",
                    "var() travel int MaxAmmo;",
                    "var() class<ammo> ParentAmmo;    // Class of ammo to be represented in inventory",
                    "var() byte UsedInWeaponSlot[10];",
                    "var   ammo  PAmmo;"
                ]
            }
        },
        "Bitmap.uc": {
            "body": "//=============================================================================\n// Bitmap: An abstract bitmap.\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass Bitmap extends Object\n\tnative\n\tnoexport;\n\n// Texture format.\nvar const enum ETextureFormat\n{\n\tTEXF_P8,\n\tTEXF_RGB32,\n\tTEXF_RGB64,\n\tTEXF_DXT1,\n\tTEXF_RGB24\n} Format;\n\n// Palette.\nvar(Texture) palette Palette;\n\n// Internal info.\nvar const byte  UBits, VBits;\nvar const int   USize, VSize;\nvar(Texture) const int UClamp, VClamp;\nvar const color MipZero;\nvar const color MaxColor;\nvar const int   InternalTime[2];\n\ndefaultproperties\n{\n     MipZero=(R=64,G=128,B=64)\n     MaxColor=(R=255,G=255,B=255,A=255)\n}\n",
            "name": "Bitmap.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "MipZero=(R=64,G=128,B=64)",
                    "MaxColor=(R=255,G=255,B=255,A=255)"
                ],
                "exec": [],
                "extends": "Object",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 35,
                "replication": "",
                "states": [],
                "variables": [
                    "var const enum ETextureFormat",
                    "var(Texture) palette Palette;",
                    "var const byte  UBits, VBits;",
                    "var const int   USize, VSize;",
                    "var(Texture) const int UClamp, VClamp;",
                    "var const color MipZero;",
                    "var const color MaxColor;",
                    "var const int   InternalTime[2];"
                ]
            }
        },
        "BlockAll.uc": {
            "body": "//=============================================================================\n// Blocks all actors from passing.\n//=============================================================================\nclass BlockAll extends Keypoint;\n\ndefaultproperties\n{\n     bCollideActors=True\n     bBlockActors=True\n     bBlockPlayers=True\n}\n",
            "name": "BlockAll.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bCollideActors=True",
                    "bBlockActors=True",
                    "bBlockPlayers=True"
                ],
                "exec": [],
                "extends": "Keypoint",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 12,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "BlockMonsters.uc": {
            "body": "//=============================================================================\n// BlockMonsters prevents monsters from passing, but allows players and projectiles to cross.\n//=============================================================================\nclass BlockMonsters extends Keypoint;\n\ndefaultproperties\n{\n     bCollideActors=True\n     bBlockActors=True\n}\n",
            "name": "BlockMonsters.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bCollideActors=True",
                    "bBlockActors=True"
                ],
                "exec": [],
                "extends": "Keypoint",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 11,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "BlockPlayer.uc": {
            "body": "//=============================================================================\n// BlockPlayers prevents players from passing, but allows monsters and projectiles to cross.\n//=============================================================================\nclass BlockPlayer extends Keypoint;\n\ndefaultproperties\n{\n     bBlockPlayers=True\n}\n",
            "name": "BlockPlayer.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bBlockPlayers=True"
                ],
                "exec": [],
                "extends": "Keypoint",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 10,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "Brush.uc": {
            "body": "//=============================================================================\n// The brush class.\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass Brush extends Actor\n\tnative;\n\n//-----------------------------------------------------------------------------\n// Variables.\n\n// CSG operation performed in editor.\nvar() enum ECsgOper\n{\n\tCSG_Active,\t\t\t// Active brush.\n\tCSG_Add,\t\t\t// Add to world.\n\tCSG_Subtract,\t\t// Subtract from world.\n\tCSG_Intersect,\t\t// Form from intersection with world.\n\tCSG_Deintersect,\t// Form from negative intersection with world.\n} CsgOper;\n\n// Outdated.\nvar const object UnusedLightMesh;\nvar vector  PostPivot;\n\n// Scaling.\nvar() scale MainScale;\nvar() scale PostScale;\nvar scale   TempScale;\n\n// Information.\nvar() color BrushColor;\nvar() int\tPolyFlags;\nvar() bool  bColored;\n\ndefaultproperties\n{\n     MainScale=(Scale=(X=1.000000,Y=1.000000,Z=1.000000))\n     PostScale=(Scale=(X=1.000000,Y=1.000000,Z=1.000000))\n     TempScale=(Scale=(X=1.000000,Y=1.000000,Z=1.000000))\n     bStatic=True\n     bNoDelete=True\n     bEdShouldSnap=True\n     DrawType=DT_Brush\n     bFixedRotationDir=True\n}\n",
            "name": "Brush.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "MainScale=(Scale=(X=1.000000,Y=1.000000,Z=1.000000))",
                    "PostScale=(Scale=(X=1.000000,Y=1.000000,Z=1.000000))",
                    "TempScale=(Scale=(X=1.000000,Y=1.000000,Z=1.000000))",
                    "bStatic=True",
                    "bNoDelete=True",
                    "bEdShouldSnap=True",
                    "DrawType=DT_Brush",
                    "bFixedRotationDir=True"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 46,
                "replication": "",
                "states": [],
                "variables": [
                    "var() enum ECsgOper",
                    "var const object UnusedLightMesh;",
                    "var vector  PostPivot;",
                    "var() scale MainScale;",
                    "var() scale PostScale;",
                    "var scale   TempScale;",
                    "var() color BrushColor;",
                    "var() int\tPolyFlags;",
                    "var() bool  bColored;"
                ]
            }
        },
        "ButtonMarker.uc": {
            "body": "//=============================================================================\n// ButtonMarker.\n//=============================================================================\nclass ButtonMarker extends NavigationPoint\n\tnative;\n\n// OBSOLETE - TO BE REMOVED\n\ndefaultproperties\n{\n}\n",
            "name": "ButtonMarker.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "NavigationPoint",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 12,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "Camera.uc": {
            "body": "//=============================================================================\n// A camera, used in UnrealEd.\n//=============================================================================\nclass Camera extends PlayerPawn\n\tnative;\n\n// Sprite.\n#exec Texture Import File=Textures\\S_Camera.pcx Name=S_Camera Mips=Off Flags=2\n\ndefaultproperties\n{\n     Location=(X=-500.000000,Y=-300.000000,Z=300.000000)\n     Texture=Texture'Engine.S_Camera'\n     CollisionRadius=16.000000\n     CollisionHeight=39.000000\n     LightBrightness=100\n     LightRadius=16\n}\n",
            "name": "Camera.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Location=(X=-500.000000,Y=-300.000000,Z=300.000000)",
                    "Texture=Texture'Engine.S_Camera'",
                    "CollisionRadius=16.000000",
                    "CollisionHeight=39.000000",
                    "LightBrightness=100",
                    "LightRadius=16"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\S_Camera.pcx Name=S_Camera Mips=Off Flags=2"
                ],
                "extends": "PlayerPawn",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 19,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "CameraPoint.uc": {
            "body": "//=============================================================================\n// CameraPoint.\n//=============================================================================\nclass CameraPoint extends Keypoint\n\tnative;\n\n//\n// DEUS_EX CNN\n// CameraPoint.uc - Cinematic camera control script\n// These points are to be placed in the editor to control\n// the camera during a cinematic cut-scene.\n//\n\nenum ECameraCommand\n{\n\tCAMCMD_MOVE,\t\t\t\t\t\t// cut (or smoothly move if timeSmooth > 0) to XYZPYR\n\tCAMCMD_PUSH,\t\t\t\t\t\t// move forward along view axis\n\tCAMCMD_FOV,\t\t\t\t\t\t\t// change FOV\n\tCAMCMD_TILT,\t\t\t\t\t\t// change Pitch\n\tCAMCMD_PAN,\t\t\t\t\t\t\t// change Yaw\n\tCAMCMD_ROLL,\t\t\t\t\t\t// change Roll\n\tCAMCMD_WAIT,\t\t\t\t\t\t// wait time or for a specific event\n\tCAMCMD_TRIGGER\t\t\t\t\t\t// trigger an event\n};\n\nvar() ECameraCommand\tcmd;\t\t\t// what command to execute\nvar() float\t\t\t\tvalue;\t\t\t// parameter for command\nvar() name\t\t\t\teventName;\t\t// used by CAMCMD_WAIT_EVENT\nvar() float\t\t\t\ttimeSmooth;\t\t// execute command smoothly over time (0 = instant)\nvar() float\t\t\t\ttimeWaitPost;\t// delay after executing command\nvar() bool\t\t\t\tbParallel;\t\t// execute the next command simultaneously\nvar() bool\t\t\t\tbRandom;\t\t// the next point is chosen at random from other bRandoms\nvar() int\t\t\t\trandomCount;\t// number of times to choose randomly\nvar() int\t\t\t\tpostRandomNum;\t// sequence to start at after random sequence\n\n// internal vars not editable by the user\nvar() const int\t\t\tsequenceNum;\t// assigned in editor automatically\nvar CameraPoint\t\t\tnextPoint;\t\t// next point to be executed - points linked at runtime\nvar CameraPoint\t\t\tprevPoint;\t\t// point that was just executed - used by bParallel\nvar float\t\t\t\tcurTime;\t\t// timer used by movement routines\nvar vector\t\t\t\tstartLoc;\t\t// init location at beginning of command\nvar rotator\t\t\t\tstartRot;\t\t// init rotation at beginning of command\nvar float\t\t\t\tstartFOV;\t\t// init FOV at beginning of command\nvar vector\t\t\t\tendLoc;\t\t\t// dest location\nvar rotator\t\t\t\tendRot;\t\t\t// dest rotation\nvar float\t\t\t\tendFOV;\t\t\t// dest FOV\nvar PlayerPawn\t\t\tPlayer;\t\t\t// which player is being controlled\nvar bool\t\t\t\tbTickReady;\t\t// can we tick now?\nvar bool\t\t\t\tbFirstRandom;\t// are we the first random point in this sequence?\nvar int\t\t\t\t\trandomRemain;\t// how many random choices are left?\nvar CameraPoint\t\t\tcontinuePoint;\t// where we continue after a random sequence\n\n// link all CameraPoints together\nfunction InitAllPoints()\n{\n\tlocal CameraPoint cur, next;\n\tlocal int num;\n\tlocal rotator rot;\n\n\tcur = Self;\n\tnum = 0;\n\twhile (num != 999999)\n\t{\n\t\tnum = 999999;\n\t\tforeach AllActors(class'CameraPoint', next)\n\t\t{\n\t\t\t// clamp the rotation\n\t\t\trot.Pitch = Rotation.Pitch % 65536;\n\t\t\trot.Yaw = Rotation.Yaw % 65536;\n\t\t\trot.Roll = Rotation.Roll % 65536;\n\t\t\tSetRotation(rot);\n\n\t\t\t// find the next highest number in the sequence\n\t\t\tif ((next.sequenceNum < num) && (next.sequenceNum > cur.sequenceNum))\n\t\t\t{\n\t\t\t\tnum = next.sequenceNum;\n\t\t\t\tcur.nextPoint = next;\n\t\t\t}\n\t\t}\n\n\t\tif (num != 999999)\n\t\t{\n//\t\t\tlog(\"** CameraPoint.InitAllPoints - linked \"$cur.sequenceNum$\" to \"$num);\n\t\t\tcur = cur.nextPoint;\n\t\t}\n\t}\n}\n\n//\n// state control code\n//\nauto state Idle\n{\n\t// wait to be triggered\n\tfunction Trigger(Actor Other, Pawn Instigator)\n\t{\n\t\tSuper.Trigger(Other, Instigator);\n\t\tTag = '';\n\t\tNext();\n\t}\n\nBegin:\n\t// find the player in this level\n\t// if there's not a player, destroy ourself\n\tPlayer = GetPlayerPawn();\n\tif (Player == None)\n\t{\n\t\tlog(\"** WARNING - CameraPoint.Idle.Begin() - \"$sequenceNum$\" - can't find the player!\");\n\t\tDestroy();\n\t\tStop;\n\t}\n\n\t// if we are the first one, link up the points and begin execution\n\tif (sequenceNum == 0)\n\t{\n\t\t// grab the player, make it not collide, and freeze it's controls\n\t\tPlayer.GotoState('Paralyzed', 'Letterbox');\n\t\tPlayer.bHidden = True;\n\t\tPlayer.bCollideWorld = False;\n\t\tPlayer.SetCollision(False, False, False);\n\t\tPlayer.BaseEyeHeight = 0.0;\n\t\tif (Player.Shadow != None)\n\t\t{\n\t\t\tPlayer.Shadow.Destroy();\n\t\t\tPlayer.Shadow = None;\n\t\t}\n\t\tInitAllPoints();\n\t\tGotoState('Running');\n\t}\n\nWait:\n\t// do nothing until somebody wakes us up\n\tStop;\n}\n\nstate Running\n{\n\t// used for smooth moves/rotations\n\tfunction Tick(float deltaTime)\n\t{\n\t\tlocal float alpha, beta;\n\t\tlocal vector loc;\n\t\tlocal rotator rot, diffrot;\n\t\tlocal float fov;\n\n\t\tif (!bTickReady)\n\t\t\treturn;\n\n\t\tSuper.Tick(deltaTime);\n\n\t\t// update the timer and see if we're done\n\t\tcurTime += deltaTime;\n\n\t\tif (curTime >= timeSmooth)\n\t\t{\n\t\t\tPlayer.ViewRotation = endRot;\n\t\t\tPlayer.SetLocation(endLoc);\n\t\t\tPlayer.SetFOVAngle(endFOV);\n\t\t\tPlayer.DesiredFOV = endFOV;\n\t\t\tNext();\n\t\t}\n\t\telse\n\t\t{\n\t\t\talpha = curTime / timeSmooth;\n\n\t\t\t// make sure we rotate the shortest direction\n\t\t\tdiffrot = endRot - startRot;\n\n\t\t\tif (diffrot.Pitch >= 32768)\n\t\t\t\tdiffrot.Pitch = diffrot.Pitch - 65536;\n\t\t\telse if (diffrot.Pitch <= -32768)\n\t\t\t\tdiffrot.Pitch = diffrot.Pitch + 65536;\n\n\t\t\tif (diffrot.Yaw >= 32768)\n\t\t\t\tdiffrot.Yaw = diffrot.Yaw - 65536;\n\t\t\telse if (diffrot.Yaw <= -32768)\n\t\t\t\tdiffrot.Yaw = diffrot.Yaw + 65536;\n\n\t\t\tif (diffrot.Roll >= 32768)\n\t\t\t\tdiffrot.Roll = diffrot.Roll - 65536;\n\t\t\telse if (diffrot.Roll <= -32768)\n\t\t\t\tdiffrot.Roll = diffrot.Roll + 65536;\n\n\t\t\t// calculate our smoothing coefficient\n\t\t\tbeta = 3.0*alpha*alpha - 2.0*alpha*alpha*alpha;\n\n\t\t\t// smooth the camera rotation, movement, and FOV\n\t\t\trot = startRot + beta * diffrot;\n\t\t\tloc = startLoc + beta * (endLoc - startLoc);\n\t\t\tfov = startFOV + beta * (endFOV - startFOV);\n\n\t\t\tPlayer.SetLocation(loc);\n\t\t\tPlayer.ViewRotation = rot;\n\t\t\tPlayer.SetFOVAngle(fov);\n\t\t\tPlayer.DesiredFOV = fov;\n\t\t}\n\t}\n\nBegin:\n//\tlog(\"** starting \"$sequenceNum);\n\t// save the starting location/rotation\n\tstartLoc = Player.Location;\n\tstartRot = Player.ViewRotation;\n\tstartFOV = Player.FOVAngle;\n\n\t// init the destination\n\tendLoc = startLoc;\n\tendRot = startRot;\n\tendFOV = startFOV;\n\n\t// evaluate the command\n\tEvaluateCommand();\n\tbTickReady = True;\n\n\t// should we execute the next command in parallel?\n\tif (bParallel)\n\t{\n\t\tnextPoint.prevPoint = Self;\n\t\tNext();\n\t}\n\n\tStop;\n\nNext:\n\tif (!bParallel)\n\t\tbTickReady = False;\n\n\t// if there's a postdelay, wait for it\n\tif (timeWaitPost > 0.0)\n\t\tSleep(timeWaitPost);\n\n\tif (bRandom && !bParallel)\n\t{\n\t\tbTickReady = False;\n\n\t\t// if this is the first random encounter, set some values\n\t\tif (randomRemain == -1)\n\t\t{\n\t\t\tbFirstRandom = True;\n\t\t\trandomRemain = randomCount;\n\t\t\tSetContinuePoint();\n\t\t}\n\n\t\t// if we're done being random, continue where we left off\n\t\tif (randomRemain == 0)\n\t\t\tcontinuePoint.WakeUp();\n\t\telse\n\t\t\tWakeUpRandomPoint();\n\t}\n\telse if (nextPoint != None)\n\t\tnextPoint.WakeUp();\n//\telse\n//\t\tlog(\"** CameraPoint.Running.Next - \"$sequenceNum$\" - finished with path!\");\n\nWait:\n\tGoToSleep();\n}\n\n\n//\n// state control functions\n//\n\n// called to find another random camerapoint\nfunction WakeUpRandomPoint()\n{\n\tlocal CameraPoint point;\n\tlocal int count, rnd;\n\n\t// count how many there are\n\tcount = 0;\n\tforeach AllActors(class'CameraPoint', point)\n\t\tif (point.bRandom)\n\t\t\tcount++;\n\n\t// pick one at random\n\trnd = Rand(count);\n\tcount = 0;\n\tforeach AllActors(class'CameraPoint', point)\n\t\tif (point.bRandom && (count++ == rnd))\n\t\t{\n\t\t\tpoint.randomRemain = randomRemain - 1;\n\t\t\tpoint.continuePoint = continuePoint;\n\t\t\tpoint.WakeUp();\n\t\t\tbreak;\n\t\t}\n}\n\n// called to set the point to continue at after the random sequence\nfunction SetContinuePoint()\n{\n\tlocal CameraPoint point;\n\t\n\tforeach AllActors(class'CameraPoint', point)\n\t\tif (point.sequenceNum == postRandomNum)\n\t\t{\n\t\t\tcontinuePoint = point;\n\t\t\tbreak;\n\t\t}\n}\n\n// called when command is complete to move on to next command\nfunction Next()\n{\n\tGotoState('Running', 'Next');\n}\n\n// called to wake this camerapoint up\nfunction WakeUp()\n{\n\tGotoState('Running', 'Begin');\n}\n\n// called to put this camerapoint into it's idle state\nfunction GoToSleep()\n{\n\tif (IsInState('Running'))\n\t\tGotoState('Idle', 'Wait');\n\telse\n\t\tlog(\"** WARNING - CameraPoint.GoToSleep() - \"$sequenceNum$\" - already sleeping!\");\n}\n\n// wait for the timer to expire\nfunction Timer()\n{\n\tNext();\n}\n\n// evaluate the current command\nfunction bool EvaluateCommand()\n{\n\tlocal vector loc;\n\tlocal Actor A;\n\n\tloc = vect(0,0,0);\n\n\t// init the movement timer\n\tcurTime = 0.0;\n\n//\tlog(\"** CameraPoint.EvaluateCommand - \"$sequenceNum$\" - cmd = \"$cmd$\" value = \"$value$\" eventName = \"$eventName);\n\n\tswitch (cmd)\n\t{\n\t\tcase CAMCMD_MOVE:\t\tendLoc = Location;\n\t\t\t\t\t\t\t\tendRot = Rotation;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_PUSH:\t\tloc.X = value;\n\t\t\t\t\t\t\t\tendLoc += (loc >> Player.ViewRotation);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_FOV:\t\tendFOV += value;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_TILT:\t\tendRot.Pitch += value;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_PAN:\t\tendRot.Yaw += value;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_ROLL:\t\tendRot.Roll += value;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_WAIT:\t\tif (eventName != '')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tTag = eventName;\n\t\t\t\t\t\t\t\t\tGoToSleep();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tSetTimer(timeSmooth, False);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_TRIGGER:\tif (eventName != '')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tforeach AllActors(class'Actor', A, eventName)\n\t\t\t\t\t\t\t\t\t\tA.Trigger(None, None);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t}\n\n\t// if we are running in parallel with the previous point,\n\t// add its parameters to ours\n\tif (prevPoint != None)\n\t{\n\t\tendLoc += prevPoint.endLoc - prevPoint.startLoc;\n\t\tendRot += prevPoint.endRot - prevPoint.startRot;\n\t\tendFOV += prevPoint.endFOV - prevPoint.startFOV;\n\t}\n}\n\ndefaultproperties\n{\n     randomRemain=-1\n     bStatic=False\n     bDirectional=True\n     Texture=Texture'Engine.S_Camera'\n}\n",
            "name": "CameraPoint.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "randomRemain=-1",
                    "bStatic=False",
                    "bDirectional=True",
                    "Texture=Texture'Engine.S_Camera'"
                ],
                "exec": [],
                "extends": "Keypoint",
                "functions": {
                    "EvaluateCommand": {
                        "body": "{\n\n\tloc = vect(0,0,0);\n\n\t// init the movement timer\n\tcurTime = 0.0;\n\n//\tlog(\"** CameraPoint.EvaluateCommand - \"$sequenceNum$\" - cmd = \"$cmd$\" value = \"$value$\" eventName = \"$eventName);\n\n\tswitch (cmd)\n\t{\n\t\tcase CAMCMD_MOVE:\t\tendLoc = Location;\n\t\t\t\t\t\t\t\tendRot = Rotation;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_PUSH:\t\tloc.X = value;\n\t\t\t\t\t\t\t\tendLoc += (loc >> Player.ViewRotation);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_FOV:\t\tendFOV += value;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_TILT:\t\tendRot.Pitch += value;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_PAN:\t\tendRot.Yaw += value;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_ROLL:\t\tendRot.Roll += value;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_WAIT:\t\tif (eventName != '')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tTag = eventName;\n\t\t\t\t\t\t\t\t\tGoToSleep();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tSetTimer(timeSmooth, False);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\tcase CAMCMD_TRIGGER:\tif (eventName != '')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tforeach AllActors(class'Actor', A, eventName)\n\t\t\t\t\t\t\t\t\t\tA.Trigger(None, None);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t}\n\n\t// if we are running in parallel with the previous point,\n\t// add its parameters to ours\n\tif (prevPoint != None)\n\t{\n\t\tendLoc += prevPoint.endLoc - prevPoint.startLoc;\n\t\tendRot += prevPoint.endRot - prevPoint.startRot;\n\t\tendFOV += prevPoint.endFOV - prevPoint.startFOV;\n\t}\n}",
                        "locals": [
                            "local vector loc;",
                            "local Actor A;"
                        ],
                        "modifiers": [],
                        "name": "EvaluateCommand",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "GoToSleep": {
                        "body": "{\n\tif (IsInState('Running'))\n\t\tGotoState('Idle', 'Wait');\n\telse\n\t\tlog(\"** WARNING - CameraPoint.GoToSleep() - \"$sequenceNum$\" - already sleeping!\");\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GoToSleep",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "InitAllPoints": {
                        "body": "{\n\n\tcur = Self;\n\tnum = 0;\n\twhile (num != 999999)\n\t{\n\t\tnum = 999999;\n\t\tforeach AllActors(class'CameraPoint', next)\n\t\t{\n\t\t\t// clamp the rotation\n\t\t\trot.Pitch = Rotation.Pitch % 65536;\n\t\t\trot.Yaw = Rotation.Yaw % 65536;\n\t\t\trot.Roll = Rotation.Roll % 65536;\n\t\t\tSetRotation(rot);\n\n\t\t\t// find the next highest number in the sequence\n\t\t\tif ((next.sequenceNum < num) && (next.sequenceNum > cur.sequenceNum))\n\t\t\t{\n\t\t\t\tnum = next.sequenceNum;\n\t\t\t\tcur.nextPoint = next;\n\t\t\t}\n\t\t}\n\n\t\tif (num != 999999)\n\t\t{\n//\t\t\tlog(\"** CameraPoint.InitAllPoints - linked \"$cur.sequenceNum$\" to \"$num);\n\t\t\tcur = cur.nextPoint;\n\t\t}\n\t}\n}",
                        "locals": [
                            "local CameraPoint cur, next;",
                            "local int num;",
                            "local rotator rot;"
                        ],
                        "modifiers": [],
                        "name": "InitAllPoints",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Next": {
                        "body": "{\n\tGotoState('Running', 'Next');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Next",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetContinuePoint": {
                        "body": "{\n\t\n\tforeach AllActors(class'CameraPoint', point)\n\t\tif (point.sequenceNum == postRandomNum)\n\t\t{\n\t\t\tcontinuePoint = point;\n\t\t\tbreak;\n\t\t}\n}",
                        "locals": [
                            "local CameraPoint point;"
                        ],
                        "modifiers": [],
                        "name": "SetContinuePoint",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n\n\t\tif (!bTickReady)\n\t\t\treturn;\n\n\t\tSuper.Tick(deltaTime);\n\n\t\t// update the timer and see if we're done\n\t\tcurTime += deltaTime;\n\n\t\tif (curTime >= timeSmooth)\n\t\t{\n\t\t\tPlayer.ViewRotation = endRot;\n\t\t\tPlayer.SetLocation(endLoc);\n\t\t\tPlayer.SetFOVAngle(endFOV);\n\t\t\tPlayer.DesiredFOV = endFOV;\n\t\t\tNext();\n\t\t}\n\t\telse\n\t\t{\n\t\t\talpha = curTime / timeSmooth;\n\n\t\t\t// make sure we rotate the shortest direction\n\t\t\tdiffrot = endRot - startRot;\n\n\t\t\tif (diffrot.Pitch >= 32768)\n\t\t\t\tdiffrot.Pitch = diffrot.Pitch - 65536;\n\t\t\telse if (diffrot.Pitch <= -32768)\n\t\t\t\tdiffrot.Pitch = diffrot.Pitch + 65536;\n\n\t\t\tif (diffrot.Yaw >= 32768)\n\t\t\t\tdiffrot.Yaw = diffrot.Yaw - 65536;\n\t\t\telse if (diffrot.Yaw <= -32768)\n\t\t\t\tdiffrot.Yaw = diffrot.Yaw + 65536;\n\n\t\t\tif (diffrot.Roll >= 32768)\n\t\t\t\tdiffrot.Roll = diffrot.Roll - 65536;\n\t\t\telse if (diffrot.Roll <= -32768)\n\t\t\t\tdiffrot.Roll = diffrot.Roll + 65536;\n\n\t\t\t// calculate our smoothing coefficient\n\t\t\tbeta = 3.0*alpha*alpha - 2.0*alpha*alpha*alpha;\n\n\t\t\t// smooth the camera rotation, movement, and FOV\n\t\t\trot = startRot + beta * diffrot;\n\t\t\tloc = startLoc + beta * (endLoc - startLoc);\n\t\t\tfov = startFOV + beta * (endFOV - startFOV);\n\n\t\t\tPlayer.SetLocation(loc);\n\t\t\tPlayer.ViewRotation = rot;\n\t\t\tPlayer.SetFOVAngle(fov);\n\t\t\tPlayer.DesiredFOV = fov;\n\t\t}\n\t}",
                        "locals": [
                            "local float alpha, beta;",
                            "local vector loc;",
                            "local rotator rot, diffrot;",
                            "local float fov;"
                        ],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "deltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tNext();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "{\n\t\tSuper.Trigger(Other, Instigator);\n\t\tTag = '';\n\t\tNext();\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ],
                            [
                                "Pawn",
                                "Instigator"
                            ]
                        ],
                        "return": ""
                    },
                    "WakeUp": {
                        "body": "{\n\tGotoState('Running', 'Begin');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "WakeUp",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "WakeUpRandomPoint": {
                        "body": "{\n\n\t// count how many there are\n\tcount = 0;\n\tforeach AllActors(class'CameraPoint', point)\n\t\tif (point.bRandom)\n\t\t\tcount++;\n\n\t// pick one at random\n\trnd = Rand(count);\n\tcount = 0;\n\tforeach AllActors(class'CameraPoint', point)\n\t\tif (point.bRandom && (count++ == rnd))\n\t\t{\n\t\t\tpoint.randomRemain = randomRemain - 1;\n\t\t\tpoint.continuePoint = continuePoint;\n\t\t\tpoint.WakeUp();\n\t\t\tbreak;\n\t\t}\n}",
                        "locals": [
                            "local CameraPoint point;",
                            "local int count, rnd;"
                        ],
                        "modifiers": [],
                        "name": "WakeUpRandomPoint",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 398,
                "replication": "",
                "states": [],
                "variables": [
                    "var() ECameraCommand\tcmd;\t\t\t// what command to execute",
                    "var() float\t\t\t\tvalue;\t\t\t// parameter for command",
                    "var() name\t\t\t\teventName;\t\t// used by CAMCMD_WAIT_EVENT",
                    "var() float\t\t\t\ttimeSmooth;\t\t// execute command smoothly over time (0 = instant)",
                    "var() float\t\t\t\ttimeWaitPost;\t// delay after executing command",
                    "var() bool\t\t\t\tbParallel;\t\t// execute the next command simultaneously",
                    "var() bool\t\t\t\tbRandom;\t\t// the next point is chosen at random from other bRandoms",
                    "var() int\t\t\t\trandomCount;\t// number of times to choose randomly",
                    "var() int\t\t\t\tpostRandomNum;\t// sequence to start at after random sequence",
                    "var() const int\t\t\tsequenceNum;\t// assigned in editor automatically",
                    "var CameraPoint\t\t\tnextPoint;\t\t// next point to be executed - points linked at runtime",
                    "var CameraPoint\t\t\tprevPoint;\t\t// point that was just executed - used by bParallel",
                    "var float\t\t\t\tcurTime;\t\t// timer used by movement routines",
                    "var vector\t\t\t\tstartLoc;\t\t// init location at beginning of command",
                    "var rotator\t\t\t\tstartRot;\t\t// init rotation at beginning of command",
                    "var float\t\t\t\tstartFOV;\t\t// init FOV at beginning of command",
                    "var vector\t\t\t\tendLoc;\t\t\t// dest location",
                    "var rotator\t\t\t\tendRot;\t\t\t// dest rotation",
                    "var float\t\t\t\tendFOV;\t\t\t// dest FOV",
                    "var PlayerPawn\t\t\tPlayer;\t\t\t// which player is being controlled",
                    "var bool\t\t\t\tbTickReady;\t\t// can we tick now?",
                    "var bool\t\t\t\tbFirstRandom;\t// are we the first random point in this sequence?",
                    "var int\t\t\t\t\trandomRemain;\t// how many random choices are left?",
                    "var CameraPoint\t\t\tcontinuePoint;\t// where we continue after a random sequence"
                ]
            }
        },
        "Canvas.uc": {
            "body": "//=============================================================================\n// Canvas: A drawing canvas.\n// This is a built-in Unreal class and it shouldn't be modified.\n//\n// Notes.\n//   To determine size of a drawable object, set Style to STY_None,\n//   remember CurX, draw the thing, then inspect CurX and CurYL.\n//=============================================================================\nclass Canvas extends Object\n\tnative\n\tnoexport;\n\n// Objects.\n#exec Font Import File=Textures\\SmallFont.bmp   Name=SmallFont\n\n// DEUS_EX AJY\n#exec Font Import File=Textures\\MedFont.pcx Name=MedFont\n#exec Font Import File=Textures\\BigFont.pcx Name=BigFont\n#exec new TrueTypeFontFactory Name=\"LargeFont\" FontName=\"HandelGothic BT\" Height=32 AntiAlias=1 XPad=2 CharactersPerPage=64\n\n\n// Modifiable properties.\nvar font    Font;            // Font for DrawText.\nvar float   SpaceX, SpaceY;  // Spacing for after Draw*.\nvar float   OrgX, OrgY;      // Origin for drawing.\nvar float   ClipX, ClipY;    // Bottom right clipping region.\nvar float   CurX, CurY;      // Current position for drawing.\nvar float   Z;               // Z location. 1=no screenflash, 2=yes screenflash.\nvar byte    Style;           // Drawing style STY_None means don't draw.\nvar float   CurYL;           // Largest Y size since DrawText.\nvar color   DrawColor;       // Color for drawing.\nvar bool    bCenter;         // Whether to center the text.\nvar bool    bNoSmooth;       // Don't bilinear filter.\nvar const int SizeX, SizeY;  // Zero-based actual dimensions.\n\n// Stock fonts.\nvar font SmallFont;          // Small system font.\nvar font MedFont;            // Medium system font.\nvar font BigFont;            // Big system font.\nvar font LargeFont;          // Large system font.\n\n// Internal.\nvar const viewport Viewport; // Viewport that owns the canvas.\nvar const int FramePtr;      // Scene frame pointer.\nvar const int RenderPtr;\t // Render device pointer, only valid during UGameEngine::Draw\n\n// native functions.\nnative(464) final function StrLen( coerce string String, out float XL, out float YL );\nnative(465) final function DrawText( coerce string Text, optional bool CR );\nnative(466) final function DrawTile( texture Tex, float XL, float YL, float U, float V, float UL, float VL );\nnative(467) final function DrawActor( Actor A, bool WireFrame, optional bool ClearZ );\nnative(468) final function DrawTileClipped( texture Tex, float XL, float YL, float U, float V, float UL, float VL );\nnative(469) final function DrawTextClipped( coerce string Text, optional bool bCheckHotKey );\nnative(470) final function TextSize( coerce string String, out float XL, out float YL );\nnative(471) final function DrawClippedActor( Actor A, bool WireFrame, int X, int Y, int XB, int YB, optional bool ClearZ );\nnative(480) final function DrawPortal( int X, int Y, int Width, int Height, actor CamActor, vector CamLocation, rotator CamRotation, optional int FOV, optional bool ClearZ );\n\n// UnrealScript functions.\nevent Reset()\n{\n\tFont        = Default.Font;\n\tSpaceX      = Default.SpaceX;\n\tSpaceY      = Default.SpaceY;\n\tOrgX        = Default.OrgX;\n\tOrgY        = Default.OrgY;\n\tCurX        = Default.CurX;\n\tCurY        = Default.CurY;\n\tStyle       = Default.Style;\n\tDrawColor   = Default.DrawColor;\n\tCurYL       = Default.CurYL;\n\tbCenter     = false;\n\tbNoSmooth   = false;\n\tZ           = 1.0;\n}\nfinal function SetPos( float X, float Y )\n{\n\tCurX = X;\n\tCurY = Y;\n}\nfinal function SetOrigin( float X, float Y )\n{\n\tOrgX = X;\n\tOrgY = Y;\n}\nfinal function SetClip( float X, float Y )\n{\n\tClipX = X;\n\tClipY = Y;\n}\nfinal function DrawPattern( texture Tex, float XL, float YL, float Scale )\n{\n\tDrawTile( Tex, XL, YL, (CurX-OrgX)*Scale, (CurY-OrgY)*Scale, XL*Scale, YL*Scale );\n}\nfinal function DrawIcon( texture Tex, float Scale )\n{\n\tif ( Tex != None )\n\t\tDrawTile( Tex, Tex.USize*Scale, Tex.VSize*Scale, 0, 0, Tex.USize, Tex.VSize );\n}\nfinal function DrawRect( texture Tex, float RectX, float RectY )\n{\n\tDrawTile( Tex, RectX, RectY, 0, 0, Tex.USize, Tex.VSize );\n}\n\ndefaultproperties\n{\n     Z=1.000000\n     Style=1\n     DrawColor=(R=127,G=127,B=127)\n     SmallFont=Font'Engine.SmallFont'\n     MedFont=Font'Engine.MedFont'\n     BigFont=Font'Engine.BigFont'\n     LargeFont=Font'Engine.LargeFont'\n}\n",
            "name": "Canvas.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Z=1.000000",
                    "Style=1",
                    "DrawColor=(R=127,G=127,B=127)",
                    "SmallFont=Font'Engine.SmallFont'",
                    "MedFont=Font'Engine.MedFont'",
                    "BigFont=Font'Engine.BigFont'",
                    "LargeFont=Font'Engine.LargeFont'"
                ],
                "exec": [
                    "#exec Font Import File=Textures\\SmallFont.bmp   Name=SmallFont",
                    "#exec Font Import File=Textures\\MedFont.pcx Name=MedFont",
                    "#exec Font Import File=Textures\\BigFont.pcx Name=BigFont",
                    "#exec new TrueTypeFontFactory Name=\"LargeFont\" FontName=\"HandelGothic BT\" Height=32 AntiAlias=1 XPad=2 CharactersPerPage=64"
                ],
                "extends": "Object",
                "functions": {
                    "DrawActor": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawActor",
                        "native": true,
                        "param": [
                            [
                                "Actor",
                                "A"
                            ],
                            [
                                "bool",
                                "WireFrame"
                            ],
                            [
                                "optional",
                                "bool",
                                "ClearZ"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawClippedActor": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawClippedActor",
                        "native": true,
                        "param": [
                            [
                                "Actor",
                                "A"
                            ],
                            [
                                "bool",
                                "WireFrame"
                            ],
                            [
                                "int",
                                "X"
                            ],
                            [
                                "int",
                                "Y"
                            ],
                            [
                                "int",
                                "XB"
                            ],
                            [
                                "int",
                                "YB"
                            ],
                            [
                                "optional",
                                "bool",
                                "ClearZ"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawIcon": {
                        "body": "{\n\tif ( Tex != None )\n\t\tDrawTile( Tex, Tex.USize*Scale, Tex.VSize*Scale, 0, 0, Tex.USize, Tex.VSize );\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "DrawIcon",
                        "native": false,
                        "param": [
                            [
                                "texture",
                                "Tex"
                            ],
                            [
                                "float",
                                "Scale"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawPattern": {
                        "body": "{\n\tDrawTile( Tex, XL, YL, (CurX-OrgX)*Scale, (CurY-OrgY)*Scale, XL*Scale, YL*Scale );\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "DrawPattern",
                        "native": false,
                        "param": [
                            [
                                "texture",
                                "Tex"
                            ],
                            [
                                "float",
                                "XL"
                            ],
                            [
                                "float",
                                "YL"
                            ],
                            [
                                "float",
                                "Scale"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawPortal": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawPortal",
                        "native": true,
                        "param": [
                            [
                                "int",
                                "X"
                            ],
                            [
                                "int",
                                "Y"
                            ],
                            [
                                "int",
                                "Width"
                            ],
                            [
                                "int",
                                "Height"
                            ],
                            [
                                "actor",
                                "CamActor"
                            ],
                            [
                                "vector",
                                "CamLocation"
                            ],
                            [
                                "rotator",
                                "CamRotation"
                            ],
                            [
                                "optional",
                                "int",
                                "FOV"
                            ],
                            [
                                "optional",
                                "bool",
                                "ClearZ"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawRect": {
                        "body": "{\n\tDrawTile( Tex, RectX, RectY, 0, 0, Tex.USize, Tex.VSize );\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "DrawRect",
                        "native": false,
                        "param": [
                            [
                                "texture",
                                "Tex"
                            ],
                            [
                                "float",
                                "RectX"
                            ],
                            [
                                "float",
                                "RectY"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawText": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawText",
                        "native": true,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "Text"
                            ],
                            [
                                "optional",
                                "bool",
                                "CR"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawTextClipped": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawTextClipped",
                        "native": true,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "Text"
                            ],
                            [
                                "optional",
                                "bool",
                                "bCheckHotKey"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawTile": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawTile",
                        "native": true,
                        "param": [
                            [
                                "texture",
                                "Tex"
                            ],
                            [
                                "float",
                                "XL"
                            ],
                            [
                                "float",
                                "YL"
                            ],
                            [
                                "float",
                                "U"
                            ],
                            [
                                "float",
                                "V"
                            ],
                            [
                                "float",
                                "UL"
                            ],
                            [
                                "float",
                                "VL"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawTileClipped": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawTileClipped",
                        "native": true,
                        "param": [
                            [
                                "texture",
                                "Tex"
                            ],
                            [
                                "float",
                                "XL"
                            ],
                            [
                                "float",
                                "YL"
                            ],
                            [
                                "float",
                                "U"
                            ],
                            [
                                "float",
                                "V"
                            ],
                            [
                                "float",
                                "UL"
                            ],
                            [
                                "float",
                                "VL"
                            ]
                        ],
                        "return": ""
                    },
                    "Reset": {
                        "body": "{\n\tFont        = Default.Font;\n\tSpaceX      = Default.SpaceX;\n\tSpaceY      = Default.SpaceY;\n\tOrgX        = Default.OrgX;\n\tOrgY        = Default.OrgY;\n\tCurX        = Default.CurX;\n\tCurY        = Default.CurY;\n\tStyle       = Default.Style;\n\tDrawColor   = Default.DrawColor;\n\tCurYL       = Default.CurYL;\n\tbCenter     = false;\n\tbNoSmooth   = false;\n\tZ           = 1.0;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Reset",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetClip": {
                        "body": "{\n\tClipX = X;\n\tClipY = Y;\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "SetClip",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "X"
                            ],
                            [
                                "float",
                                "Y"
                            ]
                        ],
                        "return": ""
                    },
                    "SetOrigin": {
                        "body": "{\n\tOrgX = X;\n\tOrgY = Y;\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "SetOrigin",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "X"
                            ],
                            [
                                "float",
                                "Y"
                            ]
                        ],
                        "return": ""
                    },
                    "SetPos": {
                        "body": "{\n\tCurX = X;\n\tCurY = Y;\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "SetPos",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "X"
                            ],
                            [
                                "float",
                                "Y"
                            ]
                        ],
                        "return": ""
                    },
                    "StrLen": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "StrLen",
                        "native": true,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "String"
                            ],
                            [
                                "out",
                                "float",
                                "XL"
                            ],
                            [
                                "out",
                                "float",
                                "YL"
                            ]
                        ],
                        "return": ""
                    },
                    "TextSize": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TextSize",
                        "native": true,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "String"
                            ],
                            [
                                "out",
                                "float",
                                "XL"
                            ],
                            [
                                "out",
                                "float",
                                "YL"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 114,
                "replication": "",
                "states": [],
                "variables": [
                    "var font    Font;            // Font for DrawText.",
                    "var float   SpaceX, SpaceY;  // Spacing for after Draw*.",
                    "var float   OrgX, OrgY;      // Origin for drawing.",
                    "var float   ClipX, ClipY;    // Bottom right clipping region.",
                    "var float   CurX, CurY;      // Current position for drawing.",
                    "var float   Z;               // Z location. 1=no screenflash, 2=yes screenflash.",
                    "var byte    Style;           // Drawing style STY_None means don't draw.",
                    "var float   CurYL;           // Largest Y size since DrawText.",
                    "var color   DrawColor;       // Color for drawing.",
                    "var bool    bCenter;         // Whether to center the text.",
                    "var bool    bNoSmooth;       // Don't bilinear filter.",
                    "var const int SizeX, SizeY;  // Zero-based actual dimensions.",
                    "var font SmallFont;          // Small system font.",
                    "var font MedFont;            // Medium system font.",
                    "var font BigFont;            // Big system font.",
                    "var font LargeFont;          // Large system font.",
                    "var const viewport Viewport; // Viewport that owns the canvas.",
                    "var const int FramePtr;      // Scene frame pointer.",
                    "var const int RenderPtr;\t // Render device pointer, only valid during UGameEngine::Draw"
                ]
            }
        },
        "Carcass.uc": {
            "body": "//=============================================================================\n// Carcass.\n//=============================================================================\nclass Carcass extends Decoration\n\tnative;\n\n// Sprite.\n#exec Texture Import File=Textures\\Corpse.pcx Name=S_Corpse Mips=Off Flags=2\n\n// Variables.\nvar bool bPlayerCarcass;\nvar() byte flies;\nvar() byte rats;\nvar() bool bReducedHeight;\nvar bool bDecorative;\nvar bool bSlidingCarcass;\nvar int CumulativeDamage;\nvar PlayerReplicationInfo PlayerOwner;\n\nvar Pawn Bugs;\n\n\tfunction CreateReplacement()\n\t{\n\t\tif (Bugs != None)\n\t\t\tBugs.Destroy();\n\t}\n\n\tfunction Destroyed()\n\t{\n\t\tlocal Actor A;\n\n\t\tif (Bugs != None)\n\t\t\tBugs.Destroy();\n\t\t\t\t\n\t\tSuper.Destroyed();\n\t}\n\n\tfunction Initfor(actor Other)\n\t{\n\t\t//implemented in subclasses\n\t}\n\t\t\t\n\tfunction ChunkUp(int Damage)\n\t{\n\t\tdestroy();\n\t}\n\t\n\tstatic simulated function bool AllowChunk(int N, name A)\n\t{\n\t\treturn true;\n\t}\n\n\tfunction TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation, \n\t\t\t\t\t\t\tVector momentum, name damageType)\n\t{\n\t\tif ( !bDecorative )\n\t\t{\n\t\t\tbBobbing = false;\n\t\t\tSetPhysics(PHYS_Falling);\n\t\t}\n\t\tif ( (Physics == PHYS_None) && (Momentum.Z < 0) )\n\t\t\tMomentum.Z *= -1;\n\t\tVelocity += 3 * momentum/(Mass + 200);\n\t\tif ( DamageType == 'shot' )\n\t\t\tDamage *= 0.4;\n\t\tCumulativeDamage += Damage;\n\t\tif ( (((Damage > 30) || !IsAnimating()) && (CumulativeDamage > 0.8 * Mass)) || (Damage > 0.4 * Mass) \n\t\t\t|| ((Velocity.Z > 150) && !IsAnimating()) )\n\t\t\tChunkUp(Damage);\n\t\tif ( bDecorative )\n\t\t\tVelocity = vect(0,0,0);\n\t}\n\nauto state Dying\n{\n\tignores TakeDamage;\n\nBegin:\n\tSleep(0.2);\n\tGotoState('Dead');\n}\n\t\nstate Dead \n{\n\tfunction Timer()\n\t{\n\t\tlocal bool bSeen;\n\t\tlocal Pawn aPawn;\n\t\tlocal float dist;\n\n\t\tif ( Region.Zone.NumCarcasses <= Region.Zone.MaxCarcasses )\n\t\t{\n\t\t\tif ( !PlayerCanSeeMe() )\n\t\t\t\tDestroy();\n\t\t\telse\n\t\t\t\tSetTimer(2.0, false);\t\n\t\t}\n\t\telse\n\t\t\tDestroy();\n\t}\n\t\n\tfunction AddFliesAndRats()\n\t{\n\t}\n\n\tfunction CheckZoneCarcasses()\n\t{\n\t}\n\t\n\tfunction BeginState()\n\t{\n\t\tif ( bDecorative )\n\t\t\tlifespan = 0.0;\n\t\telse\n\t\t\tSetTimer(18.0, false);\n\t}\n\t\t\t\nBegin:\n\tFinishAnim();\n\tSleep(5.0);\n\tCheckZoneCarcasses();\n\tSleep(7.0);\n\tif ( !bDecorative && !bHidden && !Region.Zone.bWaterZone && !Region.Zone.bPainZone )\n\t\tAddFliesAndRats();\t\n}\n\ndefaultproperties\n{\n     bDecorative=True\n     bStatic=False\n     bStasis=False\n     Physics=PHYS_Falling\n     LifeSpan=180.000000\n     AnimSequence=Dead\n     AnimFrame=0.900000\n     DrawType=DT_Mesh\n     Texture=Texture'Engine.S_Corpse'\n     CollisionRadius=18.000000\n     CollisionHeight=4.000000\n     bCollideActors=True\n     bCollideWorld=True\n     bProjTarget=True\n     Mass=180.000000\n     Buoyancy=105.000000\n}\n",
            "name": "Carcass.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bDecorative=True",
                    "bStatic=False",
                    "bStasis=False",
                    "Physics=PHYS_Falling",
                    "LifeSpan=180.000000",
                    "AnimSequence=Dead",
                    "AnimFrame=0.900000",
                    "DrawType=DT_Mesh",
                    "Texture=Texture'Engine.S_Corpse'",
                    "CollisionRadius=18.000000",
                    "CollisionHeight=4.000000",
                    "bCollideActors=True",
                    "bCollideWorld=True",
                    "bProjTarget=True",
                    "Mass=180.000000",
                    "Buoyancy=105.000000"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Corpse.pcx Name=S_Corpse Mips=Off Flags=2"
                ],
                "extends": "Decoration",
                "functions": {
                    "AddFliesAndRats": {
                        "body": "{\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AddFliesAndRats",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AllowChunk": {
                        "body": "{\n\t\treturn true;\n\t}",
                        "locals": [],
                        "modifiers": [
                            "static",
                            "simulated"
                        ],
                        "name": "AllowChunk",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "N"
                            ],
                            [
                                "name",
                                "A"
                            ]
                        ],
                        "return": "bool"
                    },
                    "BeginState": {
                        "body": "{\n\t\tif ( bDecorative )\n\t\t\tlifespan = 0.0;\n\t\telse\n\t\t\tSetTimer(18.0, false);\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CheckZoneCarcasses": {
                        "body": "{\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CheckZoneCarcasses",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ChunkUp": {
                        "body": "{\n\t\tdestroy();\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChunkUp",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Damage"
                            ]
                        ],
                        "return": ""
                    },
                    "CreateReplacement": {
                        "body": "{\n\t\tif (Bugs != None)\n\t\t\tBugs.Destroy();\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CreateReplacement",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Destroyed": {
                        "body": "{\n\n\t\tif (Bugs != None)\n\t\t\tBugs.Destroy();\n\t\t\t\t\n\t\tSuper.Destroyed();\n\t}",
                        "locals": [
                            "local Actor A;"
                        ],
                        "modifiers": [],
                        "name": "Destroyed",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Initfor": {
                        "body": "{\n\t\t//implemented in subclasses\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Initfor",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\n\t\tif ( Region.Zone.NumCarcasses <= Region.Zone.MaxCarcasses )\n\t\t{\n\t\t\tif ( !PlayerCanSeeMe() )\n\t\t\t\tDestroy();\n\t\t\telse\n\t\t\t\tSetTimer(2.0, false);\t\n\t\t}\n\t\telse\n\t\t\tDestroy();\n\t}",
                        "locals": [
                            "local bool bSeen;",
                            "local Pawn aPawn;",
                            "local float dist;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 146,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool bPlayerCarcass;",
                    "var() byte flies;",
                    "var() byte rats;",
                    "var() bool bReducedHeight;",
                    "var bool bDecorative;",
                    "var bool bSlidingCarcass;",
                    "var int CumulativeDamage;",
                    "var PlayerReplicationInfo PlayerOwner;",
                    "var Pawn Bugs;"
                ]
            }
        },
        "Console.uc": {
            "body": "//=============================================================================\n// Console: A player console, associated with a viewport.\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass Console extends Object\n\tnative\n\tnoexport\n\ttransient;\n\n// Imports.\n#exec Texture Import NAME=ConsoleBack File=Textures\\Console.pcx\n#exec Texture Import File=Textures\\Border.pcx\n\n// Internal.\nvar private const int vtblOut;\n\n// Constants.\nconst MaxBorder=6;\nconst MaxLines=64;\nconst MaxHistory=16;\nconst TextMsgSize=128;\n\n// Variables.\nvar viewport Viewport;\nvar int HistoryTop, HistoryBot, HistoryCur;\nvar string TypedStr, History[16];\nvar int Scrollback, NumLines, TopLine, TextLines;\nvar float MsgTime, MsgTickTime;\nvar string MsgText[64];\nvar name MsgType[64];\nvar PlayerReplicationInfo MsgPlayer[64];\nvar float MsgTick[64];\nvar int BorderSize;\nvar int ConsoleLines, BorderLines, BorderPixels;\nvar float ConsolePos, ConsoleDest;\nvar float FrameX, FrameY;\nvar texture ConBackground, Border;\nvar bool bNoStuff, bTyping;\nvar bool bNoDrawWorld;\n\n// Timedemo\nvar bool bTimeDemo;\nvar bool bStartTimeDemo;\nvar bool bRestartTimeDemo;\nvar bool bSaveTimeDemoToFile;\nvar float StartTime;\nvar float ExtraTime;\nvar float LastFrameTime;\nvar float LastSecondStartTime;\nvar int FrameCount;\nvar int LastSecondFrameCount;\nvar float MinFPS;\nvar float MaxFPS;\t\t\nvar float LastSecFPS;\nvar Font TimeDemoFont;\n\nvar localized string LoadingMessage;\nvar localized string SavingMessage;\nvar localized string ConnectingMessage;\nvar localized string PausedMessage;\nvar localized string PrecachingMessage;\n\n\nvar localized string FrameRateText;\nvar localized string AvgText;\nvar localized string LastSecText;\nvar localized string MinText;\nvar localized string MaxText;\nvar localized string fpsText;\nvar localized string SecondsText;\nvar localized string FramesText;\n\n//-----------------------------------------------------------------------------\n// Input.\n\n// Input system states.\nenum EInputAction\n{\n\tIST_None,    // Not performing special input processing.\n\tIST_Press,   // Handling a keypress or button press.\n\tIST_Hold,    // Handling holding a key or button.\n\tIST_Release, // Handling a key or button release.\n\tIST_Axis,    // Handling analog axis movement.\n};\n\n// Input keys.\nenum EInputKey\n{\n/*00*/\tIK_None\t\t\t,IK_LeftMouse\t,IK_RightMouse\t,IK_Cancel\t\t,\n/*04*/\tIK_MiddleMouse\t,IK_Unknown05\t,IK_Unknown06\t,IK_Unknown07\t,\n/*08*/\tIK_Backspace\t,IK_Tab         ,IK_Unknown0A\t,IK_Unknown0B\t,\n/*0C*/\tIK_Unknown0C\t,IK_Enter\t    ,IK_Unknown0E\t,IK_Unknown0F\t,\n/*10*/\tIK_Shift\t\t,IK_Ctrl\t    ,IK_Alt\t\t\t,IK_Pause       ,\n/*14*/\tIK_CapsLock\t\t,IK_Unknown15\t,IK_Unknown16\t,IK_Unknown17\t,\n/*18*/\tIK_Unknown18\t,IK_Unknown19\t,IK_Unknown1A\t,IK_Escape\t\t,\n/*1C*/\tIK_Unknown1C\t,IK_Unknown1D\t,IK_Unknown1E\t,IK_Unknown1F\t,\n/*20*/\tIK_Space\t\t,IK_PageUp      ,IK_PageDown    ,IK_End         ,\n/*24*/\tIK_Home\t\t\t,IK_Left        ,IK_Up          ,IK_Right       ,\n/*28*/\tIK_Down\t\t\t,IK_Select      ,IK_Print       ,IK_Execute     ,\n/*2C*/\tIK_PrintScrn\t,IK_Insert      ,IK_Delete      ,IK_Help\t\t,\n/*30*/\tIK_0\t\t\t,IK_1\t\t\t,IK_2\t\t\t,IK_3\t\t\t,\n/*34*/\tIK_4\t\t\t,IK_5\t\t\t,IK_6\t\t\t,IK_7\t\t\t,\n/*38*/\tIK_8\t\t\t,IK_9\t\t\t,IK_Unknown3A\t,IK_Unknown3B\t,\n/*3C*/\tIK_Unknown3C\t,IK_Unknown3D\t,IK_Unknown3E\t,IK_Unknown3F\t,\n/*40*/\tIK_Unknown40\t,IK_A\t\t\t,IK_B\t\t\t,IK_C\t\t\t,\n/*44*/\tIK_D\t\t\t,IK_E\t\t\t,IK_F\t\t\t,IK_G\t\t\t,\n/*48*/\tIK_H\t\t\t,IK_I\t\t\t,IK_J\t\t\t,IK_K\t\t\t,\n/*4C*/\tIK_L\t\t\t,IK_M\t\t\t,IK_N\t\t\t,IK_O\t\t\t,\n/*50*/\tIK_P\t\t\t,IK_Q\t\t\t,IK_R\t\t\t,IK_S\t\t\t,\n/*54*/\tIK_T\t\t\t,IK_U\t\t\t,IK_V\t\t\t,IK_W\t\t\t,\n/*58*/\tIK_X\t\t\t,IK_Y\t\t\t,IK_Z\t\t\t,IK_Unknown5B\t,\n/*5C*/\tIK_Unknown5C\t,IK_Unknown5D\t,IK_Unknown5E\t,IK_Unknown5F\t,\n/*60*/\tIK_NumPad0\t\t,IK_NumPad1     ,IK_NumPad2     ,IK_NumPad3     ,\n/*64*/\tIK_NumPad4\t\t,IK_NumPad5     ,IK_NumPad6     ,IK_NumPad7     ,\n/*68*/\tIK_NumPad8\t\t,IK_NumPad9     ,IK_GreyStar    ,IK_GreyPlus    ,\n/*6C*/\tIK_Separator\t,IK_GreyMinus\t,IK_NumPadPeriod,IK_GreySlash   ,\n/*70*/\tIK_F1\t\t\t,IK_F2          ,IK_F3          ,IK_F4          ,\n/*74*/\tIK_F5\t\t\t,IK_F6          ,IK_F7          ,IK_F8          ,\n/*78*/\tIK_F9           ,IK_F10         ,IK_F11         ,IK_F12         ,\n/*7C*/\tIK_F13\t\t\t,IK_F14         ,IK_F15         ,IK_F16         ,\n/*80*/\tIK_F17\t\t\t,IK_F18         ,IK_F19         ,IK_F20         ,\n/*84*/\tIK_F21\t\t\t,IK_F22         ,IK_F23         ,IK_F24         ,\n/*88*/\tIK_Unknown88\t,IK_Unknown89\t,IK_Unknown8A\t,IK_Unknown8B\t,\n/*8C*/\tIK_Unknown8C\t,IK_Unknown8D\t,IK_Unknown8E\t,IK_Unknown8F\t,\n/*90*/\tIK_NumLock\t\t,IK_ScrollLock  ,IK_Unknown92\t,IK_Unknown93\t,\n/*94*/\tIK_Unknown94\t,IK_Unknown95\t,IK_Unknown96\t,IK_Unknown97\t,\n/*98*/\tIK_Unknown98\t,IK_Unknown99\t,IK_Unknown9A\t,IK_Unknown9B\t,\n/*9C*/\tIK_Unknown9C\t,IK_Unknown9D\t,IK_Unknown9E\t,IK_Unknown9F\t,\n/*A0*/\tIK_LShift\t\t,IK_RShift      ,IK_LControl    ,IK_RControl    ,\n/*A4*/\tIK_UnknownA4\t,IK_UnknownA5\t,IK_UnknownA6\t,IK_UnknownA7\t,\n/*A8*/\tIK_UnknownA8\t,IK_UnknownA9\t,IK_UnknownAA\t,IK_UnknownAB\t,\n/*AC*/\tIK_UnknownAC\t,IK_UnknownAD\t,IK_UnknownAE\t,IK_UnknownAF\t,\n/*B0*/\tIK_UnknownB0\t,IK_UnknownB1\t,IK_UnknownB2\t,IK_UnknownB3\t,\n/*B4*/\tIK_UnknownB4\t,IK_UnknownB5\t,IK_UnknownB6\t,IK_UnknownB7\t,\n/*B8*/\tIK_UnknownB8\t,IK_UnknownB9\t,IK_Semicolon\t,IK_Equals\t\t,\n/*BC*/\tIK_Comma\t\t,IK_Minus\t\t,IK_Period\t\t,IK_Slash\t\t,\n/*C0*/\tIK_Tilde\t\t,IK_UnknownC1\t,IK_UnknownC2\t,IK_UnknownC3\t,\n/*C4*/\tIK_UnknownC4\t,IK_UnknownC5\t,IK_UnknownC6\t,IK_UnknownC7\t,\n/*C8*/\tIK_Joy1\t        ,IK_Joy2\t    ,IK_Joy3\t    ,IK_Joy4\t    ,\n/*CC*/\tIK_Joy5\t        ,IK_Joy6\t    ,IK_Joy7\t    ,IK_Joy8\t    ,\n/*D0*/\tIK_Joy9\t        ,IK_Joy10\t    ,IK_Joy11\t    ,IK_Joy12\t\t,\n/*D4*/\tIK_Joy13\t\t,IK_Joy14\t    ,IK_Joy15\t    ,IK_Joy16\t    ,\n/*D8*/\tIK_UnknownD8\t,IK_UnknownD9\t,IK_UnknownDA\t,IK_LeftBracket\t,\n/*DC*/\tIK_Backslash\t,IK_RightBracket,IK_SingleQuote\t,IK_UnknownDF\t,\n/*E0*/  IK_JoyX\t\t\t,IK_JoyY\t\t,IK_JoyZ\t\t,IK_JoyR\t\t,\n/*E4*/\tIK_MouseX\t\t,IK_MouseY\t\t,IK_MouseZ\t\t,IK_MouseW\t\t,\n/*E8*/\tIK_JoyU\t\t\t,IK_JoyV\t\t,IK_UnknownEA\t,IK_UnknownEB\t,\n/*EC*/\tIK_MouseWheelUp ,IK_MouseWheelDown,IK_Unknown10E,UK_Unknown10F  ,\n/*F0*/\tIK_UnknownF0\t,IK_UnknownF1\t,IK_UnknownF2\t,IK_UnknownF3\t,\n/*F4*/\tIK_UnknownF4\t,IK_UnknownF5\t,IK_Attn\t\t,IK_CrSel\t\t,\n/*F8*/\tIK_ExSel\t\t,IK_ErEof\t\t,IK_Play\t\t,IK_Zoom\t\t,\n/*FC*/\tIK_NoName\t\t,IK_PA1\t\t\t,IK_OEMClear\n};\n\n//-----------------------------------------------------------------------------\n// natives.\n\n// Execute a command on this console.\nnative function bool ConsoleCommand( coerce string S );\nnative function SaveTimeDemo( string S );\n\n//-----------------------------------------------------------------------------\n// Exec functions accessible from the console and key bindings.\n\n// DEUS_EX CNN - moved to PlayerPawn to allow cheats to affect it\n// Begin typing a command on the console.\n//exec function Type()\n//{\n//\tTypedStr=\"\";\n//\tGotoState( 'Typing' );\n//}\n \nexec function Talk()\n{\n\tTypedStr=\"Say \";\n\tbNoStuff = true;\n\tGotoState( 'Typing' );\n}\n\nexec function TeamTalk()\n{\n\tTypedStr=\"TeamSay \";\n\tbNoStuff = true;\n\tGotoState( 'Typing' );\n}\n\n// Size the view up.\nexec function ViewUp()\n{\n//\tBorderSize = Clamp( BorderSize-1, 0, MaxBorder );\n}\n\n// Size the view down.\nexec function ViewDown()\n{\n//\tBorderSize = Clamp( BorderSize+1, 0, MaxBorder );\n}\n\n//-----------------------------------------------------------------------------\n// Member Access Functions.\n\nfunction string GetMsgText( int Index )\n{\n\treturn MsgText[Index];\n}\nfunction SetMsgText( int Index, string NewMsgText )\n{\n\tMsgText[Index] = NewMsgText;\n}\n\nfunction name GetMsgType(int Index)\n{\n\treturn MsgType[Index];\n}\nfunction SetMsgType(int Index, name NewMsgType)\n{\n\tMsgType[Index] = NewMsgType;\n}\n\nfunction PlayerReplicationInfo GetMsgPlayer(int Index)\n{\n\treturn MsgPlayer[Index];\n}\nfunction SetMsgPlayer(int Index, PlayerReplicationInfo NewMsgPlayer)\n{\n\tMsgPlayer[Index] = NewMsgPlayer;\n}\n\nfunction float GetMsgTick(int Index)\n{\n\treturn MsgTick[Index];\n}\nfunction SetMsgTick(int Index, int NewMsgTick)\n{\n\tMsgTick[Index] = NewMsgTick;\n}\n\n//-----------------------------------------------------------------------------\n// Functions.\n\n// Clear messages.\nfunction ClearMessages()\n{\n\tlocal int i;\n\n\tfor (i=0; i<MaxLines; i++)\n\t{\n\t\tMsgText[i] = \"\";\n\t\tMsgType[i] = '';\n\t\tMsgPlayer[i] = None;\n\t\tMsgTick[i] = 0.0;\n\t}\n\tMsgTime = 0.0;\n}\n\n// Write to console.\nevent Message( PlayerReplicationInfo PRI, coerce string Msg, name N )\n{\n\tif( Msg!=\"\" )\n\t{\n\t\tTopLine\t\t     = (TopLine+1) % MaxLines;\n\t\tNumLines\t     = Min(NumLines+1,MaxLines-1);\n\t\tMsgType[TopLine] = N;\n\t\tMsgTime\t\t     = 6.0;\n\t\tTextLines++;\n\t\tMsgText[TopLine] = Msg;\n\t\tMsgPlayer[TopLine] = PRI;\n\t\tMsgTick[TopLine] = MsgTickTime + MsgTime;\n\t}\n}\n\nevent AddString( coerce string Msg )\n{\n\tif( Msg!=\"\" )\n\t{\n\t\tTopLine\t\t     = (TopLine+1) % MaxLines;\n\t\tNumLines\t     = Min(NumLines+1,MaxLines-1);\n\t\tMsgType[TopLine] = 'Event';\n\t\tMsgTime\t\t     = 6.0;\n\t\tTextLines++;\n\t\tMsgText[TopLine] = Msg;\n\t\tMsgPlayer[TopLine] = None;\n\t\tMsgTick[TopLine] = MsgTickTime + MsgTime;\n\t}\n}\n\n// Called by the engine when a single key is typed.\nevent bool KeyType( EInputKey Key );\n\n// Called by the engine when a key, mouse, or joystick button is pressed\n// or released, or any analog axis movement is processed.\nevent bool KeyEvent( EInputKey Key, EInputAction Action, FLOAT Delta )\n{\n\tif( Action!=IST_Press )\n\t{\n\t\treturn false;\n\t}\n\t// DEUS_EX CNN - Shift-Tilde is console now\n/*\telse if( Key==IK_Tilde )\n\t{\n\t\tif( ConsoleDest==0.0 )\n\t\t{\n\t\t\tConsoleDest=0.6;\n\t\t\tGotoState('Typing');\n\t\t}\n\t\telse GotoState('');\n\t\treturn true;\n\t}\n*/\n\telse return false;\n}\n\n// Called each rendering iteration to update any time-based display.\nevent Tick( float Delta )\n{\n\tlocal int I;\n\tMsgTickTime += Delta;\n\n\t// Slide console up or down.\n\tif( ConsolePos < ConsoleDest )\n\t\tConsolePos = FMin(ConsolePos+Delta,ConsoleDest);\n\telse if( ConsolePos > ConsoleDest )\n\t\tConsolePos = FMax(ConsolePos-Delta,ConsoleDest);\n\n\t// Update status message.\n\tif( ((MsgTime-=Delta) <= 0.0) && (TextLines > 0) )\n\t\tTextLines--;\n\n   // Update progress messages.\n   if (Viewport.Actor.ProgressTimeOut > Viewport.Actor.Level.TimeSeconds)\n   {\n      Viewport.Actor.ShowProgress();\n   }\n}\n\n// Called before rendering the world view.\nevent PreRender( canvas C );\n\n// Called when video settings change (resolution, driver, color depth).\nevent VideoChange();\n\nevent NotifyLevelChange()\n{\n\tbRestartTimeDemo = True;\n\tClearMessages();\n}\n\nevent ConnectFailure( string FailCode, string URL );\n\nfunction DrawLevelAction( canvas C )\n{\n\tlocal string BigMessage;\n\n\t// DEUS_EX AJY - don't want to print any text \n\t// if the game is paused because we're in a menu\n\tif (Viewport.Actor.bShowMenu )\n\t{\n\t\tBigMessage = \"\";\n\t\treturn;\n\t}\n\tif ( (Viewport.Actor.Level.Pauser != \"\") && (Viewport.Actor.Level.LevelAction == LEVACT_None) )\n\t{\n\t\tC.Font = C.BigFont;\n\t\tC.Style = 1;\n\t\tC.DrawColor.R = 255;\n\t\tC.DrawColor.G = 255;\n\t\tC.DrawColor.B = 255;\n\n\t\tBigMessage = PausedMessage; // Add pauser name?\n\t\tPrintActionMessage(C, BigMessage);\n\t\treturn;\n\t}\n\telse if ( Viewport.Actor.Level.LevelAction == LEVACT_Loading )\n\t\tBigMessage = LoadingMessage;\n\telse if ( Viewport.Actor.Level.LevelAction == LEVACT_Saving )\n\t\tBigMessage = SavingMessage;\n\telse if ( Viewport.Actor.Level.LevelAction == LEVACT_Connecting )\n\t\tBigMessage = ConnectingMessage;\n\telse if ( Viewport.Actor.Level.LevelAction == LEVACT_Precaching )\n\t\tBigMessage = PrecachingMessage;\n\t\n\tif ( BigMessage != \"\" )\n\t{\n\t\tC.Style = 3;\n\t\tC.DrawColor.R = 0;\n\t\tC.DrawColor.G = 0;\n\t\tC.DrawColor.B = 255;\n\t\tC.Font = C.LargeFont;\t\n\t\tPrintActionMessage(C, BigMessage);\n\t}\n}\n\nfunction PrintActionMessage( Canvas C, string BigMessage )\n{\n\tlocal float XL, YL;\n\n\tC.bCenter = false;\n\tC.StrLen( BigMessage, XL, YL );\n\tC.SetPos(FrameX/2 - XL/2, FrameY/2 - YL/2);\n\tC.DrawText( BigMessage, false );\n}\t\t\n\n// Add localization to hardcoded strings!!\n// Called after rendering the world view.\nevent PostRender( canvas C )\n{\n\tlocal int YStart, YEnd, Y, I, J, Line, iLine;\n\n\tif(bNoDrawWorld)\n\t{\n\t\tC.SetPos(0,0);\n\t\tC.DrawPattern( Texture'Border', C.ClipX, C.ClipY, 1.0 );\n\t}\n\n\tif( bTimeDemo )\n\t{\n\t\tTimeDemoCalc();\n\t\tTimeDemoRender( C );\n\t}\n\n\t// call overridable \"level action\" rendering code to draw the \"big message\"\n\tDrawLevelAction( C );\n\n\t// If the console has changed since the previous frame, draw it.\n\tif ( ConsoleLines > 0 )\n\t{\n\t\t// DEUS_EX AJY\n\t\tC.Style = 1;\n\t\tC.DrawColor.R = 128;\n\t\tC.DrawColor.G = 128;\n\t\tC.DrawColor.B = 128;\n\t\tC.SetPos(0.0, ConsoleLines - FrameY);\n\t\tC.SetOrigin(0.0, 0.0);\n\t\tC.DrawTile(ConBackground, FrameX, FrameY, 0.0, 0.0, FrameX, FrameY);\n\n\t}\n\n\t// Draw border.\n\tif ( BorderLines > 0 || BorderPixels > 0 )\n\t{\n\t\tYStart \t= BorderLines + ConsoleLines;\n\t\tYEnd \t= FrameY - BorderLines;\n\t\tif ( BorderLines > 0 )\n\t\t{\n\t\t\tC.SetOrigin(0.0, 0.0);\n\t\t\tC.SetPos(0.0, 0.0);\n\t\t\tC.DrawPattern( Border, FrameX, BorderLines, 1.0 );\n\t\t\tC.SetPos(0.0, YEnd);\n\t\t\tC.DrawPattern( Border, FrameX, BorderLines, 1.0 );\n\t\t}\n\t\tif ( BorderPixels > 0 )\n\t\t{\n\t\t\tC.SetOrigin(0.0, 0.0);\n\t\t\tC.SetPos(0.0, YStart);\n\t\t\tC.DrawPattern( Border, BorderPixels, YEnd - YStart, 1.0 );\n\t\t\tC.SetPos( FrameX - BorderPixels, YStart );\n\t\t\tC.DrawPattern( Border, BorderPixels, YEnd - YStart, 1.0 );\n\t\t}\n\t}\n\n\t// Draw console text.\n\tC.SetOrigin(0.0, 0.0);\n\tif ( ConsoleLines > 0 )\n\t\tDrawConsoleView( C );\n\telse\n\t\tDrawSingleView( C );\n}\n\nsimulated function DrawConsoleView( Canvas C )\n{\n\tlocal int Y, I, Line;\n\tlocal float XL, YL;\n\n\t// Console is visible; display console view.\n\tY = ConsoleLines - 1;\n\tMsgText[(TopLine + 1 + MaxLines) % MaxLines] = \"(>\"@TypedStr;\n\tfor ( I = Scrollback; I < (NumLines + 1); I++ )\n\t{\n\t\t// Display all text in the buffer.\n\t\tLine = (TopLine + MaxLines*2 - (I-1)) % MaxLines;\n\t\t\n\t\tC.DrawColor.R = 255;\n\t\tC.DrawColor.G = 255;\n\t\tC.DrawColor.B = 255;\n\t\tC.Font = C.MedFont;\n\n\t\tif (( MsgType[Line] == 'Say' ) || ( MsgType[Line] == 'TeamSay' ))\n\t\t\tC.StrLen( MsgPlayer[Line].PlayerName$\":\"@MsgText[Line], XL, YL );\t\t\t\t\n\t\telse\n\t\t\tC.StrLen( MsgText[Line], XL, YL );\n\t\t\n\t\t// Half-space blank lines.\n\t\tif ( YL == 0 )\n\t\t\tYL = 5;\n\t\t\t\n\t\tY -= YL;\n\t\tif ( (Y + YL) < 0 )\n\t\t\tbreak;\n\t\tC.SetPos(4, Y);\n\t\tC.Font = C.MedFont;\n\n\t\tif (( MsgType[Line] == 'Say' ) || ( MsgType[Line] == 'TeamSay' ))\n\t\t\tC.DrawText( MsgPlayer[Line].PlayerName$\":\"@MsgText[Line], false );\n\t\telse\n\t\t\tC.DrawText( MsgText[Line], false );\n\t}\t\t\t\t\n}\n\nsimulated function DrawSingleView( Canvas C )\n{\n\tlocal string TypingPrompt;\n\tlocal int I, J;\n\tlocal float XL, YL;\n\tlocal string ShortMessages[4];\n\tlocal int ExtraSpace;\n\n\n\t// Console is hidden; display single-line view.\n\n\tC.SetOrigin(0.0, 0.0);\n\n\t// Ask the HUD to deal with messages.\n\tif ( Viewport.Actor.myHUD != None \n\t\t&& Viewport.Actor.myHUD.DisplayMessages(C) )\n\t\treturn;\n\n\tC.DrawColor.R = 255;\n\tC.DrawColor.G = 255;\n\tC.DrawColor.B = 255;\n\n\t// If the HUD doesn't deal with messages, use the default behavior\n\tif (!Viewport.Actor.bShowMenu)\n\t{\n\t\tif ( bTyping )\n\t\t{\t\t\t\n\t\t\tTypingPrompt = \"(>\"@TypedStr$\"_\";\n\t\t\tC.Font = C.MedFont;\n\t\t\tC.StrLen( TypingPrompt, XL, YL );\n\t\t\tC.SetPos( 2, FrameY - ConsoleLines - YL - 1 );\n\t\t\tC.DrawText( TypingPrompt, false );\n\t\t}\n\t}\n\t\t\n\tif ( TextLines > 0 && (!Viewport.Actor.bShowMenu || Viewport.Actor.bShowScores) )\n\t{\n\t\tJ = TopLine;\n\t\tI = 0;\n\t\twhile ((I < 4) && (J >= 0))\n\t\t{\n\t\t\tif ((MsgText[J] != \"\") && (MsgTick[J] > 0.0) && (MsgTick[J] > MsgTickTime) )\n\t\t\t{\n\t\t\t\tif (MsgType[J] == 'Say') \n\t\t\t\t\tShortMessages[I] = MsgPlayer[J].PlayerName$\":\"@MsgText[J];\n\t\t\t\telse\n\t\t\t\t\tShortMessages[I] = MsgText[J];\n\t\t\t\tI++;\n\t\t\t}\n\t\t\tJ--;\n\t\t}\n\n\t\tJ = 0;\n\t\tC.Font = C.MedFont;\n\t\tfor ( I = 0; I < 4; I++ )\n\t\t{\n\t\t\tif (ShortMessages[3 - I] != \"\")\n\t\t\t{\n\t\t\t\tC.SetPos(4, 2 + (10 * J) + (10 * ExtraSpace));\n\t\t\t\tC.StrLen( ShortMessages[3 - I], XL, YL );\n\t\t\t\tC.DrawText( ShortMessages[3 - I], false );\n\t\t\t\tif ( YL == 18.0 )\n\t\t\t\t\tExtraSpace++;\n\t\t\t\tJ++;\n\t\t\t}\n\t\t}\t\t\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// State used while typing a command on the console.\n\nstate Typing\n{\n\texec function Type()\n\t{\n\t\tTypedStr=\"\";\n\t\tgotoState( '' );\n\t}\n\tfunction bool KeyType( EInputKey Key )\n\t{\n\t\t// DEUS_EX CNN - bring up the console if we hit shift-tilde\n\t\tif (Key == Asc(\"~\"))\n\t\t{\n\t\t\tif( ConsoleDest==0.0 )\n\t\t\t{\n\t\t\t\tConsoleDest=1.0;\t\t// DEUS_EX CNN - fullscreen console\n//\t\t\t\tConsoleDest=0.6;\n\t\t\t\tGotoState('Typing');\n\t\t\t}\n\t\t\telse GotoState('');\n\t\t}\n\t\telse if( Key>=0x20 && Key<0x80 && Key!=Asc(\"~\") && Key!=Asc(\"`\") )\n\t\t{\n\t\t\tif ( bNoStuff )\n\t\t\t{\n\t\t\t\tbNoStuff = false;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tTypedStr = TypedStr $ Chr(Key);\n\t\t\tScrollback=0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfunction bool KeyEvent( EInputKey Key, EInputAction Action, FLOAT Delta )\n\t{\n\t\tlocal string Temp;\n\n\t\tbNoStuff = false;\n\t\tif( Key==IK_Escape )\n\t\t{\n\t\t\tif( Scrollback!=0 )\n\t\t\t{\n\t\t\t\tScrollback=0;\n\t\t\t}\n\t\t\telse if( TypedStr!=\"\" )\n\t\t\t{\n\t\t\t\tTypedStr=\"\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tConsoleDest=0.0;\n\t\t\t\tGotoState( '' );\n\t\t\t}\n\t\t\tScrollback=0;\n\t\t}\n\t\telse if( global.KeyEvent( Key, Action, Delta ) )\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse if( Action != IST_Press )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\telse if( Key==IK_Enter )\n\t\t{\n\t\t\tif( Scrollback!=0 )\n\t\t\t{\n\t\t\t\tScrollback=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( TypedStr!=\"\" )\n\t\t\t\t{\n\t\t\t\t\t// Print to console.\n\t\t\t\t\tif( ConsoleLines!=0 )\n\t\t\t\t\t\tMessage( None, \"(>\" @ TypedStr, 'Console' );\n\n\t\t\t\t\t// Update history buffer.\n\t\t\t\t\tHistory[HistoryCur++ % MaxHistory] = TypedStr;\n\t\t\t\t\tif( HistoryCur > HistoryBot )\n\t\t\t\t\t\tHistoryBot++;\n\t\t\t\t\tif( HistoryCur - HistoryTop >= MaxHistory )\n\t\t\t\t\t\tHistoryTop = HistoryCur - MaxHistory + 1;\n\n\t\t\t\t\t// Make a local copy of the string.\n\t\t\t\t\tTemp=TypedStr;\n\t\t\t\t\tTypedStr=\"\";\n\t\t\t\t\tif( !ConsoleCommand( Temp ) )\n\t\t\t\t\t\tMessage( None, Localize(\"Errors\",\"Exec\",\"Core\"), 'Console' );\n\t\t\t\t\tMessage( None, \"\", 'Console' );\n\t\t\t\t}\n\t\t\t\tif( ConsoleDest==0.0 )\n\t\t\t\t\tGotoState('');\n\t\t\t\tScrollback=0;\n\t\t\t}\n\t\t}\n\t\telse if( Key==IK_Up )\n\t\t{\n\t\t\tif( HistoryCur > HistoryTop )\n\t\t\t{\n\t\t\t\tHistory[HistoryCur % MaxHistory] = TypedStr;\n\t\t\t\tTypedStr = History[--HistoryCur % MaxHistory];\n\t\t\t}\n\t\t\tScrollback=0;\n\t\t}\n\t\telse if( Key==IK_Down )\n\t\t{\n\t\t\tHistory[HistoryCur % MaxHistory] = TypedStr;\n\t\t\tif( HistoryCur < HistoryBot )\n\t\t\t\tTypedStr = History[++HistoryCur % MaxHistory];\n\t\t\telse\n\t\t\t\tTypedStr=\"\";\n\t\t\tScrollback=0;\n\t\t}\n\t\telse if( Key==IK_PageUp )\n\t\t{\n\t\t\tif( ++Scrollback >= MaxLines )\n\t\t\t\tScrollback = MaxLines-1;\n\t\t}\n\t\telse if( Key==IK_PageDown )\n\t\t{\n\t\t\tif( --Scrollback < 0 )\n\t\t\t\tScrollback = 0;\n\t\t}\n\t\telse if( Key==IK_Backspace || Key==IK_Left )\n\t\t{\n\t\t\tif( Len(TypedStr)>0 )\n\t\t\t\tTypedStr = Left(TypedStr,Len(TypedStr)-1);\n\t\t\tScrollback = 0;\n\t\t}\n\t\treturn true;\n\t}\n\tfunction BeginState()\n\t{\n\t\tbTyping = true;\n\t\tViewport.Actor.Typing(bTyping);\n\t}\n\tfunction EndState()\n\t{\n\t\tbTyping = false;\n\t\tViewport.Actor.Typing(bTyping);\n\t\t//log(\"Console leaving Typing\");\n\t\tConsoleDest=0.0;\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// State used while in a menu.\n\nstate Menuing\n{\n\tfunction bool KeyEvent( EInputKey Key, EInputAction Action, FLOAT Delta )\n\t{\n\t\tif ( Action != IST_Press )\n\t\t\treturn false;\n\t\tif ( Viewport.Actor.myHUD == None || Viewport.Actor.myHUD.MainMenu == None )\n\t\t\treturn false;\n\t\t\n\t\tViewport.Actor.myHUD.MainMenu.MenuProcessInput(Key, Action);\n\t\tScrollback=0;\n\t\treturn true;\n\t}\n\tfunction BeginState()\n\t{\n\t\t//log(\"Console entering Menuing\");\n\t}\n\tfunction EndState()\n\t{\n\t\t//log(\"Console leaving Menuing\");\n\t}\n}\n\nstate EndMenuing\n{\n\t// pass all key events, not just presses\n\tfunction bool KeyEvent( EInputKey Key, EInputAction Action, FLOAT Delta )\n\t{\n\t\tif ( Viewport.Actor.myHUD == None || Viewport.Actor.myHUD.MainMenu == None )\n\t\t\treturn false;\n\t\t\n\t\tViewport.Actor.myHUD.MainMenu.MenuProcessInput(Key, Action);\n\t\tScrollback=0;\n\t\treturn true;\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// State used while typing in a menu.\n\nstate MenuTyping\n{\n\tfunction bool KeyType( EInputKey Key )\n\t{\n\t\tif( Key>=0x20 && Key<0x100 && Key!=Asc(\"~\") && Key!=Asc(\"`\") && Key!=Asc(\" \") )\n\t\t{\n\t\t\tTypedStr = TypedStr $ Chr(Key);\n\t\t\tScrollback=0;\n\t\t\tif ( (Viewport.Actor.myHUD != None) && (Viewport.Actor.myHUD.MainMenu != None) )\n\t\t\t\tViewport.Actor.myHUD.MainMenu.ProcessMenuUpdate( TypedStr );\n\t\t\treturn true;\n\t\t}\n\t}\t\n\tfunction bool KeyEvent( EInputKey Key, EInputAction Action, FLOAT Delta )\n\t{\n\t\tlocal Menu PlayerMenu;\n\n\t\tif( Action != IST_Press )\n\t\t\treturn false;\n\n\t\tif( Viewport.Actor.myHUD==None || Viewport.Actor.myHUD.MainMenu==None )\n\t\t\treturn false;\n\t\t\n\t\tPlayerMenu = Viewport.Actor.myHUD.MainMenu;\n\n\t\tif( Key==IK_Escape )\n\t\t{\n\t\t\tif( Scrollback!=0 )\n\t\t\t\tScrollback = 0;\n\t\t\telse if( TypedStr!=\"\" )\n\t\t\t\tTypedStr=\"\";\n\t\t\telse\n\t\t\t\tGotoState( 'Menuing' );\n\t\t\tPlayerMenu.ProcessMenuEscape();\n\t\t\tScrollback=0;\n\t\t}\n\t\telse if( Key==IK_Enter )\n\t\t{\n\t\t\tif( Scrollback!=0 )\n\t\t\t\tScrollback = 0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( TypedStr!=\"\" )\n\t\t\t\t\tPlayerMenu.ProcessMenuInput( TypedStr );\t\n\t\t\t\tTypedStr=\"\";\n\t\t\t\tGotoState( 'Menuing' );\n\t\t\t\tScrollback = 0;\n\t\t\t}\n\t\t}\n\t\telse if( Key==IK_Backspace || Key==IK_Left )\n\t\t{\n\t\t\tif( Len(TypedStr)>0 )\n\t\t\t\tTypedStr = Left(TypedStr,Len(TypedStr)-1);\n\t\t\tScrollback = 0;\n\t\t\tPlayerMenu.ProcessMenuUpdate( TypedStr );\t\n\t\t}\n\t\treturn true;\n\t}\n\tfunction BeginState()\n\t{\n\t\tlog(\"Console entering MenuTyping\");\n\t}\n\tfunction EndState()\n\t{\n\t\tlog(\"Console leaving MenuTyping\");\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// State used while expecting single key input in a menu.\n\nstate KeyMenuing\n{\n\tfunction bool KeyType( EInputKey Key )\n\t{\n\t\tConsoleDest=0.0;\n\t\tif( Viewport.Actor.myHUD!=None && Viewport.Actor.myHUD.MainMenu!=None )\n\t\t\tViewport.Actor.myHUD.MainMenu.ProcessMenuKey( Key, Chr(Key) );\n\t\tScrollback=0;\n\t\tGotoState( 'Menuing' );\n\t}\n\tfunction bool KeyEvent( EInputKey Key, EInputAction Action, FLOAT Delta )\n\t{\n\t\tif( Action==IST_Press )\n\t\t{\n\t\t\tConsoleDest=0.0;\n\t\t\tif( Viewport.Actor.myHUD!=None && Viewport.Actor.myHUD.MainMenu!=None )\n\t\t\t\tViewport.Actor.myHUD.MainMenu.ProcessMenuKey( Key, mid(string(GetEnum(enum'EInputKey',Key)),3) );\n\t\t\tScrollback=0;\n\t\t\tGotoState( 'Menuing' );\n\t\t\treturn true;\n\t\t}\n\t}\n\tfunction BeginState()\n\t{\n\t\t//log( \"Console entering KeyMenuing\" );\n\t}\n\tfunction EndState()\n\t{\n\t\t//log( \"Console leaving KeyMenuing\" );\n\t}\n}\n\n\n//-----------------------------------------------------------------------------\n// Timedemo functions\n\nexec function TimeDemo(bool bEnabled, optional bool bSaveToFile)\n{\n\tbSaveTimeDemoToFile = bSaveToFile;\n\tif(bEnabled)\n\t\tStartTimeDemo();\n\telse\n\t\tStopTimeDemo();\n}\n\nfunction StartTimeDemo()\n{\n\tif(bTimeDemo)\n\t\treturn;\n\tbTimeDemo = True;\n\tbStartTimeDemo = True;\n}\n\nfunction StopTimeDemo()\n{\n\tif(!bTimeDemo)\n\t\treturn;\n\tbTimeDemo = False;\n\tPrintTimeDemoResult();\n}\n\nfunction PrintTimeDemoResult()\n{\n\tlocal LevelInfo Entry;\n\tlocal float Avg;\n\tlocal float Delta;\n\tlocal string AvgString;\n\tlocal string Temp;\n\n\tEntry = Viewport.Actor.GetEntryLevel();\n\n\tDelta = Entry.TimeSeconds - StartTime - ExtraTime;\n\tif(Delta <= 0)\n\t\tAvg = 0;\n\telse\n\t\tAvg = FrameCount / Delta;\n\t\n\tAvgString = string(FrameCount)@FramesText@FormatFloat(delta)@SecondsText@MinText@FormatFloat(MinFPS)@MaxText@FormatFloat(MaxFPS)@AvgText@FormatFloat(Avg)@fpsText$\".\";\n\tViewport.Actor.ClientMessage(AvgString);\n\tLog(AvgString);\n\tif(bSaveTimeDemoToFile)\n\t{\t\t\n\t\tTemp =\n\t\t\tFormatFloat(Avg) $ \" Unreal \"$ Viewport.Actor.Level.EngineVersion $ Chr(13) $ Chr(10) $\n\t\t\tFormatFloat(MinFPS) $ \" Min\"$ Chr(13) $ Chr(10) $\n\t\t\tFormatFloat(MaxFPS) $ \" Max\"$ Chr(13) $ Chr(10);\n\t\t\t\n\t\tSaveTimeDemo(Temp);\n\t}\n}\n\nfunction TimeDemoCalc()\n{\n\tlocal LevelInfo Entry;\n\tlocal float Delta;\n\tEntry = Viewport.Actor.GetEntryLevel();\n\n\tif( bRestartTimeDemo )\n\t{\n\t\tStopTimeDemo();\n\t\tStartTimeDemo();\n\t\tbRestartTimeDemo = False;\n\t}\n\n\tif(\tbStartTimeDemo )\n\t{\n\t\tbStartTimeDemo = False;\n\t\tStartTime = Entry.TimeSeconds;\n\t\tExtraTime =  0;\n\t\tLastFrameTime = StartTime;\n\t\tLastSecondStartTime = StartTime;\n\t\tFrameCount = 0;\n\t\tLastSecondFrameCount = 0;\n\t\tMinFPS = 0;\n\t\tMaxFPS = 0;\t\t\n\t\tLastSecFPS = 0;\n\t\treturn;\n\t}\n\n\tDelta = Entry.TimeSeconds - LastFrameTime;\n\n\t// If delta time is more than a half of a second, ignore frame entirely (precaching, loading etc)\n\tif( Delta > 0.5 )\n\t{\n\t\tExtraTime += Delta;\n\t\tLastSecondStartTime = Entry.TimeSeconds;\n\t\tLastSecondFrameCount = 0;\n\t\tLastFrameTime = Entry.TimeSeconds;\n\t\treturn;\n\t}\n\n\tFrameCount++;\n\tLastSecondFrameCount++;\n\n\tif( Entry.TimeSeconds - LastSecondStartTime > 1)\n\t{\n\t\tLastSecFPS = LastSecondFrameCount / (Entry.TimeSeconds - LastSecondStartTime);\n\t\tif( MinFPS == 0 || LastSecFPS < MinFPS )\n\t\t\tMinFPS = LastSecFPS;\n\t\tif( LastSecFPS > MaxFPS )\n\t\t\tMaxFPS = LastSecFPS;\n\t\tLastSecondFrameCount = 0;\n\t\tLastSecondStartTime = Entry.TimeSeconds;\n\t}\n\n\tLastFrameTime = Entry.TimeSeconds;\n}\n\nfunction TimeDemoRender( Canvas C )\n{\n\tlocal string AText, LText;\n\tlocal float W, H;\n\n\tC.Font = TimeDemoFont;\n\tC.DrawColor.R = 255;\n\tC.DrawColor.G = 255;\n\tC.DrawColor.B = 255;\n\n\tAText = AvgText @ FormatFloat(FrameCount / (Viewport.Actor.GetEntryLevel().TimeSeconds - StartTime - ExtraTime));\n\tLText = LastSecText @ FormatFloat(LastSecFPS);\n\n\tC.TextSize(AText, W, H);\n\tC.SetPos(C.ClipX - W, 0.3*C.ClipY);\n\tC.DrawText(AText);\n\tC.TextSize(LText, W, H);\n\tC.SetPos(C.ClipX - W, 0.3*C.ClipY+H);\n\tC.DrawText(LText);\n}\n\nfinal function string FormatFloat( float f)\n{\n\tlocal string s;\n\tlocal int i;\n\ts = string(f);\n\ti = InStr(s, \".\");\n\tif(i != -1)\n\t\ts = Left(s, i+3);\n\treturn s;\n}\n\ndefaultproperties\n{\n     ConBackground=Texture'Engine.ConsoleBack'\n     Border=Texture'Engine.Border'\n     TimeDemoFont=Font'Engine.SmallFont'\n     LoadingMessage=\"LOADING\"\n     SavingMessage=\"SAVING\"\n     ConnectingMessage=\"CONNECTING\"\n     PausedMessage=\"PAUSED\"\n     PrecachingMessage=\"PRECACHING\"\n     FrameRateText=\"Frame Rate\"\n     AvgText=\"Avg\"\n     LastSecText=\"Last Sec\"\n     MinText=\"Min\"\n     MaxText=\"Max\"\n     fpsText=\"fps\"\n     SecondsText=\"seconds.\"\n     FramesText=\"frames rendered in\"\n}\n",
            "name": "Console.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "ConBackground=Texture'Engine.ConsoleBack'",
                    "Border=Texture'Engine.Border'",
                    "TimeDemoFont=Font'Engine.SmallFont'",
                    "LoadingMessage=\"LOADING\"",
                    "SavingMessage=\"SAVING\"",
                    "ConnectingMessage=\"CONNECTING\"",
                    "PausedMessage=\"PAUSED\"",
                    "PrecachingMessage=\"PRECACHING\"",
                    "FrameRateText=\"Frame Rate\"",
                    "AvgText=\"Avg\"",
                    "LastSecText=\"Last Sec\"",
                    "MinText=\"Min\"",
                    "MaxText=\"Max\"",
                    "fpsText=\"fps\"",
                    "SecondsText=\"seconds.\"",
                    "FramesText=\"frames rendered in\""
                ],
                "exec": [
                    "#exec Texture Import NAME=ConsoleBack File=Textures\\Console.pcx",
                    "#exec Texture Import File=Textures\\Border.pcx"
                ],
                "extends": "Object",
                "functions": {
                    "AddString": {
                        "body": "{\n\tif( Msg!=\"\" )\n\t{\n\t\tTopLine\t\t     = (TopLine+1) % MaxLines;\n\t\tNumLines\t     = Min(NumLines+1,MaxLines-1);\n\t\tMsgType[TopLine] = 'Event';\n\t\tMsgTime\t\t     = 6.0;\n\t\tTextLines++;\n\t\tMsgText[TopLine] = Msg;\n\t\tMsgPlayer[TopLine] = None;\n\t\tMsgTick[TopLine] = MsgTickTime + MsgTime;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AddString",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "Msg"
                            ]
                        ],
                        "return": ""
                    },
                    "BeginState": {
                        "body": "{\n\t\t//log( \"Console entering KeyMenuing\" );\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ClearMessages": {
                        "body": "{\n\n\tfor (i=0; i<MaxLines; i++)\n\t{\n\t\tMsgText[i] = \"\";\n\t\tMsgType[i] = '';\n\t\tMsgPlayer[i] = None;\n\t\tMsgTick[i] = 0.0;\n\t}\n\tMsgTime = 0.0;\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "ClearMessages",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ConnectFailure": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ConnectFailure",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "FailCode"
                            ],
                            [
                                "string",
                                "URL"
                            ]
                        ],
                        "return": ""
                    },
                    "ConsoleCommand": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ConsoleCommand",
                        "native": true,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "S"
                            ]
                        ],
                        "return": "bool"
                    },
                    "DrawConsoleView": {
                        "body": "{\n\n\t// Console is visible; display console view.\n\tY = ConsoleLines - 1;\n\tMsgText[(TopLine + 1 + MaxLines) % MaxLines] = \"(>\"@TypedStr;\n\tfor ( I = Scrollback; I < (NumLines + 1); I++ )\n\t{\n\t\t// Display all text in the buffer.\n\t\tLine = (TopLine + MaxLines*2 - (I-1)) % MaxLines;\n\t\t\n\t\tC.DrawColor.R = 255;\n\t\tC.DrawColor.G = 255;\n\t\tC.DrawColor.B = 255;\n\t\tC.Font = C.MedFont;\n\n\t\tif (( MsgType[Line] == 'Say' ) || ( MsgType[Line] == 'TeamSay' ))\n\t\t\tC.StrLen( MsgPlayer[Line].PlayerName$\":\"@MsgText[Line], XL, YL );\t\t\t\t\n\t\telse\n\t\t\tC.StrLen( MsgText[Line], XL, YL );\n\t\t\n\t\t// Half-space blank lines.\n\t\tif ( YL == 0 )\n\t\t\tYL = 5;\n\t\t\t\n\t\tY -= YL;\n\t\tif ( (Y + YL) < 0 )\n\t\t\tbreak;\n\t\tC.SetPos(4, Y);\n\t\tC.Font = C.MedFont;\n\n\t\tif (( MsgType[Line] == 'Say' ) || ( MsgType[Line] == 'TeamSay' ))\n\t\t\tC.DrawText( MsgPlayer[Line].PlayerName$\":\"@MsgText[Line], false );\n\t\telse\n\t\t\tC.DrawText( MsgText[Line], false );\n\t}\t\t\t\t\n}",
                        "locals": [
                            "local int Y, I, Line;",
                            "local float XL, YL;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DrawConsoleView",
                        "native": false,
                        "param": [
                            [
                                "Canvas",
                                "C"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawLevelAction": {
                        "body": "{\n\n\t// DEUS_EX AJY - don't want to print any text \n\t// if the game is paused because we're in a menu\n\tif (Viewport.Actor.bShowMenu )\n\t{\n\t\tBigMessage = \"\";\n\t\treturn;\n\t}\n\tif ( (Viewport.Actor.Level.Pauser != \"\") && (Viewport.Actor.Level.LevelAction == LEVACT_None) )\n\t{\n\t\tC.Font = C.BigFont;\n\t\tC.Style = 1;\n\t\tC.DrawColor.R = 255;\n\t\tC.DrawColor.G = 255;\n\t\tC.DrawColor.B = 255;\n\n\t\tBigMessage = PausedMessage; // Add pauser name?\n\t\tPrintActionMessage(C, BigMessage);\n\t\treturn;\n\t}\n\telse if ( Viewport.Actor.Level.LevelAction == LEVACT_Loading )\n\t\tBigMessage = LoadingMessage;\n\telse if ( Viewport.Actor.Level.LevelAction == LEVACT_Saving )\n\t\tBigMessage = SavingMessage;\n\telse if ( Viewport.Actor.Level.LevelAction == LEVACT_Connecting )\n\t\tBigMessage = ConnectingMessage;\n\telse if ( Viewport.Actor.Level.LevelAction == LEVACT_Precaching )\n\t\tBigMessage = PrecachingMessage;\n\t\n\tif ( BigMessage != \"\" )\n\t{\n\t\tC.Style = 3;\n\t\tC.DrawColor.R = 0;\n\t\tC.DrawColor.G = 0;\n\t\tC.DrawColor.B = 255;\n\t\tC.Font = C.LargeFont;\t\n\t\tPrintActionMessage(C, BigMessage);\n\t}\n}",
                        "locals": [
                            "local string BigMessage;"
                        ],
                        "modifiers": [],
                        "name": "DrawLevelAction",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "C"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawSingleView": {
                        "body": "{\n\n\n\t// Console is hidden; display single-line view.\n\n\tC.SetOrigin(0.0, 0.0);\n\n\t// Ask the HUD to deal with messages.\n\tif ( Viewport.Actor.myHUD != None \n\t\t&& Viewport.Actor.myHUD.DisplayMessages(C) )\n\t\treturn;\n\n\tC.DrawColor.R = 255;\n\tC.DrawColor.G = 255;\n\tC.DrawColor.B = 255;\n\n\t// If the HUD doesn't deal with messages, use the default behavior\n\tif (!Viewport.Actor.bShowMenu)\n\t{\n\t\tif ( bTyping )\n\t\t{\t\t\t\n\t\t\tTypingPrompt = \"(>\"@TypedStr$\"_\";\n\t\t\tC.Font = C.MedFont;\n\t\t\tC.StrLen( TypingPrompt, XL, YL );\n\t\t\tC.SetPos( 2, FrameY - ConsoleLines - YL - 1 );\n\t\t\tC.DrawText( TypingPrompt, false );\n\t\t}\n\t}\n\t\t\n\tif ( TextLines > 0 && (!Viewport.Actor.bShowMenu || Viewport.Actor.bShowScores) )\n\t{\n\t\tJ = TopLine;\n\t\tI = 0;\n\t\twhile ((I < 4) && (J >= 0))\n\t\t{\n\t\t\tif ((MsgText[J] != \"\") && (MsgTick[J] > 0.0) && (MsgTick[J] > MsgTickTime) )\n\t\t\t{\n\t\t\t\tif (MsgType[J] == 'Say') \n\t\t\t\t\tShortMessages[I] = MsgPlayer[J].PlayerName$\":\"@MsgText[J];\n\t\t\t\telse\n\t\t\t\t\tShortMessages[I] = MsgText[J];\n\t\t\t\tI++;\n\t\t\t}\n\t\t\tJ--;\n\t\t}\n\n\t\tJ = 0;\n\t\tC.Font = C.MedFont;\n\t\tfor ( I = 0; I < 4; I++ )\n\t\t{\n\t\t\tif (ShortMessages[3 - I] != \"\")\n\t\t\t{\n\t\t\t\tC.SetPos(4, 2 + (10 * J) + (10 * ExtraSpace));\n\t\t\t\tC.StrLen( ShortMessages[3 - I], XL, YL );\n\t\t\t\tC.DrawText( ShortMessages[3 - I], false );\n\t\t\t\tif ( YL == 18.0 )\n\t\t\t\t\tExtraSpace++;\n\t\t\t\tJ++;\n\t\t\t}\n\t\t}\t\t\n\t}\n}",
                        "locals": [
                            "local string TypingPrompt;",
                            "local int I, J;",
                            "local float XL, YL;",
                            "local string ShortMessages[4];",
                            "local int ExtraSpace;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DrawSingleView",
                        "native": false,
                        "param": [
                            [
                                "Canvas",
                                "C"
                            ]
                        ],
                        "return": ""
                    },
                    "EndState": {
                        "body": "{\n\t\t//log( \"Console leaving KeyMenuing\" );\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "EndState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FormatFloat": {
                        "body": "{\n\ts = string(f);\n\ti = InStr(s, \".\");\n\tif(i != -1)\n\t\ts = Left(s, i+3);\n\treturn s;\n}",
                        "locals": [
                            "local string s;",
                            "local int i;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "FormatFloat",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "f"
                            ]
                        ],
                        "return": "string"
                    },
                    "GetMsgPlayer": {
                        "body": "{\n\treturn MsgPlayer[Index];\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetMsgPlayer",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Index"
                            ]
                        ],
                        "return": "PlayerReplicationInfo"
                    },
                    "GetMsgText": {
                        "body": "{\n\treturn MsgText[Index];\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetMsgText",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Index"
                            ]
                        ],
                        "return": "string"
                    },
                    "GetMsgTick": {
                        "body": "{\n\treturn MsgTick[Index];\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetMsgTick",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Index"
                            ]
                        ],
                        "return": "float"
                    },
                    "GetMsgType": {
                        "body": "{\n\treturn MsgType[Index];\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetMsgType",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Index"
                            ]
                        ],
                        "return": "name"
                    },
                    "KeyEvent": {
                        "body": "{\n\t\tif( Action==IST_Press )\n\t\t{\n\t\t\tConsoleDest=0.0;\n\t\t\tif( Viewport.Actor.myHUD!=None && Viewport.Actor.myHUD.MainMenu!=None )\n\t\t\t\tViewport.Actor.myHUD.MainMenu.ProcessMenuKey( Key, mid(string(GetEnum(enum'EInputKey',Key)),3) );\n\t\t\tScrollback=0;\n\t\t\tGotoState( 'Menuing' );\n\t\t\treturn true;\n\t\t}\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "KeyEvent",
                        "native": false,
                        "param": [
                            [
                                "EInputKey",
                                "Key"
                            ],
                            [
                                "EInputAction",
                                "Action"
                            ],
                            [
                                "FLOAT",
                                "Delta"
                            ]
                        ],
                        "return": "bool"
                    },
                    "KeyType": {
                        "body": "{\n\t\tConsoleDest=0.0;\n\t\tif( Viewport.Actor.myHUD!=None && Viewport.Actor.myHUD.MainMenu!=None )\n\t\t\tViewport.Actor.myHUD.MainMenu.ProcessMenuKey( Key, Chr(Key) );\n\t\tScrollback=0;\n\t\tGotoState( 'Menuing' );\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "KeyType",
                        "native": false,
                        "param": [
                            [
                                "EInputKey",
                                "Key"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Message": {
                        "body": "{\n\tif( Msg!=\"\" )\n\t{\n\t\tTopLine\t\t     = (TopLine+1) % MaxLines;\n\t\tNumLines\t     = Min(NumLines+1,MaxLines-1);\n\t\tMsgType[TopLine] = N;\n\t\tMsgTime\t\t     = 6.0;\n\t\tTextLines++;\n\t\tMsgText[TopLine] = Msg;\n\t\tMsgPlayer[TopLine] = PRI;\n\t\tMsgTick[TopLine] = MsgTickTime + MsgTime;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Message",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "PRI"
                            ],
                            [
                                "coerce",
                                "string",
                                "Msg"
                            ],
                            [
                                "name",
                                "N"
                            ]
                        ],
                        "return": ""
                    },
                    "NotifyLevelChange": {
                        "body": "{\n\tbRestartTimeDemo = True;\n\tClearMessages();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "NotifyLevelChange",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostRender": {
                        "body": "{\n\n\tif(bNoDrawWorld)\n\t{\n\t\tC.SetPos(0,0);\n\t\tC.DrawPattern( Texture'Border', C.ClipX, C.ClipY, 1.0 );\n\t}\n\n\tif( bTimeDemo )\n\t{\n\t\tTimeDemoCalc();\n\t\tTimeDemoRender( C );\n\t}\n\n\t// call overridable \"level action\" rendering code to draw the \"big message\"\n\tDrawLevelAction( C );\n\n\t// If the console has changed since the previous frame, draw it.\n\tif ( ConsoleLines > 0 )\n\t{\n\t\t// DEUS_EX AJY\n\t\tC.Style = 1;\n\t\tC.DrawColor.R = 128;\n\t\tC.DrawColor.G = 128;\n\t\tC.DrawColor.B = 128;\n\t\tC.SetPos(0.0, ConsoleLines - FrameY);\n\t\tC.SetOrigin(0.0, 0.0);\n\t\tC.DrawTile(ConBackground, FrameX, FrameY, 0.0, 0.0, FrameX, FrameY);\n\n\t}\n\n\t// Draw border.\n\tif ( BorderLines > 0 || BorderPixels > 0 )\n\t{\n\t\tYStart \t= BorderLines + ConsoleLines;\n\t\tYEnd \t= FrameY - BorderLines;\n\t\tif ( BorderLines > 0 )\n\t\t{\n\t\t\tC.SetOrigin(0.0, 0.0);\n\t\t\tC.SetPos(0.0, 0.0);\n\t\t\tC.DrawPattern( Border, FrameX, BorderLines, 1.0 );\n\t\t\tC.SetPos(0.0, YEnd);\n\t\t\tC.DrawPattern( Border, FrameX, BorderLines, 1.0 );\n\t\t}\n\t\tif ( BorderPixels > 0 )\n\t\t{\n\t\t\tC.SetOrigin(0.0, 0.0);\n\t\t\tC.SetPos(0.0, YStart);\n\t\t\tC.DrawPattern( Border, BorderPixels, YEnd - YStart, 1.0 );\n\t\t\tC.SetPos( FrameX - BorderPixels, YStart );\n\t\t\tC.DrawPattern( Border, BorderPixels, YEnd - YStart, 1.0 );\n\t\t}\n\t}\n\n\t// Draw console text.\n\tC.SetOrigin(0.0, 0.0);\n\tif ( ConsoleLines > 0 )\n\t\tDrawConsoleView( C );\n\telse\n\t\tDrawSingleView( C );\n}",
                        "locals": [
                            "local int YStart, YEnd, Y, I, J, Line, iLine;"
                        ],
                        "modifiers": [],
                        "name": "PostRender",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "C"
                            ]
                        ],
                        "return": ""
                    },
                    "PreRender": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreRender",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "C"
                            ]
                        ],
                        "return": ""
                    },
                    "PrintActionMessage": {
                        "body": "{\n\n\tC.bCenter = false;\n\tC.StrLen( BigMessage, XL, YL );\n\tC.SetPos(FrameX/2 - XL/2, FrameY/2 - YL/2);\n\tC.DrawText( BigMessage, false );\n}",
                        "locals": [
                            "local float XL, YL;"
                        ],
                        "modifiers": [],
                        "name": "PrintActionMessage",
                        "native": false,
                        "param": [
                            [
                                "Canvas",
                                "C"
                            ],
                            [
                                "string",
                                "BigMessage"
                            ]
                        ],
                        "return": ""
                    },
                    "PrintTimeDemoResult": {
                        "body": "{\n\n\tEntry = Viewport.Actor.GetEntryLevel();\n\n\tDelta = Entry.TimeSeconds - StartTime - ExtraTime;\n\tif(Delta <= 0)\n\t\tAvg = 0;\n\telse\n\t\tAvg = FrameCount / Delta;\n\t\n\tAvgString = string(FrameCount)@FramesText@FormatFloat(delta)@SecondsText@MinText@FormatFloat(MinFPS)@MaxText@FormatFloat(MaxFPS)@AvgText@FormatFloat(Avg)@fpsText$\".\";\n\tViewport.Actor.ClientMessage(AvgString);\n\tLog(AvgString);\n\tif(bSaveTimeDemoToFile)\n\t{\t\t\n\t\tTemp =\n\t\t\tFormatFloat(Avg) $ \" Unreal \"$ Viewport.Actor.Level.EngineVersion $ Chr(13) $ Chr(10) $\n\t\t\tFormatFloat(MinFPS) $ \" Min\"$ Chr(13) $ Chr(10) $\n\t\t\tFormatFloat(MaxFPS) $ \" Max\"$ Chr(13) $ Chr(10);\n\t\t\t\n\t\tSaveTimeDemo(Temp);\n\t}\n}",
                        "locals": [
                            "local LevelInfo Entry;",
                            "local float Avg;",
                            "local float Delta;",
                            "local string AvgString;",
                            "local string Temp;"
                        ],
                        "modifiers": [],
                        "name": "PrintTimeDemoResult",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SaveTimeDemo": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SaveTimeDemo",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "SetMsgPlayer": {
                        "body": "{\n\tMsgPlayer[Index] = NewMsgPlayer;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetMsgPlayer",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Index"
                            ],
                            [
                                "PlayerReplicationInfo",
                                "NewMsgPlayer"
                            ]
                        ],
                        "return": ""
                    },
                    "SetMsgText": {
                        "body": "{\n\tMsgText[Index] = NewMsgText;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetMsgText",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Index"
                            ],
                            [
                                "string",
                                "NewMsgText"
                            ]
                        ],
                        "return": ""
                    },
                    "SetMsgTick": {
                        "body": "{\n\tMsgTick[Index] = NewMsgTick;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetMsgTick",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Index"
                            ],
                            [
                                "int",
                                "NewMsgTick"
                            ]
                        ],
                        "return": ""
                    },
                    "SetMsgType": {
                        "body": "{\n\tMsgType[Index] = NewMsgType;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetMsgType",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Index"
                            ],
                            [
                                "name",
                                "NewMsgType"
                            ]
                        ],
                        "return": ""
                    },
                    "StartTimeDemo": {
                        "body": "{\n\tif(bTimeDemo)\n\t\treturn;\n\tbTimeDemo = True;\n\tbStartTimeDemo = True;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StartTimeDemo",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StopTimeDemo": {
                        "body": "{\n\tif(!bTimeDemo)\n\t\treturn;\n\tbTimeDemo = False;\n\tPrintTimeDemoResult();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StopTimeDemo",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Talk": {
                        "body": "{\n\tTypedStr=\"Say \";\n\tbNoStuff = true;\n\tGotoState( 'Typing' );\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Talk",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TeamTalk": {
                        "body": "{\n\tTypedStr=\"TeamSay \";\n\tbNoStuff = true;\n\tGotoState( 'Typing' );\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "TeamTalk",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n\tMsgTickTime += Delta;\n\n\t// Slide console up or down.\n\tif( ConsolePos < ConsoleDest )\n\t\tConsolePos = FMin(ConsolePos+Delta,ConsoleDest);\n\telse if( ConsolePos > ConsoleDest )\n\t\tConsolePos = FMax(ConsolePos-Delta,ConsoleDest);\n\n\t// Update status message.\n\tif( ((MsgTime-=Delta) <= 0.0) && (TextLines > 0) )\n\t\tTextLines--;\n\n   // Update progress messages.\n   if (Viewport.Actor.ProgressTimeOut > Viewport.Actor.Level.TimeSeconds)\n   {\n      Viewport.Actor.ShowProgress();\n   }\n}",
                        "locals": [
                            "local int I;"
                        ],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Delta"
                            ]
                        ],
                        "return": ""
                    },
                    "TimeDemo": {
                        "body": "{\n\tbSaveTimeDemoToFile = bSaveToFile;\n\tif(bEnabled)\n\t\tStartTimeDemo();\n\telse\n\t\tStopTimeDemo();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "TimeDemo",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "bEnabled"
                            ],
                            [
                                "optional",
                                "bool",
                                "bSaveToFile"
                            ]
                        ],
                        "return": ""
                    },
                    "TimeDemoCalc": {
                        "body": "{\n\tEntry = Viewport.Actor.GetEntryLevel();\n\n\tif( bRestartTimeDemo )\n\t{\n\t\tStopTimeDemo();\n\t\tStartTimeDemo();\n\t\tbRestartTimeDemo = False;\n\t}\n\n\tif(\tbStartTimeDemo )\n\t{\n\t\tbStartTimeDemo = False;\n\t\tStartTime = Entry.TimeSeconds;\n\t\tExtraTime =  0;\n\t\tLastFrameTime = StartTime;\n\t\tLastSecondStartTime = StartTime;\n\t\tFrameCount = 0;\n\t\tLastSecondFrameCount = 0;\n\t\tMinFPS = 0;\n\t\tMaxFPS = 0;\t\t\n\t\tLastSecFPS = 0;\n\t\treturn;\n\t}\n\n\tDelta = Entry.TimeSeconds - LastFrameTime;\n\n\t// If delta time is more than a half of a second, ignore frame entirely (precaching, loading etc)\n\tif( Delta > 0.5 )\n\t{\n\t\tExtraTime += Delta;\n\t\tLastSecondStartTime = Entry.TimeSeconds;\n\t\tLastSecondFrameCount = 0;\n\t\tLastFrameTime = Entry.TimeSeconds;\n\t\treturn;\n\t}\n\n\tFrameCount++;\n\tLastSecondFrameCount++;\n\n\tif( Entry.TimeSeconds - LastSecondStartTime > 1)\n\t{\n\t\tLastSecFPS = LastSecondFrameCount / (Entry.TimeSeconds - LastSecondStartTime);\n\t\tif( MinFPS == 0 || LastSecFPS < MinFPS )\n\t\t\tMinFPS = LastSecFPS;\n\t\tif( LastSecFPS > MaxFPS )\n\t\t\tMaxFPS = LastSecFPS;\n\t\tLastSecondFrameCount = 0;\n\t\tLastSecondStartTime = Entry.TimeSeconds;\n\t}\n\n\tLastFrameTime = Entry.TimeSeconds;\n}",
                        "locals": [
                            "local LevelInfo Entry;",
                            "local float Delta;"
                        ],
                        "modifiers": [],
                        "name": "TimeDemoCalc",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TimeDemoRender": {
                        "body": "{\n\n\tC.Font = TimeDemoFont;\n\tC.DrawColor.R = 255;\n\tC.DrawColor.G = 255;\n\tC.DrawColor.B = 255;\n\n\tAText = AvgText @ FormatFloat(FrameCount / (Viewport.Actor.GetEntryLevel().TimeSeconds - StartTime - ExtraTime));\n\tLText = LastSecText @ FormatFloat(LastSecFPS);\n\n\tC.TextSize(AText, W, H);\n\tC.SetPos(C.ClipX - W, 0.3*C.ClipY);\n\tC.DrawText(AText);\n\tC.TextSize(LText, W, H);\n\tC.SetPos(C.ClipX - W, 0.3*C.ClipY+H);\n\tC.DrawText(LText);\n}",
                        "locals": [
                            "local string AText, LText;",
                            "local float W, H;"
                        ],
                        "modifiers": [],
                        "name": "TimeDemoRender",
                        "native": false,
                        "param": [
                            [
                                "Canvas",
                                "C"
                            ]
                        ],
                        "return": ""
                    },
                    "Type": {
                        "body": "{\n\t\tTypedStr=\"\";\n\t\tgotoState( '' );\n\t}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Type",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "VideoChange": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "VideoChange",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ViewDown": {
                        "body": "{\n//\tBorderSize = Clamp( BorderSize+1, 0, MaxBorder );\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ViewDown",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ViewUp": {
                        "body": "{\n//\tBorderSize = Clamp( BorderSize-1, 0, MaxBorder );\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ViewUp",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 1039,
                "replication": "",
                "states": [],
                "variables": [
                    "var private const int vtblOut;",
                    "var viewport Viewport;",
                    "var int HistoryTop, HistoryBot, HistoryCur;",
                    "var string TypedStr, History[16];",
                    "var int Scrollback, NumLines, TopLine, TextLines;",
                    "var float MsgTime, MsgTickTime;",
                    "var string MsgText[64];",
                    "var name MsgType[64];",
                    "var PlayerReplicationInfo MsgPlayer[64];",
                    "var float MsgTick[64];",
                    "var int BorderSize;",
                    "var int ConsoleLines, BorderLines, BorderPixels;",
                    "var float ConsolePos, ConsoleDest;",
                    "var float FrameX, FrameY;",
                    "var texture ConBackground, Border;",
                    "var bool bNoStuff, bTyping;",
                    "var bool bNoDrawWorld;",
                    "var bool bTimeDemo;",
                    "var bool bStartTimeDemo;",
                    "var bool bRestartTimeDemo;",
                    "var bool bSaveTimeDemoToFile;",
                    "var float StartTime;",
                    "var float ExtraTime;",
                    "var float LastFrameTime;",
                    "var float LastSecondStartTime;",
                    "var int FrameCount;",
                    "var int LastSecondFrameCount;",
                    "var float MinFPS;",
                    "var float MaxFPS;",
                    "var float LastSecFPS;",
                    "var Font TimeDemoFont;",
                    "var localized string LoadingMessage;",
                    "var localized string SavingMessage;",
                    "var localized string ConnectingMessage;",
                    "var localized string PausedMessage;",
                    "var localized string PrecachingMessage;",
                    "var localized string FrameRateText;",
                    "var localized string AvgText;",
                    "var localized string LastSecText;",
                    "var localized string MinText;",
                    "var localized string MaxText;",
                    "var localized string fpsText;",
                    "var localized string SecondsText;",
                    "var localized string FramesText;"
                ]
            }
        },
        "Counter.uc": {
            "body": "//=============================================================================\n// Counter: waits until it has been triggered 'NumToCount' times, and then\n// it sends Trigger/UnTrigger events to actors whose names match 'EventName'.\n//=============================================================================\nclass Counter extends Triggers;\n\n#exec Texture Import File=Textures\\Counter.pcx Name=S_Counter Mips=Off Flags=2\n\n//-----------------------------------------------------------------------------\n// Counter variables.\n\nvar() byte       NumToCount;                // Number to count down from.\nvar() bool       bShowMessage;              // Display count message?\nvar() localized  string CountMessage;       // Human readable count message.\nvar() localized  string CompleteMessage;    // Completion message.\nvar   byte       OriginalNum;               // Number to count at startup time.\n\n//-----------------------------------------------------------------------------\n// Counter functions.\n\n//\n// Init for play.\n//\nfunction BeginPlay()\n{\n\tOriginalNum = NumToCount;\n}\n\n//\n// Reset the counter.\n//\nfunction Reset()\n{\n\tNumToCount = OriginalNum;\n}\n\n//\n// Counter was triggered.\n//\nfunction Trigger( actor Other, pawn EventInstigator )\n{\n\tlocal string S;\n\tlocal string Num;\n\tlocal int i;\n\tlocal actor A;\n\n\tif( NumToCount > 0 )\n\t{\n\t\tif( --NumToCount == 0 )\n\t\t{\n\t\t\t// Trigger all matching actors.\n\t\t\tif( bShowMessage && CompleteMessage != \"\" )\n\t\t\t\tEventInstigator.ClientMessage( CompleteMessage );\n\t\t\tif( Event != '' )\n\t\t\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\t\t\tA.Trigger( Other, EventInstigator );\n\t\t}\n\t\telse if( bShowMessage && CountMessage != \"\" )\n\t\t{\n\t\t\t// Still counting down.\n\t\t\tswitch( NumToCount )\n\t\t\t{\n\t\t\t\tcase 1:  Num=\"one\"; break;\n\t\t\t\tcase 2:  Num=\"two\"; break;\n\t\t\t\tcase 3:  Num=\"three\"; break;\n\t\t\t\tcase 4:  Num=\"four\"; break;\n\t\t\t\tcase 5:  Num=\"five\"; break;\n\t\t\t\tcase 6:  Num=\"six\"; break;\n\t\t\t\tdefault: Num=string(NumToCount); break;\n\t\t\t}\n\t\t\tS = CountMessage;\n\t\t\twhile( InStr(S, \"%i\") >= 0 )\n\t\t\t{\n\t\t\t\ti = InStr(S, \"%i\");\n\t\t\t\tS = Left(S,i) $ Num $ Mid(S,i+2);\n\t\t\t}\n\t\t\tEventInstigator.ClientMessage( S );\n\t\t}\n\t}\n}\n\ndefaultproperties\n{\n     NumToCount=2\n     CountMessage=\"Only %i more to go...\"\n     CompleteMessage=\"Completed!\"\n     Texture=Texture'Engine.S_Counter'\n}\n",
            "name": "Counter.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "NumToCount=2",
                    "CountMessage=\"Only %i more to go...\"",
                    "CompleteMessage=\"Completed!\"",
                    "Texture=Texture'Engine.S_Counter'"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Counter.pcx Name=S_Counter Mips=Off Flags=2"
                ],
                "extends": "Triggers",
                "functions": {
                    "BeginPlay": {
                        "body": "{\n\tOriginalNum = NumToCount;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Reset": {
                        "body": "{\n\tNumToCount = OriginalNum;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Reset",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "{\n\n\tif( NumToCount > 0 )\n\t{\n\t\tif( --NumToCount == 0 )\n\t\t{\n\t\t\t// Trigger all matching actors.\n\t\t\tif( bShowMessage && CompleteMessage != \"\" )\n\t\t\t\tEventInstigator.ClientMessage( CompleteMessage );\n\t\t\tif( Event != '' )\n\t\t\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\t\t\tA.Trigger( Other, EventInstigator );\n\t\t}\n\t\telse if( bShowMessage && CountMessage != \"\" )\n\t\t{\n\t\t\t// Still counting down.\n\t\t\tswitch( NumToCount )\n\t\t\t{\n\t\t\t\tcase 1:  Num=\"one\"; break;\n\t\t\t\tcase 2:  Num=\"two\"; break;\n\t\t\t\tcase 3:  Num=\"three\"; break;\n\t\t\t\tcase 4:  Num=\"four\"; break;\n\t\t\t\tcase 5:  Num=\"five\"; break;\n\t\t\t\tcase 6:  Num=\"six\"; break;\n\t\t\t\tdefault: Num=string(NumToCount); break;\n\t\t\t}\n\t\t\tS = CountMessage;\n\t\t\twhile( InStr(S, \"%i\") >= 0 )\n\t\t\t{\n\t\t\t\ti = InStr(S, \"%i\");\n\t\t\t\tS = Left(S,i) $ Num $ Mid(S,i+2);\n\t\t\t}\n\t\t\tEventInstigator.ClientMessage( S );\n\t\t}\n\t}\n}",
                        "locals": [
                            "local string S;",
                            "local string Num;",
                            "local int i;",
                            "local actor A;"
                        ],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 89,
                "replication": "",
                "states": [],
                "variables": [
                    "var() byte       NumToCount;                // Number to count down from.",
                    "var() bool       bShowMessage;              // Display count message?",
                    "var() localized  string CountMessage;       // Human readable count message.",
                    "var() localized  string CompleteMessage;    // Completion message.",
                    "var   byte       OriginalNum;               // Number to count at startup time."
                ]
            }
        },
        "DamageType.uc": {
            "body": "//=============================================================================\n// DamageType, the base class of all damagetypes.\n// this and its subclasses are never spawned, just used as information holders\n//=============================================================================\nclass DamageType extends Actor\n\tabstract;\n\n// Description of a type of damage.\nvar() localized string     Name;         // Description of damage.\nvar() localized string     AltName;      // Alternative description.\nvar() float                ViewFlash;    // View flash to play.\nvar() vector               ViewFog;      // View fog to play.\nvar() class<effects>       DamageEffect; // Special effect.\n\nstatic function string DeathMessage()\n{\n\tif( FRand() < 0.5 )\n\t\treturn Default.Name;\n\telse \n\t\treturn Default.AltName;\n}\n\ndefaultproperties\n{\n     AltName=\"killed\"\n}\n",
            "name": "DamageType.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "AltName=\"killed\""
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "DeathMessage": {
                        "body": "{\n\tif( FRand() < 0.5 )\n\t\treturn Default.Name;\n\telse \n\t\treturn Default.AltName;\n}",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "DeathMessage",
                        "native": false,
                        "param": [],
                        "return": "string"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 27,
                "replication": "",
                "states": [],
                "variables": [
                    "var() localized string     Name;         // Description of damage.",
                    "var() localized string     AltName;      // Alternative description.",
                    "var() float                ViewFlash;    // View flash to play.",
                    "var() vector               ViewFog;      // View fog to play.",
                    "var() class<effects>       DamageEffect; // Special effect."
                ]
            }
        },
        "Decal.uc": {
            "body": "class Decal expands Actor\n\tnative;\n\n// properties\nvar int MultiDecalLevel;\nvar float LastRenderedTime;\n\n// native stuff.\nvar const array<int> SurfList;\n\nsimulated native function bool AttachDecal( float TraceDistance, optional vector DecalDir ); // trace forward and attach this decal to surfaces.\nsimulated native function DetachDecal(); // detach this decal from all surfaces.\n\nsimulated event BeginPlay()\n{\n\tif(!AttachDecal(100))\t// trace 100 units ahead in direction of current rotation\n\t\tDestroy();\n}\n\nsimulated event Destroyed()\n{\n\tDetachDecal();\n\tSuper.Destroyed();\n}\n\nevent Update(Actor L);\n\ndefaultproperties\n{\n     MultiDecalLevel=4\n     bHighDetail=True\n     bNetTemporary=True\n     bNetOptional=True\n     RemoteRole=ROLE_None\n     DrawType=DT_None\n     bUnlit=True\n     bGameRelevant=True\n     CollisionRadius=0.000000\n     CollisionHeight=0.000000\n}\n",
            "name": "Decal.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "MultiDecalLevel=4",
                    "bHighDetail=True",
                    "bNetTemporary=True",
                    "bNetOptional=True",
                    "RemoteRole=ROLE_None",
                    "DrawType=DT_None",
                    "bUnlit=True",
                    "bGameRelevant=True",
                    "CollisionRadius=0.000000",
                    "CollisionHeight=0.000000"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "BeginPlay": {
                        "body": "{\n\tif(!AttachDecal(100))\t// trace 100 units ahead in direction of current rotation\n\t\tDestroy();\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "BeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Destroyed": {
                        "body": "{\n\tDetachDecal();\n\tSuper.Destroyed();\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Destroyed",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Update": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Update",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "L"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 41,
                "replication": "",
                "states": [],
                "variables": [
                    "var int MultiDecalLevel;",
                    "var float LastRenderedTime;",
                    "var const array<int> SurfList;"
                ]
            }
        },
        "Decoration.uc": {
            "body": "//=============================================================================\n// Decoration.\n//=============================================================================\nclass Decoration extends Actor\n\tabstract\n\tnative;\n\n// If set, the pyrotechnic or explosion when item is damaged.\nvar() class<actor> EffectWhenDestroyed;\nvar() bool bPushable;\nvar() bool bOnlyTriggerable;\nvar bool bSplash;\nvar bool bBobbing;\nvar bool bWasCarried;\nvar() sound PushSound;\nvar const int\t numLandings; // Used by engine physics.\nvar() class<inventory> contents;\nvar() class<inventory> content2;\nvar() class<inventory> content3;\nvar() sound EndPushSound;\nvar bool bPushSoundPlaying;\n\n// DEUS_EX AJY\n// Converstion Crap\nvar Float   BaseEyeHeight;\n\nsimulated function FollowHolder(Actor Other);\n\nfunction Drop(vector newVel);\n\nfunction Landed(vector HitNormall)\n{\n\tif( bWasCarried && !SetLocation(Location) )\n\t{\n\t\tif( Instigator!=None && (VSize(Instigator.Location - Location) < CollisionRadius + Instigator.CollisionRadius) )\n\t\t\tSetLocation(Instigator.Location);\n\t\tTakeDamage( 1000, Instigator, Location, Vect(0,0,1)*900,'exploded' );\n\t}\n\tbWasCarried = false;\n\tbBobbing = false;\n}\n\nsingular function ZoneChange( ZoneInfo NewZone )\n{\n\tlocal float splashsize;\n\tlocal actor splash;\n\n\tif( NewZone.bWaterZone )\n\t{\n\t\tif( bSplash && !Region.Zone.bWaterZone && Mass<=Buoyancy \n\t\t\t&& ((Abs(Velocity.Z) < 100) || (Mass == 0)) && (FRand() < 0.05) && !PlayerCanSeeMe() )\n\t\t{\n\t\t\tbSplash = false;\n\t\t\tSetPhysics(PHYS_None);\n\t\t}\n\t\telse if( !Region.Zone.bWaterZone && (Velocity.Z < -200) )\n\t\t{\n\t\t\t// Else play a splash.\n\t\t\tsplashSize = FClamp(0.0001 * Mass * (250 - 0.5 * FMax(-600,Velocity.Z)), 1.0, 3.0 );\n\t\t\tif( NewZone.EntrySound != None )\n\t\t\t\tPlaySound(NewZone.EntrySound, SLOT_Interact, splashSize);\n\t\t\tif( NewZone.EntryActor != None )\n\t\t\t{\n\t\t\t\tsplash = Spawn(NewZone.EntryActor); \n\t\t\t\tif ( splash != None )\n\t\t\t\t\tsplash.DrawScale = splashSize;\n\t\t\t}\n\t\t}\n\t\tbSplash = true;\n\t}\n\telse if( Region.Zone.bWaterZone && (Buoyancy > Mass) )\n\t{\n//\t\tbBobbing = true;      // removed (looked stupid) - DEUS_EX CNN\n\t\tif( Buoyancy > 1.1 * Mass )\n\t\t\tBuoyancy = 0.95 * Buoyancy; // waterlog\n\t\telse if( Buoyancy > 1.03 * Mass )\n\t\t\tBuoyancy = 0.99 * Buoyancy;\n\t}\n\n\tif( NewZone.bPainZone && (NewZone.DamagePerSec > 0) )\n\t\tTakeDamage(100, None, location, vect(0,0,0), NewZone.DamageType);\n}\n\nfunction Trigger( actor Other, pawn EventInstigator )\n{\n\tInstigator = EventInstigator;\n\tTakeDamage( 1000, Instigator, Location, Vect(0,0,1)*900,'exploded' );\n}\n\nsingular function BaseChange()\n{\n\tlocal float decorMass, decorMass2;\n\n\tdecormass= FMax(1, Mass);\n\tbBobbing = false;\n\tif( Velocity.Z < -500 )\n\t\tTakeDamage( (1-Velocity.Z/30),Instigator,Location,vect(0,0,0) , 'crushed');\n\n\tif( (base == None) && (bPushable || IsA('Carcass')) && (Physics == PHYS_None) )\n\t\tSetPhysics(PHYS_Falling);\n\telse if( (Pawn(base) != None) && (Pawn(Base).CarriedDecoration != self) )\n\t{\n\t\tBase.TakeDamage( (1-Velocity.Z/400)* decormass/Base.Mass,Instigator,Location,0.5 * Velocity , 'crushed');\n\t\tVelocity.Z = 100;\n\t\tif (FRand() < 0.5)\n\t\t\tVelocity.X += 70;\n\t\telse\n\t\t\tVelocity.Y += 70;\n\t\tSetPhysics(PHYS_Falling);\n\t}\n\telse if( Decoration(Base)!=None && Velocity.Z<-500 )\n\t{\n\t\tdecorMass2 = FMax(Decoration(Base).Mass, 1);\n\t\tBase.TakeDamage((1 - decorMass/decorMass2 * Velocity.Z/30), Instigator, Location, 0.2 * Velocity, 'stomped');\n\t\tVelocity.Z = 100;\n\t\tif (FRand() < 0.5)\n\t\t\tVelocity.X += 70;\n\t\telse\n\t\t\tVelocity.Y += 70;\n\t\tSetPhysics(PHYS_Falling);\n\t}\n\telse\n\t\tinstigator = None;\n}\n\nfunction Destroyed()\n{\n\tlocal actor dropped, A;\n\tlocal class<actor> tempClass;\n\n\tif( (Pawn(Base) != None) && (Pawn(Base).CarriedDecoration == self) )\n\t\tPawn(Base).DropDecoration();\n\tif( (Contents!=None) && !Level.bStartup )\n\t{\n\t\ttempClass = Contents;\n\t\tif (Content2!=None && FRand()<0.3) tempClass = Content2;\n\t\tif (Content3!=None && FRand()<0.3) tempClass = Content3;\n\t\tdropped = Spawn(tempClass);\n\t\tdropped.RemoteRole = ROLE_DumbProxy;\n\t\tdropped.SetPhysics(PHYS_Falling);\n\t\tdropped.bCollideWorld = true;\n\t\tif ( inventory(dropped) != None )\n\t\t\tinventory(dropped).GotoState('Pickup', 'Dropped');\n\t}\t\n\n\tif( Event != '' )\n\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\tA.Trigger( Self, None );\n\n\tif ( bPushSoundPlaying )\n\t\tPlaySound(EndPushSound, SLOT_Misc,0.0);\n\t\t\t\n\tSuper.Destroyed();\n}\n\nsimulated function skinnedFrag(class<fragment> FragType, texture FragSkin, vector Momentum, float DSize, int NumFrags) \n{\n\tlocal int i;\n\tlocal actor A, Toucher;\n\tlocal Fragment s;\n\n\tif ( bOnlyTriggerable )\n\t\treturn; \n\tif (Event!='')\n\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\tA.Trigger( Toucher, pawn(Toucher) );\n\tif ( Region.Zone.bDestructive )\n\t{\n\t\tDestroy();\n\t\treturn;\n\t}\n\tfor (i=0 ; i<NumFrags ; i++) \n\t{\n\t\ts = Spawn( FragType, Owner);\n\t\ts.CalcVelocity(Momentum/100,0);\n\t\ts.Skin = FragSkin;\n\t\ts.DrawScale = DSize*0.5+0.7*DSize*FRand();\n\t}\n\n\tDestroy();\n}\n\nsimulated function Frag(class<fragment> FragType, vector Momentum, float DSize, int NumFrags) \n{\n\tlocal int i;\n\tlocal actor A, Toucher;\n\tlocal Fragment s;\n\n\tif ( bOnlyTriggerable )\n\t\treturn; \n\tif (Event!='')\n\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\tA.Trigger( Toucher, pawn(Toucher) );\n\tif ( Region.Zone.bDestructive )\n\t{\n\t\tDestroy();\n\t\treturn;\n\t}\n\tfor (i=0 ; i<NumFrags ; i++) \n\t{\n\t\ts = Spawn( FragType, Owner);\n\t\ts.CalcVelocity(Momentum,0);\n\t\ts.DrawScale = DSize*0.5+0.7*DSize*FRand();\n\t}\n\n\tDestroy();\n}\n\nfunction Timer()\n{\n\tPlaySound(EndPushSound, SLOT_Misc,0.0);\n\tbPushSoundPlaying=False;\n}\n\nfunction Bump( actor Other )\n{\n\tlocal float speed, oldZ;\n\tif( bPushable && (Pawn(Other)!=None) && (Other.Mass > 40) )\n\t{\n\t\tbBobbing = false;\n\t\toldZ = Velocity.Z;\n\t\tspeed = VSize(Other.Velocity);\n\t\tVelocity = Other.Velocity * FMin(120.0, 20 + speed)/speed;\n\t\tif ( Physics == PHYS_None ) {\n\t\t\tVelocity.Z = 25;\n\t\t\tif (!bPushSoundPlaying) PlaySound(PushSound, SLOT_Misc,0.25);\n\t\t\tbPushSoundPlaying = True;\t\t\t\n\t\t}\n\t\telse\n\t\t\tVelocity.Z = oldZ;\n\t\tSetPhysics(PHYS_Falling);\n\t\tSetTimer(0.3,False);\n\t\tInstigator = Pawn(Other);\n\t}\n}\n\ndefaultproperties\n{\n     bStatic=True\n     bStasis=True\n     Texture=None\n     Mass=0.000000\n}\n",
            "name": "Decoration.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bStatic=True",
                    "bStasis=True",
                    "Texture=None",
                    "Mass=0.000000"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "BaseChange": {
                        "body": "{\n\n\tdecormass= FMax(1, Mass);\n\tbBobbing = false;\n\tif( Velocity.Z < -500 )\n\t\tTakeDamage( (1-Velocity.Z/30),Instigator,Location,vect(0,0,0) , 'crushed');\n\n\tif( (base == None) && (bPushable || IsA('Carcass')) && (Physics == PHYS_None) )\n\t\tSetPhysics(PHYS_Falling);\n\telse if( (Pawn(base) != None) && (Pawn(Base).CarriedDecoration != self) )\n\t{\n\t\tBase.TakeDamage( (1-Velocity.Z/400)* decormass/Base.Mass,Instigator,Location,0.5 * Velocity , 'crushed');\n\t\tVelocity.Z = 100;\n\t\tif (FRand() < 0.5)\n\t\t\tVelocity.X += 70;\n\t\telse\n\t\t\tVelocity.Y += 70;\n\t\tSetPhysics(PHYS_Falling);\n\t}\n\telse if( Decoration(Base)!=None && Velocity.Z<-500 )\n\t{\n\t\tdecorMass2 = FMax(Decoration(Base).Mass, 1);\n\t\tBase.TakeDamage((1 - decorMass/decorMass2 * Velocity.Z/30), Instigator, Location, 0.2 * Velocity, 'stomped');\n\t\tVelocity.Z = 100;\n\t\tif (FRand() < 0.5)\n\t\t\tVelocity.X += 70;\n\t\telse\n\t\t\tVelocity.Y += 70;\n\t\tSetPhysics(PHYS_Falling);\n\t}\n\telse\n\t\tinstigator = None;\n}",
                        "locals": [
                            "local float decorMass, decorMass2;"
                        ],
                        "modifiers": [
                            "singular"
                        ],
                        "name": "BaseChange",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Bump": {
                        "body": "{\n\tif( bPushable && (Pawn(Other)!=None) && (Other.Mass > 40) )\n\t{\n\t\tbBobbing = false;\n\t\toldZ = Velocity.Z;\n\t\tspeed = VSize(Other.Velocity);\n\t\tVelocity = Other.Velocity * FMin(120.0, 20 + speed)/speed;\n\t\tif ( Physics == PHYS_None ) {\n\t\t\tVelocity.Z = 25;\n\t\t\tif (!bPushSoundPlaying) PlaySound(PushSound, SLOT_Misc,0.25);\n\t\t\tbPushSoundPlaying = True;\t\t\t\n\t\t}\n\t\telse\n\t\t\tVelocity.Z = oldZ;\n\t\tSetPhysics(PHYS_Falling);\n\t\tSetTimer(0.3,False);\n\t\tInstigator = Pawn(Other);\n\t}",
                        "locals": [
                            "local float speed, oldZ;"
                        ],
                        "modifiers": [],
                        "name": "Bump",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "Destroyed": {
                        "body": "{\n\n\tif( (Pawn(Base) != None) && (Pawn(Base).CarriedDecoration == self) )\n\t\tPawn(Base).DropDecoration();\n\tif( (Contents!=None) && !Level.bStartup )\n\t{\n\t\ttempClass = Contents;\n\t\tif (Content2!=None && FRand()<0.3) tempClass = Content2;\n\t\tif (Content3!=None && FRand()<0.3) tempClass = Content3;\n\t\tdropped = Spawn(tempClass);\n\t\tdropped.RemoteRole = ROLE_DumbProxy;\n\t\tdropped.SetPhysics(PHYS_Falling);\n\t\tdropped.bCollideWorld = true;\n\t\tif ( inventory(dropped) != None )\n\t\t\tinventory(dropped).GotoState('Pickup', 'Dropped');\n\t}\t\n\n\tif( Event != '' )\n\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\tA.Trigger( Self, None );\n\n\tif ( bPushSoundPlaying )\n\t\tPlaySound(EndPushSound, SLOT_Misc,0.0);\n\t\t\t\n\tSuper.Destroyed();\n}",
                        "locals": [
                            "local actor dropped, A;",
                            "local class<actor> tempClass;"
                        ],
                        "modifiers": [],
                        "name": "Destroyed",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Drop": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Drop",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "newVel"
                            ]
                        ],
                        "return": ""
                    },
                    "FollowHolder": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "FollowHolder",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "Frag": {
                        "body": "{\n\n\tif ( bOnlyTriggerable )\n\t\treturn; \n\tif (Event!='')\n\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\tA.Trigger( Toucher, pawn(Toucher) );\n\tif ( Region.Zone.bDestructive )\n\t{\n\t\tDestroy();\n\t\treturn;\n\t}\n\tfor (i=0 ; i<NumFrags ; i++) \n\t{\n\t\ts = Spawn( FragType, Owner);\n\t\ts.CalcVelocity(Momentum,0);\n\t\ts.DrawScale = DSize*0.5+0.7*DSize*FRand();\n\t}\n\n\tDestroy();\n}",
                        "locals": [
                            "local int i;",
                            "local actor A, Toucher;",
                            "local Fragment s;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Frag",
                        "native": false,
                        "param": [
                            [
                                "class<fragment>",
                                "FragType"
                            ],
                            [
                                "vector",
                                "Momentum"
                            ],
                            [
                                "float",
                                "DSize"
                            ],
                            [
                                "int",
                                "NumFrags"
                            ]
                        ],
                        "return": ""
                    },
                    "Landed": {
                        "body": "{\n\tif( bWasCarried && !SetLocation(Location) )\n\t{\n\t\tif( Instigator!=None && (VSize(Instigator.Location - Location) < CollisionRadius + Instigator.CollisionRadius) )\n\t\t\tSetLocation(Instigator.Location);\n\t\tTakeDamage( 1000, Instigator, Location, Vect(0,0,1)*900,'exploded' );\n\t}\n\tbWasCarried = false;\n\tbBobbing = false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Landed",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "HitNormall"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tPlaySound(EndPushSound, SLOT_Misc,0.0);\n\tbPushSoundPlaying=False;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "{\n\tInstigator = EventInstigator;\n\tTakeDamage( 1000, Instigator, Location, Vect(0,0,1)*900,'exploded' );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    },
                    "ZoneChange": {
                        "body": "{\n\n\tif( NewZone.bWaterZone )\n\t{\n\t\tif( bSplash && !Region.Zone.bWaterZone && Mass<=Buoyancy \n\t\t\t&& ((Abs(Velocity.Z) < 100) || (Mass == 0)) && (FRand() < 0.05) && !PlayerCanSeeMe() )\n\t\t{\n\t\t\tbSplash = false;\n\t\t\tSetPhysics(PHYS_None);\n\t\t}\n\t\telse if( !Region.Zone.bWaterZone && (Velocity.Z < -200) )\n\t\t{\n\t\t\t// Else play a splash.\n\t\t\tsplashSize = FClamp(0.0001 * Mass * (250 - 0.5 * FMax(-600,Velocity.Z)), 1.0, 3.0 );\n\t\t\tif( NewZone.EntrySound != None )\n\t\t\t\tPlaySound(NewZone.EntrySound, SLOT_Interact, splashSize);\n\t\t\tif( NewZone.EntryActor != None )\n\t\t\t{\n\t\t\t\tsplash = Spawn(NewZone.EntryActor); \n\t\t\t\tif ( splash != None )\n\t\t\t\t\tsplash.DrawScale = splashSize;\n\t\t\t}\n\t\t}\n\t\tbSplash = true;\n\t}\n\telse if( Region.Zone.bWaterZone && (Buoyancy > Mass) )\n\t{\n//\t\tbBobbing = true;      // removed (looked stupid) - DEUS_EX CNN\n\t\tif( Buoyancy > 1.1 * Mass )\n\t\t\tBuoyancy = 0.95 * Buoyancy; // waterlog\n\t\telse if( Buoyancy > 1.03 * Mass )\n\t\t\tBuoyancy = 0.99 * Buoyancy;\n\t}\n\n\tif( NewZone.bPainZone && (NewZone.DamagePerSec > 0) )\n\t\tTakeDamage(100, None, location, vect(0,0,0), NewZone.DamageType);\n}",
                        "locals": [
                            "local float splashsize;",
                            "local actor splash;"
                        ],
                        "modifiers": [
                            "singular"
                        ],
                        "name": "ZoneChange",
                        "native": false,
                        "param": [
                            [
                                "ZoneInfo",
                                "NewZone"
                            ]
                        ],
                        "return": ""
                    },
                    "skinnedFrag": {
                        "body": "{\n\n\tif ( bOnlyTriggerable )\n\t\treturn; \n\tif (Event!='')\n\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\tA.Trigger( Toucher, pawn(Toucher) );\n\tif ( Region.Zone.bDestructive )\n\t{\n\t\tDestroy();\n\t\treturn;\n\t}\n\tfor (i=0 ; i<NumFrags ; i++) \n\t{\n\t\ts = Spawn( FragType, Owner);\n\t\ts.CalcVelocity(Momentum/100,0);\n\t\ts.Skin = FragSkin;\n\t\ts.DrawScale = DSize*0.5+0.7*DSize*FRand();\n\t}\n\n\tDestroy();\n}",
                        "locals": [
                            "local int i;",
                            "local actor A, Toucher;",
                            "local Fragment s;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "skinnedFrag",
                        "native": false,
                        "param": [
                            [
                                "class<fragment>",
                                "FragType"
                            ],
                            [
                                "texture",
                                "FragSkin"
                            ],
                            [
                                "vector",
                                "Momentum"
                            ],
                            [
                                "float",
                                "DSize"
                            ],
                            [
                                "int",
                                "NumFrags"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 244,
                "replication": "",
                "states": [],
                "variables": [
                    "var() class<actor> EffectWhenDestroyed;",
                    "var() bool bPushable;",
                    "var() bool bOnlyTriggerable;",
                    "var bool bSplash;",
                    "var bool bBobbing;",
                    "var bool bWasCarried;",
                    "var() sound PushSound;",
                    "var const int\t numLandings; // Used by engine physics.",
                    "var() class<inventory> contents;",
                    "var() class<inventory> content2;",
                    "var() class<inventory> content3;",
                    "var() sound EndPushSound;",
                    "var bool bPushSoundPlaying;",
                    "var Float   BaseEyeHeight;"
                ]
            }
        },
        "DemoRecSpectator.uc": {
            "body": "//=============================================================================\n// DemoRecSpectator - spectator for demo recordings to replicate ClientMessages\n//=============================================================================\n\nclass DemoRecSpectator extends MessagingSpectator;\n\nvar PlayerPawn PlaybackActor;\nvar GameReplicationInfo PlaybackGRI;\n\nfunction ClientMessage( coerce string S, optional name Type, optional bool bBeep )\n{\n\tRepClientMessage( S, Type, bBeep );\n}\n\nfunction TeamMessage( PlayerReplicationInfo PRI, coerce string S, name Type, optional bool bBeep )\n{\n\tRepTeamMessage( PRI, S, Type );\n}\n\nfunction ClientVoiceMessage(PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID)\n{\n\tRepClientVoiceMessage(Sender, Recipient, messagetype, messageID);\n}\n\nfunction ReceiveLocalizedMessage( class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject )\n{\n\tRepReceiveLocalizedMessage( Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );\n}\n\n//==== Called during demo playback ============================================\n\nsimulated function Tick(float Delta)\n{\n\tlocal PlayerPawn p;\n\tlocal GameReplicationInfo g;\n\n\t// find local playerpawn and attach.\n\tif(Level.NetMode == NM_Client)\n\t{\n\t\tif(PlaybackActor == None)\n\t\t{\n\t\t\tforeach AllActors(class'PlayerPawn', p)\n\t\t\t{\n\t\t\t\tif( p.Player.IsA('Viewport') )\n\t\t\t\t{\n\t\t\t\t\tPlaybackActor = p;\n\t\t\t\t\tif(PlaybackGRI != None)\n\t\t\t\t\t\tPlaybackActor.GameReplicationInfo = PlaybackGRI;\n\n\t\t\t\t\tLog(\"Attached to player \"$p);\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(PlaybackGRI == None)\n\t\t{\n\t\t\tforeach AllActors(class'GameReplicationInfo', g)\n\t\t\t{\n\t\t\t\tPlaybackGRI = g;\n\t\t\t\tif(PlaybackActor != None)\n\t\t\t\t\tPlaybackActor.GameReplicationInfo = PlaybackGRI;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(PlaybackActor != None && PlaybackGRI != None)\n\t\t\tDisable('Tick');\n\n\t}\n\telse\n\t{\n\t\tDisable('Tick');\n\t}\n}\n\nsimulated function RepClientMessage( coerce string S, optional name Type, optional bool bBeep )\n{\t\n\tif(PlaybackActor != None && PlaybackActor.Role == ROLE_Authority)\n\t\tPlaybackActor.ClientMessage( S, Type, bBeep );\n}\n\nsimulated function RepTeamMessage( PlayerReplicationInfo PRI, coerce string S, name Type )\n{\n\tif(PlaybackActor != None && PlaybackActor.Role == ROLE_Authority)\n\t\tPlaybackActor.TeamMessage( PRI, S, Type );\n}\n\nsimulated function RepClientVoiceMessage(PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID)\n{\n\tif(PlaybackActor != None && PlaybackActor.Role == ROLE_Authority)\n\t\tPlaybackActor.ClientVoiceMessage(Sender, Recipient, messagetype, messageID);\n}\n\nsimulated function RepReceiveLocalizedMessage( class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject )\n{\n\tif(PlaybackActor != None && PlaybackActor.Role == ROLE_Authority)\n\t\tPlaybackActor.ReceiveLocalizedMessage( Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );\n}\n\nreplication\n{\n\treliable if ( bDemoRecording )\n\t\tRepClientMessage, RepTeamMessage, RepClientVoiceMessage, RepReceiveLocalizedMessage;\n}\n\ndefaultproperties\n{\n}\n",
            "name": "DemoRecSpectator.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "MessagingSpectator",
                "functions": {
                    "ClientMessage": {
                        "body": "{\n\tRepClientMessage( S, Type, bBeep );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientMessage",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "S"
                            ],
                            [
                                "optional",
                                "name",
                                "Type"
                            ],
                            [
                                "optional",
                                "bool",
                                "bBeep"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientVoiceMessage": {
                        "body": "{\n\tRepClientVoiceMessage(Sender, Recipient, messagetype, messageID);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientVoiceMessage",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "Sender"
                            ],
                            [
                                "PlayerReplicationInfo",
                                "Recipient"
                            ],
                            [
                                "name",
                                "messagetype"
                            ],
                            [
                                "byte",
                                "messageID"
                            ]
                        ],
                        "return": ""
                    },
                    "ReceiveLocalizedMessage": {
                        "body": "{\n\tRepReceiveLocalizedMessage( Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ReceiveLocalizedMessage",
                        "native": false,
                        "param": [
                            [
                                "class<LocalMessage>",
                                "Message"
                            ],
                            [
                                "optional",
                                "int",
                                "Switch"
                            ],
                            [
                                "optional",
                                "PlayerReplicationInfo",
                                "RelatedPRI_1"
                            ],
                            [
                                "optional",
                                "PlayerReplicationInfo",
                                "RelatedPRI_2"
                            ],
                            [
                                "optional",
                                "Object",
                                "OptionalObject"
                            ]
                        ],
                        "return": ""
                    },
                    "RepClientMessage": {
                        "body": "{\t\n\tif(PlaybackActor != None && PlaybackActor.Role == ROLE_Authority)\n\t\tPlaybackActor.ClientMessage( S, Type, bBeep );\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "RepClientMessage",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "S"
                            ],
                            [
                                "optional",
                                "name",
                                "Type"
                            ],
                            [
                                "optional",
                                "bool",
                                "bBeep"
                            ]
                        ],
                        "return": ""
                    },
                    "RepClientVoiceMessage": {
                        "body": "{\n\tif(PlaybackActor != None && PlaybackActor.Role == ROLE_Authority)\n\t\tPlaybackActor.ClientVoiceMessage(Sender, Recipient, messagetype, messageID);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "RepClientVoiceMessage",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "Sender"
                            ],
                            [
                                "PlayerReplicationInfo",
                                "Recipient"
                            ],
                            [
                                "name",
                                "messagetype"
                            ],
                            [
                                "byte",
                                "messageID"
                            ]
                        ],
                        "return": ""
                    },
                    "RepReceiveLocalizedMessage": {
                        "body": "{\n\tif(PlaybackActor != None && PlaybackActor.Role == ROLE_Authority)\n\t\tPlaybackActor.ReceiveLocalizedMessage( Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "RepReceiveLocalizedMessage",
                        "native": false,
                        "param": [
                            [
                                "class<LocalMessage>",
                                "Message"
                            ],
                            [
                                "optional",
                                "int",
                                "Switch"
                            ],
                            [
                                "optional",
                                "PlayerReplicationInfo",
                                "RelatedPRI_1"
                            ],
                            [
                                "optional",
                                "PlayerReplicationInfo",
                                "RelatedPRI_2"
                            ],
                            [
                                "optional",
                                "Object",
                                "OptionalObject"
                            ]
                        ],
                        "return": ""
                    },
                    "RepTeamMessage": {
                        "body": "{\n\tif(PlaybackActor != None && PlaybackActor.Role == ROLE_Authority)\n\t\tPlaybackActor.TeamMessage( PRI, S, Type );\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "RepTeamMessage",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "PRI"
                            ],
                            [
                                "coerce",
                                "string",
                                "S"
                            ],
                            [
                                "name",
                                "Type"
                            ]
                        ],
                        "return": ""
                    },
                    "TeamMessage": {
                        "body": "{\n\tRepTeamMessage( PRI, S, Type );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TeamMessage",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "PRI"
                            ],
                            [
                                "coerce",
                                "string",
                                "S"
                            ],
                            [
                                "name",
                                "Type"
                            ],
                            [
                                "optional",
                                "bool",
                                "bBeep"
                            ]
                        ],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n\n\t// find local playerpawn and attach.\n\tif(Level.NetMode == NM_Client)\n\t{\n\t\tif(PlaybackActor == None)\n\t\t{\n\t\t\tforeach AllActors(class'PlayerPawn', p)\n\t\t\t{\n\t\t\t\tif( p.Player.IsA('Viewport') )\n\t\t\t\t{\n\t\t\t\t\tPlaybackActor = p;\n\t\t\t\t\tif(PlaybackGRI != None)\n\t\t\t\t\t\tPlaybackActor.GameReplicationInfo = PlaybackGRI;\n\n\t\t\t\t\tLog(\"Attached to player \"$p);\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(PlaybackGRI == None)\n\t\t{\n\t\t\tforeach AllActors(class'GameReplicationInfo', g)\n\t\t\t{\n\t\t\t\tPlaybackGRI = g;\n\t\t\t\tif(PlaybackActor != None)\n\t\t\t\t\tPlaybackActor.GameReplicationInfo = PlaybackGRI;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(PlaybackActor != None && PlaybackGRI != None)\n\t\t\tDisable('Tick');\n\n\t}\n\telse\n\t{\n\t\tDisable('Tick');\n\t}\n}",
                        "locals": [
                            "local PlayerPawn p;",
                            "local GameReplicationInfo g;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Delta"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 111,
                "replication": "",
                "states": [],
                "variables": [
                    "var PlayerPawn PlaybackActor;",
                    "var GameReplicationInfo PlaybackGRI;"
                ]
            }
        },
        "Dispatcher.uc": {
            "body": "//=============================================================================\n// Dispatcher: receives one trigger (corresponding to its name) as input, \n// then triggers a set of specifid events with optional delays.\n//=============================================================================\nclass Dispatcher extends Triggers;\n\n#exec Texture Import File=Textures\\Dispatch.pcx Name=S_Dispatcher Mips=Off Flags=2\n\n//-----------------------------------------------------------------------------\n// Dispatcher variables.\n\nvar() name  OutEvents[8]; // Events to generate.\nvar() float OutDelays[8]; // Relative delays before generating events.\nvar int i;                // Internal counter.\n\n//=============================================================================\n// Dispatcher logic.\n\n//\n// When dispatcher is triggered...\n//\nfunction Trigger( actor Other, pawn EventInstigator )\n{\n\tInstigator = EventInstigator;\n\tgotostate('Dispatch');\n}\n\n//\n// Dispatch events.\n//\nstate Dispatch\n{\nBegin:\n\tdisable('Trigger');\n\tfor( i=0; i<ArrayCount(OutEvents); i++ )\n\t{\n\t\tif( OutEvents[i] != '' )\n\t\t{\n\t\t\tSleep( OutDelays[i] );\n\t\t\tforeach AllActors( class 'Actor', Target, OutEvents[i] )\n\t\t\t\tTarget.Trigger( Self, Instigator );\n\t\t}\n\t}\n\tenable('Trigger');\n}\n\ndefaultproperties\n{\n     Texture=Texture'Engine.S_Dispatcher'\n}\n",
            "name": "Dispatcher.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Texture=Texture'Engine.S_Dispatcher'"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Dispatch.pcx Name=S_Dispatcher Mips=Off Flags=2"
                ],
                "extends": "Triggers",
                "functions": {
                    "Trigger": {
                        "body": "{\n\tInstigator = EventInstigator;\n\tgotostate('Dispatch');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 51,
                "replication": "",
                "states": [],
                "variables": [
                    "var() name  OutEvents[8]; // Events to generate.",
                    "var() float OutDelays[8]; // Relative delays before generating events.",
                    "var int i;                // Internal counter."
                ]
            }
        },
        "Effects.uc": {
            "body": "//=============================================================================\n// Effects, the base class of all gratuitous special effects.\n//=============================================================================\nclass Effects extends Actor;\n\nvar() sound \tEffectSound1;\nvar() sound \tEffectSound2;\nvar() bool bOnlyTriggerable;\n\ndefaultproperties\n{\n     RemoteRole=ROLE_SimulatedProxy\n     DrawType=DT_None\n     bGameRelevant=True\n     CollisionRadius=0.000000\n     CollisionHeight=0.000000\n}\n",
            "name": "Effects.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "RemoteRole=ROLE_SimulatedProxy",
                    "DrawType=DT_None",
                    "bGameRelevant=True",
                    "CollisionRadius=0.000000",
                    "CollisionHeight=0.000000"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 18,
                "replication": "",
                "states": [],
                "variables": [
                    "var() sound \tEffectSound1;",
                    "var() sound \tEffectSound2;",
                    "var() bool bOnlyTriggerable;"
                ]
            }
        },
        "Engine.uc": {
            "body": "//=============================================================================\n// Engine: The base class of the global application object classes.\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass Engine extends Subsystem\n\tnative\n\tnoexport\n\ttransient;\n\n// Drivers.\nvar config class<RenderDevice>   GameRenderDevice;\nvar(Drivers) config class<AudioSubsystem> AudioDevice;\nvar(Drivers) config class<Console>        Console;\nvar(Drivers) config class<NetDriver>      NetworkDevice;\nvar(Drivers) config class<Language>       Language;\n\n// Variables.\nvar primitive Cylinder;\nvar const client Client;\nvar const renderbase Render;\nvar const audiosubsystem Audio;\nvar int TickCycles, GameCycles, ClientCycles;\nvar(Settings) config int CacheSizeMegs;\nvar(Settings) config bool UseSound;\nvar(Settings) float CurrentTickRate;\n\ndefaultproperties\n{\n     Console=Class'Engine.Console'\n     CacheSizeMegs=2\n     UseSound=True\n}\n",
            "name": "Engine.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Console=Class'Engine.Console'",
                    "CacheSizeMegs=2",
                    "UseSound=True"
                ],
                "exec": [],
                "extends": "Subsystem",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 33,
                "replication": "",
                "states": [],
                "variables": [
                    "var config class<RenderDevice>   GameRenderDevice;",
                    "var(Drivers) config class<AudioSubsystem> AudioDevice;",
                    "var(Drivers) config class<Console>        Console;",
                    "var(Drivers) config class<NetDriver>      NetworkDevice;",
                    "var(Drivers) config class<Language>       Language;",
                    "var primitive Cylinder;",
                    "var const client Client;",
                    "var const renderbase Render;",
                    "var const audiosubsystem Audio;",
                    "var int TickCycles, GameCycles, ClientCycles;",
                    "var(Settings) config int CacheSizeMegs;",
                    "var(Settings) config bool UseSound;",
                    "var(Settings) float CurrentTickRate;"
                ]
            }
        },
        "Fragment.uc": {
            "body": "//=============================================================================\n// Fragment.\n//=============================================================================\nclass Fragment extends Projectile;\n\nvar() MESH Fragments[11];\nvar int numFragmentTypes;\nvar bool bFirstHit;\n\n// DEUS_EX CNN\n// 0.5 is normal Elasticity\n// < 0.5 is not very bouncy, > 0.5 is very bouncy\nvar() float Elasticity;\n\nfunction PostBeginPlay()\n{\n\tif ( Region.Zone.bDestructive )\n\t\tDestroy();\n\telse\n\t\tSuper.PostBeginPlay();\n}\n\nsimulated function CalcVelocity(vector Momentum, float ExplosionSize)\n{\n\tVelocity = VRand()*(ExplosionSize+FRand()*150.0+100.0 + VSize(Momentum)/80); \n}\n\nsimulated function HitWall (vector HitNormal, actor HitWall)\n{\n\t// Added elasticity - DEUS_EX CNN\n\tVelocity = Elasticity*(( Velocity dot HitNormal ) * HitNormal * (-2.0) + Velocity);   // Reflect off Wall w/damping\n\tspeed = VSize(Velocity);\t\n\tif (bFirstHit && speed<400) \n\t{\n\t\tbFirstHit=False;\n\t\tbRotatetoDesired=True;\n\t\tbFixedRotationDir=False;\n\t\tDesiredRotation.Pitch=0;\t\n\t\tDesiredRotation.Yaw=FRand()*65536;\n\t\tDesiredRotation.roll=0;\n\t}\n\tRotationRate.Yaw = RotationRate.Yaw*0.75;\n\tRotationRate.Roll = RotationRate.Roll*0.75;\n\tRotationRate.Pitch = RotationRate.Pitch*0.75;\n\tif ( (speed < 60) && (HitNormal.Z > 0.7) )\n\t{\n\t\tSetPhysics(PHYS_none);\n\t\tbBounce = false;\n\t\tGoToState('Dying');\n\t}\n\telse If (speed > 50) \n\t{\n\t\tif (FRand()<0.5) PlaySound(ImpactSound, SLOT_None, 0.5+FRand()*0.5,, 300, 0.85+FRand()*0.3);\n\t\telse PlaySound(MiscSound, SLOT_None, 0.5+FRand()*0.5,, 300, 0.85+FRand()*0.3);\n\t}\n}\n\nauto state Flying\n{\n\tsimulated function timer()\n\t{\n\t\tGoToState('Dying');\n\t}\n\n\n\tsimulated function Touch(actor Other)\n\t{\n\t\tif (Pawn(Other)==None) Return;\n\t\tif (!Pawn(Other).bIsPlayer) Destroy();\n\t}\n\n\n\tsimulated singular function ZoneChange( ZoneInfo NewZone )\n\t{\n\t\tlocal float splashsize;\n\t\tlocal actor splash;\n\n\t\tif ( NewZone.bWaterZone )\n\t\t{\n\t\t\tVelocity = 0.2 * Velocity;\n\t\t\tsplashSize = 0.0005 * (250 - 0.5 * Velocity.Z);\n\t\t\tif ( Level.NetMode != NM_DedicatedServer )\n\t\t\t{\n\t\t\t\tif ( NewZone.EntrySound != None )\n\t\t\t\t\tPlaySound(NewZone.EntrySound, SLOT_Interact, splashSize);\n\t\t\t\tif ( NewZone.EntryActor != None )\n\t\t\t\t{\n\t\t\t\t\tsplash = Spawn(NewZone.EntryActor); \n\t\t\t\t\tif ( splash != None )\n\t\t\t\t\t\tsplash.DrawScale = 4 * splashSize;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bFirstHit) \n\t\t\t{\n\t\t\t\tbFirstHit=False;\n\t\t\t\tbRotatetoDesired=True;\n\t\t\t\tbFixedRotationDir=False;\n\t\t\t\tDesiredRotation.Pitch=0;\t\n\t\t\t\tDesiredRotation.Yaw=FRand()*65536;\n\t\t\t\tDesiredRotation.roll=0;\n\t\t\t}\n\t\t\t\n\t\t\tRotationRate = 0.2 * RotationRate;\n\t\t\tGotoState('Dying');\n\t\t}\n\t\tif ( NewZone.bPainZone && (NewZone.DamagePerSec > 0) )\n\t\t\tDestroy();\n\t}\n\n\tsimulated function BeginState()\n\t{\n\t\tRandSpin(125000);\n\t\tif (RotationRate.Pitch>-10000&&RotationRate.Pitch<10000) \n\t\t\tRotationRate.Pitch=10000;\n\t\tif (RotationRate.Roll>-10000&&RotationRate.Roll<10000) \n\t\t\tRotationRate.Roll=10000;\t\t\t\n\t\tMesh = Fragments[int(FRand()*numFragmentTypes)];\n/* Removed - DEUS_EX CNN\n\t\tif ( Level.NetMode == NM_Standalone )\n\t\t\tLifeSpan = 20 + 40 * FRand();\n*/\n\t\tSetTimer(5.0,True);\t\t\t\n\t}\n}\n\nstate Dying\n{\n\tsimulated function HitWall (vector HitNormal, actor HitWall)\n\t{\n\t\t// Added elasticity - DEUS_EX CNN\n\t\tVelocity = Elasticity*(( Velocity dot HitNormal ) * HitNormal * (-2.0) + Velocity);   // Reflect off Wall w/damping\n\t\tspeed = VSize(Velocity);\t\n\t\tif (bFirstHit && speed<400) \n\t\t{\n\t\t\tbFirstHit=False;\n\t\t\tbRotatetoDesired=True;\n\t\t\tbFixedRotationDir=False;\n\t\t\tDesiredRotation.Pitch=0;\t\n\t\t\tDesiredRotation.Yaw=FRand()*65536;\n\t\t\tDesiredRotation.roll=0;\n\t\t}\n\t\tRotationRate.Yaw = RotationRate.Yaw*0.75;\n\t\tRotationRate.Roll = RotationRate.Roll*0.75;\n\t\tRotationRate.Pitch = RotationRate.Pitch*0.75;\n\t\tif ( (Velocity.Z < 50) && (HitNormal.Z > 0.7) )\n\t\t{\n\t\t\tSetPhysics(PHYS_none);\n\t\t\tbBounce = false;\n\t\t}\n\t\telse If (speed > 80) \n\t\t{\n\t\t\tif (FRand()<0.5) PlaySound(ImpactSound, SLOT_None, 0.5+FRand()*0.5,, 300, 0.85+FRand()*0.3);\n\t\t\telse PlaySound(MiscSound, SLOT_None, 0.5+FRand()*0.5,, 300, 0.85+FRand()*0.3);\n\t\t}\n\t}\n\n\tfunction TakeDamage( int Dam, Pawn instigatedBy, Vector hitlocation, \n\t\t\t\t\t\t\tVector momentum, name damageType)\n\t{\n\t\tDestroy();\n\t}\n\n/* Removed - DEUS_EX CNN\n\tsimulated function timer()\n\t{\n\t\tif (!PlayerCanSeeMe()) \n\t\t\tDestroy();\n\t}\n*/\n\tsimulated function BeginState()\n\t{\n//\t\tSetTimer(1.5,True);       // Removed - DEUS_EX CNN\n\t\tSetCollision(true, false, false);\n\t}\n}\n\ndefaultproperties\n{\n     bFirstHit=True\n     elasticity=0.500000\n     bNetOptional=True\n     Physics=PHYS_Falling\n     RemoteRole=ROLE_SimulatedProxy\n     LifeSpan=20.000000\n     CollisionRadius=18.000000\n     CollisionHeight=4.000000\n     bCollideActors=False\n     bBounce=True\n     bFixedRotationDir=True\n     NetPriority=1.400000\n}\n",
            "name": "Fragment.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bFirstHit=True",
                    "elasticity=0.500000",
                    "bNetOptional=True",
                    "Physics=PHYS_Falling",
                    "RemoteRole=ROLE_SimulatedProxy",
                    "LifeSpan=20.000000",
                    "CollisionRadius=18.000000",
                    "CollisionHeight=4.000000",
                    "bCollideActors=False",
                    "bBounce=True",
                    "bFixedRotationDir=True",
                    "NetPriority=1.400000"
                ],
                "exec": [],
                "extends": "Projectile",
                "functions": {
                    "BeginState": {
                        "body": "{\n//\t\tSetTimer(1.5,True);       // Removed - DEUS_EX CNN\n\t\tSetCollision(true, false, false);\n\t}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "BeginState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CalcVelocity": {
                        "body": "{\n\tVelocity = VRand()*(ExplosionSize+FRand()*150.0+100.0 + VSize(Momentum)/80); \n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "CalcVelocity",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "Momentum"
                            ],
                            [
                                "float",
                                "ExplosionSize"
                            ]
                        ],
                        "return": ""
                    },
                    "HitWall": {
                        "body": "{\n\t\t// Added elasticity - DEUS_EX CNN\n\t\tVelocity = Elasticity*(( Velocity dot HitNormal ) * HitNormal * (-2.0) + Velocity);   // Reflect off Wall w/damping\n\t\tspeed = VSize(Velocity);\t\n\t\tif (bFirstHit && speed<400) \n\t\t{\n\t\t\tbFirstHit=False;\n\t\t\tbRotatetoDesired=True;\n\t\t\tbFixedRotationDir=False;\n\t\t\tDesiredRotation.Pitch=0;\t\n\t\t\tDesiredRotation.Yaw=FRand()*65536;\n\t\t\tDesiredRotation.roll=0;\n\t\t}\n\t\tRotationRate.Yaw = RotationRate.Yaw*0.75;\n\t\tRotationRate.Roll = RotationRate.Roll*0.75;\n\t\tRotationRate.Pitch = RotationRate.Pitch*0.75;\n\t\tif ( (Velocity.Z < 50) && (HitNormal.Z > 0.7) )\n\t\t{\n\t\t\tSetPhysics(PHYS_none);\n\t\t\tbBounce = false;\n\t\t}\n\t\telse If (speed > 80) \n\t\t{\n\t\t\tif (FRand()<0.5) PlaySound(ImpactSound, SLOT_None, 0.5+FRand()*0.5,, 300, 0.85+FRand()*0.3);\n\t\t\telse PlaySound(MiscSound, SLOT_None, 0.5+FRand()*0.5,, 300, 0.85+FRand()*0.3);\n\t\t}\n\t}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "HitWall",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "HitNormal"
                            ],
                            [
                                "actor",
                                "HitWall"
                            ]
                        ],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\tif ( Region.Zone.bDestructive )\n\t\tDestroy();\n\telse\n\t\tSuper.PostBeginPlay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Touch": {
                        "body": "{\n\t\tif (Pawn(Other)==None) Return;\n\t\tif (!Pawn(Other).bIsPlayer) Destroy();\n\t}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Touch",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "ZoneChange": {
                        "body": "{\n\n\t\tif ( NewZone.bWaterZone )\n\t\t{\n\t\t\tVelocity = 0.2 * Velocity;\n\t\t\tsplashSize = 0.0005 * (250 - 0.5 * Velocity.Z);\n\t\t\tif ( Level.NetMode != NM_DedicatedServer )\n\t\t\t{\n\t\t\t\tif ( NewZone.EntrySound != None )\n\t\t\t\t\tPlaySound(NewZone.EntrySound, SLOT_Interact, splashSize);\n\t\t\t\tif ( NewZone.EntryActor != None )\n\t\t\t\t{\n\t\t\t\t\tsplash = Spawn(NewZone.EntryActor); \n\t\t\t\t\tif ( splash != None )\n\t\t\t\t\t\tsplash.DrawScale = 4 * splashSize;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bFirstHit) \n\t\t\t{\n\t\t\t\tbFirstHit=False;\n\t\t\t\tbRotatetoDesired=True;\n\t\t\t\tbFixedRotationDir=False;\n\t\t\t\tDesiredRotation.Pitch=0;\t\n\t\t\t\tDesiredRotation.Yaw=FRand()*65536;\n\t\t\t\tDesiredRotation.roll=0;\n\t\t\t}\n\t\t\t\n\t\t\tRotationRate = 0.2 * RotationRate;\n\t\t\tGotoState('Dying');\n\t\t}\n\t\tif ( NewZone.bPainZone && (NewZone.DamagePerSec > 0) )\n\t\t\tDestroy();\n\t}",
                        "locals": [
                            "local float splashsize;",
                            "local actor splash;"
                        ],
                        "modifiers": [
                            "simulated",
                            "singular"
                        ],
                        "name": "ZoneChange",
                        "native": false,
                        "param": [
                            [
                                "ZoneInfo",
                                "NewZone"
                            ]
                        ],
                        "return": ""
                    },
                    "timer": {
                        "body": "{\n\t\tif (!PlayerCanSeeMe()) \n\t\t\tDestroy();\n\t}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 192,
                "replication": "",
                "states": [],
                "variables": [
                    "var() MESH Fragments[11];",
                    "var int numFragmentTypes;",
                    "var bool bFirstHit;",
                    "var() float Elasticity;"
                ]
            }
        },
        "GameInfo.uc": {
            "body": "//=============================================================================\n// GameInfo.\n//\n// default game info is normal single player\n//\n//=============================================================================\nclass GameInfo extends Info\n\tnative;\n\n//-----------------------------------------------------------------------------\n// Variables.\n\nvar int ItemGoals, KillGoals, SecretGoals;\t\t\t\t// Special game goals.\nvar byte  Difficulty;\t\t\t\t\t\t\t\t\t// 0=easy, 1=medium, 2=hard, 3=very hard.\nvar() config bool   \t\t  bNoMonsters;\t\t\t\t// Whether monsters are allowed in this play mode.\nvar() globalconfig bool\t\t  bMuteSpectators;\t\t\t// Whether spectators are allowed to speak.\nvar() config bool\t\t\t  bHumansOnly;\t\t\t\t// Whether non human player models are allowed.\nvar() bool\t\t\t\t      bRestartLevel;\t\nvar() bool\t\t\t\t      bPauseable;\t\t\t\t// Whether the level is pauseable.\nvar() config bool\t\t\t  bCoopWeaponMode;\t\t\t// Whether or not weapons stay when picked up.\nvar() config bool\t\t\t  bClassicDeathmessages;\t// Weapon deathmessages if false.\nvar   globalconfig bool\t      bLowGore;\t\t\t\t\t// Whether or not to reduce gore.\nvar\t  bool\t\t\t\t      bCanChangeSkin;\t\t\t// Allow player to change skins in game.\nvar() bool\t\t\t\t      bTeamGame;\t\t\t\t// This is a teamgame.\n// DEUS_EX CNN - removed globalconfig from bVeryLowGore\nvar\t  bool\t      \t\t\tbVeryLowGore;\t\t\t\t// Greatly reduces gore.\nvar() globalconfig bool       bNoCheating;\t\t\t\t// Disallows cheating. Hehe.\nvar() globalconfig bool       bAllowFOV;\t\t\t\t// Allows FOV changes in net games\nvar() bool\t\t\t\t\t  bDeathMatch;\t\t\t\t// This game is some type of deathmatch (where players can respawn during gameplay)\nvar\t  bool\t\t\t\t\t  bGameEnded;\t\t\t\t// set when game ends\nvar\t  bool\t\t\t\t\t  bOverTime;\nvar localized bool\t\t\t  bAlternateMode;\nvar\t\tbool\t\t\t\t  bCanViewOthers;\n\nvar() globalconfig float\t  AutoAim;\t\t\t\t\t// How much autoaiming to do (1 = none, 0 = always).\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// (cosine of max error to correct)\n\nvar() globalconfig float\t  GameSpeed;\t\t\t\t// Scale applied to game rate.\nvar   float                   StartTime;\n\nvar() class<playerpawn>       DefaultPlayerClass;\nvar() class<weapon>           DefaultWeapon;\t\t\t// Default weapon given to player at start.\n\nvar() globalconfig int\t      MaxSpectators;\t\t\t// Maximum number of spectators.\nvar\t  int\t\t\t\t\t  NumSpectators;\t\t\t// Current number of spectators.\n\nvar() private globalconfig string AdminPassword;\t    // Password to receive bAdmin privileges.\nvar() private globalconfig string GamePassword;\t\t    // Password to enter game.\n\nvar() class<scoreboard>\t\t  ScoreBoardType;\t\t\t// Type of scoreboard this game uses.\nvar() class<menu>\t\t\t  GameMenuType;\t\t\t\t// Type of oldstyle game options menu to display.\nvar() string\t\t\t      BotMenuType;\t\t\t\t// Type of bot menu to display.\nvar() string\t\t\t      RulesMenuType;\t\t\t// Type of rules menu to display.\nvar() string\t\t\t\t  SettingsMenuType;\t\t\t// Type of settings menu to display.\nvar() string\t\t\t\t  GameUMenuType;\t\t\t// Type of Game dropdown to display.\nvar() string\t\t\t\t  MultiplayerUMenuType;\t\t// Type of Multiplayer dropdown to display.\nvar() string\t\t\t\t  GameOptionsMenuType;\t\t// Type of options dropdown to display.\n\nvar() class<hud>\t\t\t  HUDType;\t\t\t\t\t// HUD class this game uses.\nvar() class<MapList>\t\t  MapListType;\t\t\t\t// Maplist this game uses.\nvar() string\t\t\t      MapPrefix;\t\t\t\t// Prefix characters for names of maps for this game type.\nvar() string\t\t\t      BeaconName;\t\t\t\t// Identifying string used for finding LAN servers.\nvar() string\t\t\t      SpecialDamageString;\nvar localized string\t      SwitchLevelMessage;\nvar\tint\t\t\t\t\t      SentText;\nvar localized string\t      DefaultPlayerName;\nvar localized string\t      LeftMessage;\nvar localized string\t      FailedSpawnMessage;\nvar localized string\t      FailedPlaceMessage;\nvar localized string\t      FailedTeamMessage;\nvar localized string\t      NameChangedMessage;\nvar localized string\t      EnteredMessage;\nvar localized string\t      GameName;\nvar\tlocalized string\t      MaxedOutMessage;\nvar\tlocalized string\t      WrongPassword;\nvar\tlocalized string          NeedPassword;\nvar\tlocalized string          IPBanned;\n\nvar() globalconfig int\t\t  MaxPlayers; \nvar   int\t\t\t\t\t  NumPlayers;\nvar   int\t\t\t\t\t  CurrentID;\nvar() globalconfig string     IPPolicies[50];\n\n// Message classes.\nvar class<LocalMessage>\t\t  DeathMessageClass;\nvar class<LocalMessage>\t\t  DMMessageClass;\n\n// Mutator (for modifying actors as they enter the game)\nvar class<Mutator> MutatorClass;\nvar Mutator BaseMutator;\nvar Mutator DamageMutator;\t// linked list of mutators which affect damage\n\n// Default waterzone entry and exit effects\nvar class<ZoneInfo> WaterZoneType;\n\n// What state a player should start in for this game type\nvar name DefaultPlayerState;\n\n// ReplicationInfo\nvar() class<GameReplicationInfo> GameReplicationInfoClass;\nvar GameReplicationInfo GameReplicationInfo;\n\n// Server Log\nvar globalconfig string         ServerLogName;\n\n// Statistics Logging\nvar StatLog\t\t\t\t\t\tLocalLog;\nvar StatLog\t\t\t\t\t\tWorldLog;\nvar globalconfig bool\t\t\tbLocalLog;\nvar globalconfig bool\t\t\tbWorldLog;\nvar globalconfig bool\t\t\tbBatchLocal;\nvar bool\t\t\t\t\t\tbLoggingGame;\t\t\t// Does this gametype log?\nvar string\t\t\t\t\t    LocalLogFileName;\nvar string\t\t\t\t\t    WorldLogFileName;\nvar class<StatLog>\t\t\t\tStatLogClass;\n\n// Demo Information\nvar globalconfig int DemoBuild;\nvar globalconfig int DemoHasTuts;\n\n//------------------------------------------------------------------------------\n// Admin\n\nfunction AdminLogin( PlayerPawn P, string Password )\n{\n\tif (AdminPassword == \"\")\n\t\treturn;\n\n\tif (Password == AdminPassword)\n\t{\n\t\tP.bAdmin = True;\n\t\tP.PlayerReplicationInfo.bAdmin = P.bAdmin;\n\t\tLog(\"Administrator logged in.\");\n\t\tBroadcastMessage( P.PlayerReplicationInfo.PlayerName@\"became a server administrator.\" );\n\t}\n}\n\nfunction AdminLogout( PlayerPawn P )\n{\n\tif (AdminPassword == \"\")\n\t\treturn;\n\n\tif (P.bAdmin)\n\t{\n\t\tP.bAdmin = False;\n\t\tP.PlayerReplicationInfo.bAdmin = P.bAdmin;\n\t\tLog(\"Administrator logged out.\");\n\t\tBroadcastMessage( P.PlayerReplicationInfo.PlayerName@\"gave up administrator abilities.\" );\n\t}\n}\n\n//------------------------------------------------------------------------------\n// Engine notifications.\n\nfunction PreBeginPlay()\n{\n\tStartTime = 0;\n\tSetGameSpeed(GameSpeed);\n\tLevel.bNoCheating = bNoCheating;\n\tLevel.bAllowFOV = bAllowFOV;\n\t\n\tif (GameReplicationInfoClass != None)\n\t\tGameReplicationInfo = Spawn(GameReplicationInfoClass);\n\telse\n\t\tGameReplicationInfo = Spawn(class'GameReplicationInfo');\n\tInitGameReplicationInfo();\n}\n\nfunction PostBeginPlay()\n{\n\tlocal ZoneInfo W;\n\n\tif ( bAlternateMode )\n\t{\n\t\tbLowGore = true;\n\t\tbVeryLowGore = true;\n\t}\n\n\tif ( bVeryLowGore )\n\t\tbLowGore = true;\n\n\tif ( WaterZoneType != None )\n\t{\n\t\tForEach AllActors(class'ZoneInfo', W )\n\t\t\tif ( W.bWaterZone )\n\t\t\t{\n\t\t\t\tif( W.EntryActor == None )\n\t\t\t\t\tW.EntryActor = WaterZoneType.Default.EntryActor;\n\t\t\t\tif( W.ExitActor == None )\n\t\t\t\t\tW.ExitActor = WaterZoneType.Default.ExitActor;\n\t\t\t\tif( W.EntrySound == None )\n\t\t\t\t\tW.EntrySound = WaterZoneType.Default.EntrySound;\n\t\t\t\tif( W.ExitSound == None )\n\t\t\t\t\tW.ExitSound = WaterZoneType.Default.ExitSound;\n\t\t\t}\n\t}\n\n\t// Setup local statistics logging.\n\tInitLogging();\n\n\tSuper.PostBeginPlay();\n}\n\nfunction InitLogging()\n{\n\tlocal Mutator M;\n\n\tif (bLocalLog && bLoggingGame)\n\t{\n\t\tLog(\"Initiating local logging...\");\n\t\tLocalLog = spawn(StatLogClass);\n\t\tLocalLog.bWorld = False;\n\t\tLocalLog.StartLog();\n\t\tLocalLog.LogStandardInfo();\n\t\tLocalLog.LogServerInfo();\n\t\tLocalLog.LogMapParameters();\n\t\tfor (M = BaseMutator; M != None; M = M.NextMutator)\n\t\t\tLocalLog.LogMutator(M);\n\t\tLogGameParameters(LocalLog);\n\t\tLocalLogFileName = LocalLog.GetLogFileName();\n\t}\n\n\t// Setup world statistics logging.\n\tif ((Level.NetMode != NM_DedicatedServer) && (Level.NetMode != NM_ListenServer))\n\t\treturn;\n\n\tif (bWorldLog && bLoggingGame)\n\t{\n\t\tLog(\"Initiating world logging...\");\n\t\tWorldLog = spawn(StatLogClass);\n\t\tWorldLog.bWorld = True;\n\t\tWorldLog.StartLog();\n\t\tWorldLog.LogStandardInfo();\n\t\tWorldLog.LogServerInfo();\n\t\tWorldLog.LogMapParameters();\n\t\tWorldLog.InitialCheck(Self);\n\t\tfor (M = BaseMutator; M != None; M = M.NextMutator)\n\t\t\tWorldLog.LogMutator(M);\n\t\tLogGameParameters(WorldLog);\n\t\tWorldLogFileName = WorldLog.GetLogFileName();\n\t}\n}\n\nfunction Timer()\n{\n\tSentText = 0;\n}\n\n// Called when game shutsdown.\nevent GameEnding()\n{\n\tif (LocalLog != None)\n\t{\n\t\tLocalLog.LogGameEnd(\"serverquit\");\n\t\tLocalLog.StopLog();\n\t\tLocalLog.Destroy();\n\t\tLocalLog = None;\n\t}\n\n\tif (WorldLog != None)\n\t{\n\t\tWorldLog.LogGameEnd(\"serverquit\");\n\t\tWorldLog.StopLog();\n\t\tWorldLog.Destroy();\n\t\tWorldLog = None;\n\t}\n}\n\n//------------------------------------------------------------------------------\n// Replication\n\nfunction InitGameReplicationInfo()\n{\n\tGameReplicationInfo.bTeamGame = bTeamGame;\n\tGameReplicationInfo.GameName = GameName;\n\tGameReplicationInfo.GameClass = string(Class);\n\tGameReplicationInfo.bClassicDeathmessages = bClassicDeathmessages;\n}\n\nnative function string GetNetworkNumber();\n\n//------------------------------------------------------------------------------\n// Game Querying.\n\nfunction string GetInfo()\n{\n\tlocal string ResultSet;\n\n\tif (GamePassword != \"\")\n\t\tResultSet = \"\\\\password\\\\True\";\n\telse\n\t\tResultSet = \"\\\\password\\\\False\";\n\n\n\treturn ResultSet;\n}\n\nfunction string GetRules()\n{\n\tlocal string ResultSet;\n\tlocal Mutator M;\n\tlocal string NextMutator, NextDesc;\n\tlocal string EnabledMutators;\n\tlocal int Num, i;\n\n\tResultSet = \"\";\n\n\tEnabledMutators = \"\";\n\tfor (M = BaseMutator.NextMutator; M != None; M = M.NextMutator)\n\t{\n\t\tNum = 0;\n\t\tNextMutator = \"\";\n\t\tGetNextIntDesc(\"Engine.Mutator\", 0, NextMutator, NextDesc);\n\t\twhile( (NextMutator != \"\") && (Num < 50) )\n\t\t{\n\t\t\tif(NextMutator ~= string(M.Class))\n\t\t\t{\n\t\t\t\ti = InStr(NextDesc, \",\");\n\t\t\t\tif(i != -1)\n\t\t\t\t\tNextDesc = Left(NextDesc, i);\n\n\t\t\t\tif(EnabledMutators != \"\")\n\t\t\t\t\tEnabledMutators = EnabledMutators $ \", \";\n\t\t\t\t EnabledMutators = EnabledMutators $ NextDesc;\n\t\t\t\t break;\n\t\t\t}\n\t\t\t\n\t\t\tNum++;\n\t\t\tGetNextIntDesc(\"Engine.Mutator\", Num, NextMutator, NextDesc);\n\t\t}\n\t}\n\tif(EnabledMutators != \"\")\n\t\tResultSet = ResultSet $ \"\\\\mutators\\\\\"$EnabledMutators;\n\n\tResultSet = ResultSet $ \"\\\\listenserver\\\\\"$string(Level.NetMode==NM_ListenServer);\n\n\tif (GamePassword != \"\")\n\t\tResultSet = ResultSet $ \"\\\\password\\\\True\";\n\telse\n\t\tResultSet = ResultSet $ \"\\\\password\\\\False\";\n\n\treturn ResultSet;\n}\n\n// Return the server's port number.\nfunction int GetServerPort()\n{\n\tlocal string S;\n\tlocal int i;\n\n\t// Figure out the server's port.\n\tS = Level.GetAddressURL();\n\ti = InStr( S, \":\" );\n\tassert(i>=0);\n\treturn int(Mid(S,i+1));\n}\n\nfunction bool SetPause( BOOL bPause, PlayerPawn P )\n{\n\tif( bPauseable || P.bAdmin || Level.Netmode==NM_Standalone )\n\t{\n\t\tif( bPause )\n\t\t\tLevel.Pauser=P.PlayerReplicationInfo.PlayerName;\n\t\telse\n\t\t\tLevel.Pauser=\"\";\n\t\treturn True;\n\t}\n\telse return False;\n}\n\n//------------------------------------------------------------------------------\n// Stat Logging.\n\nfunction LogGameParameters(StatLog StatLog)\n{\n\tif (StatLog == None)\n\t\treturn;\n\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"GameName\"$Chr(9)$GameName);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"GameClass\"$Chr(9)$Class);// <-- Move to c++\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"GameVersion\"$Chr(9)$Level.EngineVersion);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"MinNetVersion\"$Chr(9)$Level.MinNetVersion);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"NoMonsters\"$Chr(9)$bNoMonsters);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"MuteSpectators\"$Chr(9)$bMuteSpectators);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"HumansOnly\"$Chr(9)$bHumansOnly);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"WeaponsStay\"$Chr(9)$bCoopWeaponMode);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"ClassicDeathmessages\"$Chr(9)$bClassicDeathmessages);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"LowGore\"$Chr(9)$bLowGore);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"VeryLowGore\"$Chr(9)$bVeryLowGore);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"TeamGame\"$Chr(9)$bTeamGame);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"GameSpeed\"$Chr(9)$int(GameSpeed*100));\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"MaxSpectators\"$Chr(9)$MaxSpectators);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"MaxPlayers\"$Chr(9)$MaxPlayers);\n}\n\n//------------------------------------------------------------------------------\n// Game parameters.\n\n//\n// Set gameplay speed.\n//\nfunction SetGameSpeed( Float T )\n{\n\tGameSpeed = FMax(T, 0.1);\n\tLevel.TimeDilation = GameSpeed;\n\tSetTimer(Level.TimeDilation, true);\n}\n\nstatic function ResetGame();\n\n//\n// Called after setting low or high detail mode.\n//\nevent DetailChange()\n{\n\tlocal actor A;\n\tlocal zoneinfo Z;\n\tlocal skyzoneinfo S;\n\tif( !Level.bHighDetailMode )\n\t{\n\t\tforeach AllActors(class'Actor', A)\n\t\t{\n\t\t\tif( A.bHighDetail && !A.bGameRelevant )\n\t\t\t\tA.Destroy();\n\t\t}\n\t}\n\tforeach AllActors(class'ZoneInfo', Z)\n\t\tZ.LinkToSkybox();\n}\n\n//\n// Return whether an actor should be destroyed in\n// this type of game.\n//\t\nfunction bool IsRelevant( actor Other )\n{\n\tlocal byte bSuperRelevant;\n\n\t// let the mutators mutate the actor or choose to remove it\n\tif ( BaseMutator.AlwaysKeep(Other) )\n\t\treturn true;\n\tif ( BaseMutator.IsRelevant(Other, bSuperRelevant) )\n\t{\n\t\tif ( bSuperRelevant == 1 ) // mutator wants to override any logic in here\n\t\t\treturn true;\n\t}\n\telse return false;\n\n\tif\n\t(\t(Difficulty==0 && !Other.bDifficulty0 )\n\t||  (Difficulty==1 && !Other.bDifficulty1 )\n\t||  (Difficulty==2 && !Other.bDifficulty2 )\n\t||  (Difficulty==3 && !Other.bDifficulty3 )\n\t||  (!Other.bSinglePlayer && (Level.NetMode==NM_Standalone) ) \n\t||  (!Other.bNet && ((Level.NetMode == NM_DedicatedServer) || (Level.NetMode == NM_ListenServer)) )\n\t||  (!Other.bNetSpecial  && (Level.NetMode==NM_Client)) )\n\t\treturn False;\n\n\tif( bNoMonsters && (Pawn(Other) != None) && !Pawn(Other).bIsPlayer )\n\t\treturn False;\n\n\tif( FRand() > Other.OddsOfAppearing )\n\t\treturn False;\n\n    // Update the level info goal counts.\n    if( Other.bIsSecretGoal )\n       SecretGoals++;\n\n    if( Other.bIsItemGoal )\n       ItemGoals++;\n\n    if( Other.bIsKillGoal )\n       KillGoals++;\n\n\treturn True;\n}\n\n//------------------------------------------------------------------------------\n// Player start functions\n\n//\n// Grab the next option from a string.\n//\nfunction bool GrabOption( out string Options, out string Result )\n{\n\tif( Left(Options,1)==\"?\" )\n\t{\n\t\t// Get result.\n\t\tResult = Mid(Options,1);\n\t\tif( InStr(Result,\"?\")>=0 )\n\t\t\tResult = Left( Result, InStr(Result,\"?\") );\n\n\t\t// Update options.\n\t\tOptions = Mid(Options,1);\n\t\tif( InStr(Options,\"?\")>=0 )\n\t\t\tOptions = Mid( Options, InStr(Options,\"?\") );\n\t\telse\n\t\t\tOptions = \"\";\n\n\t\treturn true;\n\t}\n\telse return false;\n}\n\n//\n// Break up a key=value pair into its key and value.\n//\nfunction GetKeyValue( string Pair, out string Key, out string Value )\n{\n\tif( InStr(Pair,\"=\")>=0 )\n\t{\n\t\tKey   = Left(Pair,InStr(Pair,\"=\"));\n\t\tValue = Mid(Pair,InStr(Pair,\"=\")+1);\n\t}\n\telse\n\t{\n\t\tKey   = Pair;\n\t\tValue = \"\";\n\t}\n}\n\n//\n// See if an option was specified in the options string.\n//\nfunction bool HasOption( string Options, string InKey )\n{\n\tlocal string Pair, Key, Value;\n\twhile( GrabOption( Options, Pair ) )\n\t{\n\t\tGetKeyValue( Pair, Key, Value );\n\t\tif( Key ~= InKey )\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n//\n// Find an option in the options string and return it.\n//\nfunction string ParseOption( string Options, string InKey )\n{\n\tlocal string Pair, Key, Value;\n\twhile( GrabOption( Options, Pair ) )\n\t{\n\t\tGetKeyValue( Pair, Key, Value );\n\t\tif( Key ~= InKey )\n\t\t\treturn Value;\n\t}\n\treturn \"\";\n}\n\n//\n// Initialize the game.\n//warning: this is called before actors' PreBeginPlay.\n//\nevent InitGame( string Options, out string Error )\n{\n\tlocal string InOpt, LeftOpt;\n\tlocal int pos;\n\tlocal class<Mutator> MClass;\n\n\tlog( \"InitGame:\" @ Options );\n\tMaxPlayers = Min( 32,GetIntOption( Options, \"MaxPlayers\", MaxPlayers ));\n\tInOpt = ParseOption( Options, \"Difficulty\" );\n\tif( InOpt != \"\" )\n\t\tDifficulty = int(InOpt);\n\n\tInOpt = ParseOption( Options, \"AdminPassword\");\n\tif( InOpt!=\"\" )\n\t\tAdminPassword = InOpt;\n\n\tInOpt = ParseOption( Options, \"GameSpeed\");\n\tif( InOpt != \"\" )\n\t{\n\t\tlog(\"GameSpeed\"@InOpt);\n\t\tSetGameSpeed(float(InOpt));\n\t}\n\n\tBaseMutator = spawn(MutatorClass);\n\tlog(\"Base Mutator is \"$BaseMutator);\n\tInOpt = ParseOption( Options, \"Mutator\");\n\tif ( InOpt != \"\" )\n\t{\n\t\tlog(\"Mutators\"@InOpt);\n\t\twhile ( InOpt != \"\" )\n\t\t{\n\t\t\tpos = InStr(InOpt,\",\");\n\t\t\tif ( pos > 0 )\n\t\t\t{\n\t\t\t\tLeftOpt = Left(InOpt, pos);\n\t\t\t\tInOpt = Right(InOpt, Len(InOpt) - pos - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLeftOpt = InOpt;\n\t\t\t\tInOpt = \"\";\n\t\t\t}\n\t\t\tlog(\"Add mutator \"$LeftOpt);\n\t\t\tMClass = class<Mutator>(DynamicLoadObject(LeftOpt, class'Class'));\t\n\t\t\tBaseMutator.AddMutator(Spawn(MClass));\n\t\t}\n\t}\n\n\tInOpt = ParseOption( Options, \"GamePassword\");\n\tif( InOpt != \"\" )\n\t{\n\t\tGamePassWord = InOpt;\n\t\tlog( \"GamePassword\" @ InOpt );\n\t}\n\n\tInOpt = ParseOption( Options, \"LocalLog\");\n\tif( InOpt ~= \"true\" )\n\t\tbLocalLog = True;\n\n\tInOpt = ParseOption( Options, \"WorldLog\");\n\tif( InOpt ~= \"true\" )\n\t\tbWorldLog = True;\n}\n\n//\n// Return beacon text for serverbeacon.\n//\nevent string GetBeaconText()\n{\t\n\treturn\n\t\tLevel.ComputerName\n\t$\t\" \"\n\t$\tLeft(Level.Title,24) \n\t$\t\" \"\n\t$\tBeaconName\n\t$\t\" \"\n\t$\tNumPlayers\n\t$\t\"/\"\n\t$\tMaxPlayers;\n}\n\n//\n// Optional handling of ServerTravel for network games.\n//\nfunction ProcessServerTravel( string URL, bool bItems )\n{\n\tlocal playerpawn P, LocalPlayer;\n\n\tif (LocalLog != None)\n\t{\n\t\tLocalLog.LogGameEnd(\"mapchange\");\n\t\tLocalLog.StopLog();\n\t\tLocalLog.Destroy();\n\t\tLocalLog = None;\n\t}\n\n\tif (WorldLog != None)\n\t{\n\t\tWorldLog.LogGameEnd(\"mapchange\");\n\t\tWorldLog.StopLog();\n\t\tWorldLog.Destroy();\n\t\tWorldLog = None;\n\t}\n\n\t// Notify clients we're switching level and give them time to receive.\n\t// We call PreClientTravel directly on any local PlayerPawns (ie listen server)\n\tlog(\"ProcessServerTravel:\"@URL);\n\tforeach AllActors( class'PlayerPawn', P )\n\t\tif( NetConnection(P.Player)!=None )\n\t\t\tP.ClientTravel( URL, TRAVEL_Relative, bItems );\n\t\telse\n\t\t{\t\n\t\t\tLocalPlayer = P;\n\t\t\tP.PreClientTravel();\n\t\t}\n\n\tif ( (Level.NetMode == NM_ListenServer) && (LocalPlayer != None) )\n\t\tLevel.NextURL = Level.NextURL$\"?Skin=\"$LocalPlayer.GetDefaultURL(\"Skin\")\n\t\t\t\t\t $\"?Face=\"$LocalPlayer.GetDefaultURL(\"Face\")\n\t\t\t\t\t $\"?Team=\"$LocalPlayer.GetDefaultURL(\"Team\")\n\t\t\t\t\t $\"?Name=\"$LocalPlayer.GetDefaultURL(\"Name\")\n\t\t\t\t\t $\"?Class=\"$LocalPlayer.GetDefaultURL(\"Class\");\n\n\t// Switch immediately if not networking.\n\tif( Level.NetMode!=NM_DedicatedServer && Level.NetMode!=NM_ListenServer )\n\t\tLevel.NextSwitchCountdown = 0.0;\n}\n\nfunction bool AtCapacity(string Options)\n{\n\treturn ( (MaxPlayers>0) && (NumPlayers>=MaxPlayers) );\n}\n\n//\n// Accept or reject a player on the server.\n// Fails login if you set the Error to a non-empty string.\n//\nevent PreLogin\n(\n\tstring Options,\n\tstring Address,\n\tout string Error,\n\tout string FailCode\n)\n{\n\t// Do any name or password or name validation here.\n\tlocal string InPassword;\n\tError=\"\";\n\tInPassword = ParseOption( Options, \"Password\" );\n\tif( (Level.NetMode != NM_Standalone) && AtCapacity(Options) )\n\t{\n\t\tError=MaxedOutMessage;\n\t}\n\telse if\n\t(\tGamePassword!=\"\"\n\t&&\tcaps(InPassword)!=caps(GamePassword)\n\t&&\t(AdminPassword==\"\" || caps(InPassword)!=caps(AdminPassword)) )\n\t{\n\t\tif( InPassword == \"\" )\n\t\t{\n\t\t\tError = NeedPassword;\n\t\t\tFailCode = \"NEEDPW\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tError = WrongPassword;\n\t\t\tFailCode = \"WRONGPW\";\n\t\t}\n\t}\n\n\tif(!CheckIPPolicy(Address))\n\t\tError = IPBanned;\n}\n\nfunction bool CheckIPPolicy(string Address)\n{\n\tlocal int i, j, LastMatchingPolicy;\n\tlocal string Policy, Mask;\n\tlocal bool bAcceptAddress, bAcceptPolicy;\n\t\n\t// strip port number\n\tj = InStr(Address, \":\");\n\tif(j != -1)\n\t\tAddress = Left(Address, j);\n\n\tbAcceptAddress = True;\n\tfor(i=0; i<50 && IPPolicies[i] != \"\"; i++)\n\t{\n\t\tj = InStr(IPPolicies[i], \",\");\n\t\tif(j==-1)\n\t\t\tcontinue;\n\t\tPolicy = Left(IPPolicies[i], j);\n\t\tMask = Mid(IPPolicies[i], j+1);\n\t\tif(Policy ~= \"ACCEPT\") \n\t\t\tbAcceptPolicy = True;\n\t\telse\n\t\tif(Policy ~= \"DENY\") \n\t\t\tbAcceptPolicy = False;\n\t\telse\n\t\t\tcontinue;\n\n\t\tj = InStr(Mask, \"*\");\n\t\tif(j != -1)\n\t\t{\n\t\t\tif(Left(Mask, j) == Left(Address, j))\n\t\t\t{\n\t\t\t\tbAcceptAddress = bAcceptPolicy;\n\t\t\t\tLastMatchingPolicy = i;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(Mask == Address)\n\t\t\t{\n\t\t\t\tbAcceptAddress = bAcceptPolicy;\n\t\t\t\tLastMatchingPolicy = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!bAcceptAddress)\n\t\tLog(\"Denied connection for \"$Address$\" with IP policy \"$IPPolicies[LastMatchingPolicy]);\n\t\t\n\treturn bAcceptAddress;\n}\n\nfunction int GetIntOption( string Options, string ParseString, int CurrentValue)\n{\n\tlocal string InOpt;\n\n\tInOpt = ParseOption( Options, ParseString );\n\tif ( InOpt != \"\" )\n\t{\n\t\tlog(ParseString@InOpt);\n\t\treturn int(InOpt);\n\t}\t\n\treturn CurrentValue;\n}\n\n//\n// Log a player in.\n// Fails login if you set the Error string.\n// PreLogin is called before Login, but significant game time may pass before\n// Login is called, especially if content is downloaded.\n//\nevent playerpawn Login\n(\n\tstring Portal,\n\tstring Options,\n\tout string Error,\n\tclass<playerpawn> SpawnClass\n)\n{\n\tlocal NavigationPoint StartSpot;\n\tlocal PlayerPawn      NewPlayer, TestPlayer;\n\tlocal Pawn            PawnLink;\n\tlocal string          InName, InPassword, InSkin, InFace, InChecksum;\n\tlocal byte            InTeam;\n\n\t// Make sure there is capacity. (This might have changed since the PreLogin call).\n\tif ( Level.NetMode != NM_Standalone )\n\t{\n\t\tif ( ClassIsChildOf(SpawnClass, class'Spectator') )\n\t\t{\n\t\t\tif ( (NumSpectators >= MaxSpectators)\n\t\t\t\t&& ((Level.NetMode != NM_ListenServer) || (NumPlayers > 0)) )\n\t\t\t{\n\t\t\t\tError=MaxedOutMessage;\n\t\t\t\treturn None;\n\t\t\t}\n\t\t}\t\t\n\t\telse if ( (MaxPlayers>0) && (NumPlayers>=MaxPlayers) )\n\t\t{\n\t\t\tError=MaxedOutMessage;\n\t\t\treturn None;\n\t\t}\n\t}\n\n\t// Get URL options.\n\tInName     = Left(ParseOption ( Options, \"Name\"), 20);\n\tInTeam     = GetIntOption( Options, \"Team\", 0 ); // default to \"no team\"\n\tInPassword = ParseOption ( Options, \"Password\" );\n\tInSkin\t   = ParseOption ( Options, \"Skin\"    );\n\tInFace     = ParseOption ( Options, \"Face\"    );\n\tInChecksum = ParseOption ( Options, \"Checksum\" );\n\n\tlog( \"Login:\" @ InName );\n\tif( InPassword != \"\" )\n\t\tlog( \"Password\"@InPassword );\n\t \n\t// Find a start spot.\n\tStartSpot = FindPlayerStart( None, InTeam, Portal );\n\n\tif( StartSpot == None )\n\t{\n\t\tError = FailedPlaceMessage;\n\t\treturn None;\n\t}\n\n\t// Try to match up to existing unoccupied player in level,\n\t// for savegames and coop level switching.\n\tfor( PawnLink=Level.PawnList; PawnLink!=None; PawnLink=PawnLink.NextPawn )\n\t{\n\t\tTestPlayer = PlayerPawn(PawnLink);\n\t\tif\n\t\t(\tTestPlayer!=None\n\t\t&&\tTestPlayer.Player==None \n\t\t&&  TestPlayer.PlayerReplicationInfo != None\n\t\t&&  TestPlayer.bIsPlayer\n\t\t&&\tTestPlayer.PlayerReplicationInfo.PlayerName != class'PlayerReplicationInfo'.default.PlayerName\n\t\t)\n\t\t{\n\t\t\tif\n\t\t\t(\t(Level.NetMode==NM_Standalone)\n\t\t\t||\t(TestPlayer.PlayerReplicationInfo.PlayerName~=InName && TestPlayer.Password~=InPassword) )\n\t\t\t{\n\t\t\t\t// Found matching unoccupied player, so use this one.\n\t\t\t\tNewPlayer = TestPlayer;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// In not found, spawn a new player.\n\tif( NewPlayer==None )\n\t{\n\t\t// Make sure this kind of player is allowed.\n\t\tif ( (bHumansOnly || Level.bHumansOnly) && !SpawnClass.Default.bIsHuman\n\t\t\t&& !ClassIsChildOf(SpawnClass, class'Spectator') )\n\t\t\tSpawnClass = DefaultPlayerClass;\n\n\t\tNewPlayer = Spawn(SpawnClass,,,StartSpot.Location,StartSpot.Rotation);\n\t\tif( NewPlayer!=None )\n\t\t\tNewPlayer.ViewRotation = StartSpot.Rotation;\n\t}\n\n\t// Handle spawn failure.\n\tif( NewPlayer == None )\n\t{\n\t\tlog(\"Couldn't spawn player at \"$StartSpot);\n\t\tError = FailedSpawnMessage;\n\t\treturn None;\n\t}\n\n\tNewPlayer.static.SetMultiSkin(NewPlayer, InSkin, InFace, InTeam);\n\n\t// Set the player's ID.\n\tNewPlayer.PlayerReplicationInfo.PlayerID = CurrentID++;\n\n\t// Init player's information.\n\tNewPlayer.ClientSetRotation(NewPlayer.Rotation);\n\tif( InName==\"\" )\n\t\tInName=DefaultPlayerName;\n\tif( Level.NetMode!=NM_Standalone || NewPlayer.PlayerReplicationInfo.PlayerName==DefaultPlayerName )\n\t\tChangeName( NewPlayer, InName, false );\n\n\t// Change player's team.\n\tif ( !ChangeTeam(newPlayer, InTeam) )\n\t{\n\t\tError = FailedTeamMessage;\n\t\treturn None;\n\t}\n\n\tif( NewPlayer.IsA('Spectator') && (Level.NetMode == NM_DedicatedServer) )\n\t\tNumSpectators++;\n\n\t// Init player's administrative privileges\n\tNewPlayer.Password = InPassword;\n\tNewPlayer.bAdmin = AdminPassword!=\"\" && caps(InPassword)==caps(AdminPassword);\n\tif( NewPlayer.bAdmin )\n\t\tlog( \"Administrator logged in!\" );\n\n\t// Init player's replication info\n\tNewPlayer.GameReplicationInfo = GameReplicationInfo;\n\n\t// If we are a server, broadcast a welcome message.\n\tif( Level.NetMode==NM_DedicatedServer || Level.NetMode==NM_ListenServer )\n\t\tBroadcastMessage( NewPlayer.PlayerReplicationInfo.PlayerName$EnteredMessage, false );\n\n\t// Teleport-in effect.\n\tStartSpot.PlayTeleportEffect( NewPlayer, true );\n\n\t// Log it.\n\tif ( LocalLog != None )\n\t\tLocalLog.LogPlayerConnect(NewPlayer);\n\tif ( WorldLog != None )\n\t\tWorldLog.LogPlayerConnect(NewPlayer, InChecksum);\n\n\tif ( !NewPlayer.IsA('Spectator') )\n\t\tNumPlayers++;\n\treturn newPlayer;\n}\t\n\n//\n// Called after a successful login. This is the first place\n// it is safe to call replicated functions on the PlayerPawn.\n//\nevent PostLogin( playerpawn NewPlayer )\n{\n\tlocal Pawn P;\n\t// Start player's music.\n\tNewPlayer.ClientSetMusic( Level.Song, Level.SongSection, Level.CdTrack, MTRAN_Fade );\n\tif ( Level.NetMode != NM_Standalone )\n\t{\n\t\t// replicate skins\n\t\tfor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t\t\tif ( P.bIsPlayer && (P != NewPlayer) )\n\t\t\t{\n\t\t\t\tif ( P.bIsMultiSkinned )\n\t\t\t\t\tNewPlayer.ClientReplicateSkins(P.MultiSkins[0], P.MultiSkins[1], P.MultiSkins[2], P.MultiSkins[3]);\n\t\t\t\telse\n\t\t\t\t\tNewPlayer.ClientReplicateSkins(P.Skin);\t\n\t\t\t\t\t\n\t\t\t\tif ( (P.PlayerReplicationInfo != None) && P.PlayerReplicationInfo.bWaitingPlayer && P.IsA('PlayerPawn') )\n\t\t\t\t{\n\t\t\t\t\tif ( NewPlayer.bIsMultiSkinned )\n\t\t\t\t\t\tPlayerPawn(P).ClientReplicateSkins(NewPlayer.MultiSkins[0], NewPlayer.MultiSkins[1], NewPlayer.MultiSkins[2], NewPlayer.MultiSkins[3]);\n\t\t\t\t\telse\n\t\t\t\t\t\tPlayerPawn(P).ClientReplicateSkins(NewPlayer.Skin);\t\n\t\t\t\t}\t\t\t\t\t\t\n\t\t\t}\n\t}\n}\n\n//\n// Add bot to game.\n//\nfunction bool AddBot();\nfunction bool ForceAddBot();\n\n//\n// Pawn exits.\n//\nfunction Logout( pawn Exiting )\n{\n\tlocal bool bMessage;\n\n\tbMessage = true;\n\tif ( Exiting.IsA('PlayerPawn') )\n\t{\n\t\tif ( Exiting.IsA('Spectator') )\n\t\t{\n\t\t\tbMessage = false;\n\t\t\tif ( Level.NetMode == NM_DedicatedServer )\n\t\t\t\tNumSpectators--;\n\t\t}\n\t\telse\n\t\t\tNumPlayers--;\n\t}\n\tif( bMessage && (Level.NetMode==NM_DedicatedServer || Level.NetMode==NM_ListenServer) )\n\t\tBroadcastMessage( Exiting.PlayerReplicationInfo.PlayerName$LeftMessage, false );\n\n\tif ( LocalLog != None )\n\t\tLocalLog.LogPlayerDisconnect(Exiting);\n\tif ( WorldLog != None )\n\t\tWorldLog.LogPlayerDisconnect(Exiting);\n}\n\n//\n// Examine the passed player's inventory, and accept or discard each item.\n// AcceptInventory needs to gracefully handle the case of some inventory\n// being accepted but other inventory not being accepted (such as the default\n// weapon).  There are several things that can go wrong: A weapon's\n// AmmoType not being accepted but the weapon being accepted -- the weapon\n// should be killed off. Or the player's selected inventory item, active\n// weapon, etc. not being accepted, leaving the player weaponless or leaving\n// the HUD inventory rendering messed up (AcceptInventory should pick another\n// applicable weapon/item as current).\n//\nevent AcceptInventory(pawn PlayerPawn)\n{\n\t//default accept all inventory except default weapon (spawned explicitly)\n\n\tlocal inventory inv;\n\n\t// Initialize the inventory.\n\tAddDefaultInventory( PlayerPawn );\n\n\tlog( \"All inventory from\" @ PlayerPawn.PlayerReplicationInfo.PlayerName @ \"is accepted\" );\n}\n\n//\n// Spawn any default inventory for the player.\n//\nfunction AddDefaultInventory( pawn PlayerPawn )\n{\n\tlocal Weapon newWeapon;\n\tlocal class<Weapon> WeapClass;\n\n\tPlayerPawn.JumpZ = PlayerPawn.Default.JumpZ * PlayerJumpZScaling();\n\t \n\tif( PlayerPawn.IsA('Spectator') )\n\t\treturn;\n\n\t// Spawn default weapon.\n\tWeapClass = BaseMutator.MutatedDefaultWeapon();\n\tif( (WeapClass!=None) && (PlayerPawn.FindInventoryType(WeapClass)==None) )\n\t{\n\t\tnewWeapon = Spawn(WeapClass);\n\t\tif( newWeapon != None )\n\t\t{\n\t\t\tnewWeapon.Instigator = PlayerPawn;\n\t\t\tnewWeapon.BecomeItem();\n\t\t\tnewWeapon.GiveAmmo(PlayerPawn);\n\t\t\tPlayerPawn.AddInventory(newWeapon);\n\t\t\tnewWeapon.BringUp();\n\t\t\tnewWeapon.SetSwitchPriority(PlayerPawn);\n\t\t\tnewWeapon.WeaponSet(PlayerPawn);\n\t\t}\n\t}\n\tBaseMutator.ModifyPlayer(PlayerPawn);\n}\n\n\n//\n// Return the 'best' player start for this player to start from.\n// Re-implement for each game type.\n//\nfunction NavigationPoint FindPlayerStart( Pawn Player, optional byte InTeam, optional string incomingName )\n{\n\tlocal PlayerStart Dest;\n\tlocal Teleporter Tel;\n\tif( incomingName!=\"\" )\n\t\tforeach AllActors( class 'Teleporter', Tel )\n\t\t\tif( string(Tel.Tag)~=incomingName )\n\t\t\t\treturn Tel;\n\tforeach AllActors( class 'PlayerStart', Dest )\n\t\tif( Dest.bSinglePlayerStart && Dest.bEnabled )\n\t\t\treturn Dest;\n\n\t// if none, check for any that aren't enabled\n\tlog(\"WARNING: All single player starts were disabled - picking one anyway!\");\n\tforeach AllActors( class 'PlayerStart', Dest )\n\t\tif( Dest.bSinglePlayerStart )\n\t\t\treturn Dest;\n\tlog( \"No single player start found\" );\n\treturn None;\n}\n\n//\n// Restart a player.\n//\nfunction bool RestartPlayer( pawn aPlayer )\t\n{\n\tlocal NavigationPoint startSpot;\n\tlocal bool foundStart;\n\n\tif( bRestartLevel && Level.NetMode!=NM_DedicatedServer && Level.NetMode!=NM_ListenServer )\n\t\treturn true;\n\n\tstartSpot = FindPlayerStart(aPlayer, 255);\n\tif( startSpot == None )\n\t{\n\t\tlog(\" Player start not found!!!\");\n\t\treturn false;\n\t}\t\n\tfoundStart = aPlayer.SetLocation(startSpot.Location);\n\tif( foundStart )\n\t{\n\t\tstartSpot.PlayTeleportEffect(aPlayer, true);\n\t\taPlayer.SetRotation(startSpot.Rotation);\n\t\taPlayer.ViewRotation = aPlayer.Rotation;\n\t\taPlayer.Acceleration = vect(0,0,0);\n\t\taPlayer.Velocity = vect(0,0,0);\n\t\taPlayer.Health = aPlayer.Default.Health;\n\t\taPlayer.SetCollision( true, true, true );\n\t\taPlayer.ClientSetLocation( startSpot.Location, startSpot.Rotation );\n\t\taPlayer.bHidden = false;\n\t\taPlayer.DamageScaling = aPlayer.Default.DamageScaling;\n\t\taPlayer.SoundDampening = aPlayer.Default.SoundDampening;\n\t\tAddDefaultInventory(aPlayer);\n\t}\n\telse\n\t\tlog(startspot$\" Player start not useable!!!\");\n\treturn foundStart;\n}\n\n//\n// Start a player.\n//\nfunction StartPlayer(PlayerPawn Other)\n{\n\tif( Level.NetMode==NM_DedicatedServer || Level.NetMode==NM_ListenServer || !bRestartLevel )\n\t\tOther.GotoState(Other.PlayerRestartState);\n\telse\n\t\tOther.ClientTravel( \"?restart\", TRAVEL_Relative, false );\n}\n\n//------------------------------------------------------------------------------\n// Level death message functions.\n\nfunction Killed( pawn Killer, pawn Other, name damageType )\n{\n\tlocal String Message, KillerWeapon, OtherWeapon;\n\tlocal bool bSpecialDamage;\n\n\tif (Other.bIsPlayer)\n\t{\n\t\tif ( (Killer != None) && (!Killer.bIsPlayer) )\n\t\t{\n\t\t\tif ( Level.NetMode != NM_Standalone )\n\t\t\t{\n\t\t\t\tMessage = Other.PlayerReplicationInfo.PlayerName$Killer.KillMessage(damageType, Other);\n\t\t\t\tBroadcastMessage( Message, false, 'DeathMessage');\n\t\t\t}\n\t\t\tif ( LocalLog != None )\n\t\t\t\tLocalLog.LogSuicide(Other, DamageType, None);\n\t\t\tif ( WorldLog != None )\n\t\t\t\tWorldLog.LogSuicide(Other, DamageType, None);\n\t\t\treturn;\n\t\t}\n\t\tif ( (DamageType == 'SpecialDamage') && (SpecialDamageString != \"\") )\n\t\t{\n\t\t\tif ( Level.NetMode != NM_Standalone )\n\t\t\t{\n\t\t\t\tBroadcastMessage( ParseKillMessage(\n\t\t\t\t\t\tKiller.PlayerReplicationInfo.PlayerName,\n\t\t\t\t\t\tOther.PlayerReplicationInfo.PlayerName,\n\t\t\t\t\t\tKiller.Weapon.ItemName,\n\t\t\t\t\t\tSpecialDamageString\n\t\t\t\t\t\t),\n\t\t\t\t\tfalse, 'DeathMessage');\n\t\t\t}\n\t\t\tbSpecialDamage = True;\n\t\t}\n\t\tif ( (Killer == Other) || (Killer == None) )\n\t\t{\n\t\t\t// Suicide\n\t\t\tif (damageType == '')\n\t\t\t{\n\t\t\t\tif ( LocalLog != None )\n\t\t\t\t\tLocalLog.LogSuicide(Other, 'Unknown', Killer);\n\t\t\t\tif ( WorldLog != None )\n\t\t\t\t\tWorldLog.LogSuicide(Other, 'Unknown', Killer);\n\t\t\t} else {\n\t\t\t\tif ( LocalLog != None )\n\t\t\t\t\tLocalLog.LogSuicide(Other, damageType, Killer);\n\t\t\t\tif ( WorldLog != None )\n\t\t\t\t\tWorldLog.LogSuicide(Other, damageType, Killer);\n\t\t\t}\n\t\t\tif (!bSpecialDamage)\n\t\t\t{\n\t\t\t\tif ( damageType == 'Fell' )\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 2, Other.PlayerReplicationInfo, None);\n\t\t\t\telse if ( damageType == 'Eradicated' )\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 3, Other.PlayerReplicationInfo, None);\n\t\t\t\telse if ( damageType == 'Drowned' )\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 4, Other.PlayerReplicationInfo, None);\n\t\t\t\telse if ( damageType == 'Burned' )\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 5, Other.PlayerReplicationInfo, None);\n\t\t\t\telse if ( damageType == 'Corroded' )\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 6, Other.PlayerReplicationInfo, None);\n\t\t\t\telse if ( damageType == 'Mortared' )\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 7, Other.PlayerReplicationInfo, None);\n\t\t\t\telse\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 1, Other.PlayerReplicationInfo, None);\n\t\t\t}\n\t\t} \n\t\telse \n\t\t{\n\t\t\t// Increment deaths if you were killed by another player. (But not for suicides.)\n\t\t\tOther.PlayerReplicationInfo.Deaths += 1;\n\t\t\tif ( Killer.bIsPlayer )\n\t\t\t{\n\t\t\t\tKillerWeapon = \"None\";\n\t\t\t\tif (Killer.Weapon != None)\n\t\t\t\t\tKillerWeapon = Killer.Weapon.ItemName;\n\t\t\t\tOtherWeapon = \"None\";\n\t\t\t\tif (Other.Weapon != None)\n\t\t\t\t\tOtherWeapon = Other.Weapon.ItemName;\n\t\t\t\tif ( Killer.PlayerReplicationInfo.Team == Other.PlayerReplicationInfo.Team )\n\t\t\t\t{\n\t\t\t\t\tif ( LocalLog != None )\n\t\t\t\t\t\tLocalLog.LogTeamKill(\n\t\t\t\t\t\t\tKiller.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tOther.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tKillerWeapon,\n\t\t\t\t\t\t\tOtherWeapon,\n\t\t\t\t\t\t\tdamageType\n\t\t\t\t\t\t);\n\t\t\t\t\tif ( WorldLog != None )\n\t\t\t\t\t\tWorldLog.LogTeamKill(\n\t\t\t\t\t\t\tKiller.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tOther.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tKillerWeapon,\n\t\t\t\t\t\t\tOtherWeapon,\n\t\t\t\t\t\t\tdamageType\n\t\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tif ( LocalLog != None )\n\t\t\t\t\t\tLocalLog.LogKill(\n\t\t\t\t\t\t\tKiller.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tOther.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tKillerWeapon,\n\t\t\t\t\t\t\tOtherWeapon,\n\t\t\t\t\t\t\tdamageType\n\t\t\t\t\t\t);\n\t\t\t\t\tif ( WorldLog != None )\n\t\t\t\t\t\tWorldLog.LogKill(\n\t\t\t\t\t\t\tKiller.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tOther.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tKillerWeapon,\n\t\t\t\t\t\t\tOtherWeapon,\n\t\t\t\t\t\t\tdamageType\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (!bSpecialDamage && (Other != None))\n\t\t\t\t{\n\t\t\t\t\tBroadcastRegularDeathMessage(Killer, Other, damageType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tScoreKill(Killer, Other);\n}\n\nfunction BroadcastRegularDeathMessage(pawn Killer, pawn Other, name damageType)\n{\n\tBroadcastLocalizedMessage(DeathMessageClass, 0, Killer.PlayerReplicationInfo, Other.PlayerReplicationInfo, Killer.Weapon.Class);\n}\n\n// %k = Owner's PlayerName (Killer)\n// %o = Other's PlayerName (Victim)\n// %w = Owner's Weapon ItemName\nstatic native function string ParseKillMessage( string KillerName, string VictimName, string WeaponName, string DeathMessage );\n\nfunction ScoreKill(pawn Killer, pawn Other)\n{\n\tOther.DieCount++;\n\tif( (killer == Other) || (killer == None) )\n\t\tOther.PlayerReplicationInfo.Score -= 1;\n\telse if ( killer != None )\n\t{\n\t\tkiller.killCount++;\n\t\tif ( killer.PlayerReplicationInfo != None )\n\t\t\tkiller.PlayerReplicationInfo.Score += 1;\n\t}\n\n\tBaseMutator.ScoreKill(Killer, Other);\n}\n\n//\n// Default death message.\n//\nstatic function string KillMessage( name damageType, pawn Other )\n{\n\treturn \" died.\";\n}\n\n//-------------------------------------------------------------------------------------\n// Level gameplay modification.\n\n//\n// Return whether Viewer is allowed to spectate from the\n// point of view of ViewTarget.\n//\nfunction bool CanSpectate( pawn Viewer, actor ViewTarget )\n{\n\treturn true;\n}\n\nfunction RegisterDamageMutator(Mutator M)\n{\n\tM.NextDamageMutator = DamageMutator;\n\tDamageMutator = M;\n}\n\n//\n// Use reduce damage for teamplay modifications, etc.\n//\nfunction int ReduceDamage( int Damage, name DamageType, pawn injured, pawn instigatedBy )\n{\n\tif( injured.Region.Zone.bNeutralZone )\n\t\treturn 0;\t\n\treturn Damage;\n}\n\n//\n// Award a score to an actor.\n//\nfunction ScoreEvent( name EventName, actor EventActor, pawn InstigatedBy )\n{\n}\n\n//\n// Return whether an item should respawn.\n//\nfunction bool ShouldRespawn( actor Other )\n{\n\tif( Level.NetMode == NM_StandAlone )\n\t\treturn false;\n\treturn Inventory(Other)!=None && Inventory(Other).ReSpawnTime!=0.0;\n}\n\n//\n// Called when pawn has a chance to pick Item up (i.e. when \n// the pawn touches a weapon pickup). Should return true if \n// he wants to pick it up, false if he does not want it.\n//\nfunction bool PickupQuery( Pawn Other, Inventory item )\n{\n\tif ( Other.Inventory == None )\n\t\treturn true;\n\telse\n\t\treturn !Other.Inventory.HandlePickupQuery(Item);\n}\n\t\t\n//\n// Discard a player's inventory after he dies.\n//\nfunction DiscardInventory( Pawn Other )\n{\n\tlocal actor dropped;\n\tlocal inventory Inv;\n\tlocal weapon weap;\n\tlocal float speed;\n\n\tif( Other.DropWhenKilled != None )\n\t{\n\t\tdropped = Spawn(Other.DropWhenKilled,,,Other.Location);\n\t\tInv = Inventory(dropped);\n\t\tif ( Inv != None )\n\t\t{ \n\t\t\tInv.RespawnTime = 0.0; //don't respawn\n\t\t\tInv.BecomePickup();\t\t\n\t\t}\n\t\tif ( dropped != None )\n\t\t{\n\t\t\tdropped.RemoteRole = ROLE_DumbProxy;\n\t\t\tdropped.SetPhysics(PHYS_Falling);\n\t\t\tdropped.bCollideWorld = true;\n\t\t\tdropped.Velocity = Other.Velocity + VRand() * 280;\n\t\t}\n\t\tif ( Inv != None )\n\t\t\tInv.GotoState('PickUp', 'Dropped');\n\t}\t\t\t\t\t\n\tif( (Other.Weapon!=None) && (Other.Weapon.Class!=Level.Game.BaseMutator.MutatedDefaultWeapon()) \n\t\t&& Other.Weapon.bCanThrow )\n\t{\n\t\tspeed = VSize(Other.Velocity);\n\t\tweap = Other.Weapon;\n\t\tif (speed != 0)\n\t\t\tweap.Velocity = Normal(Other.Velocity/speed + 0.5 * VRand()) * (speed + 280);\n\t\telse {\n\t\t\tweap.Velocity.X = 0;\n\t\t\tweap.Velocity.Y = 0;\n\t\t\tweap.Velocity.Z = 0;\n\t\t}\n\t\tOther.TossWeapon();\n\t\tif ( weap.PickupAmmoCount == 0 )\n\t\t\tweap.PickupAmmoCount = 1;\n\t}\n\tOther.Weapon = None;\n\tOther.SelectedItem = None;\t\n\tfor( Inv=Other.Inventory; Inv!=None; Inv=Inv.Inventory )\n\t\tInv.Destroy();\n}\n\n// Return the player jumpZ scaling for this gametype\nfunction float PlayerJumpZScaling()\n{\n\treturn 1.0;\n}\n\n//\n// Try to change a player's name.\n//\t\nfunction ChangeName( Pawn Other, coerce string S, bool bNameChange )\n{\n\tif( S == \"\" )\n\t\treturn;\n\tif (LocalLog != None)\n\t\tLocalLog.LogNameChange(Other);\n\tif (WorldLog != None)\n\t\tWorldLog.LogNameChange(Other);\n\tOther.PlayerReplicationInfo.PlayerName = S;\n\tif( bNameChange )\n\t\tOther.ClientMessage( NameChangedMessage $ Other.PlayerReplicationInfo.PlayerName );\n}\n\n//\n// Return whether a team change is allowed.\n//\nfunction bool ChangeTeam(Pawn Other, int N)\n{\n\tOther.PlayerReplicationInfo.Team = N;\n\tif (LocalLog != None)\n\t\tLocalLog.LogTeamChange(Other);\n\tif (WorldLog != None)\n\t\tWorldLog.LogTeamChange(Other);\n\treturn true;\n}\n\n//\n// Play an inventory respawn effect.\n//\nfunction float PlaySpawnEffect( inventory Inv )\n{\n\treturn 0.3;\n}\n\n//\n// Generate a player killled message.\n//\nstatic function string PlayerKillMessage( name damageType, PlayerReplicationInfo Other )\n{\n\tlocal string message;\n\n\tmessage = \" was killed by \";\n\treturn message;\n}\n\n//\n// Generate a killed by creature message.\n//\nstatic function string CreatureKillMessage( name damageType, pawn Other )\n{\n\treturn \" was killed by a \";\n}\n\n//\n// Send a player to a URL.\n//\nfunction SendPlayer( PlayerPawn aPlayer, string URL )\n{\n\taPlayer.ClientTravel( URL, TRAVEL_Relative, true );\n}\n\n//\n// Play a teleporting special effect.\n//\nfunction PlayTeleportEffect( actor Incoming, bool bOut, bool bSound);\n\n//\n// Restart the game.\n//\nfunction RestartGame()\n{\n\tLevel.ServerTravel( \"?Restart\", false );\n}\n\n//\n// Whether players are allowed to broadcast messages now.\n//\nfunction bool AllowsBroadcast( actor broadcaster, int Len )\n{\n\tSentText += Len;\n\n\treturn (SentText < 260);\n}\n\n//\n// End of game.\n//\nfunction EndGame( string Reason )\n{\n\tlocal actor A;\n\n\t// don't end game if not really ready\n\tif ( !SetEndCams(Reason) )\n\t{\n\t\tbOverTime = true;\n\t\treturn;\n\t}\n\tbGameEnded = true;\n\tforeach AllActors(class'Actor', A, 'EndGame')\n\t\tA.trigger(self, none);\n\n\tif (LocalLog != None)\n\t{\n\t\tLocalLog.LogGameEnd(Reason);\n\t\tLocalLog.StopLog();\n\t\tif (bBatchLocal)\n\t\t\tLocalLog.ExecuteSilentLogBatcher();\n\t\tLocalLog.Destroy();\n\t\tLocalLog = None;\n\t}\n\tif (WorldLog != None)\n\t{\n\t\tWorldLog.LogGameEnd(Reason);\n\t\tWorldLog.StopLog();\n\t\tWorldLog.ExecuteWorldLogBatcher();\n\t\tWorldLog.Destroy();\n\t\tWorldLog = None;\n\t}\n}\n\nfunction bool SetEndCams(string Reason)\n{\n\tlocal pawn aPawn;\n\n\tfor ( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )\n\t\tif ( aPawn.bIsPlayer )\n\t\t{\n\t\t\taPawn.GotoState('GameEnded');\n\t\t\taPawn.ClientGameEnded();\n\t\t}\t\n\n\treturn true;\n}\n\ndefaultproperties\n{\n     Difficulty=1\n     bRestartLevel=True\n     bPauseable=True\n     bCanChangeSkin=True\n     bNoCheating=True\n     bCanViewOthers=True\n     AutoAim=0.930000\n     GameSpeed=1.000000\n     MaxSpectators=2\n     BotMenuType=\"UMenu.UMenuBotConfigSClient\"\n     RulesMenuType=\"UMenu.UMenuGameRulesSClient\"\n     SettingsMenuType=\"UMenu.UMenuGameSettingsSClient\"\n     GameUMenuType=\"UMenu.UMenuGameMenu\"\n     MultiplayerUMenuType=\"UMenu.UMenuMultiplayerMenu\"\n     GameOptionsMenuType=\"UMenu.UMenuOptionsMenu\"\n     SwitchLevelMessage=\"Switching Levels\"\n     DefaultPlayerName=\"Player\"\n     LeftMessage=\" left the game.\"\n     FailedSpawnMessage=\"Failed to spawn player actor\"\n     FailedPlaceMessage=\"Could not find starting spot (level might need a 'PlayerStart' actor)\"\n     FailedTeamMessage=\"Could not find team for player\"\n     NameChangedMessage=\"Name changed to \"\n     EnteredMessage=\" entered the game.\"\n     GameName=\"Game\"\n     MaxedOutMessage=\"Server is already at capacity.\"\n     WrongPassword=\"The password you entered is incorrect.\"\n     NeedPassword=\"You need to enter a password to join this game.\"\n     IPBanned=\"Your IP address has been banned on this server.\"\n     MaxPlayers=16\n     IPPolicies(0)=\"ACCEPT,*\"\n     DeathMessageClass=Class'Engine.LocalMessage'\n     MutatorClass=Class'Engine.Mutator'\n     DefaultPlayerState=PlayerWalking\n     ServerLogName=\"server.log\"\n     bLocalLog=True\n     bWorldLog=True\n     StatLogClass=Class'Engine.StatLogFile'\n}\n",
            "name": "GameInfo.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Difficulty=1",
                    "bRestartLevel=True",
                    "bPauseable=True",
                    "bCanChangeSkin=True",
                    "bNoCheating=True",
                    "bCanViewOthers=True",
                    "AutoAim=0.930000",
                    "GameSpeed=1.000000",
                    "MaxSpectators=2",
                    "BotMenuType=\"UMenu.UMenuBotConfigSClient\"",
                    "RulesMenuType=\"UMenu.UMenuGameRulesSClient\"",
                    "SettingsMenuType=\"UMenu.UMenuGameSettingsSClient\"",
                    "GameUMenuType=\"UMenu.UMenuGameMenu\"",
                    "MultiplayerUMenuType=\"UMenu.UMenuMultiplayerMenu\"",
                    "GameOptionsMenuType=\"UMenu.UMenuOptionsMenu\"",
                    "SwitchLevelMessage=\"Switching Levels\"",
                    "DefaultPlayerName=\"Player\"",
                    "LeftMessage=\" left the game.\"",
                    "FailedSpawnMessage=\"Failed to spawn player actor\"",
                    "FailedPlaceMessage=\"Could not find starting spot (level might need a 'PlayerStart' actor)\"",
                    "FailedTeamMessage=\"Could not find team for player\"",
                    "NameChangedMessage=\"Name changed to \"",
                    "EnteredMessage=\" entered the game.\"",
                    "GameName=\"Game\"",
                    "MaxedOutMessage=\"Server is already at capacity.\"",
                    "WrongPassword=\"The password you entered is incorrect.\"",
                    "NeedPassword=\"You need to enter a password to join this game.\"",
                    "IPBanned=\"Your IP address has been banned on this server.\"",
                    "MaxPlayers=16",
                    "IPPolicies(0)=\"ACCEPT,*\"",
                    "DeathMessageClass=Class'Engine.LocalMessage'",
                    "MutatorClass=Class'Engine.Mutator'",
                    "DefaultPlayerState=PlayerWalking",
                    "ServerLogName=\"server.log\"",
                    "bLocalLog=True",
                    "bWorldLog=True",
                    "StatLogClass=Class'Engine.StatLogFile'"
                ],
                "exec": [],
                "extends": "Info",
                "functions": {
                    "AcceptInventory": {
                        "body": "{\n\t//default accept all inventory except default weapon (spawned explicitly)\n\n\n\t// Initialize the inventory.\n\tAddDefaultInventory( PlayerPawn );\n\n\tlog( \"All inventory from\" @ PlayerPawn.PlayerReplicationInfo.PlayerName @ \"is accepted\" );\n}",
                        "locals": [
                            "local inventory inv;"
                        ],
                        "modifiers": [],
                        "name": "AcceptInventory",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "PlayerPawn"
                            ]
                        ],
                        "return": ""
                    },
                    "AddBot": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AddBot",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "AddDefaultInventory": {
                        "body": "{\n\n\tPlayerPawn.JumpZ = PlayerPawn.Default.JumpZ * PlayerJumpZScaling();\n\t \n\tif( PlayerPawn.IsA('Spectator') )\n\t\treturn;\n\n\t// Spawn default weapon.\n\tWeapClass = BaseMutator.MutatedDefaultWeapon();\n\tif( (WeapClass!=None) && (PlayerPawn.FindInventoryType(WeapClass)==None) )\n\t{\n\t\tnewWeapon = Spawn(WeapClass);\n\t\tif( newWeapon != None )\n\t\t{\n\t\t\tnewWeapon.Instigator = PlayerPawn;\n\t\t\tnewWeapon.BecomeItem();\n\t\t\tnewWeapon.GiveAmmo(PlayerPawn);\n\t\t\tPlayerPawn.AddInventory(newWeapon);\n\t\t\tnewWeapon.BringUp();\n\t\t\tnewWeapon.SetSwitchPriority(PlayerPawn);\n\t\t\tnewWeapon.WeaponSet(PlayerPawn);\n\t\t}\n\t}\n\tBaseMutator.ModifyPlayer(PlayerPawn);\n}",
                        "locals": [
                            "local Weapon newWeapon;",
                            "local class<Weapon> WeapClass;"
                        ],
                        "modifiers": [],
                        "name": "AddDefaultInventory",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "PlayerPawn"
                            ]
                        ],
                        "return": ""
                    },
                    "AdminLogin": {
                        "body": "{\n\tif (AdminPassword == \"\")\n\t\treturn;\n\n\tif (Password == AdminPassword)\n\t{\n\t\tP.bAdmin = True;\n\t\tP.PlayerReplicationInfo.bAdmin = P.bAdmin;\n\t\tLog(\"Administrator logged in.\");\n\t\tBroadcastMessage( P.PlayerReplicationInfo.PlayerName@\"became a server administrator.\" );\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AdminLogin",
                        "native": false,
                        "param": [
                            [
                                "PlayerPawn",
                                "P"
                            ],
                            [
                                "string",
                                "Password"
                            ]
                        ],
                        "return": ""
                    },
                    "AdminLogout": {
                        "body": "{\n\tif (AdminPassword == \"\")\n\t\treturn;\n\n\tif (P.bAdmin)\n\t{\n\t\tP.bAdmin = False;\n\t\tP.PlayerReplicationInfo.bAdmin = P.bAdmin;\n\t\tLog(\"Administrator logged out.\");\n\t\tBroadcastMessage( P.PlayerReplicationInfo.PlayerName@\"gave up administrator abilities.\" );\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AdminLogout",
                        "native": false,
                        "param": [
                            [
                                "PlayerPawn",
                                "P"
                            ]
                        ],
                        "return": ""
                    },
                    "AllowsBroadcast": {
                        "body": "{\n\tSentText += Len;\n\n\treturn (SentText < 260);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AllowsBroadcast",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "broadcaster"
                            ],
                            [
                                "int",
                                "Len"
                            ]
                        ],
                        "return": "bool"
                    },
                    "AtCapacity": {
                        "body": "{\n\treturn ( (MaxPlayers>0) && (NumPlayers>=MaxPlayers) );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AtCapacity",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Options"
                            ]
                        ],
                        "return": "bool"
                    },
                    "BroadcastRegularDeathMessage": {
                        "body": "{\n\tBroadcastLocalizedMessage(DeathMessageClass, 0, Killer.PlayerReplicationInfo, Other.PlayerReplicationInfo, Killer.Weapon.Class);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BroadcastRegularDeathMessage",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": ""
                    },
                    "CanSpectate": {
                        "body": "{\n\treturn true;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CanSpectate",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Viewer"
                            ],
                            [
                                "actor",
                                "ViewTarget"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ChangeName": {
                        "body": "{\n\tif( S == \"\" )\n\t\treturn;\n\tif (LocalLog != None)\n\t\tLocalLog.LogNameChange(Other);\n\tif (WorldLog != None)\n\t\tWorldLog.LogNameChange(Other);\n\tOther.PlayerReplicationInfo.PlayerName = S;\n\tif( bNameChange )\n\t\tOther.ClientMessage( NameChangedMessage $ Other.PlayerReplicationInfo.PlayerName );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangeName",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ],
                            [
                                "coerce",
                                "string",
                                "S"
                            ],
                            [
                                "bool",
                                "bNameChange"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangeTeam": {
                        "body": "{\n\tOther.PlayerReplicationInfo.Team = N;\n\tif (LocalLog != None)\n\t\tLocalLog.LogTeamChange(Other);\n\tif (WorldLog != None)\n\t\tWorldLog.LogTeamChange(Other);\n\treturn true;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangeTeam",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ],
                            [
                                "int",
                                "N"
                            ]
                        ],
                        "return": "bool"
                    },
                    "CheckIPPolicy": {
                        "body": "{\n\t\n\t// strip port number\n\tj = InStr(Address, \":\");\n\tif(j != -1)\n\t\tAddress = Left(Address, j);\n\n\tbAcceptAddress = True;\n\tfor(i=0; i<50 && IPPolicies[i] != \"\"; i++)\n\t{\n\t\tj = InStr(IPPolicies[i], \",\");\n\t\tif(j==-1)\n\t\t\tcontinue;\n\t\tPolicy = Left(IPPolicies[i], j);\n\t\tMask = Mid(IPPolicies[i], j+1);\n\t\tif(Policy ~= \"ACCEPT\") \n\t\t\tbAcceptPolicy = True;\n\t\telse\n\t\tif(Policy ~= \"DENY\") \n\t\t\tbAcceptPolicy = False;\n\t\telse\n\t\t\tcontinue;\n\n\t\tj = InStr(Mask, \"*\");\n\t\tif(j != -1)\n\t\t{\n\t\t\tif(Left(Mask, j) == Left(Address, j))\n\t\t\t{\n\t\t\t\tbAcceptAddress = bAcceptPolicy;\n\t\t\t\tLastMatchingPolicy = i;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(Mask == Address)\n\t\t\t{\n\t\t\t\tbAcceptAddress = bAcceptPolicy;\n\t\t\t\tLastMatchingPolicy = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!bAcceptAddress)\n\t\tLog(\"Denied connection for \"$Address$\" with IP policy \"$IPPolicies[LastMatchingPolicy]);\n\t\t\n\treturn bAcceptAddress;\n}",
                        "locals": [
                            "local int i, j, LastMatchingPolicy;",
                            "local string Policy, Mask;",
                            "local bool bAcceptAddress, bAcceptPolicy;"
                        ],
                        "modifiers": [],
                        "name": "CheckIPPolicy",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Address"
                            ]
                        ],
                        "return": "bool"
                    },
                    "CreatureKillMessage": {
                        "body": "{\n\treturn \" was killed by a \";\n}",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "CreatureKillMessage",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "damageType"
                            ],
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": "string"
                    },
                    "DetailChange": {
                        "body": "{\n\tif( !Level.bHighDetailMode )\n\t{\n\t\tforeach AllActors(class'Actor', A)\n\t\t{\n\t\t\tif( A.bHighDetail && !A.bGameRelevant )\n\t\t\t\tA.Destroy();\n\t\t}\n\t}\n\tforeach AllActors(class'ZoneInfo', Z)\n\t\tZ.LinkToSkybox();\n}",
                        "locals": [
                            "local actor A;",
                            "local zoneinfo Z;",
                            "local skyzoneinfo S;"
                        ],
                        "modifiers": [],
                        "name": "DetailChange",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DiscardInventory": {
                        "body": "{\n\n\tif( Other.DropWhenKilled != None )\n\t{\n\t\tdropped = Spawn(Other.DropWhenKilled,,,Other.Location);\n\t\tInv = Inventory(dropped);\n\t\tif ( Inv != None )\n\t\t{ \n\t\t\tInv.RespawnTime = 0.0; //don't respawn\n\t\t\tInv.BecomePickup();\t\t\n\t\t}\n\t\tif ( dropped != None )\n\t\t{\n\t\t\tdropped.RemoteRole = ROLE_DumbProxy;\n\t\t\tdropped.SetPhysics(PHYS_Falling);\n\t\t\tdropped.bCollideWorld = true;\n\t\t\tdropped.Velocity = Other.Velocity + VRand() * 280;\n\t\t}\n\t\tif ( Inv != None )\n\t\t\tInv.GotoState('PickUp', 'Dropped');\n\t}\t\t\t\t\t\n\tif( (Other.Weapon!=None) && (Other.Weapon.Class!=Level.Game.BaseMutator.MutatedDefaultWeapon()) \n\t\t&& Other.Weapon.bCanThrow )\n\t{\n\t\tspeed = VSize(Other.Velocity);\n\t\tweap = Other.Weapon;\n\t\tif (speed != 0)\n\t\t\tweap.Velocity = Normal(Other.Velocity/speed + 0.5 * VRand()) * (speed + 280);\n\t\telse {\n\t\t\tweap.Velocity.X = 0;\n\t\t\tweap.Velocity.Y = 0;\n\t\t\tweap.Velocity.Z = 0;\n\t\t}\n\t\tOther.TossWeapon();\n\t\tif ( weap.PickupAmmoCount == 0 )\n\t\t\tweap.PickupAmmoCount = 1;\n\t}",
                        "locals": [
                            "local actor dropped;",
                            "local inventory Inv;",
                            "local weapon weap;",
                            "local float speed;"
                        ],
                        "modifiers": [],
                        "name": "DiscardInventory",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "EndGame": {
                        "body": "{\n\n\t// don't end game if not really ready\n\tif ( !SetEndCams(Reason) )\n\t{\n\t\tbOverTime = true;\n\t\treturn;\n\t}\n\tbGameEnded = true;\n\tforeach AllActors(class'Actor', A, 'EndGame')\n\t\tA.trigger(self, none);\n\n\tif (LocalLog != None)\n\t{\n\t\tLocalLog.LogGameEnd(Reason);\n\t\tLocalLog.StopLog();\n\t\tif (bBatchLocal)\n\t\t\tLocalLog.ExecuteSilentLogBatcher();\n\t\tLocalLog.Destroy();\n\t\tLocalLog = None;\n\t}\n\tif (WorldLog != None)\n\t{\n\t\tWorldLog.LogGameEnd(Reason);\n\t\tWorldLog.StopLog();\n\t\tWorldLog.ExecuteWorldLogBatcher();\n\t\tWorldLog.Destroy();\n\t\tWorldLog = None;\n\t}\n}",
                        "locals": [
                            "local actor A;"
                        ],
                        "modifiers": [],
                        "name": "EndGame",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Reason"
                            ]
                        ],
                        "return": ""
                    },
                    "FindPlayerStart": {
                        "body": "{\n\tif( incomingName!=\"\" )\n\t\tforeach AllActors( class 'Teleporter', Tel )\n\t\t\tif( string(Tel.Tag)~=incomingName )\n\t\t\t\treturn Tel;\n\tforeach AllActors( class 'PlayerStart', Dest )\n\t\tif( Dest.bSinglePlayerStart && Dest.bEnabled )\n\t\t\treturn Dest;\n\n\t// if none, check for any that aren't enabled\n\tlog(\"WARNING: All single player starts were disabled - picking one anyway!\");\n\tforeach AllActors( class 'PlayerStart', Dest )\n\t\tif( Dest.bSinglePlayerStart )\n\t\t\treturn Dest;\n\tlog( \"No single player start found\" );\n\treturn None;\n}",
                        "locals": [
                            "local PlayerStart Dest;",
                            "local Teleporter Tel;"
                        ],
                        "modifiers": [],
                        "name": "FindPlayerStart",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Player"
                            ],
                            [
                                "optional",
                                "byte",
                                "InTeam"
                            ],
                            [
                                "optional",
                                "string",
                                "incomingName"
                            ]
                        ],
                        "return": "NavigationPoint"
                    },
                    "ForceAddBot": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ForceAddBot",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "GameEnding": {
                        "body": "{\n\tif (LocalLog != None)\n\t{\n\t\tLocalLog.LogGameEnd(\"serverquit\");\n\t\tLocalLog.StopLog();\n\t\tLocalLog.Destroy();\n\t\tLocalLog = None;\n\t}\n\n\tif (WorldLog != None)\n\t{\n\t\tWorldLog.LogGameEnd(\"serverquit\");\n\t\tWorldLog.StopLog();\n\t\tWorldLog.Destroy();\n\t\tWorldLog = None;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GameEnding",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GetBeaconText": {
                        "body": "{\t\n\treturn\n\t\tLevel.ComputerName\n\t$\t\" \"\n\t$\tLeft(Level.Title,24) \n\t$\t\" \"\n\t$\tBeaconName\n\t$\t\" \"\n\t$\tNumPlayers\n\t$\t\"/\"\n\t$\tMaxPlayers;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetBeaconText",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "GetInfo": {
                        "body": "{\n\n\tif (GamePassword != \"\")\n\t\tResultSet = \"\\\\password\\\\True\";\n\telse\n\t\tResultSet = \"\\\\password\\\\False\";\n\n\n\treturn ResultSet;\n}",
                        "locals": [
                            "local string ResultSet;"
                        ],
                        "modifiers": [],
                        "name": "GetInfo",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "GetIntOption": {
                        "body": "{\n\n\tInOpt = ParseOption( Options, ParseString );\n\tif ( InOpt != \"\" )\n\t{\n\t\tlog(ParseString@InOpt);\n\t\treturn int(InOpt);\n\t}\t\n\treturn CurrentValue;\n}",
                        "locals": [
                            "local string InOpt;"
                        ],
                        "modifiers": [],
                        "name": "GetIntOption",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Options"
                            ],
                            [
                                "string",
                                "ParseString"
                            ],
                            [
                                "int",
                                "CurrentValue"
                            ]
                        ],
                        "return": "int"
                    },
                    "GetKeyValue": {
                        "body": "{\n\tif( InStr(Pair,\"=\")>=0 )\n\t{\n\t\tKey   = Left(Pair,InStr(Pair,\"=\"));\n\t\tValue = Mid(Pair,InStr(Pair,\"=\")+1);\n\t}\n\telse\n\t{\n\t\tKey   = Pair;\n\t\tValue = \"\";\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetKeyValue",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Pair"
                            ],
                            [
                                "out",
                                "string",
                                "Key"
                            ],
                            [
                                "out",
                                "string",
                                "Value"
                            ]
                        ],
                        "return": ""
                    },
                    "GetNetworkNumber": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetNetworkNumber",
                        "native": true,
                        "param": [],
                        "return": "string"
                    },
                    "GetRules": {
                        "body": "{\n\n\tResultSet = \"\";\n\n\tEnabledMutators = \"\";\n\tfor (M = BaseMutator.NextMutator; M != None; M = M.NextMutator)\n\t{\n\t\tNum = 0;\n\t\tNextMutator = \"\";\n\t\tGetNextIntDesc(\"Engine.Mutator\", 0, NextMutator, NextDesc);\n\t\twhile( (NextMutator != \"\") && (Num < 50) )\n\t\t{\n\t\t\tif(NextMutator ~= string(M.Class))\n\t\t\t{\n\t\t\t\ti = InStr(NextDesc, \",\");\n\t\t\t\tif(i != -1)\n\t\t\t\t\tNextDesc = Left(NextDesc, i);\n\n\t\t\t\tif(EnabledMutators != \"\")\n\t\t\t\t\tEnabledMutators = EnabledMutators $ \", \";\n\t\t\t\t EnabledMutators = EnabledMutators $ NextDesc;\n\t\t\t\t break;\n\t\t\t}\n\t\t\t\n\t\t\tNum++;\n\t\t\tGetNextIntDesc(\"Engine.Mutator\", Num, NextMutator, NextDesc);\n\t\t}\n\t}\n\tif(EnabledMutators != \"\")\n\t\tResultSet = ResultSet $ \"\\\\mutators\\\\\"$EnabledMutators;\n\n\tResultSet = ResultSet $ \"\\\\listenserver\\\\\"$string(Level.NetMode==NM_ListenServer);\n\n\tif (GamePassword != \"\")\n\t\tResultSet = ResultSet $ \"\\\\password\\\\True\";\n\telse\n\t\tResultSet = ResultSet $ \"\\\\password\\\\False\";\n\n\treturn ResultSet;\n}",
                        "locals": [
                            "local string ResultSet;",
                            "local Mutator M;",
                            "local string NextMutator, NextDesc;",
                            "local string EnabledMutators;",
                            "local int Num, i;"
                        ],
                        "modifiers": [],
                        "name": "GetRules",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "GetServerPort": {
                        "body": "{\n\n\t// Figure out the server's port.\n\tS = Level.GetAddressURL();\n\ti = InStr( S, \":\" );\n\tassert(i>=0);\n\treturn int(Mid(S,i+1));\n}",
                        "locals": [
                            "local string S;",
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "GetServerPort",
                        "native": false,
                        "param": [],
                        "return": "int"
                    },
                    "GrabOption": {
                        "body": "{\n\tif( Left(Options,1)==\"?\" )\n\t{\n\t\t// Get result.\n\t\tResult = Mid(Options,1);\n\t\tif( InStr(Result,\"?\")>=0 )\n\t\t\tResult = Left( Result, InStr(Result,\"?\") );\n\n\t\t// Update options.\n\t\tOptions = Mid(Options,1);\n\t\tif( InStr(Options,\"?\")>=0 )\n\t\t\tOptions = Mid( Options, InStr(Options,\"?\") );\n\t\telse\n\t\t\tOptions = \"\";\n\n\t\treturn true;\n\t}\n\telse return false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GrabOption",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "string",
                                "Options"
                            ],
                            [
                                "out",
                                "string",
                                "Result"
                            ]
                        ],
                        "return": "bool"
                    },
                    "HasOption": {
                        "body": "{\n\twhile( GrabOption( Options, Pair ) )\n\t{\n\t\tGetKeyValue( Pair, Key, Value );\n\t\tif( Key ~= InKey )\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
                        "locals": [
                            "local string Pair, Key, Value;"
                        ],
                        "modifiers": [],
                        "name": "HasOption",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Options"
                            ],
                            [
                                "string",
                                "InKey"
                            ]
                        ],
                        "return": "bool"
                    },
                    "InitGame": {
                        "body": "{\n\n\tlog( \"InitGame:\" @ Options );\n\tMaxPlayers = Min( 32,GetIntOption( Options, \"MaxPlayers\", MaxPlayers ));\n\tInOpt = ParseOption( Options, \"Difficulty\" );\n\tif( InOpt != \"\" )\n\t\tDifficulty = int(InOpt);\n\n\tInOpt = ParseOption( Options, \"AdminPassword\");\n\tif( InOpt!=\"\" )\n\t\tAdminPassword = InOpt;\n\n\tInOpt = ParseOption( Options, \"GameSpeed\");\n\tif( InOpt != \"\" )\n\t{\n\t\tlog(\"GameSpeed\"@InOpt);\n\t\tSetGameSpeed(float(InOpt));\n\t}\n\n\tBaseMutator = spawn(MutatorClass);\n\tlog(\"Base Mutator is \"$BaseMutator);\n\tInOpt = ParseOption( Options, \"Mutator\");\n\tif ( InOpt != \"\" )\n\t{\n\t\tlog(\"Mutators\"@InOpt);\n\t\twhile ( InOpt != \"\" )\n\t\t{\n\t\t\tpos = InStr(InOpt,\",\");\n\t\t\tif ( pos > 0 )\n\t\t\t{\n\t\t\t\tLeftOpt = Left(InOpt, pos);\n\t\t\t\tInOpt = Right(InOpt, Len(InOpt) - pos - 1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLeftOpt = InOpt;\n\t\t\t\tInOpt = \"\";\n\t\t\t}\n\t\t\tlog(\"Add mutator \"$LeftOpt);\n\t\t\tMClass = class<Mutator>(DynamicLoadObject(LeftOpt, class'Class'));\t\n\t\t\tBaseMutator.AddMutator(Spawn(MClass));\n\t\t}\n\t}\n\n\tInOpt = ParseOption( Options, \"GamePassword\");\n\tif( InOpt != \"\" )\n\t{\n\t\tGamePassWord = InOpt;\n\t\tlog( \"GamePassword\" @ InOpt );\n\t}\n\n\tInOpt = ParseOption( Options, \"LocalLog\");\n\tif( InOpt ~= \"true\" )\n\t\tbLocalLog = True;\n\n\tInOpt = ParseOption( Options, \"WorldLog\");\n\tif( InOpt ~= \"true\" )\n\t\tbWorldLog = True;\n}",
                        "locals": [
                            "local string InOpt, LeftOpt;",
                            "local int pos;",
                            "local class<Mutator> MClass;"
                        ],
                        "modifiers": [],
                        "name": "InitGame",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Options"
                            ],
                            [
                                "out",
                                "string",
                                "Error"
                            ]
                        ],
                        "return": ""
                    },
                    "InitGameReplicationInfo": {
                        "body": "{\n\tGameReplicationInfo.bTeamGame = bTeamGame;\n\tGameReplicationInfo.GameName = GameName;\n\tGameReplicationInfo.GameClass = string(Class);\n\tGameReplicationInfo.bClassicDeathmessages = bClassicDeathmessages;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "InitGameReplicationInfo",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "InitLogging": {
                        "body": "{\n\n\tif (bLocalLog && bLoggingGame)\n\t{\n\t\tLog(\"Initiating local logging...\");\n\t\tLocalLog = spawn(StatLogClass);\n\t\tLocalLog.bWorld = False;\n\t\tLocalLog.StartLog();\n\t\tLocalLog.LogStandardInfo();\n\t\tLocalLog.LogServerInfo();\n\t\tLocalLog.LogMapParameters();\n\t\tfor (M = BaseMutator; M != None; M = M.NextMutator)\n\t\t\tLocalLog.LogMutator(M);\n\t\tLogGameParameters(LocalLog);\n\t\tLocalLogFileName = LocalLog.GetLogFileName();\n\t}\n\n\t// Setup world statistics logging.\n\tif ((Level.NetMode != NM_DedicatedServer) && (Level.NetMode != NM_ListenServer))\n\t\treturn;\n\n\tif (bWorldLog && bLoggingGame)\n\t{\n\t\tLog(\"Initiating world logging...\");\n\t\tWorldLog = spawn(StatLogClass);\n\t\tWorldLog.bWorld = True;\n\t\tWorldLog.StartLog();\n\t\tWorldLog.LogStandardInfo();\n\t\tWorldLog.LogServerInfo();\n\t\tWorldLog.LogMapParameters();\n\t\tWorldLog.InitialCheck(Self);\n\t\tfor (M = BaseMutator; M != None; M = M.NextMutator)\n\t\t\tWorldLog.LogMutator(M);\n\t\tLogGameParameters(WorldLog);\n\t\tWorldLogFileName = WorldLog.GetLogFileName();\n\t}\n}",
                        "locals": [
                            "local Mutator M;"
                        ],
                        "modifiers": [],
                        "name": "InitLogging",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "IsRelevant": {
                        "body": "{\n\n\t// let the mutators mutate the actor or choose to remove it\n\tif ( BaseMutator.AlwaysKeep(Other) )\n\t\treturn true;\n\tif ( BaseMutator.IsRelevant(Other, bSuperRelevant) )\n\t{\n\t\tif ( bSuperRelevant == 1 ) // mutator wants to override any logic in here\n\t\t\treturn true;\n\t}\n\telse return false;\n\n\tif\n\t(\t(Difficulty==0 && !Other.bDifficulty0 )\n\t||  (Difficulty==1 && !Other.bDifficulty1 )\n\t||  (Difficulty==2 && !Other.bDifficulty2 )\n\t||  (Difficulty==3 && !Other.bDifficulty3 )\n\t||  (!Other.bSinglePlayer && (Level.NetMode==NM_Standalone) ) \n\t||  (!Other.bNet && ((Level.NetMode == NM_DedicatedServer) || (Level.NetMode == NM_ListenServer)) )\n\t||  (!Other.bNetSpecial  && (Level.NetMode==NM_Client)) )\n\t\treturn False;\n\n\tif( bNoMonsters && (Pawn(Other) != None) && !Pawn(Other).bIsPlayer )\n\t\treturn False;\n\n\tif( FRand() > Other.OddsOfAppearing )\n\t\treturn False;\n\n    // Update the level info goal counts.\n    if( Other.bIsSecretGoal )\n       SecretGoals++;\n\n    if( Other.bIsItemGoal )\n       ItemGoals++;\n\n    if( Other.bIsKillGoal )\n       KillGoals++;\n\n\treturn True;\n}",
                        "locals": [
                            "local byte bSuperRelevant;"
                        ],
                        "modifiers": [],
                        "name": "IsRelevant",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": "bool"
                    },
                    "KillMessage": {
                        "body": "{\n\treturn \" died.\";\n}",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "KillMessage",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "damageType"
                            ],
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": "string"
                    },
                    "Killed": {
                        "body": "{\n\n\tif (Other.bIsPlayer)\n\t{\n\t\tif ( (Killer != None) && (!Killer.bIsPlayer) )\n\t\t{\n\t\t\tif ( Level.NetMode != NM_Standalone )\n\t\t\t{\n\t\t\t\tMessage = Other.PlayerReplicationInfo.PlayerName$Killer.KillMessage(damageType, Other);\n\t\t\t\tBroadcastMessage( Message, false, 'DeathMessage');\n\t\t\t}\n\t\t\tif ( LocalLog != None )\n\t\t\t\tLocalLog.LogSuicide(Other, DamageType, None);\n\t\t\tif ( WorldLog != None )\n\t\t\t\tWorldLog.LogSuicide(Other, DamageType, None);\n\t\t\treturn;\n\t\t}\n\t\tif ( (DamageType == 'SpecialDamage') && (SpecialDamageString != \"\") )\n\t\t{\n\t\t\tif ( Level.NetMode != NM_Standalone )\n\t\t\t{\n\t\t\t\tBroadcastMessage( ParseKillMessage(\n\t\t\t\t\t\tKiller.PlayerReplicationInfo.PlayerName,\n\t\t\t\t\t\tOther.PlayerReplicationInfo.PlayerName,\n\t\t\t\t\t\tKiller.Weapon.ItemName,\n\t\t\t\t\t\tSpecialDamageString\n\t\t\t\t\t\t),\n\t\t\t\t\tfalse, 'DeathMessage');\n\t\t\t}\n\t\t\tbSpecialDamage = True;\n\t\t}\n\t\tif ( (Killer == Other) || (Killer == None) )\n\t\t{\n\t\t\t// Suicide\n\t\t\tif (damageType == '')\n\t\t\t{\n\t\t\t\tif ( LocalLog != None )\n\t\t\t\t\tLocalLog.LogSuicide(Other, 'Unknown', Killer);\n\t\t\t\tif ( WorldLog != None )\n\t\t\t\t\tWorldLog.LogSuicide(Other, 'Unknown', Killer);\n\t\t\t} else {\n\t\t\t\tif ( LocalLog != None )\n\t\t\t\t\tLocalLog.LogSuicide(Other, damageType, Killer);\n\t\t\t\tif ( WorldLog != None )\n\t\t\t\t\tWorldLog.LogSuicide(Other, damageType, Killer);\n\t\t\t}\n\t\t\tif (!bSpecialDamage)\n\t\t\t{\n\t\t\t\tif ( damageType == 'Fell' )\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 2, Other.PlayerReplicationInfo, None);\n\t\t\t\telse if ( damageType == 'Eradicated' )\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 3, Other.PlayerReplicationInfo, None);\n\t\t\t\telse if ( damageType == 'Drowned' )\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 4, Other.PlayerReplicationInfo, None);\n\t\t\t\telse if ( damageType == 'Burned' )\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 5, Other.PlayerReplicationInfo, None);\n\t\t\t\telse if ( damageType == 'Corroded' )\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 6, Other.PlayerReplicationInfo, None);\n\t\t\t\telse if ( damageType == 'Mortared' )\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 7, Other.PlayerReplicationInfo, None);\n\t\t\t\telse\n\t\t\t\t\tBroadcastLocalizedMessage(DeathMessageClass, 1, Other.PlayerReplicationInfo, None);\n\t\t\t}\n\t\t} \n\t\telse \n\t\t{\n\t\t\t// Increment deaths if you were killed by another player. (But not for suicides.)\n\t\t\tOther.PlayerReplicationInfo.Deaths += 1;\n\t\t\tif ( Killer.bIsPlayer )\n\t\t\t{\n\t\t\t\tKillerWeapon = \"None\";\n\t\t\t\tif (Killer.Weapon != None)\n\t\t\t\t\tKillerWeapon = Killer.Weapon.ItemName;\n\t\t\t\tOtherWeapon = \"None\";\n\t\t\t\tif (Other.Weapon != None)\n\t\t\t\t\tOtherWeapon = Other.Weapon.ItemName;\n\t\t\t\tif ( Killer.PlayerReplicationInfo.Team == Other.PlayerReplicationInfo.Team )\n\t\t\t\t{\n\t\t\t\t\tif ( LocalLog != None )\n\t\t\t\t\t\tLocalLog.LogTeamKill(\n\t\t\t\t\t\t\tKiller.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tOther.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tKillerWeapon,\n\t\t\t\t\t\t\tOtherWeapon,\n\t\t\t\t\t\t\tdamageType\n\t\t\t\t\t\t);\n\t\t\t\t\tif ( WorldLog != None )\n\t\t\t\t\t\tWorldLog.LogTeamKill(\n\t\t\t\t\t\t\tKiller.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tOther.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tKillerWeapon,\n\t\t\t\t\t\t\tOtherWeapon,\n\t\t\t\t\t\t\tdamageType\n\t\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tif ( LocalLog != None )\n\t\t\t\t\t\tLocalLog.LogKill(\n\t\t\t\t\t\t\tKiller.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tOther.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tKillerWeapon,\n\t\t\t\t\t\t\tOtherWeapon,\n\t\t\t\t\t\t\tdamageType\n\t\t\t\t\t\t);\n\t\t\t\t\tif ( WorldLog != None )\n\t\t\t\t\t\tWorldLog.LogKill(\n\t\t\t\t\t\t\tKiller.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tOther.PlayerReplicationInfo.PlayerID,\n\t\t\t\t\t\t\tKillerWeapon,\n\t\t\t\t\t\t\tOtherWeapon,\n\t\t\t\t\t\t\tdamageType\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (!bSpecialDamage && (Other != None))\n\t\t\t\t{\n\t\t\t\t\tBroadcastRegularDeathMessage(Killer, Other, damageType);\n\t\t\t\t}\n\t\t\t}\n\t\t}",
                        "locals": [
                            "local String Message, KillerWeapon, OtherWeapon;",
                            "local bool bSpecialDamage;"
                        ],
                        "modifiers": [],
                        "name": "Killed",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": ""
                    },
                    "LogGameParameters": {
                        "body": "{\n\tif (StatLog == None)\n\t\treturn;\n\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"GameName\"$Chr(9)$GameName);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"GameClass\"$Chr(9)$Class);// <-- Move to c++\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"GameVersion\"$Chr(9)$Level.EngineVersion);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"MinNetVersion\"$Chr(9)$Level.MinNetVersion);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"NoMonsters\"$Chr(9)$bNoMonsters);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"MuteSpectators\"$Chr(9)$bMuteSpectators);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"HumansOnly\"$Chr(9)$bHumansOnly);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"WeaponsStay\"$Chr(9)$bCoopWeaponMode);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"ClassicDeathmessages\"$Chr(9)$bClassicDeathmessages);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"LowGore\"$Chr(9)$bLowGore);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"VeryLowGore\"$Chr(9)$bVeryLowGore);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"TeamGame\"$Chr(9)$bTeamGame);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"GameSpeed\"$Chr(9)$int(GameSpeed*100));\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"MaxSpectators\"$Chr(9)$MaxSpectators);\n\tStatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$\"MaxPlayers\"$Chr(9)$MaxPlayers);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogGameParameters",
                        "native": false,
                        "param": [
                            [
                                "StatLog",
                                "StatLog"
                            ]
                        ],
                        "return": ""
                    },
                    "Logout": {
                        "body": "{\n\n\tbMessage = true;\n\tif ( Exiting.IsA('PlayerPawn') )\n\t{\n\t\tif ( Exiting.IsA('Spectator') )\n\t\t{\n\t\t\tbMessage = false;\n\t\t\tif ( Level.NetMode == NM_DedicatedServer )\n\t\t\t\tNumSpectators--;\n\t\t}\n\t\telse\n\t\t\tNumPlayers--;\n\t}\n\tif( bMessage && (Level.NetMode==NM_DedicatedServer || Level.NetMode==NM_ListenServer) )\n\t\tBroadcastMessage( Exiting.PlayerReplicationInfo.PlayerName$LeftMessage, false );\n\n\tif ( LocalLog != None )\n\t\tLocalLog.LogPlayerDisconnect(Exiting);\n\tif ( WorldLog != None )\n\t\tWorldLog.LogPlayerDisconnect(Exiting);\n}",
                        "locals": [
                            "local bool bMessage;"
                        ],
                        "modifiers": [],
                        "name": "Logout",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Exiting"
                            ]
                        ],
                        "return": ""
                    },
                    "ParseKillMessage": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "ParseKillMessage",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "KillerName"
                            ],
                            [
                                "string",
                                "VictimName"
                            ],
                            [
                                "string",
                                "WeaponName"
                            ],
                            [
                                "string",
                                "DeathMessage"
                            ]
                        ],
                        "return": "string"
                    },
                    "ParseOption": {
                        "body": "{\n\twhile( GrabOption( Options, Pair ) )\n\t{\n\t\tGetKeyValue( Pair, Key, Value );\n\t\tif( Key ~= InKey )\n\t\t\treturn Value;\n\t}\n\treturn \"\";\n}",
                        "locals": [
                            "local string Pair, Key, Value;"
                        ],
                        "modifiers": [],
                        "name": "ParseOption",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Options"
                            ],
                            [
                                "string",
                                "InKey"
                            ]
                        ],
                        "return": "string"
                    },
                    "PickupQuery": {
                        "body": "{\n\tif ( Other.Inventory == None )\n\t\treturn true;\n\telse\n\t\treturn !Other.Inventory.HandlePickupQuery(Item);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PickupQuery",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ],
                            [
                                "Inventory",
                                "item"
                            ]
                        ],
                        "return": "bool"
                    },
                    "PlaySpawnEffect": {
                        "body": "{\n\treturn 0.3;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlaySpawnEffect",
                        "native": false,
                        "param": [
                            [
                                "inventory",
                                "Inv"
                            ]
                        ],
                        "return": "float"
                    },
                    "PlayTeleportEffect": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayTeleportEffect",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Incoming"
                            ],
                            [
                                "bool",
                                "bOut"
                            ],
                            [
                                "bool",
                                "bSound"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayerJumpZScaling": {
                        "body": "{\n\treturn 1.0;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayerJumpZScaling",
                        "native": false,
                        "param": [],
                        "return": "float"
                    },
                    "PlayerKillMessage": {
                        "body": "{\n\n\tmessage = \" was killed by \";\n\treturn message;\n}",
                        "locals": [
                            "local string message;"
                        ],
                        "modifiers": [
                            "static"
                        ],
                        "name": "PlayerKillMessage",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "damageType"
                            ],
                            [
                                "PlayerReplicationInfo",
                                "Other"
                            ]
                        ],
                        "return": "string"
                    },
                    "PostBeginPlay": {
                        "body": "{\n\n\tif ( bAlternateMode )\n\t{\n\t\tbLowGore = true;\n\t\tbVeryLowGore = true;\n\t}\n\n\tif ( bVeryLowGore )\n\t\tbLowGore = true;\n\n\tif ( WaterZoneType != None )\n\t{\n\t\tForEach AllActors(class'ZoneInfo', W )\n\t\t\tif ( W.bWaterZone )\n\t\t\t{\n\t\t\t\tif( W.EntryActor == None )\n\t\t\t\t\tW.EntryActor = WaterZoneType.Default.EntryActor;\n\t\t\t\tif( W.ExitActor == None )\n\t\t\t\t\tW.ExitActor = WaterZoneType.Default.ExitActor;\n\t\t\t\tif( W.EntrySound == None )\n\t\t\t\t\tW.EntrySound = WaterZoneType.Default.EntrySound;\n\t\t\t\tif( W.ExitSound == None )\n\t\t\t\t\tW.ExitSound = WaterZoneType.Default.ExitSound;\n\t\t\t}\n\t}\n\n\t// Setup local statistics logging.\n\tInitLogging();\n\n\tSuper.PostBeginPlay();\n}",
                        "locals": [
                            "local ZoneInfo W;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostLogin": {
                        "body": "{\n\t// Start player's music.\n\tNewPlayer.ClientSetMusic( Level.Song, Level.SongSection, Level.CdTrack, MTRAN_Fade );\n\tif ( Level.NetMode != NM_Standalone )\n\t{\n\t\t// replicate skins\n\t\tfor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t\t\tif ( P.bIsPlayer && (P != NewPlayer) )\n\t\t\t{\n\t\t\t\tif ( P.bIsMultiSkinned )\n\t\t\t\t\tNewPlayer.ClientReplicateSkins(P.MultiSkins[0], P.MultiSkins[1], P.MultiSkins[2], P.MultiSkins[3]);\n\t\t\t\telse\n\t\t\t\t\tNewPlayer.ClientReplicateSkins(P.Skin);\t\n\t\t\t\t\t\n\t\t\t\tif ( (P.PlayerReplicationInfo != None) && P.PlayerReplicationInfo.bWaitingPlayer && P.IsA('PlayerPawn') )\n\t\t\t\t{\n\t\t\t\t\tif ( NewPlayer.bIsMultiSkinned )\n\t\t\t\t\t\tPlayerPawn(P).ClientReplicateSkins(NewPlayer.MultiSkins[0], NewPlayer.MultiSkins[1], NewPlayer.MultiSkins[2], NewPlayer.MultiSkins[3]);\n\t\t\t\t\telse\n\t\t\t\t\t\tPlayerPawn(P).ClientReplicateSkins(NewPlayer.Skin);\t\n\t\t\t\t}\t\t\t\t\t\t\n\t\t\t}\n\t}\n}",
                        "locals": [
                            "local Pawn P;"
                        ],
                        "modifiers": [],
                        "name": "PostLogin",
                        "native": false,
                        "param": [
                            [
                                "playerpawn",
                                "NewPlayer"
                            ]
                        ],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tStartTime = 0;\n\tSetGameSpeed(GameSpeed);\n\tLevel.bNoCheating = bNoCheating;\n\tLevel.bAllowFOV = bAllowFOV;\n\t\n\tif (GameReplicationInfoClass != None)\n\t\tGameReplicationInfo = Spawn(GameReplicationInfoClass);\n\telse\n\t\tGameReplicationInfo = Spawn(class'GameReplicationInfo');\n\tInitGameReplicationInfo();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ProcessServerTravel": {
                        "body": "{\n\n\tif (LocalLog != None)\n\t{\n\t\tLocalLog.LogGameEnd(\"mapchange\");\n\t\tLocalLog.StopLog();\n\t\tLocalLog.Destroy();\n\t\tLocalLog = None;\n\t}\n\n\tif (WorldLog != None)\n\t{\n\t\tWorldLog.LogGameEnd(\"mapchange\");\n\t\tWorldLog.StopLog();\n\t\tWorldLog.Destroy();\n\t\tWorldLog = None;\n\t}\n\n\t// Notify clients we're switching level and give them time to receive.\n\t// We call PreClientTravel directly on any local PlayerPawns (ie listen server)\n\tlog(\"ProcessServerTravel:\"@URL);\n\tforeach AllActors( class'PlayerPawn', P )\n\t\tif( NetConnection(P.Player)!=None )\n\t\t\tP.ClientTravel( URL, TRAVEL_Relative, bItems );\n\t\telse\n\t\t{\t\n\t\t\tLocalPlayer = P;\n\t\t\tP.PreClientTravel();\n\t\t}\n\n\tif ( (Level.NetMode == NM_ListenServer) && (LocalPlayer != None) )\n\t\tLevel.NextURL = Level.NextURL$\"?Skin=\"$LocalPlayer.GetDefaultURL(\"Skin\")\n\t\t\t\t\t $\"?Face=\"$LocalPlayer.GetDefaultURL(\"Face\")\n\t\t\t\t\t $\"?Team=\"$LocalPlayer.GetDefaultURL(\"Team\")\n\t\t\t\t\t $\"?Name=\"$LocalPlayer.GetDefaultURL(\"Name\")\n\t\t\t\t\t $\"?Class=\"$LocalPlayer.GetDefaultURL(\"Class\");\n\n\t// Switch immediately if not networking.\n\tif( Level.NetMode!=NM_DedicatedServer && Level.NetMode!=NM_ListenServer )\n\t\tLevel.NextSwitchCountdown = 0.0;\n}",
                        "locals": [
                            "local playerpawn P, LocalPlayer;"
                        ],
                        "modifiers": [],
                        "name": "ProcessServerTravel",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "URL"
                            ],
                            [
                                "bool",
                                "bItems"
                            ]
                        ],
                        "return": ""
                    },
                    "ReduceDamage": {
                        "body": "{\n\tif( injured.Region.Zone.bNeutralZone )\n\t\treturn 0;\t\n\treturn Damage;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ReduceDamage",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Damage"
                            ],
                            [
                                "name",
                                "DamageType"
                            ],
                            [
                                "pawn",
                                "injured"
                            ],
                            [
                                "pawn",
                                "instigatedBy"
                            ]
                        ],
                        "return": "int"
                    },
                    "RegisterDamageMutator": {
                        "body": "{\n\tM.NextDamageMutator = DamageMutator;\n\tDamageMutator = M;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "RegisterDamageMutator",
                        "native": false,
                        "param": [
                            [
                                "Mutator",
                                "M"
                            ]
                        ],
                        "return": ""
                    },
                    "ResetGame": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "ResetGame",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "RestartGame": {
                        "body": "{\n\tLevel.ServerTravel( \"?Restart\", false );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "RestartGame",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "RestartPlayer": {
                        "body": "{\n\n\tif( bRestartLevel && Level.NetMode!=NM_DedicatedServer && Level.NetMode!=NM_ListenServer )\n\t\treturn true;\n\n\tstartSpot = FindPlayerStart(aPlayer, 255);\n\tif( startSpot == None )\n\t{\n\t\tlog(\" Player start not found!!!\");\n\t\treturn false;\n\t}\t\n\tfoundStart = aPlayer.SetLocation(startSpot.Location);\n\tif( foundStart )\n\t{\n\t\tstartSpot.PlayTeleportEffect(aPlayer, true);\n\t\taPlayer.SetRotation(startSpot.Rotation);\n\t\taPlayer.ViewRotation = aPlayer.Rotation;\n\t\taPlayer.Acceleration = vect(0,0,0);\n\t\taPlayer.Velocity = vect(0,0,0);\n\t\taPlayer.Health = aPlayer.Default.Health;\n\t\taPlayer.SetCollision( true, true, true );\n\t\taPlayer.ClientSetLocation( startSpot.Location, startSpot.Rotation );\n\t\taPlayer.bHidden = false;\n\t\taPlayer.DamageScaling = aPlayer.Default.DamageScaling;\n\t\taPlayer.SoundDampening = aPlayer.Default.SoundDampening;\n\t\tAddDefaultInventory(aPlayer);\n\t}\n\telse\n\t\tlog(startspot$\" Player start not useable!!!\");\n\treturn foundStart;\n}",
                        "locals": [
                            "local NavigationPoint startSpot;",
                            "local bool foundStart;"
                        ],
                        "modifiers": [],
                        "name": "RestartPlayer",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "aPlayer"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ScoreEvent": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ScoreEvent",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "EventName"
                            ],
                            [
                                "actor",
                                "EventActor"
                            ],
                            [
                                "pawn",
                                "InstigatedBy"
                            ]
                        ],
                        "return": ""
                    },
                    "ScoreKill": {
                        "body": "{\n\tOther.DieCount++;\n\tif( (killer == Other) || (killer == None) )\n\t\tOther.PlayerReplicationInfo.Score -= 1;\n\telse if ( killer != None )\n\t{\n\t\tkiller.killCount++;\n\t\tif ( killer.PlayerReplicationInfo != None )\n\t\t\tkiller.PlayerReplicationInfo.Score += 1;\n\t}\n\n\tBaseMutator.ScoreKill(Killer, Other);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ScoreKill",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "SendPlayer": {
                        "body": "{\n\taPlayer.ClientTravel( URL, TRAVEL_Relative, true );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SendPlayer",
                        "native": false,
                        "param": [
                            [
                                "PlayerPawn",
                                "aPlayer"
                            ],
                            [
                                "string",
                                "URL"
                            ]
                        ],
                        "return": ""
                    },
                    "SetEndCams": {
                        "body": "{\n\n\tfor ( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )\n\t\tif ( aPawn.bIsPlayer )\n\t\t{\n\t\t\taPawn.GotoState('GameEnded');\n\t\t\taPawn.ClientGameEnded();\n\t\t}\t\n\n\treturn true;\n}",
                        "locals": [
                            "local pawn aPawn;"
                        ],
                        "modifiers": [],
                        "name": "SetEndCams",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Reason"
                            ]
                        ],
                        "return": "bool"
                    },
                    "SetGameSpeed": {
                        "body": "{\n\tGameSpeed = FMax(T, 0.1);\n\tLevel.TimeDilation = GameSpeed;\n\tSetTimer(Level.TimeDilation, true);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetGameSpeed",
                        "native": false,
                        "param": [
                            [
                                "Float",
                                "T"
                            ]
                        ],
                        "return": ""
                    },
                    "SetPause": {
                        "body": "{\n\tif( bPauseable || P.bAdmin || Level.Netmode==NM_Standalone )\n\t{\n\t\tif( bPause )\n\t\t\tLevel.Pauser=P.PlayerReplicationInfo.PlayerName;\n\t\telse\n\t\t\tLevel.Pauser=\"\";\n\t\treturn True;\n\t}\n\telse return False;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetPause",
                        "native": false,
                        "param": [
                            [
                                "BOOL",
                                "bPause"
                            ],
                            [
                                "PlayerPawn",
                                "P"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ShouldRespawn": {
                        "body": "{\n\tif( Level.NetMode == NM_StandAlone )\n\t\treturn false;\n\treturn Inventory(Other)!=None && Inventory(Other).ReSpawnTime!=0.0;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ShouldRespawn",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": "bool"
                    },
                    "StartPlayer": {
                        "body": "{\n\tif( Level.NetMode==NM_DedicatedServer || Level.NetMode==NM_ListenServer || !bRestartLevel )\n\t\tOther.GotoState(Other.PlayerRestartState);\n\telse\n\t\tOther.ClientTravel( \"?restart\", TRAVEL_Relative, false );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StartPlayer",
                        "native": false,
                        "param": [
                            [
                                "PlayerPawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tSentText = 0;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 1597,
                "replication": "",
                "states": [],
                "variables": [
                    "var int ItemGoals, KillGoals, SecretGoals;\t\t\t\t// Special game goals.",
                    "var byte  Difficulty;\t\t\t\t\t\t\t\t\t// 0=easy, 1=medium, 2=hard, 3=very hard.",
                    "var() config bool   \t\t  bNoMonsters;\t\t\t\t// Whether monsters are allowed in this play mode.",
                    "var() globalconfig bool\t\t  bMuteSpectators;\t\t\t// Whether spectators are allowed to speak.",
                    "var() config bool\t\t\t  bHumansOnly;\t\t\t\t// Whether non human player models are allowed.",
                    "var() bool\t\t\t\t      bRestartLevel;",
                    "var() bool\t\t\t\t      bPauseable;\t\t\t\t// Whether the level is pauseable.",
                    "var() config bool\t\t\t  bCoopWeaponMode;\t\t\t// Whether or not weapons stay when picked up.",
                    "var() config bool\t\t\t  bClassicDeathmessages;\t// Weapon deathmessages if false.",
                    "var   globalconfig bool\t      bLowGore;\t\t\t\t\t// Whether or not to reduce gore.",
                    "var() bool\t\t\t\t      bTeamGame;\t\t\t\t// This is a teamgame.",
                    "var() globalconfig bool       bNoCheating;\t\t\t\t// Disallows cheating. Hehe.",
                    "var() globalconfig bool       bAllowFOV;\t\t\t\t// Allows FOV changes in net games",
                    "var() bool\t\t\t\t\t  bDeathMatch;\t\t\t\t// This game is some type of deathmatch (where players can respawn during gameplay)",
                    "var localized bool\t\t\t  bAlternateMode;",
                    "var() globalconfig float\t  AutoAim;\t\t\t\t\t// How much autoaiming to do (1 = none, 0 = always).",
                    "var() globalconfig float\t  GameSpeed;\t\t\t\t// Scale applied to game rate.",
                    "var   float                   StartTime;",
                    "var() class<playerpawn>       DefaultPlayerClass;",
                    "var() class<weapon>           DefaultWeapon;\t\t\t// Default weapon given to player at start.",
                    "var() globalconfig int\t      MaxSpectators;\t\t\t// Maximum number of spectators.",
                    "var() private globalconfig string AdminPassword;\t    // Password to receive bAdmin privileges.",
                    "var() private globalconfig string GamePassword;\t\t    // Password to enter game.",
                    "var() class<scoreboard>\t\t  ScoreBoardType;\t\t\t// Type of scoreboard this game uses.",
                    "var() class<menu>\t\t\t  GameMenuType;\t\t\t\t// Type of oldstyle game options menu to display.",
                    "var() string\t\t\t      BotMenuType;\t\t\t\t// Type of bot menu to display.",
                    "var() string\t\t\t      RulesMenuType;\t\t\t// Type of rules menu to display.",
                    "var() string\t\t\t\t  SettingsMenuType;\t\t\t// Type of settings menu to display.",
                    "var() string\t\t\t\t  GameUMenuType;\t\t\t// Type of Game dropdown to display.",
                    "var() string\t\t\t\t  MultiplayerUMenuType;\t\t// Type of Multiplayer dropdown to display.",
                    "var() string\t\t\t\t  GameOptionsMenuType;\t\t// Type of options dropdown to display.",
                    "var() class<hud>\t\t\t  HUDType;\t\t\t\t\t// HUD class this game uses.",
                    "var() class<MapList>\t\t  MapListType;\t\t\t\t// Maplist this game uses.",
                    "var() string\t\t\t      MapPrefix;\t\t\t\t// Prefix characters for names of maps for this game type.",
                    "var() string\t\t\t      BeaconName;\t\t\t\t// Identifying string used for finding LAN servers.",
                    "var() string\t\t\t      SpecialDamageString;",
                    "var localized string\t      SwitchLevelMessage;",
                    "var localized string\t      DefaultPlayerName;",
                    "var localized string\t      LeftMessage;",
                    "var localized string\t      FailedSpawnMessage;",
                    "var localized string\t      FailedPlaceMessage;",
                    "var localized string\t      FailedTeamMessage;",
                    "var localized string\t      NameChangedMessage;",
                    "var localized string\t      EnteredMessage;",
                    "var localized string\t      GameName;",
                    "var() globalconfig int\t\t  MaxPlayers;",
                    "var   int\t\t\t\t\t  NumPlayers;",
                    "var   int\t\t\t\t\t  CurrentID;",
                    "var() globalconfig string     IPPolicies[50];",
                    "var class<LocalMessage>\t\t  DeathMessageClass;",
                    "var class<LocalMessage>\t\t  DMMessageClass;",
                    "var class<Mutator> MutatorClass;",
                    "var Mutator BaseMutator;",
                    "var Mutator DamageMutator;\t// linked list of mutators which affect damage",
                    "var class<ZoneInfo> WaterZoneType;",
                    "var name DefaultPlayerState;",
                    "var() class<GameReplicationInfo> GameReplicationInfoClass;",
                    "var GameReplicationInfo GameReplicationInfo;",
                    "var globalconfig string         ServerLogName;",
                    "var StatLog\t\t\t\t\t\tLocalLog;",
                    "var StatLog\t\t\t\t\t\tWorldLog;",
                    "var globalconfig bool\t\t\tbLocalLog;",
                    "var globalconfig bool\t\t\tbWorldLog;",
                    "var globalconfig bool\t\t\tbBatchLocal;",
                    "var bool\t\t\t\t\t\tbLoggingGame;\t\t\t// Does this gametype log?",
                    "var string\t\t\t\t\t    LocalLogFileName;",
                    "var string\t\t\t\t\t    WorldLogFileName;",
                    "var class<StatLog>\t\t\t\tStatLogClass;",
                    "var globalconfig int DemoBuild;",
                    "var globalconfig int DemoHasTuts;"
                ]
            }
        },
        "GameReplicationInfo.uc": {
            "body": "//=============================================================================\n// GameReplicationInfo.\n//=============================================================================\nclass GameReplicationInfo extends ReplicationInfo\n\tnative nativereplication;\n\nvar string GameName;\t\t\t\t\t\t// Assigned by GameInfo.\nvar string GameClass;\t\t\t\t\t\t// Assigned by GameInfo.\nvar bool bTeamGame;\t\t\t\t\t\t\t// Assigned by GameInfo.\nvar bool bClassicDeathMessages;\nvar bool bStopCountDown;\nvar int  RemainingTime, ElapsedTime, RemainingMinute;\nvar float SecondCount;\n\nvar int NumPlayers;\nvar int SumFrags;\nvar float UpdateTimer;\n\nvar() globalconfig string ServerName;\t\t// Name of the server, i.e.: Bob's Server.\nvar() globalconfig string ShortName;\t\t// Abbreviated name of server, i.e.: B's Serv (stupid example)\nvar() globalconfig string AdminName;\t\t// Name of the server admin.\nvar() globalconfig string AdminEmail;\t\t// Email address of the server admin.\nvar() globalconfig int \t\t Region;\t\t// Region of the game server.\n\nvar() globalconfig string MOTDLine1;\t\t// Message\nvar() globalconfig string MOTDLine2;\t\t// Of\nvar() globalconfig string MOTDLine3;\t\t// The\nvar() globalconfig string MOTDLine4;\t\t// Day\n\nvar string GameEndedComments;\t\t\t\t// set by gameinfo when game ends\n\nvar PlayerReplicationInfo PRIArray[32];\n\nreplication\n{\n\t// DEUS_EX CNN - fixed to match the CPP optimized rep list in UnActor.cpp\n\treliable if ( Role == ROLE_Authority )\n\t\tGameName, GameClass, bTeamGame, ServerName, ShortName, AdminName,\n\t\tAdminEmail, Region, MOTDLine1, MOTDLine2, \n\t\tMOTDLine3, MOTDLine4, RemainingMinute, NumPlayers, bStopCountDown, GameEndedComments;\n\n\treliable if ( bNetInitial && (Role==ROLE_Authority) )\n\t\tRemainingTime, ElapsedTime;\n}\n\nsimulated function PostBeginPlay()\n{\n\tif( Level.NetMode == NM_Client )\n\t{\n\t\t// clear variables so we don't display our own values if the server has them left blank \n\t\tServerName = \"\";\n\t\tAdminName = \"\";\n\t\tAdminEmail = \"\";\n\t\tMOTDLine1 = \"\";\n\t\tMOTDLine2 = \"\";\n\t\tMOTDLine3 = \"\";\n\t\tMOTDLine4 = \"\";\n\t}\n\n\tSecondCount = Level.TimeSeconds;\n\tSetTimer(0.2, true);\n}\n\nsimulated function Timer()\n{\n\tlocal PlayerReplicationInfo PRI;\n\tlocal int i, FragAcc;\n\n\tif ( Level.NetMode == NM_Client )\n\t{\n\t\tif (Level.TimeSeconds - SecondCount >= Level.TimeDilation)\n\t\t{\n\t\t\tElapsedTime++;\n\t\t\tif ( RemainingMinute != 0 )\n\t\t\t{\n\t\t\t\tRemainingTime = RemainingMinute;\n\t\t\t\tRemainingMinute = 0;\n\t\t\t}\n\t\t\tif ( (RemainingTime > 0) && !bStopCountDown )\n\t\t\t\tRemainingTime--;\n\t\t\tSecondCount += Level.TimeDilation;\n\t\t}\n\t}\n\n\tfor (i=0; i<32; i++)\n\t\tPRIArray[i] = None;\n\ti=0;\n\tforeach AllActors(class'PlayerReplicationInfo', PRI)\n\t{\n\t\tPRIArray[i++] = PRI;\n\t}\n\n\t// Update various information.\n\tUpdateTimer = 0;\n\tfor (i=0; i<32; i++)\n\t\tif (PRIArray[i] != None)\n\t\t\tFragAcc += PRIArray[i].Score;\n\tSumFrags = FragAcc;\n\n\tif ( Level.Game != None )\n\t\tNumPlayers = Level.Game.NumPlayers;\n}\n\ndefaultproperties\n{\n     bStopCountDown=True\n     ServerName=\"Kaiser trying to make DXMP work\"\n     RemoteRole=ROLE_SimulatedProxy\n     NetUpdateFrequency=4.000000\n}\n",
            "name": "GameReplicationInfo.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bStopCountDown=True",
                    "ServerName=\"Kaiser trying to make DXMP work\"",
                    "RemoteRole=ROLE_SimulatedProxy",
                    "NetUpdateFrequency=4.000000"
                ],
                "exec": [],
                "extends": "ReplicationInfo",
                "functions": {
                    "PostBeginPlay": {
                        "body": "{\n\tif( Level.NetMode == NM_Client )\n\t{\n\t\t// clear variables so we don't display our own values if the server has them left blank \n\t\tServerName = \"\";\n\t\tAdminName = \"\";\n\t\tAdminEmail = \"\";\n\t\tMOTDLine1 = \"\";\n\t\tMOTDLine2 = \"\";\n\t\tMOTDLine3 = \"\";\n\t\tMOTDLine4 = \"\";\n\t}\n\n\tSecondCount = Level.TimeSeconds;\n\tSetTimer(0.2, true);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\n\tif ( Level.NetMode == NM_Client )\n\t{\n\t\tif (Level.TimeSeconds - SecondCount >= Level.TimeDilation)\n\t\t{\n\t\t\tElapsedTime++;\n\t\t\tif ( RemainingMinute != 0 )\n\t\t\t{\n\t\t\t\tRemainingTime = RemainingMinute;\n\t\t\t\tRemainingMinute = 0;\n\t\t\t}\n\t\t\tif ( (RemainingTime > 0) && !bStopCountDown )\n\t\t\t\tRemainingTime--;\n\t\t\tSecondCount += Level.TimeDilation;\n\t\t}\n\t}\n\n\tfor (i=0; i<32; i++)\n\t\tPRIArray[i] = None;\n\ti=0;\n\tforeach AllActors(class'PlayerReplicationInfo', PRI)\n\t{\n\t\tPRIArray[i++] = PRI;\n\t}\n\n\t// Update various information.\n\tUpdateTimer = 0;\n\tfor (i=0; i<32; i++)\n\t\tif (PRIArray[i] != None)\n\t\t\tFragAcc += PRIArray[i].Score;\n\tSumFrags = FragAcc;\n\n\tif ( Level.Game != None )\n\t\tNumPlayers = Level.Game.NumPlayers;\n}",
                        "locals": [
                            "local PlayerReplicationInfo PRI;",
                            "local int i, FragAcc;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 111,
                "replication": "",
                "states": [],
                "variables": [
                    "var string GameName;\t\t\t\t\t\t// Assigned by GameInfo.",
                    "var string GameClass;\t\t\t\t\t\t// Assigned by GameInfo.",
                    "var bool bTeamGame;\t\t\t\t\t\t\t// Assigned by GameInfo.",
                    "var bool bClassicDeathMessages;",
                    "var bool bStopCountDown;",
                    "var int  RemainingTime, ElapsedTime, RemainingMinute;",
                    "var float SecondCount;",
                    "var int NumPlayers;",
                    "var int SumFrags;",
                    "var float UpdateTimer;",
                    "var() globalconfig string ServerName;\t\t// Name of the server, i.e.: Bob's Server.",
                    "var() globalconfig string ShortName;\t\t// Abbreviated name of server, i.e.: B's Serv (stupid example)",
                    "var() globalconfig string AdminName;\t\t// Name of the server admin.",
                    "var() globalconfig string AdminEmail;\t\t// Email address of the server admin.",
                    "var() globalconfig int \t\t Region;\t\t// Region of the game server.",
                    "var() globalconfig string MOTDLine1;\t\t// Message",
                    "var() globalconfig string MOTDLine2;\t\t// Of",
                    "var() globalconfig string MOTDLine3;\t\t// The",
                    "var() globalconfig string MOTDLine4;\t\t// Day",
                    "var string GameEndedComments;\t\t\t\t// set by gameinfo when game ends",
                    "var PlayerReplicationInfo PRIArray[32];"
                ]
            }
        },
        "HUD.uc": {
            "body": "//=============================================================================\n// HUD: Superclass of the heads-up display.\n//=============================================================================\nclass HUD extends Actor\n\tabstract\n\tnative\n\tconfig(user);\n\n//=============================================================================\n// Variables.\n\nvar globalconfig int HudMode;\t\nvar globalconfig int Crosshair;\nvar() class<menu> MainMenuType;\nvar() string HUDConfigWindowType;\nvar color WhiteColor;\nvar\tMenu MainMenu;\nvar Mutator HUDMutator;\nvar PlayerPawn PlayerOwner; // always the actual owner\n\nstruct HUDLocalizedMessage\n{\n\tvar Class<LocalMessage> Message;\n\tvar int Switch;\n\tvar PlayerReplicationInfo RelatedPRI;\n\tvar Object OptionalObject;\n\tvar float EndOfLife;\n\tvar float LifeTime;\n\tvar bool bDrawing;\n\tvar int numLines;\n\tvar string StringMessage;\n\tvar color DrawColor;\n\tvar font StringFont;\n\tvar float XL, YL;\n\tvar float YPos;\n};\n\nfunction ClearMessage(out HUDLocalizedMessage M)\n{\n\tM.Message = None;\n\tM.Switch = 0;\n\tM.RelatedPRI = None;\n\tM.OptionalObject = None;\n\tM.EndOfLife = 0;\n\tM.StringMessage = \"\";\n\tM.DrawColor = WhiteColor;\n\tM.XL = 0;\n\tM.bDrawing = false;\n}\n\nfunction CopyMessage(out HUDLocalizedMessage M1, HUDLocalizedMessage M2)\n{\n\tM1.Message = M2.Message;\n\tM1.Switch = M2.Switch;\n\tM1.RelatedPRI = M2.RelatedPRI;\n\tM1.OptionalObject = M2.OptionalObject;\n\tM1.EndOfLife = M2.EndOfLife;\n\tM1.StringMessage = M2.StringMessage;\n\tM1.DrawColor = M2.DrawColor;\n\tM1.XL = M2.XL;\n\tM1.YL = M2.YL;\n\tM1.YPos = M2.YPos;\n\tM1.bDrawing = M2.bDrawing;\n\tM1.LifeTime = M2.LifeTime;\n\tM1.numLines = M2.numLines;\n}\n\n//=============================================================================\n// Status drawing.\n\nsimulated event PreRender( canvas Canvas );\nsimulated event PostRender( canvas Canvas );\nsimulated function InputNumber(byte F);\nsimulated function ChangeHud(int d);\nsimulated function ChangeCrosshair(int d);\nsimulated function DrawCrossHair( canvas Canvas, int StartX, int StartY);\n\n//=============================================================================\n// Messaging.\n\nsimulated function Message( PlayerReplicationInfo PRI, coerce string Msg, name N );\nsimulated function LocalizedMessage( class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject, optional string CriticalString );\n\nsimulated function PlayReceivedMessage( string S, string PName, ZoneInfo PZone )\n{\n\tPlayerPawn(Owner).ClientMessage(S);\n\tif (PlayerPawn(Owner).bMessageBeep)\n\t\tPlayerPawn(Owner).PlayBeepSound();\n}\n\n// DisplayMessages is called by the Console in PostRender.\n// It offers the HUD a chance to deal with messages instead of the\n// Console.  Returns true if messages were dealt with.\nsimulated function bool DisplayMessages(canvas Canvas)\n{\n\treturn false;\n}\n\ndefaultproperties\n{\n     HUDConfigWindowType=\"UMenu.UMenuHUDConfigCW\"\n     WhiteColor=(G=128,B=255)\n     bHidden=True\n     RemoteRole=ROLE_SimulatedProxy\n}\n",
            "name": "HUD.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "HUDConfigWindowType=\"UMenu.UMenuHUDConfigCW\"",
                    "WhiteColor=(G=128,B=255)",
                    "bHidden=True",
                    "RemoteRole=ROLE_SimulatedProxy"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "ChangeCrosshair": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ChangeCrosshair",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "d"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangeHud": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ChangeHud",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "d"
                            ]
                        ],
                        "return": ""
                    },
                    "ClearMessage": {
                        "body": "{\n\tM.Message = None;\n\tM.Switch = 0;\n\tM.RelatedPRI = None;\n\tM.OptionalObject = None;\n\tM.EndOfLife = 0;\n\tM.StringMessage = \"\";\n\tM.DrawColor = WhiteColor;\n\tM.XL = 0;\n\tM.bDrawing = false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClearMessage",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "HUDLocalizedMessage",
                                "M"
                            ]
                        ],
                        "return": ""
                    },
                    "CopyMessage": {
                        "body": "{\n\tM1.Message = M2.Message;\n\tM1.Switch = M2.Switch;\n\tM1.RelatedPRI = M2.RelatedPRI;\n\tM1.OptionalObject = M2.OptionalObject;\n\tM1.EndOfLife = M2.EndOfLife;\n\tM1.StringMessage = M2.StringMessage;\n\tM1.DrawColor = M2.DrawColor;\n\tM1.XL = M2.XL;\n\tM1.YL = M2.YL;\n\tM1.YPos = M2.YPos;\n\tM1.bDrawing = M2.bDrawing;\n\tM1.LifeTime = M2.LifeTime;\n\tM1.numLines = M2.numLines;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CopyMessage",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "HUDLocalizedMessage",
                                "M1"
                            ],
                            [
                                "HUDLocalizedMessage",
                                "M2"
                            ]
                        ],
                        "return": ""
                    },
                    "DisplayMessages": {
                        "body": "{\n\treturn false;\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DisplayMessages",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": "bool"
                    },
                    "DrawCrossHair": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DrawCrossHair",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ],
                            [
                                "int",
                                "StartX"
                            ],
                            [
                                "int",
                                "StartY"
                            ]
                        ],
                        "return": ""
                    },
                    "InputNumber": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "InputNumber",
                        "native": false,
                        "param": [
                            [
                                "byte",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "LocalizedMessage": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "LocalizedMessage",
                        "native": false,
                        "param": [
                            [
                                "class<LocalMessage>",
                                "Message"
                            ],
                            [
                                "optional",
                                "int",
                                "Switch"
                            ],
                            [
                                "optional",
                                "PlayerReplicationInfo",
                                "RelatedPRI_1"
                            ],
                            [
                                "optional",
                                "PlayerReplicationInfo",
                                "RelatedPRI_2"
                            ],
                            [
                                "optional",
                                "Object",
                                "OptionalObject"
                            ],
                            [
                                "optional",
                                "string",
                                "CriticalString"
                            ]
                        ],
                        "return": ""
                    },
                    "Message": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Message",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "PRI"
                            ],
                            [
                                "coerce",
                                "string",
                                "Msg"
                            ],
                            [
                                "name",
                                "N"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayReceivedMessage": {
                        "body": "{\n\tPlayerPawn(Owner).ClientMessage(S);\n\tif (PlayerPawn(Owner).bMessageBeep)\n\t\tPlayerPawn(Owner).PlayBeepSound();\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PlayReceivedMessage",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "S"
                            ],
                            [
                                "string",
                                "PName"
                            ],
                            [
                                "ZoneInfo",
                                "PZone"
                            ]
                        ],
                        "return": ""
                    },
                    "PostRender": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PostRender",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "PreRender": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PreRender",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 106,
                "replication": "",
                "states": [],
                "variables": [
                    "var globalconfig int HudMode;",
                    "var globalconfig int Crosshair;",
                    "var() class<menu> MainMenuType;",
                    "var() string HUDConfigWindowType;",
                    "var color WhiteColor;",
                    "var Mutator HUDMutator;",
                    "var PlayerPawn PlayerOwner; // always the actual owner",
                    "var Class<LocalMessage> Message;",
                    "var int Switch;",
                    "var PlayerReplicationInfo RelatedPRI;",
                    "var Object OptionalObject;",
                    "var float EndOfLife;",
                    "var float LifeTime;",
                    "var bool bDrawing;",
                    "var int numLines;",
                    "var string StringMessage;",
                    "var color DrawColor;",
                    "var font StringFont;",
                    "var float XL, YL;",
                    "var float YPos;"
                ]
            }
        },
        "HomeBase.uc": {
            "body": "//=============================================================================\n// HomeBase.\n//=============================================================================\nclass HomeBase extends NavigationPoint;\n\n#exec Texture Import File=Textures\\Flag1.pcx Name=S_Flag Mips=Off Flags=2\n\nvar() float extent; //how far the base extends from central point (in line of sight)\nvar\t vector lookdir; //direction to look while stopped\n\nfunction PreBeginPlay()\n{\n\tlookdir = 200 * vector(Rotation);\n\tSuper.PreBeginPlay();\n}\n\ndefaultproperties\n{\n     Extent=700.000000\n     Texture=Texture'Engine.S_Flag'\n     SoundVolume=128\n}\n",
            "name": "HomeBase.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Extent=700.000000",
                    "Texture=Texture'Engine.S_Flag'",
                    "SoundVolume=128"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Flag1.pcx Name=S_Flag Mips=Off Flags=2"
                ],
                "extends": "NavigationPoint",
                "functions": {
                    "PreBeginPlay": {
                        "body": "{\n\tlookdir = 200 * vector(Rotation);\n\tSuper.PreBeginPlay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 23,
                "replication": "",
                "states": [],
                "variables": [
                    "var() float extent; //how far the base extends from central point (in line of sight)"
                ]
            }
        },
        "Info.uc": {
            "body": "//=============================================================================\n// Info, the root of all information holding classes.\n//=============================================================================\nclass Info extends Actor\n\tabstract\n\tnative;\n\ndefaultproperties\n{\n     bHidden=True\n}\n",
            "name": "Info.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=True"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 12,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "InternetInfo.uc": {
            "body": "//=============================================================================\n// InternetInfo: Parent class for Internet connection classes\n//=============================================================================\nclass InternetInfo extends Info\n\tnative\n\ttransient;\n\nfunction string GetBeaconAddress( int i );\nfunction string GetBeaconText( int i );\n\ndefaultproperties\n{\n}\n",
            "name": "InternetInfo.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Info",
                "functions": {
                    "GetBeaconAddress": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetBeaconAddress",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "i"
                            ]
                        ],
                        "return": "string"
                    },
                    "GetBeaconText": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetBeaconText",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "i"
                            ]
                        ],
                        "return": "string"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 14,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "InterpolationPoint.uc": {
            "body": "//=============================================================================\n// InterpolationPoint.\n//=============================================================================\nclass InterpolationPoint extends Keypoint\n\tnative;\n\n// Sprite.\n#exec Texture Import File=Textures\\IntrpPnt.pcx Name=S_Interp Mips=Off Flags=2\n\n// Number in sequence sharing this tag.\nvar() int    Position;\nvar() float  RateModifier;\nvar() float  GameSpeedModifier;\nvar() float  FovModifier;\nvar() bool   bEndOfPath;\nvar() bool   bSkipNextPath;\nvar() float  ScreenFlashScale;\nvar() vector ScreenFlashFog;\n\n// Other points in this interpolation path.\nvar InterpolationPoint Prev, Next;\n\n//\n// At start of gameplay, link all matching interpolation points together.\n//\nfunction BeginPlay()\n{\n\tSuper.BeginPlay();\n\n\t// Try to find previous.\n\tforeach AllActors( class 'InterpolationPoint', Prev, Tag )\n\t\tif( Prev.Position == Position-1 )\n\t\t\tbreak;\n\tif( Prev != None )\n\t\tPrev.Next = Self;\n\n\t// Try to find next.\n\tforeach AllActors( class 'InterpolationPoint', Next, Tag )\n\t\tif( Next.Position == Position+1 )\n\t\t\tbreak;\n\tif( Next == None )\n\t\tforeach AllActors( class 'InterpolationPoint', Next, Tag )\n\t\t\tif( Next.Position == 0 )\n\t\t\t\tbreak;\n\tif( Next != None )\n\t\tNext.Prev = Self;\n}\n\n//\n// Verify that we're linked up.\n//\nfunction PostBeginPlay()\n{\n\tSuper.PostBeginPlay();\n\t//log( \"Interpolation point\" @ Tag @ Position $ \":\" );\n\t//if( Prev != None )\n\t//\tlog( \"   Prev # \" $ Prev.Position );\n\t//if( Next != None )\n\t//\tlog( \"   Next # \" $ Next.Position );\n}\n\n//\n// When reach an interpolation point.\n//\nfunction InterpolateEnd( actor Other )\n{\n\tif( bEndOfPath )\t\n\t{\n\t\tif( Pawn(Other)!=None && Pawn(Other).bIsPlayer )\n\t\t{\n\t\t\tOther.bCollideWorld = True;\n\t\t\tOther.bInterpolating = false;\n\t\t\tif ( Pawn(Other).Health > 0 )\n\t\t\t{\n\t\t\t\tOther.SetCollision(true,true,true);\n\t\t\t\tOther.SetPhysics(PHYS_Falling);\n\t\t\t\tOther.AmbientSound = None;\n\t\t\t\t// DEUS_EX CNN - removed by CNN - don't change the player state\n\t\t\t\t// the player will handle that itself\n//\t\t\t\tif ( Other.IsA('PlayerPawn') )\n//\t\t\t\t\tOther.GotoState('PlayerWalking');\n\t\t\t}\n\t\t}\n\t\telse if (Other != None)\n\t\t{\n\t\t\t// DEUS_EX - added by CNN - lets non players interpolate also\n\t\t\tOther.bInterpolating = False;\n\t\t\tOther.SetPhysics(PHYS_Falling);\n\t\t}\n\t}\n}\n\ndefaultproperties\n{\n     RateModifier=1.000000\n     GameSpeedModifier=1.000000\n     FovModifier=1.000000\n     ScreenFlashScale=1.000000\n     bStatic=False\n     bDirectional=True\n     Texture=Texture'Engine.S_Interp'\n}\n",
            "name": "InterpolationPoint.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "RateModifier=1.000000",
                    "GameSpeedModifier=1.000000",
                    "FovModifier=1.000000",
                    "ScreenFlashScale=1.000000",
                    "bStatic=False",
                    "bDirectional=True",
                    "Texture=Texture'Engine.S_Interp'"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\IntrpPnt.pcx Name=S_Interp Mips=Off Flags=2"
                ],
                "extends": "Keypoint",
                "functions": {
                    "BeginPlay": {
                        "body": "{\n\tSuper.BeginPlay();\n\n\t// Try to find previous.\n\tforeach AllActors( class 'InterpolationPoint', Prev, Tag )\n\t\tif( Prev.Position == Position-1 )\n\t\t\tbreak;\n\tif( Prev != None )\n\t\tPrev.Next = Self;\n\n\t// Try to find next.\n\tforeach AllActors( class 'InterpolationPoint', Next, Tag )\n\t\tif( Next.Position == Position+1 )\n\t\t\tbreak;\n\tif( Next == None )\n\t\tforeach AllActors( class 'InterpolationPoint', Next, Tag )\n\t\t\tif( Next.Position == 0 )\n\t\t\t\tbreak;\n\tif( Next != None )\n\t\tNext.Prev = Self;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "InterpolateEnd": {
                        "body": "{\n\tif( bEndOfPath )\t\n\t{\n\t\tif( Pawn(Other)!=None && Pawn(Other).bIsPlayer )\n\t\t{\n\t\t\tOther.bCollideWorld = True;\n\t\t\tOther.bInterpolating = false;\n\t\t\tif ( Pawn(Other).Health > 0 )\n\t\t\t{\n\t\t\t\tOther.SetCollision(true,true,true);\n\t\t\t\tOther.SetPhysics(PHYS_Falling);\n\t\t\t\tOther.AmbientSound = None;\n\t\t\t\t// DEUS_EX CNN - removed by CNN - don't change the player state\n\t\t\t\t// the player will handle that itself\n//\t\t\t\tif ( Other.IsA('PlayerPawn') )\n//\t\t\t\t\tOther.GotoState('PlayerWalking');\n\t\t\t}\n\t\t}\n\t\telse if (Other != None)\n\t\t{\n\t\t\t// DEUS_EX - added by CNN - lets non players interpolate also\n\t\t\tOther.bInterpolating = False;\n\t\t\tOther.SetPhysics(PHYS_Falling);\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "InterpolateEnd",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\tSuper.PostBeginPlay();\n\t//log( \"Interpolation point\" @ Tag @ Position $ \":\" );\n\t//if( Prev != None )\n\t//\tlog( \"   Prev # \" $ Prev.Position );\n\t//if( Next != None )\n\t//\tlog( \"   Next # \" $ Next.Position );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 103,
                "replication": "",
                "states": [],
                "variables": [
                    "var() int    Position;",
                    "var() float  RateModifier;",
                    "var() float  GameSpeedModifier;",
                    "var() float  FovModifier;",
                    "var() bool   bEndOfPath;",
                    "var() bool   bSkipNextPath;",
                    "var() float  ScreenFlashScale;",
                    "var() vector ScreenFlashFog;",
                    "var InterpolationPoint Prev, Next;"
                ]
            }
        },
        "Inventory.uc": {
            "body": "//=============================================================================\n// The inventory class, the parent class of all objects which can be\n// picked up and carried by actors.\n//=============================================================================\nclass Inventory extends Actor\n\tabstract\n\tnative\n\tnativereplication;\n\n#exec Texture Import File=Textures\\Inventry.pcx Name=S_Inventory Mips=Off Flags=2\n\n//-----------------------------------------------------------------------------\n// Information relevant to Active/Inactive state.\n\nvar() travel byte AutoSwitchPriority; // Autoswitch value, 0=never autoswitch.\nvar() byte        InventoryGroup;     // The weapon/inventory set, 1-9 (0=none).\nvar() bool        bActivatable;       // Whether item can be activated.\nvar() bool\t \t  bDisplayableInv;\t  // Item displayed in HUD.\nvar\ttravel bool   bActive;\t\t\t  // Whether item is currently activated.\nvar\t  bool\t\t  bSleepTouch;\t\t  // Set when item is touched when leaving sleep state.\nvar\t  bool\t\t  bHeldItem;\t\t  // Set once an item has left pickup state.\nvar\t  bool\t  bTossedOut;\t\t\t  // true if weapon was tossed out (so players can't cheat w/ weaponstay)\n\n//-----------------------------------------------------------------------------\n// Ambient glow related info.\n\nvar(Display) bool bAmbientGlow;\t\t  // Whether to glow or not.\n\n//-----------------------------------------------------------------------------\n// Information relevant to Pickup state.\n\nvar() bool\t\tbInstantRespawn;\t  // Can be tagged so this item respawns instantly.\nvar() bool\t\tbRotatingPickup;\t  // Rotates when in pickup state.\nvar() localized string PickupMessage; // Human readable description when picked up.\nvar() localized string ItemName;      // Human readable name of item\nvar() localized string ItemArticle;   // Human readable article (e.g. \"a\", \"an\")\nvar() float     RespawnTime;          // Respawn after this time, 0 for instant.\nvar name \t\tPlayerLastTouched;    // Player who last touched this item.\n\n//-----------------------------------------------------------------------------\n// Rendering information.\n\n// Player view rendering info.\nvar() vector      PlayerViewOffset;   // Offset from view center.\nvar() mesh        PlayerViewMesh;     // Mesh to render.\nvar() float       PlayerViewScale;    // Mesh scale.\nvar() float\t\t  BobDamping;\t\t  // how much to damp view bob\n\n// Pickup view rendering info.\nvar() mesh        PickupViewMesh;     // Mesh to render.\nvar() float       PickupViewScale;    // Mesh scale.\n\n// 3rd person mesh.\nvar() mesh        ThirdPersonMesh;    // Mesh to render.\nvar() float       ThirdPersonScale;   // Mesh scale.\n\n//-----------------------------------------------------------------------------\n// Status bar info.\n\nvar() texture     StatusIcon;         // Icon used with ammo/charge/power count.\n\n//-----------------------------------------------------------------------------\n// Armor related info.\n\nvar() name\t\t  ProtectionType1;\t  // Protects against DamageType (None if non-armor).\nvar() name\t\t  ProtectionType2;\t  // Secondary protection type (None if non-armor).\nvar() travel int  Charge;\t\t\t  // Amount of armor or charge if not an armor (charge in time*10).\nvar() int\t\t  ArmorAbsorption;\t  // Percent of damage item absorbs 0-100.\nvar() bool\t\t  bIsAnArmor;\t\t  // Item will protect player.\nvar() int\t\t  AbsorptionPriority; // Which items absorb damage first (higher=first).\nvar() inventory\t  NextArmor;\t\t  // Temporary list created by Armors to prioritize damage absorption.\n\n//-----------------------------------------------------------------------------\n// AI related info.\n\nvar() float\t\t  MaxDesireability;\t  // Maximum desireability this item will ever have.\nvar\t  InventorySpot MyMarker;\n\n//-----------------------------------------------------------------------------\n// 3rd person muzzleflash\n\nvar bool bSteadyFlash3rd;\nvar bool bFirstFrame;\nvar(MuzzleFlash) bool bMuzzleFlashParticles;\nvar(MuzzleFlash) bool bToggleSteadyFlash;\nvar bool\tbSteadyToggle;\nvar byte FlashCount, OldFlashCount;\nvar(MuzzleFlash) ERenderStyle MuzzleFlashStyle;\nvar(MuzzleFlash) mesh MuzzleFlashMesh;\nvar(MuzzleFlash) float MuzzleFlashScale;\nvar(MuzzleFlash) texture MuzzleFlashTexture;\n\n//-----------------------------------------------------------------------------\n// Sound assignments.\n\nvar() sound PickupSound, ActivateSound, DeActivateSound, RespawnSound;\n\n// DEUS_EX STM - added\nvar sound LandSound;\n\n//-----------------------------------------------------------------------------\n// HUD graphics.\n\nvar() texture Icon;\nvar() localized String M_Activated;\nvar() localized String M_Selected;\nvar() localized String M_Deactivated;\n\n//-----------------------------------------------------------------------------\n// Messaging\n\nvar() class<LocalMessage> PickupMessageClass;\nvar() class<LocalMessage> ItemMessageClass;\n\n//\n// DEUS_EX AJY - additions (from old DeusExPickup)\n//\nvar bool\t\t\t\t\tbCanUseObjectBelt; // Can this object be placed on the object belt?\nvar texture\t\t\t\t\tlargeIcon;         // Larger-than-usual icon for the inventory window\nvar int\t\t\t\t\t\tlargeIconWidth;    // Width of graphic in texture\nvar int\t\t\t\t\t\tlargeIconHeight;   // Height of graphic in texture\nvar int\t\t\t\t\t\tinvSlotsX;         // Number of horizontal inv. slots this item takes\nvar int\t\t\t\t\t\tinvSlotsY;         // Number of vertical inv. slots this item takes\nvar travel int\t\t\t\tinvPosX;           // X position on the inventory window\nvar travel int\t\t\t\tinvPosY;           // Y position on the inventory window\nvar travel bool\t\t\t\tbInObjectBelt;     // Is this object actually in the object belt?\nvar travel int\t\t\t\tbeltPos;           // Position on the object belt\nvar() localized String\t\tdescription;       // Description\nvar localized String\t\tbeltDescription;   // Description used on the object belt\n\n// Network replication.\nreplication\n{\n\t// Things the server should send to the client.\n\treliable if( Role==ROLE_Authority && bNetOwner )\n\t\tbIsAnArmor, Charge, bActivatable, bActive, PlayerViewOffset, PlayerViewMesh, PlayerViewScale, invPosX, invPosY, bInObjectBelt, beltPos;\n\tunreliable if( Role==ROLE_Authority )\n\t\tFlashCount, bSteadyFlash3rd, ThirdPersonMesh, ThirdPersonScale;\n}\n\nfunction PostBeginPlay()\n{\n   PickupMessageClass = None;\n\tif ( ItemName == \"\" )\n\t\tItemName = GetItemName(string(Class));\n\n\t// DEUS_EX CNN - scale since network passes vector components as ints\n\tPlayerViewOffset = Default.PlayerViewOffset * 100;\n\n\tSuper.PostBeginPlay();\n}\n\n// Draw first person view of inventory\nsimulated event RenderOverlays( canvas Canvas )\n{\n\tif ( Owner == None )\n\t\treturn;\n\tif ( (Level.NetMode == NM_Client) && (!Owner.IsA('PlayerPawn') || (PlayerPawn(Owner).Player == None)) )\n\t\treturn;\n\tSetLocation( Owner.Location + CalcDrawOffset() );\n\tSetRotation( Pawn(Owner).ViewRotation );\n\tCanvas.DrawActor(self, false);\n}\n\nfunction String GetHumanName()\n{\n\treturn ItemArticle@ItemName;\n}\n\n// overridable function to ask the inventory object to draw its StatusIcon\nsimulated function DrawStatusIconAt( canvas Canvas, int X, int Y, optional float Scale )\n{\n\tif( Scale == 0.0 )\n\t\tScale = 1.0;\n\tCanvas.SetPos( X, Y );\n\tCanvas.DrawIcon( StatusIcon, Scale );\n}\n\n//=============================================================================\n// AI inventory functions.\n\nevent float BotDesireability( pawn Bot )\n{\n\tlocal Inventory AlreadyHas;\n\tlocal float desire;\n\tlocal bool bChecked;\n\n\tdesire = MaxDesireability;\n\n\tif ( RespawnTime < 10 )\n\t{\n\t\tbChecked = true;\n\t\tAlreadyHas = Bot.FindInventoryType(class); \n\t\tif ( (AlreadyHas != None) \n\t\t\t&& (AlreadyHas.Charge >= Charge) )\n\t\t\t\treturn -1;\n\t}\n\n\tif( bIsAnArmor )\n\t{\n\t\tif ( !bChecked )\n\t\t\tAlreadyHas = Bot.FindInventoryType(class); \n\t\tif ( AlreadyHas != None )\n\t\t\tdesire *= (1 - AlreadyHas.Charge * AlreadyHas.ArmorAbsorption * 0.00003);\n\t\t\n\t\tdesire *= (Charge * 0.005);\n\t\tdesire *= (ArmorAbsorption * 0.01);\n\t\treturn desire;\n\t}\n\telse return desire;\n}\n\nfunction Weapon RecommendWeapon( out float rating, out int bUseAltMode )\n{\n\tif ( inventory != None )\n\t\treturn inventory.RecommendWeapon(rating, bUseAltMode);\n\telse\n\t{\n\t\trating = -1;\n\t\treturn None;\n\t}\n}\n\n//=============================================================================\n// Inventory travelling across servers.\n\n//\n// Called after a travelling inventory item has been accepted into a level.\n//\nevent TravelPreAccept()\n{\n\tSuper.TravelPreAccept();\n\tGiveTo( Pawn(Owner) );\n\tif( bActive )\n\t\tActivate();\n}\n\n//=============================================================================\n// General inventory functions.\n\n//\n// Called by engine when destroyed.\n//\nfunction Destroyed()\n{\n\tif (MyMarker != None )\n\t\tMyMarker.markedItem = None;\t\t\n\t// Remove from owner's inventory.\n\tif( Pawn(Owner)!=None )\n\t\tPawn(Owner).DeleteInventory( Self );\n}\n\n//\n// Compute offset for drawing.\n//\n// DEUS_EX STM - took out \"final\"\n//simulated final function vector CalcDrawOffset()\nsimulated function vector CalcDrawOffset()\n{\n\tlocal vector DrawOffset, WeaponBob;\n\tlocal Pawn PawnOwner;\n\n\tPawnOwner = Pawn(Owner);\n\tDrawOffset = ((0.9/PawnOwner.FOVAngle * PlayerViewOffset) >> PawnOwner.ViewRotation);\n\n\tif ( (Level.NetMode == NM_DedicatedServer) \n\t\t|| ((Level.NetMode == NM_ListenServer) && (Owner.RemoteRole == ROLE_AutonomousProxy)) )\n\t\tDrawOffset += (PawnOwner.BaseEyeHeight * vect(0,0,1));\n\telse\n\t{\t\n\t\tDrawOffset += (PawnOwner.EyeHeight * vect(0,0,1));\n\t\tWeaponBob = BobDamping * PawnOwner.WalkBob;\n\t\tWeaponBob.Z = (0.45 + 0.55 * BobDamping) * PawnOwner.WalkBob.Z;\n\t\tDrawOffset += WeaponBob;\n\t}\n\treturn DrawOffset;\n}\n\n//\n// Become a pickup.\n//\nfunction BecomePickup()\n{\n\tif ( Physics != PHYS_Falling )\n\t\tRemoteRole    = ROLE_SimulatedProxy;\n\tMesh          = PickupViewMesh;\n\tDrawScale     = PickupViewScale;\n\tbOnlyOwnerSee = false;\n\tbHidden       = false;\n\tbCarriedItem  = false;\n\tNetPriority   = 1.4;\n\tSetCollision( true, true, false );\t\t// make things block actors as well - DEUS_EX CNN\n}\n\n//\n// Become an inventory item.\n//\nfunction BecomeItem()\n{\n\tRemoteRole    = ROLE_SimulatedProxy;\n\tMesh          = PlayerViewMesh;\n\tDrawScale     = PlayerViewScale;\n\tbOnlyOwnerSee = true;\n\tbHidden       = true;\n\tbCarriedItem  = true;\n\tNetPriority   = 1.4;\n\tSetCollision( false, false, false );\n\tSetPhysics(PHYS_None);\n//\tSetTimer(0.0,False);\t// DEUS_EX CNN - removed\n\tAmbientGlow = 0;\n}\n\n//\n// Give this inventory item to a pawn.\n//\nfunction GiveTo( pawn Other )\n{\n\tInstigator = Other;\n\tBecomeItem();\n\tOther.AddInventory( Self );\n\tGotoState('Idle2');\n}\n\n// Either give this inventory to player Other, or spawn a copy\n// and give it to the player Other, setting up original to be respawned.\n//\nfunction inventory SpawnCopy( pawn Other )\n{\n\tlocal inventory Copy;\n\tif( Level.Game.ShouldRespawn(self) )\n\t{\n\t\tCopy = spawn(Class,Other,,,rot(0,0,0));\n\t\tCopy.Tag           = Tag;\n\t\tCopy.Event         = Event;\n\t\tGotoState('Sleeping');\n\t}\n\telse\n\t\tCopy = self;\n\n\tCopy.RespawnTime = 0.0;\n\tCopy.bHeldItem = true;\n\tCopy.GiveTo( Other );\n\treturn Copy;\n}\n\n//\n// Set up respawn waiting if desired.\n//\nfunction SetRespawn()\n{\n\tif( Level.Game.ShouldRespawn(self) )\n\t\tGotoState('Sleeping');\n\telse\n\t\tDestroy();\n}\n\n\n//\n// Toggle Activation of selected Item.\n// \nfunction Activate()\n{\n\tif( bActivatable )\n\t{\n\t\tif (Level.Game.LocalLog != None)\n\t\t\tLevel.Game.LocalLog.LogItemActivate(Self, Pawn(Owner));\n\t\tif (Level.Game.WorldLog != None)\n\t\t\tLevel.Game.WorldLog.LogItemActivate(Self, Pawn(Owner));\n\n\t\tif ( M_Activated != \"\" )\n\t\t\tPawn(Owner).ClientMessage(ItemName$M_Activated);\t\n\t\tGoToState('Activated');\n\t}\n}\n\n//\n// Function which lets existing items in a pawn's inventory\n// prevent the pawn from picking something up. Return true to abort pickup\n// or if item handles pickup, otherwise keep going through inventory list.\n//\nfunction bool HandlePickupQuery( inventory Item )\n{\n\tif ( Item.Class == Class )\n\t\treturn true;\n\tif ( Inventory == None )\n\t\treturn false;\n\n\treturn Inventory.HandlePickupQuery(Item);\n}\n\n//\n// Select first activatable item.\n//\nfunction Inventory SelectNext()\n{\n\tif ( bActivatable ) \n\t{\n\t\tif ( M_Selected != \"\" )\n\t\t\tPawn(Owner).ClientMessage(ItemName$M_Selected);\n\t\treturn self;\n\t}\n\tif ( Inventory != None )\n\t\treturn Inventory.SelectNext();\n\telse\n\t\treturn None;\n}\n\n//\n// Toss this item out.\n//\nfunction DropFrom(vector StartLocation)\n{\n\tif ( !SetLocation(StartLocation) )\n\t\treturn; \n\tRespawnTime = 0.0; //don't respawn\n\tSetPhysics(PHYS_Falling);\n\tRemoteRole = ROLE_DumbProxy;\n\tBecomePickup();\n\tNetPriority = 2.5;\n\tbCollideWorld = true;\n\tif ( Pawn(Owner) != None )\n\t\tPawn(Owner).DeleteInventory(self);\n\tInventory = None;\n\tGotoState('PickUp', 'Dropped');\n}\n\nfunction DropInventory()\n{\n}\n\n// DEUS_EX STM - added\nfunction PlayLandingSound()\n{\n\tif (LandSound != None)\n\t\tPlaySound(LandSound);\n}\n\n//=============================================================================\n// Capabilities: For feeding general info to bots.\n\n// For future use.\nfunction float InventoryCapsFloat( name Property, pawn Other, actor Test );\nfunction string InventoryCapsString( name Property, pawn Other, actor Test );\n\n//=============================================================================\n// Firing/using.\n\n// Fire functions which must be implemented in child classes.\nfunction Fire( float Value );\nfunction AltFire( float Value );\nfunction Use( pawn User );\n\n//=============================================================================\n// Weapon functions.\n\n//\n// Find a weapon in inventory that has an Inventory Group matching F.\n//\n\nfunction Weapon WeaponChange( byte F )\n{\n\tif( Inventory == None)\n\t\treturn None;\n\telse\n\t\treturn Inventory.WeaponChange( F );\n}\n\n//=============================================================================\n// Armor functions.\n\n//\n// Scan the player's inventory looking for items that reduce damage\n// to the player.  If Armor's protection type matches DamageType, then no damage is taken.\n// Returns the reduced damage.\n//\nfunction int ReduceDamage( int Damage, name DamageType, vector HitLocation )\n{\n\tlocal Inventory FirstArmor;\n\tlocal int ReducedAmount,ArmorDamage;\n\t\n\tif( Damage<0 )\n\t\treturn 0;\n\t\n\tReducedAmount = Damage;\n\tFirstArmor = PrioritizeArmor(Damage, DamageType, HitLocation);\n\twhile( (FirstArmor != None) && (ReducedAmount > 0) )\n\t{\n\t\tReducedAmount = FirstArmor.ArmorAbsorbDamage(ReducedAmount, DamageType, HitLocation);\n\t\tFirstArmor = FirstArmor.nextArmor;\n\t} \n\treturn ReducedAmount;\n}\n\n//\n// Return the best armor to use.\n//\nfunction inventory PrioritizeArmor( int Damage, name DamageType, vector HitLocation )\n{\n\tlocal Inventory FirstArmor, InsertAfter;\n\n\tif ( Inventory != None )\n\t\tFirstArmor = Inventory.PrioritizeArmor(Damage, DamageType, HitLocation);\n\telse\n\t\tFirstArmor = None;\n\n\tif ( bIsAnArmor)\n\t{\n\t\tif ( FirstArmor == None )\n\t\t{\n\t\t\tnextArmor = None;\n\t\t\treturn self;\n\t\t}\n\n\t\t// insert this armor into the prioritized armor list\n\t\tif ( FirstArmor.ArmorPriority(DamageType) < ArmorPriority(DamageType) )\n\t\t{\n\t\t\tnextArmor = FirstArmor;\n\t\t\treturn self;\n\t\t}\n\t\tInsertAfter = FirstArmor;\n\t\twhile ( (InsertAfter.nextArmor != None) \n\t\t\t&& (InsertAfter.nextArmor.ArmorPriority(DamageType) > ArmorPriority(DamageType)) )\n\t\t\tInsertAfter = InsertAfter.nextArmor;\n\n\t\tnextArmor = InsertAfter.nextArmor;\n\t\tInsertAfter.nextArmor = self;\n\t}\n\treturn FirstArmor;\n}\n\n//\n// Absorb damage.\n//\nfunction int ArmorAbsorbDamage(int Damage, name DamageType, vector HitLocation)\n{\n\tlocal int ArmorDamage;\n\n\tif ( DamageType != 'Drowned' )\n\t\tArmorImpactEffect(HitLocation);\n\tif( (DamageType!='None') && ((ProtectionType1==DamageType) || (ProtectionType2==DamageType)) )\n\t\treturn 0;\n\t\n\tif (DamageType=='Drowned') Return Damage;\n\t\n\tArmorDamage = (Damage * ArmorAbsorption) / 100;\n\tif( ArmorDamage >= Charge )\n\t{\n\t\tArmorDamage = Charge;\n\t\tDestroy();\n\t}\n\telse \n\t\tCharge -= ArmorDamage;\n\treturn (Damage - ArmorDamage);\n}\n\n//\n// Return armor value.\n//\nfunction int ArmorPriority(name DamageType)\n{\n\tif ( DamageType == 'Drowned' )\n\t\treturn 0;\n\tif( (DamageType!='None') \n\t\t&& ((ProtectionType1==DamageType) || (ProtectionType2==DamageType)) )\n\t\treturn 1000000;\n\n\treturn AbsorptionPriority;\n}\n\n//\n// This function is called by ArmorAbsorbDamage and displays a visual effect \n// for an impact on an armor.\n//\nfunction ArmorImpactEffect(vector HitLocation){ }\n\n//\n// Used to inform inventory when owner jumps.\n//\nfunction OwnerJumped()\n{\n\tif( Inventory != None )\n\t\tInventory.OwnerJumped();\n}\n\n//\n// Used to inform inventory when owner weapon changes.\n//\nfunction ChangedWeapon()\n{\n\tif( Inventory != None )\n\t\tInventory.ChangedWeapon();\n}\n\n// used to ask inventory if it needs to affect its owners display properties\nfunction SetOwnerDisplay()\n{\n\tif( Inventory != None )\n\t\tInventory.SetOwnerDisplay();\n}\n\n//=============================================================================\n// Pickup state: this inventory item is sitting on the ground.\n\nauto state Pickup\n{\n\tsingular function ZoneChange( ZoneInfo NewZone )\n\t{\n\t\tlocal float splashsize;\n\t\tlocal actor splash;\n\n\t\tif( NewZone.bWaterZone && !Region.Zone.bWaterZone ) \n\t\t{\n\t\t\tsplashSize = 0.000025 * Mass * (250 - 0.5 * Velocity.Z);\n\t\t\tif ( NewZone.EntrySound != None )\n\t\t\t\tPlaySound(NewZone.EntrySound, SLOT_Interact, splashSize);\n\t\t\tif ( NewZone.EntryActor != None )\n\t\t\t{\n\t\t\t\tsplash = Spawn(NewZone.EntryActor); \n\t\t\t\tif ( splash != None )\n\t\t\t\t\tsplash.DrawScale = 2 * splashSize;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Validate touch, and if valid trigger event.\n\tfunction bool ValidTouch( actor Other )\n\t{\n\t\tlocal Actor A;\n\n\t\tif( Other.bIsPawn && Pawn(Other).bIsPlayer && (Pawn(Other).Health > 0) && Level.Game.PickupQuery(Pawn(Other), self) )\n\t\t{\n\t\t\tif( Event != '' )\n\t\t\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\t\t\tA.Trigger( Other, Other.Instigator );\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\t\n\t// When touched by an actor.\n\t// Now, when frobbed by an actor - DEUS_EX CNN\n\tfunction Frob(Actor Other, Inventory frobWith)\n//\tfunction Touch( actor Other )\n\t{\n\t\t// If touched by a player pawn, let him pick this up.\n\t\tif( ValidTouch(Other) )\n\t\t{\n\t\t\tif (Level.Game.LocalLog != None)\n\t\t\t\tLevel.Game.LocalLog.LogPickup(Self, Pawn(Other));\n\t\t\tif (Level.Game.WorldLog != None)\n\t\t\t\tLevel.Game.WorldLog.LogPickup(Self, Pawn(Other));\n\t\t\tSpawnCopy(Pawn(Other));\n\t\t\tif ( PickupMessageClass == None )\n\t\t\t\t// DEUS_EX CNN - use the itemArticle and itemName\n//\t\t\t\tPawn(Other).ClientMessage(PickupMessage, 'Pickup');\n\t\t\t\tPawn(Other).ClientMessage(PickupMessage @ itemArticle @ itemName, 'Pickup');\n\t\t\telse\n\t\t\t\tPawn(Other).ReceiveLocalizedMessage( PickupMessageClass, 0, None, None, Self.Class );\n\t\t\tPlaySound (PickupSound);\t\t\n\t\t\tif ( Level.Game.Difficulty > 1 )\n\t\t\t\tOther.MakeNoise(0.1 * Level.Game.Difficulty);\n\t\t\tif ( Pawn(Other).MoveTarget == self )\n\t\t\t\tPawn(Other).MoveTimer = -1.0;\t\t\n\t\t}\n\t\telse if ( bTossedOut && (Other.Class == Class)\n\t\t\t\t&& Inventory(Other).bTossedOut )\n\t\t\t\tDestroy();\n\t}\n\n\t// Landed on ground.\n\tfunction Landed(Vector HitNormal)\n\t{\n\t\tlocal rotator newRot;\n\t\tnewRot = Rotation;\n\t\tnewRot.pitch = 0;\n\t\tSetRotation(newRot);\n\t\tPlayLandingSound();  // DEUS_EX STM - added\n//\t\tSetTimer(2.0, false);\t// DEUS_EX CNN - removed\n\t}\n\n\t// Make sure no pawn already touching (while touch was disabled in sleep).\n\tfunction CheckTouching()\n\t{\n\t\tlocal int i;\n\n\t\tbSleepTouch = false;\n\t\tfor ( i=0; i<4; i++ )\n\t\t\tif ( (Touching[i] != None) && Touching[i].IsA('Pawn') )\n\t\t\t\tTouch(Touching[i]);\n\t}\n\t// DEUS_EX CNN - removed this crap - we want items to stick around forever\n/*\n\tfunction Timer()\n\t{\n\t\tif ( RemoteRole != ROLE_SimulatedProxy )\n\t\t{\n\t\t\tNetPriority = 1.4;\n\t\t\tRemoteRole = ROLE_SimulatedProxy;\n\n\t\t\t// DEUS_EX STM - ick\n//\t\t\tif ( bHeldItem )\n//\t\t\t\tSetTimer(40.0, false);\n\n\t\t\tif ( bHeldItem )\n\t\t\t{\n\t\t\t\tif ( bTossedOut )\n\t\t\t\t\tSetTimer(15.0, false);\n\t\t\t\telse\n\t\t\t\t\tSetTimer(40.0, false);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// DEUS_EX CNN\n//\t\tif ( bHeldItem )\n//\t\t\tDestroy();\n\n\t\tif ( bHeldItem )\n\t\t{\n\t\t\tif (  (FRand() < 0.1) || !PlayerCanSeeMe() )\n\t\t\t\tDestroy();\n\t\t\telse\n\t\t\t\tSetTimer(3.0, true);\n\t\t}\n\t}\n*/\n\tfunction BeginState()\n\t{\n\t\tBecomePickup();\n\t\tbCollideWorld = true;\n\t\t// DEUS_EX CNN - removed\n//\t\tif ( bHeldItem )\n//\t\t\tSetTimer(30, false);\n//\t\telse if ( Level.bStartup )\n\t\tif ( Level.bStartup )\n\t\t\tbAlwaysRelevant = true;\n\n\t\t// Don't destroy it!  What were they thinking? - DEUS_EX CNN\n//\t\tif ( bHeldItem )\n//\t\t\tSetTimer(45, false);\n\t}\n\n\tfunction EndState()\n\t{\n\t\tbCollideWorld = false;\n\t\tbSleepTouch = false;\n\t}\n\nBegin:\n\tBecomePickup();\n\tif ( bRotatingPickup && (Physics != PHYS_Falling) )\n\t\tSetPhysics(PHYS_Rotating);\n\nDropped:\n\tif( bAmbientGlow )\n\t\tAmbientGlow=255;\n\tif( bSleepTouch )\n\t\tCheckTouching();\n}\n\n//=============================================================================\n// Active state: this inventory item is armed and ready to rock!\n\nstate Activated\n{\n\tfunction BeginState()\n\t{\n\t\tbActive = true;\n\t\tif ( Pawn(Owner).bIsPlayer && (ProtectionType1 != '') )\n\t\t\tPawn(Owner).ReducedDamageType = ProtectionType1;\n\t}\n\n\tfunction EndState()\n\t{\n\t\tbActive = false;\n\t\tif ( (Pawn(Owner) != None)\n\t\t\t&& Pawn(Owner).bIsPlayer && (ProtectionType1 != '') )\n\t\t\tPawn(Owner).ReducedDamageType = '';\n\t}\n\n\tfunction Activate()\n\t{\n\t\tif ( (Pawn(Owner) != None) && (M_Deactivated != \"\") )\n\t\t\tPawn(Owner).ClientMessage(ItemName$M_Deactivated);\t\n\t\tGoToState('DeActivated');\t\n\t}\n}\n\n//=============================================================================\n// Sleeping state: Sitting hidden waiting to respawn.\n\nState Sleeping\n{\n\tignores Touch;\n\n\tfunction BeginState()\n\t{\n\t\tBecomePickup();\n\t\tbHidden = true;\n\t}\n\tfunction EndState()\n\t{\n\t\tlocal int i;\n\n\t\tbSleepTouch = false;\n\t\tfor ( i=0; i<4; i++ )\n\t\t\tif ( (Touching[i] != None) && Touching[i].IsA('Pawn') )\n\t\t\t\tbSleepTouch = true;\n\t}\t\t\t\nBegin:\n\tSleep( ReSpawnTime );\n\tPlaySound( RespawnSound );\t\n\tSleep( Level.Game.PlaySpawnEffect(self) );\n\tGoToState( 'Pickup' );\n}\n\nfunction ActivateTranslator(bool bHint)\n{\n\tif( Inventory!=None )\n\t\tInventory.ActivateTranslator( bHint );\n}\n\n//\n// Null state.\n//\nState Idle2\n{\n}\n\n// ----------------------------------------------------------------------\n// UpdateInfo(()\n//\n// Updates the InformationWindow when an item is selected in the \n// inventory screen\n// \n// DEUS_EX AJY\n// ----------------------------------------------------------------------\n\nfunction bool UpdateInfo(Object winObject)\n{\n\treturn False;\n}\n\n// ----------------------------------------------------------------------\n// TestMPBeltSpot()\n// Returns true if the suggested belt location is ok for the object in mp.\n// ----------------------------------------------------------------------\n\nsimulated function bool TestMPBeltSpot(int BeltSpot)\n{\n   return ((BeltSpot <= 3) && (BeltSpot > 0));\n}\n\ndefaultproperties\n{\n     bDisplayableInv=True\n     bRotatingPickup=True\n     PickupMessage=\"Snagged an item\"\n     ItemArticle=\"a\"\n     PlayerViewScale=1.000000\n     BobDamping=0.960000\n     PickupViewScale=1.000000\n     ThirdPersonScale=1.000000\n     MaxDesireability=0.005000\n     bFirstFrame=True\n     bToggleSteadyFlash=True\n     M_Activated=\" activated\"\n     M_Selected=\" selected\"\n     M_Deactivated=\" deactivated\"\n     bCanUseObjectBelt=True\n     invSlotsX=1\n     invSlotsY=1\n     invPosX=-1\n     invPosY=-1\n     beltPos=-1\n     Description=\"Made by the ABC Widget ACME Corporation\"\n     bIsItemGoal=True\n     bTravel=True\n     Physics=PHYS_Falling\n     RemoteRole=ROLE_SimulatedProxy\n     DrawType=DT_Mesh\n     Texture=Texture'Engine.S_Inventory'\n     CollisionRadius=30.000000\n     CollisionHeight=30.000000\n     bCollideActors=True\n     bBlockActors=True\n     bFixedRotationDir=True\n     NetPriority=1.400000\n}\n",
            "name": "Inventory.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bDisplayableInv=True",
                    "bRotatingPickup=True",
                    "PickupMessage=\"Snagged an item\"",
                    "ItemArticle=\"a\"",
                    "PlayerViewScale=1.000000",
                    "BobDamping=0.960000",
                    "PickupViewScale=1.000000",
                    "ThirdPersonScale=1.000000",
                    "MaxDesireability=0.005000",
                    "bFirstFrame=True",
                    "bToggleSteadyFlash=True",
                    "M_Activated=\" activated\"",
                    "M_Selected=\" selected\"",
                    "M_Deactivated=\" deactivated\"",
                    "bCanUseObjectBelt=True",
                    "invSlotsX=1",
                    "invSlotsY=1",
                    "invPosX=-1",
                    "invPosY=-1",
                    "beltPos=-1",
                    "Description=\"Made by the ABC Widget ACME Corporation\"",
                    "bIsItemGoal=True",
                    "bTravel=True",
                    "Physics=PHYS_Falling",
                    "RemoteRole=ROLE_SimulatedProxy",
                    "DrawType=DT_Mesh",
                    "Texture=Texture'Engine.S_Inventory'",
                    "CollisionRadius=30.000000",
                    "CollisionHeight=30.000000",
                    "bCollideActors=True",
                    "bBlockActors=True",
                    "bFixedRotationDir=True",
                    "NetPriority=1.400000"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Inventry.pcx Name=S_Inventory Mips=Off Flags=2"
                ],
                "extends": "Actor",
                "functions": {
                    "Activate": {
                        "body": "{\n\t\tif ( (Pawn(Owner) != None) && (M_Deactivated != \"\") )\n\t\t\tPawn(Owner).ClientMessage(ItemName$M_Deactivated);\t\n\t\tGoToState('DeActivated');\t\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Activate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ActivateTranslator": {
                        "body": "{\n\tif( Inventory!=None )\n\t\tInventory.ActivateTranslator( bHint );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ActivateTranslator",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "bHint"
                            ]
                        ],
                        "return": ""
                    },
                    "AltFire": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AltFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Value"
                            ]
                        ],
                        "return": ""
                    },
                    "ArmorAbsorbDamage": {
                        "body": "{\n\n\tif ( DamageType != 'Drowned' )\n\t\tArmorImpactEffect(HitLocation);\n\tif( (DamageType!='None') && ((ProtectionType1==DamageType) || (ProtectionType2==DamageType)) )\n\t\treturn 0;\n\t\n\tif (DamageType=='Drowned') Return Damage;\n\t\n\tArmorDamage = (Damage * ArmorAbsorption) / 100;\n\tif( ArmorDamage >= Charge )\n\t{\n\t\tArmorDamage = Charge;\n\t\tDestroy();\n\t}\n\telse \n\t\tCharge -= ArmorDamage;\n\treturn (Damage - ArmorDamage);\n}",
                        "locals": [
                            "local int ArmorDamage;"
                        ],
                        "modifiers": [],
                        "name": "ArmorAbsorbDamage",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Damage"
                            ],
                            [
                                "name",
                                "DamageType"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ]
                        ],
                        "return": "int"
                    },
                    "ArmorPriority": {
                        "body": "{\n\tif ( DamageType == 'Drowned' )\n\t\treturn 0;\n\tif( (DamageType!='None') \n\t\t&& ((ProtectionType1==DamageType) || (ProtectionType2==DamageType)) )\n\t\treturn 1000000;\n\n\treturn AbsorptionPriority;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ArmorPriority",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "DamageType"
                            ]
                        ],
                        "return": "int"
                    },
                    "BecomeItem": {
                        "body": "{\n\tRemoteRole    = ROLE_SimulatedProxy;\n\tMesh          = PlayerViewMesh;\n\tDrawScale     = PlayerViewScale;\n\tbOnlyOwnerSee = true;\n\tbHidden       = true;\n\tbCarriedItem  = true;\n\tNetPriority   = 1.4;\n\tSetCollision( false, false, false );\n\tSetPhysics(PHYS_None);\n//\tSetTimer(0.0,False);\t// DEUS_EX CNN - removed\n\tAmbientGlow = 0;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BecomeItem",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BecomePickup": {
                        "body": "{\n\tif ( Physics != PHYS_Falling )\n\t\tRemoteRole    = ROLE_SimulatedProxy;\n\tMesh          = PickupViewMesh;\n\tDrawScale     = PickupViewScale;\n\tbOnlyOwnerSee = false;\n\tbHidden       = false;\n\tbCarriedItem  = false;\n\tNetPriority   = 1.4;\n\tSetCollision( true, true, false );\t\t// make things block actors as well - DEUS_EX CNN\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BecomePickup",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BeginState": {
                        "body": "{\n\t\tBecomePickup();\n\t\tbHidden = true;\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BotDesireability": {
                        "body": "{\n\n\tdesire = MaxDesireability;\n\n\tif ( RespawnTime < 10 )\n\t{\n\t\tbChecked = true;\n\t\tAlreadyHas = Bot.FindInventoryType(class); \n\t\tif ( (AlreadyHas != None) \n\t\t\t&& (AlreadyHas.Charge >= Charge) )\n\t\t\t\treturn -1;\n\t}\n\n\tif( bIsAnArmor )\n\t{\n\t\tif ( !bChecked )\n\t\t\tAlreadyHas = Bot.FindInventoryType(class); \n\t\tif ( AlreadyHas != None )\n\t\t\tdesire *= (1 - AlreadyHas.Charge * AlreadyHas.ArmorAbsorption * 0.00003);\n\t\t\n\t\tdesire *= (Charge * 0.005);\n\t\tdesire *= (ArmorAbsorption * 0.01);\n\t\treturn desire;\n\t}\n\telse return desire;\n}",
                        "locals": [
                            "local Inventory AlreadyHas;",
                            "local float desire;",
                            "local bool bChecked;"
                        ],
                        "modifiers": [],
                        "name": "BotDesireability",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Bot"
                            ]
                        ],
                        "return": "float"
                    },
                    "CalcDrawOffset": {
                        "body": "{\n\n\tPawnOwner = Pawn(Owner);\n\tDrawOffset = ((0.9/PawnOwner.FOVAngle * PlayerViewOffset) >> PawnOwner.ViewRotation);\n\n\tif ( (Level.NetMode == NM_DedicatedServer) \n\t\t|| ((Level.NetMode == NM_ListenServer) && (Owner.RemoteRole == ROLE_AutonomousProxy)) )\n\t\tDrawOffset += (PawnOwner.BaseEyeHeight * vect(0,0,1));\n\telse\n\t{\t\n\t\tDrawOffset += (PawnOwner.EyeHeight * vect(0,0,1));\n\t\tWeaponBob = BobDamping * PawnOwner.WalkBob;\n\t\tWeaponBob.Z = (0.45 + 0.55 * BobDamping) * PawnOwner.WalkBob.Z;\n\t\tDrawOffset += WeaponBob;\n\t}\n\treturn DrawOffset;\n}",
                        "locals": [
                            "local vector DrawOffset, WeaponBob;",
                            "local Pawn PawnOwner;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "CalcDrawOffset",
                        "native": false,
                        "param": [],
                        "return": "vector"
                    },
                    "ChangedWeapon": {
                        "body": "{\n\tif( Inventory != None )\n\t\tInventory.ChangedWeapon();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangedWeapon",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CheckTouching": {
                        "body": "{\n\n\t\tbSleepTouch = false;\n\t\tfor ( i=0; i<4; i++ )\n\t\t\tif ( (Touching[i] != None) && Touching[i].IsA('Pawn') )\n\t\t\t\tTouch(Touching[i]);\n\t}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "CheckTouching",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Destroyed": {
                        "body": "{\n\tif (MyMarker != None )\n\t\tMyMarker.markedItem = None;\t\t\n\t// Remove from owner's inventory.\n\tif( Pawn(Owner)!=None )\n\t\tPawn(Owner).DeleteInventory( Self );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Destroyed",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DrawStatusIconAt": {
                        "body": "{\n\tif( Scale == 0.0 )\n\t\tScale = 1.0;\n\tCanvas.SetPos( X, Y );\n\tCanvas.DrawIcon( StatusIcon, Scale );\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "DrawStatusIconAt",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ],
                            [
                                "int",
                                "X"
                            ],
                            [
                                "int",
                                "Y"
                            ],
                            [
                                "optional",
                                "float",
                                "Scale"
                            ]
                        ],
                        "return": ""
                    },
                    "DropFrom": {
                        "body": "{\n\tif ( !SetLocation(StartLocation) )\n\t\treturn; \n\tRespawnTime = 0.0; //don't respawn\n\tSetPhysics(PHYS_Falling);\n\tRemoteRole = ROLE_DumbProxy;\n\tBecomePickup();\n\tNetPriority = 2.5;\n\tbCollideWorld = true;\n\tif ( Pawn(Owner) != None )\n\t\tPawn(Owner).DeleteInventory(self);\n\tInventory = None;\n\tGotoState('PickUp', 'Dropped');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "DropFrom",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "StartLocation"
                            ]
                        ],
                        "return": ""
                    },
                    "DropInventory": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "DropInventory",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "EndState": {
                        "body": "{\n\n\t\tbSleepTouch = false;\n\t\tfor ( i=0; i<4; i++ )\n\t\t\tif ( (Touching[i] != None) && Touching[i].IsA('Pawn') )\n\t\t\t\tbSleepTouch = true;\n\t}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "EndState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Fire": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Fire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Value"
                            ]
                        ],
                        "return": ""
                    },
                    "Frob": {
                        "body": "//\tfunction Touch( actor Other )",
                        "locals": [],
                        "modifiers": [],
                        "name": "Frob",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ],
                            [
                                "Inventory",
                                "frobWith"
                            ]
                        ],
                        "return": ""
                    },
                    "GetHumanName": {
                        "body": "{\n\treturn ItemArticle@ItemName;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetHumanName",
                        "native": false,
                        "param": [],
                        "return": "String"
                    },
                    "GiveTo": {
                        "body": "{\n\tInstigator = Other;\n\tBecomeItem();\n\tOther.AddInventory( Self );\n\tGotoState('Idle2');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GiveTo",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "HandlePickupQuery": {
                        "body": "{\n\tif ( Item.Class == Class )\n\t\treturn true;\n\tif ( Inventory == None )\n\t\treturn false;\n\n\treturn Inventory.HandlePickupQuery(Item);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "HandlePickupQuery",
                        "native": false,
                        "param": [
                            [
                                "inventory",
                                "Item"
                            ]
                        ],
                        "return": "bool"
                    },
                    "InventoryCapsFloat": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "InventoryCapsFloat",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "Property"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "actor",
                                "Test"
                            ]
                        ],
                        "return": "float"
                    },
                    "InventoryCapsString": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "InventoryCapsString",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "Property"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "actor",
                                "Test"
                            ]
                        ],
                        "return": "string"
                    },
                    "Landed": {
                        "body": "{\n\t\tnewRot = Rotation;\n\t\tnewRot.pitch = 0;\n\t\tSetRotation(newRot);\n\t\tPlayLandingSound();  // DEUS_EX STM - added\n//\t\tSetTimer(2.0, false);\t// DEUS_EX CNN - removed\n\t}",
                        "locals": [
                            "local rotator newRot;"
                        ],
                        "modifiers": [],
                        "name": "Landed",
                        "native": false,
                        "param": [
                            [
                                "Vector",
                                "HitNormal"
                            ]
                        ],
                        "return": ""
                    },
                    "OwnerJumped": {
                        "body": "{\n\tif( Inventory != None )\n\t\tInventory.OwnerJumped();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "OwnerJumped",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayLandingSound": {
                        "body": "{\n\tif (LandSound != None)\n\t\tPlaySound(LandSound);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayLandingSound",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n   PickupMessageClass = None;\n\tif ( ItemName == \"\" )\n\t\tItemName = GetItemName(string(Class));\n\n\t// DEUS_EX CNN - scale since network passes vector components as ints\n\tPlayerViewOffset = Default.PlayerViewOffset * 100;\n\n\tSuper.PostBeginPlay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PrioritizeArmor": {
                        "body": "{\n\n\tif ( Inventory != None )\n\t\tFirstArmor = Inventory.PrioritizeArmor(Damage, DamageType, HitLocation);\n\telse\n\t\tFirstArmor = None;\n\n\tif ( bIsAnArmor)\n\t{\n\t\tif ( FirstArmor == None )\n\t\t{\n\t\t\tnextArmor = None;\n\t\t\treturn self;\n\t\t}\n\n\t\t// insert this armor into the prioritized armor list\n\t\tif ( FirstArmor.ArmorPriority(DamageType) < ArmorPriority(DamageType) )\n\t\t{\n\t\t\tnextArmor = FirstArmor;\n\t\t\treturn self;\n\t\t}\n\t\tInsertAfter = FirstArmor;\n\t\twhile ( (InsertAfter.nextArmor != None) \n\t\t\t&& (InsertAfter.nextArmor.ArmorPriority(DamageType) > ArmorPriority(DamageType)) )\n\t\t\tInsertAfter = InsertAfter.nextArmor;\n\n\t\tnextArmor = InsertAfter.nextArmor;\n\t\tInsertAfter.nextArmor = self;\n\t}\n\treturn FirstArmor;\n}",
                        "locals": [
                            "local Inventory FirstArmor, InsertAfter;"
                        ],
                        "modifiers": [],
                        "name": "PrioritizeArmor",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Damage"
                            ],
                            [
                                "name",
                                "DamageType"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ]
                        ],
                        "return": "inventory"
                    },
                    "RecommendWeapon": {
                        "body": "{\n\tif ( inventory != None )\n\t\treturn inventory.RecommendWeapon(rating, bUseAltMode);\n\telse\n\t{\n\t\trating = -1;\n\t\treturn None;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "RecommendWeapon",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "float",
                                "rating"
                            ],
                            [
                                "out",
                                "int",
                                "bUseAltMode"
                            ]
                        ],
                        "return": "Weapon"
                    },
                    "ReduceDamage": {
                        "body": "{\n\t\n\tif( Damage<0 )\n\t\treturn 0;\n\t\n\tReducedAmount = Damage;\n\tFirstArmor = PrioritizeArmor(Damage, DamageType, HitLocation);\n\twhile( (FirstArmor != None) && (ReducedAmount > 0) )\n\t{\n\t\tReducedAmount = FirstArmor.ArmorAbsorbDamage(ReducedAmount, DamageType, HitLocation);\n\t\tFirstArmor = FirstArmor.nextArmor;\n\t} \n\treturn ReducedAmount;\n}",
                        "locals": [
                            "local Inventory FirstArmor;",
                            "local int ReducedAmount,ArmorDamage;"
                        ],
                        "modifiers": [],
                        "name": "ReduceDamage",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Damage"
                            ],
                            [
                                "name",
                                "DamageType"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ]
                        ],
                        "return": "int"
                    },
                    "RenderOverlays": {
                        "body": "{\n\tif ( Owner == None )\n\t\treturn;\n\tif ( (Level.NetMode == NM_Client) && (!Owner.IsA('PlayerPawn') || (PlayerPawn(Owner).Player == None)) )\n\t\treturn;\n\tSetLocation( Owner.Location + CalcDrawOffset() );\n\tSetRotation( Pawn(Owner).ViewRotation );\n\tCanvas.DrawActor(self, false);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "RenderOverlays",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "SelectNext": {
                        "body": "{\n\tif ( bActivatable ) \n\t{\n\t\tif ( M_Selected != \"\" )\n\t\t\tPawn(Owner).ClientMessage(ItemName$M_Selected);\n\t\treturn self;\n\t}\n\tif ( Inventory != None )\n\t\treturn Inventory.SelectNext();\n\telse\n\t\treturn None;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SelectNext",
                        "native": false,
                        "param": [],
                        "return": "Inventory"
                    },
                    "SetOwnerDisplay": {
                        "body": "{\n\tif( Inventory != None )\n\t\tInventory.SetOwnerDisplay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetOwnerDisplay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetRespawn": {
                        "body": "{\n\tif( Level.Game.ShouldRespawn(self) )\n\t\tGotoState('Sleeping');\n\telse\n\t\tDestroy();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetRespawn",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpawnCopy": {
                        "body": "{\n\tif( Level.Game.ShouldRespawn(self) )\n\t{\n\t\tCopy = spawn(Class,Other,,,rot(0,0,0));\n\t\tCopy.Tag           = Tag;\n\t\tCopy.Event         = Event;\n\t\tGotoState('Sleeping');\n\t}\n\telse\n\t\tCopy = self;\n\n\tCopy.RespawnTime = 0.0;\n\tCopy.bHeldItem = true;\n\tCopy.GiveTo( Other );\n\treturn Copy;\n}",
                        "locals": [
                            "local inventory Copy;"
                        ],
                        "modifiers": [],
                        "name": "SpawnCopy",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": "inventory"
                    },
                    "TestMPBeltSpot": {
                        "body": "{\n   return ((BeltSpot <= 3) && (BeltSpot > 0));\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "TestMPBeltSpot",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "BeltSpot"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Timer": {
                        "body": "{\n\t\tif ( RemoteRole != ROLE_SimulatedProxy )\n\t\t{\n\t\t\tNetPriority = 1.4;\n\t\t\tRemoteRole = ROLE_SimulatedProxy;\n\n\t\t\t// DEUS_EX STM - ick\n//\t\t\tif ( bHeldItem )\n//\t\t\t\tSetTimer(40.0, false);\n\n\t\t\tif ( bHeldItem )\n\t\t\t{\n\t\t\t\tif ( bTossedOut )\n\t\t\t\t\tSetTimer(15.0, false);\n\t\t\t\telse\n\t\t\t\t\tSetTimer(40.0, false);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// DEUS_EX CNN\n//\t\tif ( bHeldItem )\n//\t\t\tDestroy();\n\n\t\tif ( bHeldItem )\n\t\t{\n\t\t\tif (  (FRand() < 0.1) || !PlayerCanSeeMe() )\n\t\t\t\tDestroy();\n\t\t\telse\n\t\t\t\tSetTimer(3.0, true);\n\t\t}\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TravelPreAccept": {
                        "body": "{\n\tSuper.TravelPreAccept();\n\tGiveTo( Pawn(Owner) );\n\tif( bActive )\n\t\tActivate();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TravelPreAccept",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "UpdateInfo": {
                        "body": "{\n\treturn False;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateInfo",
                        "native": false,
                        "param": [
                            [
                                "Object",
                                "winObject"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Use": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Use",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "User"
                            ]
                        ],
                        "return": ""
                    },
                    "ValidTouch": {
                        "body": "{\n\n\t\tif( Other.bIsPawn && Pawn(Other).bIsPlayer && (Pawn(Other).Health > 0) && Level.Game.PickupQuery(Pawn(Other), self) )\n\t\t{\n\t\t\tif( Event != '' )\n\t\t\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\t\t\tA.Trigger( Other, Other.Instigator );\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}",
                        "locals": [
                            "local Actor A;"
                        ],
                        "modifiers": [],
                        "name": "ValidTouch",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": "bool"
                    },
                    "WeaponChange": {
                        "body": "{\n\tif( Inventory == None)\n\t\treturn None;\n\telse\n\t\treturn Inventory.WeaponChange( F );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "WeaponChange",
                        "native": false,
                        "param": [
                            [
                                "byte",
                                "F"
                            ]
                        ],
                        "return": "Weapon"
                    },
                    "ZoneChange": {
                        "body": "{\n\n\t\tif( NewZone.bWaterZone && !Region.Zone.bWaterZone ) \n\t\t{\n\t\t\tsplashSize = 0.000025 * Mass * (250 - 0.5 * Velocity.Z);\n\t\t\tif ( NewZone.EntrySound != None )\n\t\t\t\tPlaySound(NewZone.EntrySound, SLOT_Interact, splashSize);\n\t\t\tif ( NewZone.EntryActor != None )\n\t\t\t{\n\t\t\t\tsplash = Spawn(NewZone.EntryActor); \n\t\t\t\tif ( splash != None )\n\t\t\t\t\tsplash.DrawScale = 2 * splashSize;\n\t\t\t}\n\t\t}\n\t}",
                        "locals": [
                            "local float splashsize;",
                            "local actor splash;"
                        ],
                        "modifiers": [
                            "singular"
                        ],
                        "name": "ZoneChange",
                        "native": false,
                        "param": [
                            [
                                "ZoneInfo",
                                "NewZone"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 890,
                "replication": "",
                "states": [],
                "variables": [
                    "var() travel byte AutoSwitchPriority; // Autoswitch value, 0=never autoswitch.",
                    "var() byte        InventoryGroup;     // The weapon/inventory set, 1-9 (0=none).",
                    "var() bool        bActivatable;       // Whether item can be activated.",
                    "var() bool\t \t  bDisplayableInv;\t  // Item displayed in HUD.",
                    "var(Display) bool bAmbientGlow;\t\t  // Whether to glow or not.",
                    "var() bool\t\tbInstantRespawn;\t  // Can be tagged so this item respawns instantly.",
                    "var() bool\t\tbRotatingPickup;\t  // Rotates when in pickup state.",
                    "var() localized string PickupMessage; // Human readable description when picked up.",
                    "var() localized string ItemName;      // Human readable name of item",
                    "var() localized string ItemArticle;   // Human readable article (e.g. \"a\", \"an\")",
                    "var() float     RespawnTime;          // Respawn after this time, 0 for instant.",
                    "var name \t\tPlayerLastTouched;    // Player who last touched this item.",
                    "var() vector      PlayerViewOffset;   // Offset from view center.",
                    "var() mesh        PlayerViewMesh;     // Mesh to render.",
                    "var() float       PlayerViewScale;    // Mesh scale.",
                    "var() float\t\t  BobDamping;\t\t  // how much to damp view bob",
                    "var() mesh        PickupViewMesh;     // Mesh to render.",
                    "var() float       PickupViewScale;    // Mesh scale.",
                    "var() mesh        ThirdPersonMesh;    // Mesh to render.",
                    "var() float       ThirdPersonScale;   // Mesh scale.",
                    "var() texture     StatusIcon;         // Icon used with ammo/charge/power count.",
                    "var() name\t\t  ProtectionType1;\t  // Protects against DamageType (None if non-armor).",
                    "var() name\t\t  ProtectionType2;\t  // Secondary protection type (None if non-armor).",
                    "var() travel int  Charge;\t\t\t  // Amount of armor or charge if not an armor (charge in time*10).",
                    "var() int\t\t  ArmorAbsorption;\t  // Percent of damage item absorbs 0-100.",
                    "var() bool\t\t  bIsAnArmor;\t\t  // Item will protect player.",
                    "var() int\t\t  AbsorptionPriority; // Which items absorb damage first (higher=first).",
                    "var() inventory\t  NextArmor;\t\t  // Temporary list created by Armors to prioritize damage absorption.",
                    "var() float\t\t  MaxDesireability;\t  // Maximum desireability this item will ever have.",
                    "var bool bSteadyFlash3rd;",
                    "var bool bFirstFrame;",
                    "var(MuzzleFlash) bool bMuzzleFlashParticles;",
                    "var(MuzzleFlash) bool bToggleSteadyFlash;",
                    "var bool\tbSteadyToggle;",
                    "var byte FlashCount, OldFlashCount;",
                    "var(MuzzleFlash) ERenderStyle MuzzleFlashStyle;",
                    "var(MuzzleFlash) mesh MuzzleFlashMesh;",
                    "var(MuzzleFlash) float MuzzleFlashScale;",
                    "var(MuzzleFlash) texture MuzzleFlashTexture;",
                    "var() sound PickupSound, ActivateSound, DeActivateSound, RespawnSound;",
                    "var sound LandSound;",
                    "var() texture Icon;",
                    "var() localized String M_Activated;",
                    "var() localized String M_Selected;",
                    "var() localized String M_Deactivated;",
                    "var() class<LocalMessage> PickupMessageClass;",
                    "var() class<LocalMessage> ItemMessageClass;",
                    "var bool\t\t\t\t\tbCanUseObjectBelt; // Can this object be placed on the object belt?",
                    "var texture\t\t\t\t\tlargeIcon;         // Larger-than-usual icon for the inventory window",
                    "var int\t\t\t\t\t\tlargeIconWidth;    // Width of graphic in texture",
                    "var int\t\t\t\t\t\tlargeIconHeight;   // Height of graphic in texture",
                    "var int\t\t\t\t\t\tinvSlotsX;         // Number of horizontal inv. slots this item takes",
                    "var int\t\t\t\t\t\tinvSlotsY;         // Number of vertical inv. slots this item takes",
                    "var travel int\t\t\t\tinvPosX;           // X position on the inventory window",
                    "var travel int\t\t\t\tinvPosY;           // Y position on the inventory window",
                    "var travel bool\t\t\t\tbInObjectBelt;     // Is this object actually in the object belt?",
                    "var travel int\t\t\t\tbeltPos;           // Position on the object belt",
                    "var() localized String\t\tdescription;       // Description",
                    "var localized String\t\tbeltDescription;   // Description used on the object belt"
                ]
            }
        },
        "InventorySpot.uc": {
            "body": "//=============================================================================\n// InventorySpot.\n//=============================================================================\nclass InventorySpot extends NavigationPoint\n\tnative;\n\nvar Inventory markedItem;\n\ndefaultproperties\n{\n     bEndPointOnly=True\n     bCollideWhenPlacing=False\n     bHiddenEd=True\n     CollisionRadius=20.000000\n     CollisionHeight=40.000000\n}\n",
            "name": "InventorySpot.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bEndPointOnly=True",
                    "bCollideWhenPlacing=False",
                    "bHiddenEd=True",
                    "CollisionRadius=20.000000",
                    "CollisionHeight=40.000000"
                ],
                "exec": [],
                "extends": "NavigationPoint",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 17,
                "replication": "",
                "states": [],
                "variables": [
                    "var Inventory markedItem;"
                ]
            }
        },
        "Keypoint.uc": {
            "body": "//=============================================================================\n// Keypoint, the base class of invisible actors which mark things.\n//=============================================================================\nclass Keypoint extends Actor\n\tabstract\n\tnative;\n\n// Sprite.\n#exec Texture Import File=Textures\\Keypoint.pcx Name=S_Keypoint Mips=Off Flags=2\n\ndefaultproperties\n{\n     bStatic=True\n     bHidden=True\n     Texture=Texture'Engine.S_Keypoint'\n     SoundVolume=0\n     CollisionRadius=10.000000\n     CollisionHeight=10.000000\n}\n",
            "name": "Keypoint.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bStatic=True",
                    "bHidden=True",
                    "Texture=Texture'Engine.S_Keypoint'",
                    "SoundVolume=0",
                    "CollisionRadius=10.000000",
                    "CollisionHeight=10.000000"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Keypoint.pcx Name=S_Keypoint Mips=Off Flags=2"
                ],
                "extends": "Actor",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 20,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "LevelInfo.uc": {
            "body": "//=============================================================================\n// LevelInfo contains information about the current level. There should \n// be one per level and it should be actor 0. UnrealEd creates each level's \n// LevelInfo automatically so you should never have to place one\n// manually.\n//\n// The ZoneInfo properties in the LevelInfo are used to define\n// the properties of all zones which don't themselves have ZoneInfo.\n//=============================================================================\nclass LevelInfo extends ZoneInfo\n\tnative;\n\n// Textures.\n#exec Texture Import File=Textures\\DefaultTexture.pcx\n\n//-----------------------------------------------------------------------------\n// Level time.\n\n// Time passage.\nvar() float TimeDilation;          // Normally 1 - scales real time passage.\n\n// Current time.\nvar           float\tTimeSeconds;   // Time in seconds since level began play.\nvar transient int   Year;          // Year.\nvar transient int   Month;         // Month.\nvar transient int   Day;           // Day of month.\nvar transient int   DayOfWeek;     // Day of week.\nvar transient int   Hour;          // Hour.\nvar transient int   Minute;        // Minute.\nvar transient int   Second;        // Second.\nvar transient int   Millisecond;   // Millisecond.\n\n//-----------------------------------------------------------------------------\n// Text info about level.\n\nvar() localized string Title;\nvar()           string Author;\t\t    // Who built it.\nvar() localized string IdealPlayerCount;// Ideal number of players for this level. I.E.: 6-8\nvar() int\tRecommendedEnemies;\t\t\t// number of enemy bots recommended (used by rated games)\nvar() int\tRecommendedTeammates;\t\t// number of friendly bots recommended (used by rated games)\nvar() localized string LevelEnterText;  // Message to tell players when they enter.\nvar()           string LocalizedPkg;    // Package to look in for localizations.\nvar             string Pauser;          // If paused, name of person pausing the game.\nvar levelsummary Summary;\n\n//-----------------------------------------------------------------------------\n// Flags affecting the level.\n\nvar() bool           bLonePlayer;     // No multiplayer coordination, i.e. for entranceways.\nvar bool             bBegunPlay;      // Whether gameplay has begun.\nvar bool             bPlayersOnly;    // Only update players.\nvar bool             bHighDetailMode; // Client high-detail mode.\nvar bool\t\t\t bDropDetail;\t  // frame rate is below DesiredFrameRate, so drop high detail actors\nvar bool\t\t\t bAggressiveLOD;  // frame rate is well below DesiredFrameRate, so make LOD more aggressive\nvar bool             bStartup;        // Starting gameplay.\nvar() bool\t\t\t bHumansOnly;\t  // Only allow \"human\" player pawns in this level\nvar bool\t\t\t bNoCheating;\t  \nvar bool\t\t\t bAllowFOV;\n\n//-----------------------------------------------------------------------------\n// Audio properties.\n\nvar(Audio) const music  Song;          // Default song for level.\nvar(Audio) const byte   SongSection;   // Default song order for level.\nvar(Audio) const byte   CdTrack;       // Default CD track for level.\nvar(Audio) float        PlayerDoppler; // Player doppler shift, 0=none, 1=full.\n\n//-----------------------------------------------------------------------------\n// Miscellaneous information.\n\nvar() float Brightness;\nvar() texture Screenshot;\nvar texture DefaultTexture;\nvar int HubStackLevel;\nvar transient enum ELevelAction\n{\n\tLEVACT_None,\n\tLEVACT_Loading,\n\tLEVACT_Saving,\n\tLEVACT_Connecting,\n\tLEVACT_Precaching\n} LevelAction;\n\n//-----------------------------------------------------------------------------\n// Renderer Management.\nvar() bool bNeverPrecache;\n\n//-----------------------------------------------------------------------------\n// Networking.\n\nvar enum ENetMode\n{\n\tNM_Standalone,        // Standalone game.\n\tNM_DedicatedServer,   // Dedicated server, no local client.\n\tNM_ListenServer,      // Listen server.\n\tNM_Client             // Client only, no local server.\n} NetMode;\nvar string ComputerName;  // Machine's name according to the OS.\nvar string EngineVersion; // Engine version.\nvar string MinNetVersion; // Min engine version that is net compatible.\n\n//-----------------------------------------------------------------------------\n// Gameplay rules\n\nvar() class<gameinfo> DefaultGameType;\nvar GameInfo Game;\n\n//-----------------------------------------------------------------------------\n// Navigation point and Pawn lists (chained using nextNavigationPoint and nextPawn).\n\nvar const NavigationPoint NavigationPointList;\nvar const Pawn PawnList;\n\n// DEUS_EX STM\nvar const EventManager EventManager;\n\n//-----------------------------------------------------------------------------\n// Server related.\n\nvar string NextURL;\nvar bool bNextItems;\nvar float NextSwitchCountdown;\n\n//-----------------------------------------------------------------------------\n// Actor Performance Management\n\nvar int AIProfile[8]; // TEMP statistics\nvar float AvgAITime;\t//moving average of Actor time\n\n//-----------------------------------------------------------------------------\n// Physics control\n\nvar() bool bCheckWalkSurfaces; // enable texture-specific physics code for Pawns.\n\n//-----------------------------------------------------------------------------\n// Spawn notification list\nvar SpawnNotify SpawnNotify;\n\n//-----------------------------------------------------------------------------\n// Functions.\n\n//\n// Return the URL of this level on the local machine.\n//\nnative simulated function string GetLocalURL();\n\n//\n// Return the URL of this level, which may possibly\n// exist on a remote machine.\n//\nnative simulated function string GetAddressURL();\n\n//\n// Jump the server to a new level.\n//\nevent ServerTravel( string URL, bool bItems )\n{\n   if (NetMode == NM_Standalone)\n      return;\n\tif( NextURL==\"\" )\n\t{\n\t\tbNextItems          = bItems;\n\t\tNextURL             = URL;\n\t\tif( Game!=None )\n\t\t\tGame.ProcessServerTravel( URL, bItems );\n\t\telse\n\t\t\tNextSwitchCountdown = 0;\n\t}\n}\n\n// DEUS_EX STM\n//\n// Initialize the event manager.\n//\nnative(650) final function InitEventManager();\nfunction PreBeginPlay()\n{\n\tSuper.PreBeginPlay();\n\tInitEventManager();\n}\n\n//-----------------------------------------------------------------------------\n// Network replication.\n\nreplication\n{\n\treliable if( Role==ROLE_Authority )\n\t\tPauser, TimeDilation, bNoCheating, bAllowFOV;\n}\n\ndefaultproperties\n{\n     TimeDilation=1.000000\n     Title=\"Untitled\"\n     bHighDetailMode=True\n     CdTrack=255\n     Brightness=1.000000\n     DefaultTexture=Texture'Engine.DefaultTexture'\n     bHiddenEd=True\n}\n",
            "name": "LevelInfo.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "TimeDilation=1.000000",
                    "Title=\"Untitled\"",
                    "bHighDetailMode=True",
                    "CdTrack=255",
                    "Brightness=1.000000",
                    "DefaultTexture=Texture'Engine.DefaultTexture'",
                    "bHiddenEd=True"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\DefaultTexture.pcx"
                ],
                "extends": "ZoneInfo",
                "functions": {
                    "GetAddressURL": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "GetAddressURL",
                        "native": true,
                        "param": [],
                        "return": "string"
                    },
                    "GetLocalURL": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "GetLocalURL",
                        "native": true,
                        "param": [],
                        "return": "string"
                    },
                    "InitEventManager": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "InitEventManager",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tSuper.PreBeginPlay();\n\tInitEventManager();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ServerTravel": {
                        "body": "{\n   if (NetMode == NM_Standalone)\n      return;\n\tif( NextURL==\"\" )\n\t{\n\t\tbNextItems          = bItems;\n\t\tNextURL             = URL;\n\t\tif( Game!=None )\n\t\t\tGame.ProcessServerTravel( URL, bItems );\n\t\telse\n\t\t\tNextSwitchCountdown = 0;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ServerTravel",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "URL"
                            ],
                            [
                                "bool",
                                "bItems"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 201,
                "replication": "",
                "states": [],
                "variables": [
                    "var() float TimeDilation;          // Normally 1 - scales real time passage.",
                    "var           float\tTimeSeconds;   // Time in seconds since level began play.",
                    "var transient int   Year;          // Year.",
                    "var transient int   Month;         // Month.",
                    "var transient int   Day;           // Day of month.",
                    "var transient int   DayOfWeek;     // Day of week.",
                    "var transient int   Hour;          // Hour.",
                    "var transient int   Minute;        // Minute.",
                    "var transient int   Second;        // Second.",
                    "var transient int   Millisecond;   // Millisecond.",
                    "var() localized string Title;",
                    "var()           string Author;\t\t    // Who built it.",
                    "var() localized string IdealPlayerCount;// Ideal number of players for this level. I.E.: 6-8",
                    "var() int\tRecommendedEnemies;\t\t\t// number of enemy bots recommended (used by rated games)",
                    "var() int\tRecommendedTeammates;\t\t// number of friendly bots recommended (used by rated games)",
                    "var() localized string LevelEnterText;  // Message to tell players when they enter.",
                    "var()           string LocalizedPkg;    // Package to look in for localizations.",
                    "var             string Pauser;          // If paused, name of person pausing the game.",
                    "var levelsummary Summary;",
                    "var() bool           bLonePlayer;     // No multiplayer coordination, i.e. for entranceways.",
                    "var bool             bBegunPlay;      // Whether gameplay has begun.",
                    "var bool             bPlayersOnly;    // Only update players.",
                    "var bool             bHighDetailMode; // Client high-detail mode.",
                    "var bool\t\t\t bDropDetail;\t  // frame rate is below DesiredFrameRate, so drop high detail actors",
                    "var bool\t\t\t bAggressiveLOD;  // frame rate is well below DesiredFrameRate, so make LOD more aggressive",
                    "var bool             bStartup;        // Starting gameplay.",
                    "var() bool\t\t\t bHumansOnly;\t  // Only allow \"human\" player pawns in this level",
                    "var bool\t\t\t bNoCheating;",
                    "var bool\t\t\t bAllowFOV;",
                    "var(Audio) const music  Song;          // Default song for level.",
                    "var(Audio) const byte   SongSection;   // Default song order for level.",
                    "var(Audio) const byte   CdTrack;       // Default CD track for level.",
                    "var(Audio) float        PlayerDoppler; // Player doppler shift, 0=none, 1=full.",
                    "var() float Brightness;",
                    "var() texture Screenshot;",
                    "var texture DefaultTexture;",
                    "var int HubStackLevel;",
                    "var transient enum ELevelAction",
                    "var() bool bNeverPrecache;",
                    "var enum ENetMode",
                    "var string ComputerName;  // Machine's name according to the OS.",
                    "var string EngineVersion; // Engine version.",
                    "var string MinNetVersion; // Min engine version that is net compatible.",
                    "var() class<gameinfo> DefaultGameType;",
                    "var GameInfo Game;",
                    "var const NavigationPoint NavigationPointList;",
                    "var const Pawn PawnList;",
                    "var const EventManager EventManager;",
                    "var string NextURL;",
                    "var bool bNextItems;",
                    "var float NextSwitchCountdown;",
                    "var int AIProfile[8]; // TEMP statistics",
                    "var float AvgAITime;\t//moving average of Actor time",
                    "var() bool bCheckWalkSurfaces; // enable texture-specific physics code for Pawns.",
                    "var SpawnNotify SpawnNotify;"
                ]
            }
        },
        "LevelSummary.uc": {
            "body": "//=============================================================================\n// LevelSummary contains the summary properties from the LevelInfo actor.\n// Designed for fast loading.\n//=============================================================================\nclass LevelSummary extends Object\n\tnative;\n\n//-----------------------------------------------------------------------------\n// Properties.\n\n// From LevelInfo.\nvar() localized string Title;\nvar()           string Author;\nvar() localized string IdealPlayerCount;\nvar() int\tRecommendedEnemies;\nvar() int\tRecommendedTeammates;\nvar() localized string LevelEnterText;\n\ndefaultproperties\n{\n}\n",
            "name": "LevelSummary.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Object",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 22,
                "replication": "",
                "states": [],
                "variables": [
                    "var() localized string Title;",
                    "var()           string Author;",
                    "var() localized string IdealPlayerCount;",
                    "var() int\tRecommendedEnemies;",
                    "var() int\tRecommendedTeammates;",
                    "var() localized string LevelEnterText;"
                ]
            }
        },
        "LiftCenter.uc": {
            "body": "//=============================================================================\n// LiftCenter.\n//=============================================================================\nclass LiftCenter extends NavigationPoint\n\tnative;\n\nvar() name LiftTag;\nvar\t mover MyLift;\nvar() name LiftTrigger;\nvar trigger RecommendedTrigger;\nvar float LastTriggerTime;\nvar() float MaxZDiffAdd;  //added threshold for Z difference between pawn and lift (for lifts which are at the end of a ramp or stairs)\nvar() float MaxDist2D;\nvar vector LiftOffset;\n\nfunction PostBeginPlay()\n{\n\tif ( LiftTag != '' )\n\t\tForEach AllActors(class'Mover', MyLift, LiftTag )\n\t\t{\n\t\t\tMyLift.myMarker = self;\n\t\t\tSetBase(MyLift);\n\t\t\tLiftOffset = Location - MyLift.Location;\n\t\t\tif ( MyLift.InitialState == 'BumpOpenTimed' )\n\t\t\t\tlog(\"Warning: \"$MyLift$\" is BumpOpenTimed.  Bots don't understand this well - use StandOpenTimed instead!\");\n\t\t\tbreak;\n\t\t}\n\t// log(self$\" attached to \"$MyLift);\n\tif ( LiftTrigger != '' )\n\t\tForEach AllActors(class'Trigger', RecommendedTrigger, LiftTrigger )\n\t\t\tbreak;\n\tSuper.PostBeginPlay();\n}\n\n/* SpecialHandling is called by the navigation code when the next path has been found.  \nIt gives that path an opportunity to modify the result based on any special considerations\n*/\n\nfunction Actor SpecialHandling(Pawn Other)\n{\n\tlocal float dist2d;\n\tlocal NavigationPoint N, Exit;\n\n\tif ( MyLift == None )\n\t\treturn self;\n\tif ( Other.base == MyLift )\n\t{\n\t\tif ( (RecommendedTrigger != None) \n\t\t&& (myLift.SavedTrigger == None)\n\t\t&& (Level.TimeSeconds - LastTriggerTime > 5) )\n\t\t{\n\t\t\tOther.SpecialGoal = RecommendedTrigger;\n\t\t\tLastTriggerTime = Level.TimeSeconds;\n\t\t\treturn RecommendedTrigger;\n\t\t}\n\n\t\treturn self;\n\t}\n\n\tif ( (LiftExit(Other.MoveTarget) != None) \n\t\t&& (LiftExit(Other.MoveTarget).RecommendedTrigger != None)\n\t\t&& (LiftExit(Other.MoveTarget).LiftTag == LiftTag)\n\t\t&& (Level.TimeSeconds - LiftExit(Other.MoveTarget).LastTriggerTime > 5)\n\t\t&& (MyLift.SavedTrigger == None)\n\t\t&& (Abs(Other.Location.X - Other.MoveTarget.Location.X) < Other.CollisionRadius)\n\t\t&& (Abs(Other.Location.Y - Other.MoveTarget.Location.Y) < Other.CollisionRadius)\n\t\t&& (Abs(Other.Location.Z - Other.MoveTarget.Location.Z) < Other.CollisionHeight) )\n\t{\n\t\tLiftExit(Other.MoveTarget).LastTriggerTime = Level.TimeSeconds;\n\t\tOther.SpecialGoal = LiftExit(Other.MoveTarget).RecommendedTrigger;\n\t\treturn LiftExit(Other.MoveTarget).RecommendedTrigger;\n\t}\n\n\tSetLocation(MyLift.Location + LiftOffset);\n\tSetBase(MyLift);\n\tdist2d = square(Location.X - Other.Location.X) + square(Location.Y - Other.Location.Y);\n\tif ( (Location.Z - CollisionHeight - MaxZDiffAdd < Other.Location.Z - Other.CollisionHeight + Other.MaxStepHeight)\n\t\t&& (Location.Z - CollisionHeight > Other.Location.Z - Other.CollisionHeight - 1200)\n\t\t&& ( dist2D < MaxDist2D * MaxDist2D) )\n\t{\n\t\treturn self;\n\t}\n\n\tif ( MyLift.BumpType == BT_PlayerBump && !Other.bIsPlayer )\n\t\treturn None;\n\tOther.SpecialGoal = None;\n\t\t\n\t// make sure Other is at valid lift exit\n\tif ( LiftExit(Other.MoveTarget) == None )\n\t{\n\t\tfor ( N=Level.NavigationPointList; N!=None; N=N.NextNavigationPoint )\n\t\t\tif ( N.IsA('LiftExit') && (LiftExit(N).LiftTag == LiftTag) \n\t\t\t\t&& (Abs(Other.Location.X - N.Location.X) < Other.CollisionRadius)\n\t\t\t\t&& (Abs(Other.Location.Y - N.Location.Y) < Other.CollisionRadius)\n\t\t\t\t&& (Abs(Other.Location.Z - N.Location.Z) < Other.CollisionHeight) )\n\t\t\t{\n\t\t\t\tExit = N;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif ( Exit == None )\n\t\t\treturn self;\n\t}\n\n\tMyLift.HandleDoor(Other);\n\tMyLift.RecommendedTrigger = None;\n\n\tif ( (Other.SpecialGoal == MyLift) || (Other.SpecialGoal == None) )\n\t\tOther.SpecialGoal = self;\n\n\treturn Other.SpecialGoal;\n}\n\ndefaultproperties\n{\n     MaxDist2D=400.000000\n     ExtraCost=400\n     bStatic=False\n     bNoDelete=True\n     RemoteRole=ROLE_None\n}\n",
            "name": "LiftCenter.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "MaxDist2D=400.000000",
                    "ExtraCost=400",
                    "bStatic=False",
                    "bNoDelete=True",
                    "RemoteRole=ROLE_None"
                ],
                "exec": [],
                "extends": "NavigationPoint",
                "functions": {
                    "PostBeginPlay": {
                        "body": "{\n\tif ( LiftTag != '' )\n\t\tForEach AllActors(class'Mover', MyLift, LiftTag )\n\t\t{\n\t\t\tMyLift.myMarker = self;\n\t\t\tSetBase(MyLift);\n\t\t\tLiftOffset = Location - MyLift.Location;\n\t\t\tif ( MyLift.InitialState == 'BumpOpenTimed' )\n\t\t\t\tlog(\"Warning: \"$MyLift$\" is BumpOpenTimed.  Bots don't understand this well - use StandOpenTimed instead!\");\n\t\t\tbreak;\n\t\t}\n\t// log(self$\" attached to \"$MyLift);\n\tif ( LiftTrigger != '' )\n\t\tForEach AllActors(class'Trigger', RecommendedTrigger, LiftTrigger )\n\t\t\tbreak;\n\tSuper.PostBeginPlay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpecialHandling": {
                        "body": "{\n\n\tif ( MyLift == None )\n\t\treturn self;\n\tif ( Other.base == MyLift )\n\t{\n\t\tif ( (RecommendedTrigger != None) \n\t\t&& (myLift.SavedTrigger == None)\n\t\t&& (Level.TimeSeconds - LastTriggerTime > 5) )\n\t\t{\n\t\t\tOther.SpecialGoal = RecommendedTrigger;\n\t\t\tLastTriggerTime = Level.TimeSeconds;\n\t\t\treturn RecommendedTrigger;\n\t\t}\n\n\t\treturn self;\n\t}\n\n\tif ( (LiftExit(Other.MoveTarget) != None) \n\t\t&& (LiftExit(Other.MoveTarget).RecommendedTrigger != None)\n\t\t&& (LiftExit(Other.MoveTarget).LiftTag == LiftTag)\n\t\t&& (Level.TimeSeconds - LiftExit(Other.MoveTarget).LastTriggerTime > 5)\n\t\t&& (MyLift.SavedTrigger == None)\n\t\t&& (Abs(Other.Location.X - Other.MoveTarget.Location.X) < Other.CollisionRadius)\n\t\t&& (Abs(Other.Location.Y - Other.MoveTarget.Location.Y) < Other.CollisionRadius)\n\t\t&& (Abs(Other.Location.Z - Other.MoveTarget.Location.Z) < Other.CollisionHeight) )\n\t{\n\t\tLiftExit(Other.MoveTarget).LastTriggerTime = Level.TimeSeconds;\n\t\tOther.SpecialGoal = LiftExit(Other.MoveTarget).RecommendedTrigger;\n\t\treturn LiftExit(Other.MoveTarget).RecommendedTrigger;\n\t}\n\n\tSetLocation(MyLift.Location + LiftOffset);\n\tSetBase(MyLift);\n\tdist2d = square(Location.X - Other.Location.X) + square(Location.Y - Other.Location.Y);\n\tif ( (Location.Z - CollisionHeight - MaxZDiffAdd < Other.Location.Z - Other.CollisionHeight + Other.MaxStepHeight)\n\t\t&& (Location.Z - CollisionHeight > Other.Location.Z - Other.CollisionHeight - 1200)\n\t\t&& ( dist2D < MaxDist2D * MaxDist2D) )\n\t{\n\t\treturn self;\n\t}\n\n\tif ( MyLift.BumpType == BT_PlayerBump && !Other.bIsPlayer )\n\t\treturn None;\n\tOther.SpecialGoal = None;\n\t\t\n\t// make sure Other is at valid lift exit\n\tif ( LiftExit(Other.MoveTarget) == None )\n\t{\n\t\tfor ( N=Level.NavigationPointList; N!=None; N=N.NextNavigationPoint )\n\t\t\tif ( N.IsA('LiftExit') && (LiftExit(N).LiftTag == LiftTag) \n\t\t\t\t&& (Abs(Other.Location.X - N.Location.X) < Other.CollisionRadius)\n\t\t\t\t&& (Abs(Other.Location.Y - N.Location.Y) < Other.CollisionRadius)\n\t\t\t\t&& (Abs(Other.Location.Z - N.Location.Z) < Other.CollisionHeight) )\n\t\t\t{\n\t\t\t\tExit = N;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif ( Exit == None )\n\t\t\treturn self;\n\t}\n\n\tMyLift.HandleDoor(Other);\n\tMyLift.RecommendedTrigger = None;\n\n\tif ( (Other.SpecialGoal == MyLift) || (Other.SpecialGoal == None) )\n\t\tOther.SpecialGoal = self;\n\n\treturn Other.SpecialGoal;\n}",
                        "locals": [
                            "local float dist2d;",
                            "local NavigationPoint N, Exit;"
                        ],
                        "modifiers": [],
                        "name": "SpecialHandling",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": "Actor"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 121,
                "replication": "",
                "states": [],
                "variables": [
                    "var() name LiftTag;",
                    "var() name LiftTrigger;",
                    "var trigger RecommendedTrigger;",
                    "var float LastTriggerTime;",
                    "var() float MaxZDiffAdd;  //added threshold for Z difference between pawn and lift (for lifts which are at the end of a ramp or stairs)",
                    "var() float MaxDist2D;",
                    "var vector LiftOffset;"
                ]
            }
        },
        "LiftExit.uc": {
            "body": "//=============================================================================\n// LiftExit.\n//=============================================================================\nclass LiftExit extends NavigationPoint\n\tnative;\n\nvar() name LiftTag;\nvar\tMover MyLift;\nvar() name LiftTrigger;\nvar trigger RecommendedTrigger;\nvar float LastTriggerTime;\n\nfunction PostBeginPlay()\n{\n\tif ( LiftTag != '' )\n\t\tForEach AllActors(class'Mover', MyLift, LiftTag )\n\t\t\tbreak;\n\t//log(self$\" attached to \"$MyLift);\n\tif ( LiftTrigger != '' )\n\t\tForEach AllActors(class'Trigger', RecommendedTrigger, LiftTrigger )\n\t\t\tbreak;\n\tSuper.PostBeginPlay();\n}\n\n/* SpecialHandling is called by the navigation code when the next path has been found.  \nIt gives that path an opportunity to modify the result based on any special considerations\n*/\n\nfunction Actor SpecialHandling(Pawn Other)\n{\n\n\tif ( (Other.Base == MyLift) && (MyLift != None) )\n\t{\n\t\tif ( (self.Location.Z < Other.Location.Z + Other.CollisionHeight)\n\t\t\t && Other.LineOfSightTo(self) )\n\t\t\treturn self;\n\t\tOther.SpecialGoal = None;\n\t\tOther.DesiredRotation = rotator(Location - Other.Location);\n\t\tMyLift.HandleDoor(Other);\n\n\t\tif ( (Other.SpecialGoal == MyLift) || (Other.SpecialGoal == None) )\n\t\t\tOther.SpecialGoal = MyLift.myMarker;\n\t\treturn Other.SpecialGoal;\n\t}\n\treturn self;\n}\n\ndefaultproperties\n{\n}\n",
            "name": "LiftExit.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "NavigationPoint",
                "functions": {
                    "PostBeginPlay": {
                        "body": "{\n\tif ( LiftTag != '' )\n\t\tForEach AllActors(class'Mover', MyLift, LiftTag )\n\t\t\tbreak;\n\t//log(self$\" attached to \"$MyLift);\n\tif ( LiftTrigger != '' )\n\t\tForEach AllActors(class'Trigger', RecommendedTrigger, LiftTrigger )\n\t\t\tbreak;\n\tSuper.PostBeginPlay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpecialHandling": {
                        "body": "{\n\n\tif ( (Other.Base == MyLift) && (MyLift != None) )\n\t{\n\t\tif ( (self.Location.Z < Other.Location.Z + Other.CollisionHeight)\n\t\t\t && Other.LineOfSightTo(self) )\n\t\t\treturn self;\n\t\tOther.SpecialGoal = None;\n\t\tOther.DesiredRotation = rotator(Location - Other.Location);\n\t\tMyLift.HandleDoor(Other);\n\n\t\tif ( (Other.SpecialGoal == MyLift) || (Other.SpecialGoal == None) )\n\t\t\tOther.SpecialGoal = MyLift.myMarker;\n\t\treturn Other.SpecialGoal;\n\t}\n\treturn self;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SpecialHandling",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": "Actor"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 51,
                "replication": "",
                "states": [],
                "variables": [
                    "var() name LiftTag;",
                    "var() name LiftTrigger;",
                    "var trigger RecommendedTrigger;",
                    "var float LastTriggerTime;"
                ]
            }
        },
        "Light.uc": {
            "body": "//=============================================================================\n// The light class.\n//=============================================================================\nclass Light extends Actor\n\tnative;\n\n#exec Texture Import File=Textures\\S_Light.pcx  Name=S_Light Mips=Off Flags=2\n\ndefaultproperties\n{\n     bStatic=True\n     bHidden=True\n     bNoDelete=True\n     bMovable=False\n     Texture=Texture'Engine.S_Light'\n     CollisionRadius=24.000000\n     CollisionHeight=24.000000\n     LightType=LT_Steady\n     LightBrightness=64\n     LightSaturation=255\n     LightRadius=64\n     LightPeriod=32\n     LightCone=128\n     VolumeBrightness=64\n}\n",
            "name": "Light.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bStatic=True",
                    "bHidden=True",
                    "bNoDelete=True",
                    "bMovable=False",
                    "Texture=Texture'Engine.S_Light'",
                    "CollisionRadius=24.000000",
                    "CollisionHeight=24.000000",
                    "LightType=LT_Steady",
                    "LightBrightness=64",
                    "LightSaturation=255",
                    "LightRadius=64",
                    "LightPeriod=32",
                    "LightCone=128",
                    "VolumeBrightness=64"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\S_Light.pcx  Name=S_Light Mips=Off Flags=2"
                ],
                "extends": "Actor",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 26,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "LocalMessage.uc": {
            "body": "//\n// Represents a schematic for a client localized message.\n//\nclass LocalMessage expands Info;\n\nvar bool\tbComplexString;\t\t\t\t\t\t\t\t\t// Indicates a multicolor string message class.\nvar bool\tbIsSpecial;\t\t\t\t\t\t\t\t\t\t// If true, don't add to normal queue.\nvar bool\tbIsUnique;\t\t\t\t\t\t\t\t\t\t// If true and special, only one can be in the HUD queue at a time.\nvar bool\tbIsConsoleMessage;\t\t\t\t\t\t\t\t// If true, put a GetString on the console.\nvar bool\tbFadeMessage;\t\t\t\t\t\t\t\t\t// If true, use fade out effect on message.\nvar bool\tbBeep;\t\t\t\t\t\t\t\t\t\t\t// If true, beep!\nvar bool\tbOffsetYPos;\t\t\t\t\t\t\t\t\t// If the YPos indicated isn't where the message appears.\nvar int\t\tLifetime;\t\t\t\t\t\t\t\t\t\t// # of seconds to stay in HUD message queue.\n\nvar class<LocalMessage> ChildMessage;\t\t\t\t\t\t// In some cases, we need to refer to a child message.\n\n// Canvas Variables\nvar bool\tbFromBottom;\t\t\t\t\t\t\t\t\t// Subtract YPos.\nvar color\tDrawColor;\t\t\t\t\t\t\t\t\t\t// Color to display message with.\nvar float\tXPos, YPos;\t\t\t\t\t\t\t\t\t\t// Coordinates to print message at.\nvar bool\tbCenter;\t\t\t\t\t\t\t\t\t\t// Whether or not to center the message.\n\nstatic function RenderComplexMessage( \n\tCanvas Canvas, \n\tout float XL,\n\tout float YL,\n\toptional String MessageString,\n\toptional int Switch,\n\toptional PlayerReplicationInfo RelatedPRI_1, \n\toptional PlayerReplicationInfo RelatedPRI_2,\n\toptional Object OptionalObject\n\t);\n\nstatic function string GetString(\n\toptional int Switch,\n\toptional PlayerReplicationInfo RelatedPRI_1, \n\toptional PlayerReplicationInfo RelatedPRI_2,\n\toptional Object OptionalObject\n\t)\n{\n\treturn \"\";\n}\n\nstatic function string AssembleString(\n\tHUD myHUD,\n\toptional int Switch,\n\toptional PlayerReplicationInfo RelatedPRI_1, \n\toptional String MessageString\n\t)\n{\n\treturn \"\";\n}\n\nstatic function ClientReceive( \n\tPlayerPawn P,\n\toptional int Switch,\n\toptional PlayerReplicationInfo RelatedPRI_1, \n\toptional PlayerReplicationInfo RelatedPRI_2,\n\toptional Object OptionalObject\n\t)\n{\n\tif ( P.myHUD != None )\n\t\tP.myHUD.LocalizedMessage( Default.Class, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );\n\n\tif ( Default.bBeep && P.bMessageBeep )\n\t\tP.PlayBeepSound();\n\n\tif ( Default.bIsConsoleMessage )\n\t{\n\t\tif ((P.Player != None) && (P.Player.Console != None))\n\t\t\tP.Player.Console.AddString(Static.GetString( Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject ));\n\t}\n}\n\nstatic function color GetColor(\n\toptional int Switch,\n\toptional PlayerReplicationInfo RelatedPRI_1, \n\toptional PlayerReplicationInfo RelatedPRI_2\n\t)\n{\n\treturn Default.DrawColor;\n}\n\nstatic function float GetOffset(int Switch, float YL, float ClipY )\n{\n\treturn Default.YPos;\n}\n\nstatic function int GetFontSize( int Switch );\n\ndefaultproperties\n{\n     Lifetime=3\n     DrawColor=(R=255,G=255,B=255)\n}\n",
            "name": "LocalMessage.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Lifetime=3",
                    "DrawColor=(R=255,G=255,B=255)"
                ],
                "exec": [],
                "extends": "Info",
                "functions": {
                    "GetFontSize": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "GetFontSize",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Switch"
                            ]
                        ],
                        "return": "int"
                    },
                    "GetOffset": {
                        "body": "{\n\treturn Default.YPos;\n}",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "GetOffset",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Switch"
                            ],
                            [
                                "float",
                                "YL"
                            ],
                            [
                                "float",
                                "ClipY"
                            ]
                        ],
                        "return": "float"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 96,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool\tbComplexString;\t\t\t\t\t\t\t\t\t// Indicates a multicolor string message class.",
                    "var bool\tbIsSpecial;\t\t\t\t\t\t\t\t\t\t// If true, don't add to normal queue.",
                    "var bool\tbIsUnique;\t\t\t\t\t\t\t\t\t\t// If true and special, only one can be in the HUD queue at a time.",
                    "var bool\tbIsConsoleMessage;\t\t\t\t\t\t\t\t// If true, put a GetString on the console.",
                    "var bool\tbFadeMessage;\t\t\t\t\t\t\t\t\t// If true, use fade out effect on message.",
                    "var bool\tbBeep;\t\t\t\t\t\t\t\t\t\t\t// If true, beep!",
                    "var bool\tbOffsetYPos;\t\t\t\t\t\t\t\t\t// If the YPos indicated isn't where the message appears.",
                    "var int\t\tLifetime;\t\t\t\t\t\t\t\t\t\t// # of seconds to stay in HUD message queue.",
                    "var class<LocalMessage> ChildMessage;\t\t\t\t\t\t// In some cases, we need to refer to a child message.",
                    "var bool\tbFromBottom;\t\t\t\t\t\t\t\t\t// Subtract YPos.",
                    "var color\tDrawColor;\t\t\t\t\t\t\t\t\t\t// Color to display message with.",
                    "var float\tXPos, YPos;\t\t\t\t\t\t\t\t\t\t// Coordinates to print message at.",
                    "var bool\tbCenter;\t\t\t\t\t\t\t\t\t\t// Whether or not to center the message."
                ]
            }
        },
        "MapList.uc": {
            "body": "//=============================================================================\n// MapList.\n//\n// contains a list of maps to cycle through\n//\n//=============================================================================\nclass MapList extends Info;\n\nvar(Maps) globalconfig string Maps[32];\nvar globalconfig int MapNum;\n\nfunction string GetNextMap()\n{\n\tlocal string CurrentMap;\n\tlocal int i;\n\n\tCurrentMap = GetURLMap();\n\tif ( CurrentMap != \"\" )\n\t{\n\t\tif ( Right(CurrentMap,4) ~= \".unr\" )\n\t\t\tCurrentMap = CurrentMap;\n\t\telse\n\t\t\tCurrentMap = CurrentMap$\".unr\";\n\n\t\tfor ( i=0; i<ArrayCount(Maps); i++ )\n\t\t{\n\t\t\tif ( CurrentMap ~= Maps[i] )\n\t\t\t{\n\t\t\t\tMapNum = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// search vs. w/ or w/out .unr extension\n\n\tMapNum++;\n\tif ( MapNum > ArrayCount(Maps) - 1 )\n\t\tMapNum = 0;\n\tif ( Maps[MapNum] == \"\" )\n\t\tMapNum = 0;\n\n\tSaveConfig();\n\treturn Maps[MapNum];\n}\n\ndefaultproperties\n{\n}\n",
            "name": "MapList.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Info",
                "functions": {
                    "GetNextMap": {
                        "body": "{\n\n\tCurrentMap = GetURLMap();\n\tif ( CurrentMap != \"\" )\n\t{\n\t\tif ( Right(CurrentMap,4) ~= \".unr\" )\n\t\t\tCurrentMap = CurrentMap;\n\t\telse\n\t\t\tCurrentMap = CurrentMap$\".unr\";\n\n\t\tfor ( i=0; i<ArrayCount(Maps); i++ )\n\t\t{\n\t\t\tif ( CurrentMap ~= Maps[i] )\n\t\t\t{\n\t\t\t\tMapNum = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// search vs. w/ or w/out .unr extension\n\n\tMapNum++;\n\tif ( MapNum > ArrayCount(Maps) - 1 )\n\t\tMapNum = 0;\n\tif ( Maps[MapNum] == \"\" )\n\t\tMapNum = 0;\n\n\tSaveConfig();\n\treturn Maps[MapNum];\n}",
                        "locals": [
                            "local string CurrentMap;",
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "GetNextMap",
                        "native": false,
                        "param": [],
                        "return": "string"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 50,
                "replication": "",
                "states": [],
                "variables": [
                    "var(Maps) globalconfig string Maps[32];",
                    "var globalconfig int MapNum;"
                ]
            }
        },
        "Menu.uc": {
            "body": "//=============================================================================\n// Menu: An in-game menu.\n// This is a built-in Unreal class and it shouldn't be modified.\n//\n// Serves as a generic menu master class.  Can be used with any style\n// of menu implementation.  Offers menu services such as reading input.\n// Not dependent on any visual style.\n//=============================================================================\nclass Menu extends Actor\n\tnative;\n\nvar Menu\tParentMenu;\nvar int\t\tSelection;\nvar() int\tMenuLength;\nvar bool\tbConfigChanged;\nvar bool    bExitAllMenus;\nvar PlayerPawn PlayerOwner;\n\nvar() localized string HelpMessage[24];\nvar() localized string MenuList[24];\nvar() localized string LeftString;\nvar() localized string RightString;\nvar() localized string CenterString;\nvar() localized string EnabledString;\nvar() localized string DisabledString;\nvar() localized string MenuTitle;\nvar() localized string YesString;\nvar() localized string NoString;\n\nfunction bool ProcessSelection();\nfunction bool ProcessLeft();\nfunction bool ProcessRight();\nfunction bool ProcessYes();\nfunction bool ProcessNo();\nfunction SaveConfigs();\nfunction PlaySelectSound();\nfunction PlayModifySound();\nfunction PlayEnterSound();\nfunction ProcessMenuInput( coerce string InputString );\nfunction ProcessMenuUpdate( coerce string InputString );\nfunction ProcessMenuEscape();\nfunction ProcessMenuKey( int KeyNo, string KeyName );\nfunction MenuTick( float DeltaTime );\nfunction MenuInit();\n\nfunction DrawMenu(canvas Canvas);\n\nfunction ExitAllMenus()\n{\n\twhile ( Hud(Owner).MainMenu != None )\n\t\tHud(Owner).MainMenu.ExitMenu();\n}\n\nfunction Menu ExitMenu()\n{\n\tHud(Owner).MainMenu = ParentMenu;\n\tif ( bConfigChanged )\n\t\tSaveConfigs();\n\tif ( ParentMenu == None )\n\t{\n\t\tPlayerOwner.bShowMenu = false;\n\t\tPlayerOwner.Player.Console.GotoState('');\n\t\tif( Level.Netmode == NM_Standalone )\n\t\t\tPlayerOwner.SetPause(False);\n\t}\n\n\tDestroy();\n}\n\nfunction SetFontBrightness(canvas Canvas, bool bBright)\n{\n\tif ( bBright )\n\t{\n\t\tCanvas.DrawColor.R = 255;\n\t\tCanvas.DrawColor.G = 255;\n\t\tCanvas.DrawColor.B = 255;\n\t}\n\telse \n\t\tCanvas.DrawColor = Canvas.Default.DrawColor;\n}\n\nfunction MenuProcessInput( byte KeyNum, byte ActionNum )\n{\n\tif ( KeyNum == EInputKey.IK_Escape )\n\t{\n\t\tPlayEnterSound();\n\t\tExitMenu();\n\t\treturn;\n\t}\t\n\telse if ( KeyNum == EInputKey.IK_Up )\n\t{\n\t\tPlaySelectSound();\n\t\tSelection--;\n\t\tif ( Selection < 1 )\n\t\t\tSelection = MenuLength;\n\t}\n\telse if ( KeyNum == EInputKey.IK_Down )\n\t{\n\t\tPlaySelectSound();\n\t\tSelection++;\n\t\tif ( Selection > MenuLength )\n\t\t\tSelection = 1;\n\t}\n\telse if ( KeyNum == EInputKey.IK_Enter )\n\t{\n\t\tbConfigChanged=true;\n\t\tif ( ProcessSelection() )\n\t\t\tPlayEnterSound();\n\t}\n\telse if ( KeyNum == EInputKey.IK_Left )\n\t{\n\t\tbConfigChanged=true;\n\t\tif ( ProcessLeft() )\n\t\t\tPlayModifySound();\n\t}\n\telse if ( KeyNum == EInputKey.IK_Right )\n\t{\n\t\tbConfigChanged=true;\n\t\tif ( ProcessRight() )\n\t\t\tPlayModifySound();\n\t}\n\telse if ( Chr(KeyNum) ~= left(YesString, 1) ) \n\t{\n\t\tbConfigChanged=true;\n\t\tif ( ProcessYes() )\n\t\t\tPlayModifySound();\n\t}\n\telse if ( Chr(KeyNum) ~= left(NoString, 1) )\n\t{\n\t\tbConfigChanged=true;\n\t\tif ( ProcessNo() )\n\t\t\tPlayModifySound();\n\t}\n\n\tif ( bExitAllMenus )\n\t\tExitAllMenus(); \n\t\n}\n\ndefaultproperties\n{\n     Selection=1\n     HelpMessage(1)=\"This menu has not yet been implemented.\"\n     LeftString=\"Left\"\n     RightString=\"Right\"\n     CenterString=\"Center\"\n     EnabledString=\"Enabled\"\n     DisabledString=\"Disabled\"\n     YesString=\"yes\"\n     NoString=\"no\"\n     bHidden=True\n}\n",
            "name": "Menu.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Selection=1",
                    "HelpMessage(1)=\"This menu has not yet been implemented.\"",
                    "LeftString=\"Left\"",
                    "RightString=\"Right\"",
                    "CenterString=\"Center\"",
                    "EnabledString=\"Enabled\"",
                    "DisabledString=\"Disabled\"",
                    "YesString=\"yes\"",
                    "NoString=\"no\"",
                    "bHidden=True"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "DrawMenu": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawMenu",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "ExitAllMenus": {
                        "body": "{\n\twhile ( Hud(Owner).MainMenu != None )\n\t\tHud(Owner).MainMenu.ExitMenu();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ExitAllMenus",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ExitMenu": {
                        "body": "{\n\tHud(Owner).MainMenu = ParentMenu;\n\tif ( bConfigChanged )\n\t\tSaveConfigs();\n\tif ( ParentMenu == None )\n\t{\n\t\tPlayerOwner.bShowMenu = false;\n\t\tPlayerOwner.Player.Console.GotoState('');\n\t\tif( Level.Netmode == NM_Standalone )\n\t\t\tPlayerOwner.SetPause(False);\n\t}\n\n\tDestroy();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ExitMenu",
                        "native": false,
                        "param": [],
                        "return": "Menu"
                    },
                    "MenuInit": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "MenuInit",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "MenuProcessInput": {
                        "body": "{\n\tif ( KeyNum == EInputKey.IK_Escape )\n\t{\n\t\tPlayEnterSound();\n\t\tExitMenu();\n\t\treturn;\n\t}\t\n\telse if ( KeyNum == EInputKey.IK_Up )\n\t{\n\t\tPlaySelectSound();\n\t\tSelection--;\n\t\tif ( Selection < 1 )\n\t\t\tSelection = MenuLength;\n\t}\n\telse if ( KeyNum == EInputKey.IK_Down )\n\t{\n\t\tPlaySelectSound();\n\t\tSelection++;\n\t\tif ( Selection > MenuLength )\n\t\t\tSelection = 1;\n\t}\n\telse if ( KeyNum == EInputKey.IK_Enter )\n\t{\n\t\tbConfigChanged=true;\n\t\tif ( ProcessSelection() )\n\t\t\tPlayEnterSound();\n\t}\n\telse if ( KeyNum == EInputKey.IK_Left )\n\t{\n\t\tbConfigChanged=true;\n\t\tif ( ProcessLeft() )\n\t\t\tPlayModifySound();\n\t}\n\telse if ( KeyNum == EInputKey.IK_Right )\n\t{\n\t\tbConfigChanged=true;\n\t\tif ( ProcessRight() )\n\t\t\tPlayModifySound();\n\t}\n\telse if ( Chr(KeyNum) ~= left(YesString, 1) ) \n\t{\n\t\tbConfigChanged=true;\n\t\tif ( ProcessYes() )\n\t\t\tPlayModifySound();\n\t}\n\telse if ( Chr(KeyNum) ~= left(NoString, 1) )\n\t{\n\t\tbConfigChanged=true;\n\t\tif ( ProcessNo() )\n\t\t\tPlayModifySound();\n\t}\n\n\tif ( bExitAllMenus )\n\t\tExitAllMenus(); \n\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "MenuProcessInput",
                        "native": false,
                        "param": [
                            [
                                "byte",
                                "KeyNum"
                            ],
                            [
                                "byte",
                                "ActionNum"
                            ]
                        ],
                        "return": ""
                    },
                    "MenuTick": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "MenuTick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayEnterSound": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayEnterSound",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayModifySound": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayModifySound",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlaySelectSound": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlaySelectSound",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ProcessLeft": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessLeft",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "ProcessMenuEscape": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessMenuEscape",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ProcessMenuInput": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessMenuInput",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "InputString"
                            ]
                        ],
                        "return": ""
                    },
                    "ProcessMenuKey": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessMenuKey",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "KeyNo"
                            ],
                            [
                                "string",
                                "KeyName"
                            ]
                        ],
                        "return": ""
                    },
                    "ProcessMenuUpdate": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessMenuUpdate",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "InputString"
                            ]
                        ],
                        "return": ""
                    },
                    "ProcessNo": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessNo",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "ProcessRight": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessRight",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "ProcessSelection": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessSelection",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "ProcessYes": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessYes",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "SaveConfigs": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SaveConfigs",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetFontBrightness": {
                        "body": "{\n\tif ( bBright )\n\t{\n\t\tCanvas.DrawColor.R = 255;\n\t\tCanvas.DrawColor.G = 255;\n\t\tCanvas.DrawColor.B = 255;\n\t}\n\telse \n\t\tCanvas.DrawColor = Canvas.Default.DrawColor;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetFontBrightness",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ],
                            [
                                "bool",
                                "bBright"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 153,
                "replication": "",
                "states": [],
                "variables": [
                    "var Menu\tParentMenu;",
                    "var int\t\tSelection;",
                    "var() int\tMenuLength;",
                    "var bool\tbConfigChanged;",
                    "var bool    bExitAllMenus;",
                    "var PlayerPawn PlayerOwner;",
                    "var() localized string HelpMessage[24];",
                    "var() localized string MenuList[24];",
                    "var() localized string LeftString;",
                    "var() localized string RightString;",
                    "var() localized string CenterString;",
                    "var() localized string EnabledString;",
                    "var() localized string DisabledString;",
                    "var() localized string MenuTitle;",
                    "var() localized string YesString;",
                    "var() localized string NoString;"
                ]
            }
        },
        "MessagingSpectator.uc": {
            "body": "//=============================================================================\n// MessagingSpectator - spectator base class for game helper spectators which receive messages\n//=============================================================================\n\nclass MessagingSpectator expands Spectator\n\tabstract;\n\nfunction PostBeginPlay()\n{\n\tSuper.PostBeginPlay();\n\tbIsPlayer = False;\n}\n\ndefaultproperties\n{\n}\n",
            "name": "MessagingSpectator.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Spectator",
                "functions": {
                    "PostBeginPlay": {
                        "body": "{\n\tSuper.PostBeginPlay();\n\tbIsPlayer = False;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 17,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "Mover.uc": {
            "body": "//=============================================================================\n// The moving brush class.\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass Mover extends Brush\n\tnative\n\tnativereplication;\n\n// How the mover should react when it encroaches an actor.\nvar() enum EMoverEncroachType\n{\n\tME_StopWhenEncroach,\t// Stop when we hit an actor.\n\tME_ReturnWhenEncroach,\t// Return to previous position when we hit an actor.\n   \tME_CrushWhenEncroach,   // Crush the poor helpless actor.\n   \tME_IgnoreWhenEncroach,  // Ignore encroached actors.\n} MoverEncroachType;\n\n// How the mover moves from one position to another.\nvar() enum EMoverGlideType\n{\n\tMV_MoveByTime,\t\t\t// Move linearly.\n\tMV_GlideByTime,\t\t\t// Move with smooth acceleration.\n} MoverGlideType;\n\n// What classes can bump trigger this mover\nvar() enum EBumpType\n{\n\tBT_PlayerBump,\t\t// Can only be bumped by player.\n\tBT_PawnBump,\t\t// Can be bumped by any pawn\n\tBT_AnyBump,\t\t\t// Cany be bumped by any solid actor\n} BumpType;\n\n//-----------------------------------------------------------------------------\n// Keyframe numbers.\nvar() byte       KeyNum;           // Current or destination keyframe.\nvar byte         PrevKeyNum;       // Previous keyframe.\nvar() const byte NumKeys;          // Number of keyframes in total (0-3).\nvar() const byte WorldRaytraceKey; // Raytrace the world with the brush here.\nvar() const byte BrushRaytraceKey; // Raytrace the brush here.\n\n//-----------------------------------------------------------------------------\n// Movement parameters.\nvar() float      MoveTime;         // Time to spend moving between keyframes.\nvar() float      StayOpenTime;     // How long to remain open before closing.\nvar() float      OtherTime;        // TriggerPound stay-open time.\nvar() int        EncroachDamage;   // How much to damage encroached actors.\n\n//-----------------------------------------------------------------------------\n// Mover state.\nvar() bool       bTriggerOnceOnly; // Go dormant after first trigger.\nvar() bool       bSlave;           // This brush is a slave.\nvar() bool\t\t bUseTriggered;\t\t// Triggered by player grab\nvar() bool\t\t bDamageTriggered;\t// Triggered by taking damage\nvar() bool       bDynamicLightMover; // Apply dynamic lighting to mover.\nvar() name       PlayerBumpEvent;  // Optional event to cause when the player bumps the mover.\nvar() name       BumpEvent;\t\t\t// Optional event to cause when any valid bumper bumps the mover.\nvar   actor      SavedTrigger;      // Who we were triggered by.\nvar() float\t\t DamageThreshold;\t// minimum damage to trigger\nvar\t  int\t\t numTriggerEvents;\t// number of times triggered ( count down to untrigger )\nvar\t  Mover\t\t Leader;\t\t\t// for having multiple movers return together\nvar\t  Mover\t\t Follower;\nvar() name\t\t ReturnGroup;\t\t// if none, same as tag\nvar() float\t\t DelayTime;\t\t\t// delay before starting to open\n\n//-----------------------------------------------------------------------------\n// Audio.\nvar(MoverSounds) sound      OpeningSound;     // When start opening.\nvar(MoverSounds) sound      OpenedSound;      // When finished opening.\nvar(MoverSounds) sound      ClosingSound;     // When start closing.\nvar(MoverSounds) sound      ClosedSound;      // When finish closing.\nvar(MoverSounds) sound      MoveAmbientSound; // Optional ambient sound when moving.\n\n//-----------------------------------------------------------------------------\n// Internal.\nvar vector       KeyPos[8];\nvar rotator      KeyRot[8];\nvar vector       BasePos, OldPos, OldPrePivot, SavedPos;\nvar rotator      BaseRot, OldRot, SavedRot;\n\n// AI related\nvar       NavigationPoint  myMarker;\nvar\t\t  Actor\t\t\tTriggerActor;\nvar\t\t  Actor         TriggerActor2;\nvar\t\t  Pawn\t\t\tWaitingPawn;\nvar\t\t  bool\t\t\tbOpening, bDelaying, bClientPause;\nvar\t\t  bool\t\t\tbPlayerOnly;\nvar\t\t  Trigger\t\tRecommendedTrigger;\n\n// for client side replication\nvar\t\tvector\t\t\tSimOldPos;\nvar\t\tint\t\t\t\tSimOldRotPitch, SimOldRotYaw, SimOldRotRoll;\nvar\t\tvector\t\t\tSimInterpolate;\nvar\t\tvector\t\t\tRealPosition;\nvar     rotator\t\t\tRealRotation;\nvar\t\tint\t\t\t\tClientUpdate;\n\nreplication\n{\n\t// Things the server should send to the client.\n\treliable if( Role==ROLE_Authority )\n\t\tSimOldPos, SimOldRotPitch, SimOldRotYaw, SimOldRotRoll, SimInterpolate, RealPosition, RealRotation;\n}\n\nsimulated function Timer()\n{\n\tif ( Velocity != vect(0,0,0) )\n\t{\n\t\tbClientPause = false;\n\t\treturn;\t\t\n\t}\n\tif ( Level.NetMode == NM_Client )\n\t{\n\t\tif ( ClientUpdate == 0 ) // not doing a move\n\t\t{\n\t\t\tif ( bClientPause )\n\t\t\t{\n\t\t\t\tif ( VSize(RealPosition - Location) > 3 )\n\t\t\t\t\tSetLocation(RealPosition);\n\t\t\t\telse\n\t\t\t\t\tRealPosition = Location;\n\t\t\t\tSetRotation(RealRotation);\n\t\t\t\tbClientPause = false;\n\t\t\t}\n\t\t\telse if ( RealPosition != Location )\n\t\t\t\tbClientPause = true;\n\t\t}\n\t\telse\n\t\t\tbClientPause = false;\n\t}\n\telse \n\t{\n\t\tRealPosition = Location;\n\t\tRealRotation = Rotation;\n\t}\n}\n\t\t\nfunction FindTriggerActor()\n{\n\tlocal Actor A;\n\n\tTriggerActor = None;\n\tTriggerActor2 = None;\n\tForEach AllActors(class 'Actor', A)\n\t\tif ( (A.Event == Tag) && (A.IsA('Trigger') || A.IsA('Mover')) )\n\t\t{\n\t\t\tif ( A.IsA('Counter') || A.IsA('Pawn') )\n\t\t\t{\n\t\t\t\tbPlayerOnly = true;\n\t\t\t\treturn; //FIXME - handle counters\n\t\t\t}\n\t\t\tif (TriggerActor == None)\n\t\t\t\tTriggerActor = A;\n\t\t\telse if ( TriggerActor2 == None )\n\t\t\t\tTriggerActor2 = A;\n\t\t}\n\n\tif ( TriggerActor == None )\n\t{\n\t\tbPlayerOnly = (BumpType == BT_PlayerBump);\n\t\treturn;\n\t}\n\n\tbPlayerOnly = ( TriggerActor.IsA('Trigger') && (Trigger(TriggerActor).TriggerType == TT_PlayerProximity) );\n\tif ( bPlayerOnly && ( TriggerActor2 != None) )\n\t{\n\t\tbPlayerOnly = ( TriggerActor2.IsA('Trigger') && (Trigger(TriggerActor).TriggerType == TT_PlayerProximity) );\n\t\tif ( !bPlayerOnly )\n\t\t{\n\t\t\tA = TriggerActor;\n\t\t\tTriggerActor = TriggerActor2;\n\t\t\tTriggerActor2 = A;\n\t\t}\n\t}\n}\n\n/* set specialgoal/movetarget or special pause if necessary\nif mover can't be affected by this pawn, return false\nEach mover state should implement the appropriate version\n*/\nfunction bool HandleDoor(pawn Other)\n{\n\treturn false;\n}\n\nfunction bool HandleTriggerDoor(pawn Other)\n{\n\tlocal bool bOne, bTwo;\n\tlocal float DP1, DP2, Dist1, Dist2;\n\n\tif ( bOpening || bDelaying )\n\t{\n\t\tWaitingPawn = Other;\n\t\tOther.SpecialPause = 2.5;\n\t\treturn true;\n\t}\n\tif ( bPlayerOnly && !Other.bIsPlayer )\n\t\treturn false;\n\tif ( bUseTriggered )\n\t{\n\t\tWaitingPawn = Other;\n\t\tOther.SpecialPause = 2.5;\n\t\tTrigger(Other, Other);\n\t\treturn true;\n\t}\n\tif ( (BumpEvent == tag) || (Other.bIsPlayer && (PlayerBumpEvent == tag)) )\n\t{\n\t\tWaitingPawn = Other;\n\t\tOther.SpecialPause = 2.5;\n\t\tif ( Other.Base == Self )\n\t\t\tTrigger(Other, Other);\n\t\treturn true;\n\t}\n\tif ( bDamageTriggered )\n\t{\n\t\tWaitingPawn = Other;\n\t\tOther.SpecialGoal = self;\n\t\tif ( !Other.bCanDoSpecial || (Other.Weapon == None) )\n\t\t\treturn false;\n\n\t\tOther.Target = self;\n\t\tOther.bShootSpecial = true;\n\t\tOther.FireWeapon();\n\t\tTrigger(Self, Other);\n\t\tOther.bFire = 0;\n\t\tOther.bAltFire = 0;\n\t\treturn true;\n\t}\n\n\tif ( RecommendedTrigger != None )\n\t{\n\t\tOther.SpecialGoal = RecommendedTrigger;\n\t\tOther.MoveTarget = RecommendedTrigger;\n\t\treturn True;\n\t}\n\n\tbOne = ( (TriggerActor != None) \n\t\t\t&& (!TriggerActor.IsA('Trigger') || Trigger(TriggerActor).IsRelevant(Other)) );\n\tbTwo = ( (TriggerActor2 != None) \n\t\t\t&& (!TriggerActor2.IsA('Trigger') || Trigger(TriggerActor2).IsRelevant(Other)) );\n\t\n\tif ( bOne && bTwo )\n\t{\n\t\t// Dotp, dist\n\t\tDist1 = VSize(TriggerActor.Location - Other.Location);\n\t\tDist2 = VSize(TriggerActor2.Location - Other.Location);\n\t\tif ( Dist1 < Dist2 )\n\t\t{\n\t\t\tif ( (Dist1 < 500) && Other.ActorReachable(TriggerActor) )\n\t\t\t\tbTwo = false;\n\t\t}\n\t\telse if ( (Dist2 < 500) && Other.ActorReachable(TriggerActor2) )\n\t\t\tbOne = false;\n\t\t\n\t\tif ( bOne && bTwo )\n\t\t{\n\t\t\tDP1 = Normal(Location - Other.Location) Dot (TriggerActor.Location - Other.Location)/Dist1;\n\t\t\tDP2 = Normal(Location - Other.Location) Dot (TriggerActor2.Location - Other.Location)/Dist2;\n\t\t\tif ( (DP1 > 0) && (DP2 < 0) )\n\t\t\t\tbOne = false;\n\t\t\telse if ( (DP1 < 0) && (DP2 > 0) )\n\t\t\t\tbTwo = false;\n\t\t\telse if ( Dist1 < Dist2 )\n\t\t\t\tbTwo = false;\n\t\t\telse \n\t\t\t\tbOne = false;\n\t\t}\n\t}\n\n\tif ( bOne )\n\t{\n\t\tOther.SpecialGoal = TriggerActor;\n\t\tOther.MoveTarget = TriggerActor;\n\t\treturn True;\n\t}\n\telse if ( bTwo )\n\t{\n\t\tOther.SpecialGoal = TriggerActor2;\n\t\tOther.MoveTarget = TriggerActor2;\n\t\treturn True;\n\t}\n\treturn false;\n}\n\nfunction Actor SpecialHandling(Pawn Other)\n{\n\tif ( bDamageTriggered )\t\n\t{\n\t\tif ( !Other.bCanDoSpecial || (Other.Weapon == None) )\n\t\t\treturn None;\n\n\t\tOther.Target = self;\n\t\tOther.bShootSpecial = true;\n\t\tOther.FireWeapon();\n\t\tOther.bFire = 0;\n\t\tOther.bAltFire = 0;\n\t\treturn self;\n\t}\n\n\tif ( BumpType == BT_PlayerBump && !Other.bIsPlayer )\n\t\treturn None;\n\n\treturn self;\n}\n\n//-----------------------------------------------------------------------------\n// Movement functions.\n\n// Interpolate to keyframe KeyNum in Seconds time.\nfinal function InterpolateTo( byte NewKeyNum, float Seconds )\n{\n\tNewKeyNum = Clamp( NewKeyNum, 0, ArrayCount(KeyPos)-1 );\n\tif( NewKeyNum==PrevKeyNum && KeyNum!=PrevKeyNum )\n\t{\n\t\t// Reverse the movement smoothly.\n\t\tPhysAlpha = 1.0 - PhysAlpha;\n\t\tOldPos    = BasePos + KeyPos[KeyNum];\n\t\tOldRot    = BaseRot + KeyRot[KeyNum];\n\t}\n\telse\n\t{\n\t\t// Start a new movement.\n\t\tOldPos    = Location;\n\t\tOldRot    = Rotation;\n\t\tPhysAlpha = 0.0;\n\t}\n\n\t// Setup physics.\n\tSetPhysics(PHYS_MovingBrush);\n\tbInterpolating   = true;\n\tPrevKeyNum       = KeyNum;\n\tKeyNum\t\t\t = NewKeyNum;\n\tPhysRate         = 1.0 / FMax(Seconds, 0.005);\n\n\tClientUpdate++;\n\tSimOldPos = OldPos;\n\tSimOldRotYaw = OldRot.Yaw;\n\tSimOldRotPitch = OldRot.Pitch;\n\tSimOldRotRoll = OldRot.Roll;\n\tSimInterpolate.X = 100 * PhysAlpha;\n\tSimInterpolate.Y = 100 * FMax(0.01, PhysRate);\n\tSimInterpolate.Z = 256 * PrevKeyNum + KeyNum;\n}\n\n// Set the specified keyframe.\nfinal function SetKeyframe( byte NewKeyNum, vector NewLocation, rotator NewRotation )\n{\n\tKeyNum         = Clamp( NewKeyNum, 0, ArrayCount(KeyPos)-1 );\n\tKeyPos[KeyNum] = NewLocation;\n\tKeyRot[KeyNum] = NewRotation;\n}\n\n// Interpolation ended.\nfunction InterpolateEnd( actor Other )\n{\n\tlocal byte OldKeyNum;\n\n\tOldKeyNum  = PrevKeyNum;\n\tPrevKeyNum = KeyNum;\n\tPhysAlpha  = 0;\n\tClientUpdate--;\n\n\t// If more than two keyframes, chain them.\n\tif( KeyNum>0 && KeyNum<OldKeyNum )\n\t{\n\t\t// Chain to previous.\n\t\tInterpolateTo(KeyNum-1,MoveTime);\n\t}\n\telse if( KeyNum<NumKeys-1 && KeyNum>OldKeyNum )\n\t{\n\t\t// Chain to next.\n\t\tInterpolateTo(KeyNum+1,MoveTime);\n\t}\n\telse\n\t{\n\t\t// Finished interpolating.\n\t\tAmbientSound = None;\n\t\tif ( (ClientUpdate == 0) && (Level.NetMode != NM_Client) )\n\t\t{\n\t\t\tRealPosition = Location;\n\t\t\tRealRotation = Rotation;\n\t\t}\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// Mover functions.\n\n// Notify AI that mover finished movement\nfunction FinishNotify()\n{\n\tlocal Pawn P;\n\n\tif ( StandingCount > 0 )\n\t\tfor ( P=Level.PawnList; P!=None; P=P.nextPawn )\n\t\t\tif ( P.Base == self )\n\t\t\t{\n\t\t\t\tP.StopWaiting();\n\t\t\t\tif ( (P.SpecialGoal == self) || (P.SpecialGoal == myMarker) )\n\t\t\t\t\tP.SpecialGoal = None; \n\t\t\t\tif ( P == WaitingPawn )\n\t\t\t\t\tWaitingPawn = None;\n\t\t\t}\n\n\tif ( WaitingPawn != None )\n\t{\n\t\tWaitingPawn.StopWaiting();\n\t\tif ( (WaitingPawn.SpecialGoal == self) || (WaitingPawn.SpecialGoal == myMarker) )\n\t\t\tWaitingPawn.SpecialGoal = None; \n\t\tWaitingPawn = None;\n\t}\n}\n\n// Handle when the mover finishes closing.\nfunction FinishedClosing()\n{\n\t// Update sound effects.\n//\tPlaySound( ClosedSound, SLOT_None );\n\t// DEUS_EX CNN - make the sounds use SoundRadius and SoundVolume\n\tPlaySound( ClosedSound, SLOT_None, TransientSoundVolume*SoundVolume/255.0,, 25.0*(SoundRadius+1) );\n\n\t// Notify our triggering actor that we have completed.\n\tif( SavedTrigger != None )\n\t\tSavedTrigger.EndEvent();\n\tSavedTrigger = None;\n\tInstigator = None;\n\tFinishNotify(); \n}\n\n// Handle when the mover finishes opening.\nfunction FinishedOpening()\n{\n\tlocal actor A;\n\n\t// Update sound effects.\n//\tPlaySound( OpenedSound, SLOT_None );\n\t// DEUS_EX CNN - make the sounds use SoundRadius and SoundVolume\n\tPlaySound( OpenedSound, SLOT_None, TransientSoundVolume*SoundVolume/255.0,, 25.0*(SoundRadius+1) );\n\t\n\t// Trigger any chained movers.\n\tif( Event != '' )\n\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\tA.Trigger( Self, Instigator );\n\n\tFinishNotify();\n}\n\n// Open the mover.\nfunction DoOpen()\n{\n\tbOpening = true;\n\tbDelaying = false;\n\tInterpolateTo( 1, MoveTime );\n//\tPlaySound( OpeningSound, SLOT_None );\n\t// DEUS_EX CNN - make the sounds use SoundRadius and SoundVolume\n\tPlaySound( OpeningSound, SLOT_None, TransientSoundVolume*SoundVolume/255.0,, 25.0*(SoundRadius+1) );\n\tAmbientSound = MoveAmbientSound;\n}\n\n// Close the mover.\nfunction DoClose()\n{\n\tlocal actor A;\n\n\tbOpening = false;\n\tbDelaying = false;\n\tInterpolateTo( Max(0,KeyNum-1), MoveTime );\n//\tPlaySound( ClosingSound, SLOT_None );\n\t// DEUS_EX CNN - make the sounds use SoundRadius and SoundVolume\n\tPlaySound( ClosingSound, SLOT_None, TransientSoundVolume*SoundVolume/255.0,, 25.0*(SoundRadius+1) );\n\tif( Event != '' )\n\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\tA.UnTrigger( Self, Instigator );\n\tAmbientSound = MoveAmbientSound;\n}\n\n//-----------------------------------------------------------------------------\n// Engine notifications.\n\n// When mover enters gameplay.\nsimulated function BeginPlay()\n{\n\tlocal rotator R;\n\n\t// timer updates real position every second in network play\n\tif ( Level.NetMode != NM_Standalone )\n\t{\n\t\tif ( Level.NetMode == NM_Client )\n\t\t\tsettimer(4.0, true);\n\t\telse\n\t\t\tsettimer(1.0, true);\n\t\tif ( Role < ROLE_Authority )\n\t\t\treturn;\n\t}\n\n\tif ( Level.NetMode != NM_Client )\n\t{\n\t\tRealPosition = Location;\n\t\tRealRotation = Rotation;\n\t}\n\n\t// Init key info.\n\tSuper.BeginPlay();\n\tKeyNum         = Clamp( KeyNum, 0, ArrayCount(KeyPos)-1 );\n\tPhysAlpha      = 0.0;\n\n\t// Set initial location.\n\tMove( BasePos + KeyPos[KeyNum] - Location );\n\n\t// Initial rotation.\n\tSetRotation( BaseRot + KeyRot[KeyNum] );\n\n\t// find movers in same group\n\tif ( ReturnGroup == '' )\n\t\tReturnGroup = tag;\n}\n\n// Immediately after mover enters gameplay.\nfunction PostBeginPlay()\n{\n\tlocal mover M;\n\n\t//brushes can't be deleted, so if not relevant, make it invisible and non-colliding\n\tif ( !Level.Game.IsRelevant(self) )\n\t{\n\t\tSetCollision(false, false, false);\n\t\tSetLocation(Location + vect(0,0,20000)); // temp since still in bsp\n\t\tbHidden = true;\n\t}\n\telse\n\t{\n\t\tFindTriggerActor();\n\t\t// Initialize all slaves.\n\t\tif( !bSlave )\n\t\t{\n\t\t\tforeach AllActors( class 'Mover', M, Tag )\n\t\t\t{\n\t\t\t\tif( M.bSlave )\n\t\t\t\t{\n\t\t\t\t\tM.GotoState('');\n\t\t\t\t\tM.SetBase( Self );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( Leader == None )\n\t\t{\t\n\t\t\tLeader = self;\n\t\t\tForEach AllActors( class'Mover', M )\n\t\t\t\tif ( (M != self) && (M.ReturnGroup == ReturnGroup) )\n\t\t\t\t{\n\t\t\t\t\tM.Leader = self;\n\t\t\t\t\tM.Follower = Follower;\n\t\t\t\t\tFollower = M;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\nfunction MakeGroupStop()\n{\n\t// Stop moving immediately.\n\tbInterpolating = false;\n\tAmbientSound = None;\n\tGotoState( , '' );\n\n\tif ( Follower != None )\n\t\tFollower.MakeGroupStop();\n}\n\nfunction MakeGroupReturn()\n{\n\t// Abort move and reverse course.\n\tbInterpolating = false;\n\tAmbientSound = None;\n\tif( KeyNum<PrevKeyNum )\n\t\tGotoState( , 'Open' );\n\telse\n\t\tGotoState( , 'Close' );\n\n\tif ( Follower != None )\n\t\tFollower.MakeGroupReturn();\n}\n\t\t\n// Return true to abort, false to continue.\nfunction bool EncroachingOn( actor Other )\n{\n\tlocal Pawn P;\n\tif ( Other.IsA('Carcass') || Other.IsA('Decoration') )\n\t{\n\t\tOther.TakeDamage(10000, None, Other.Location, vect(0,0,0), 'Crushed');\n\t\treturn false;\n\t}\n\t// DEUS_EX CNN - Don't destroy inventory items when encroached!\n//\tif ( Other.IsA('Fragment') || (Other.IsA('Inventory') && (Other.Owner == None)) )\n\tif (Other.IsA('Fragment'))\n\t{\n\t\tOther.Destroy();\n\t\treturn false;\n\t}\n\n\t// DEUS_EX CNN - make based actors not stop movers\n\tif (Other.Base == Self)\n\t{\n\t\treturn False;\n\t}\n\n\t// Damage the encroached actor.\n\tif( EncroachDamage != 0 )\n\t\tOther.TakeDamage( EncroachDamage, Instigator, Other.Location, vect(0,0,0), 'Crushed' );\n\n\t// If we have a bump-player event, and Other is a pawn, do the bump thing.\n\tP = Pawn(Other);\n\tif( P!=None && P.bIsPlayer )\n\t{\n\t\tif ( PlayerBumpEvent!='' )\n\t\t\tBump( Other );\n\t\tif ( (MyMarker != None) && (P.Base != self) \n\t\t\t&& (P.Location.Z < MyMarker.Location.Z - P.CollisionHeight - 0.7 * MyMarker.CollisionHeight) )\n\t\t\t// pawn is under lift - tell him to move\n\t\t\tP.UnderLift(self);\n\t}\n\n\t// Stop, return, or whatever.\n\tif( MoverEncroachType == ME_StopWhenEncroach )\n\t{\n\t\tLeader.MakeGroupStop();\n\t\treturn true;\n\t}\n\telse if( MoverEncroachType == ME_ReturnWhenEncroach )\n\t{\n\t\tLeader.MakeGroupReturn();\n\t\tif ( Other.IsA('Pawn') )\n\t\t{\n\t\t\tif ( Pawn(Other).bIsPlayer )\n\t\t\t\tPawn(Other).PlaySound(Pawn(Other).Land, SLOT_None);\t\t\t// DEUS_EX CNN - Changed from SLOT_Talk\n\t\t\telse\n\t\t\t\tPawn(Other).PlaySound(Pawn(Other).HitSound1, SLOT_None);\t// DEUS_EX CNN - Changed from SLOT_Talk\n\t\t}\t\n\t\treturn true;\n\t}\n\telse if( MoverEncroachType == ME_CrushWhenEncroach )\n\t{\n\t\t// Kill it.\n\t\tOther.KilledBy( Instigator );\n\t\treturn false;\n\t}\n\telse if( MoverEncroachType == ME_IgnoreWhenEncroach )\n\t{\n\t\t// Ignore it.\n\t\treturn false;\n\t}\n}\n\n// When bumped by player.\nfunction Bump( actor Other )\n{\n\tlocal actor A;\n\tlocal pawn  P;\n\n\tP = Pawn(Other);\n\tif ( (BumpType != BT_AnyBump) && (P == None) )\n\t\treturn;\n\tif ( (BumpType == BT_PlayerBump) && !P.bIsPlayer )\n\t\treturn;\n\tif ( (BumpType == BT_PawnBump) && (Other.Mass < 10) )\n\t\treturn;\n\tif( BumpEvent!='' )\n\t\tforeach AllActors( class 'Actor', A, BumpEvent )\n\t\t\tA.Trigger( Self, P );\n\n\tif ( P != None )\n\t{\n\t\tif( P.bIsPlayer && (PlayerBumpEvent!='') )\n\t\t\t\tforeach AllActors( class 'Actor', A, PlayerBumpEvent )\n\t\t\t\t\t\tA.Trigger( Self, P );\n\n\t\tif ( P.SpecialGoal == self )\n\t\t\tP.SpecialGoal = None;\n\t}\n}\n\n// When damaged\nfunction TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation, \n\t\t\t\t\t\tVector momentum, name damageType)\n{\n\tif ( bDamageTriggered && (Damage >= DamageThreshold) )\n\t\tself.Trigger(self, instigatedBy);\n}\n\n//-----------------------------------------------------------------------------\n// Trigger states.\n\n// When triggered, open, wait, then close.\nstate() TriggerOpenTimed\n{\n\tfunction bool HandleDoor(pawn Other)\n\t{\n\t\treturn HandleTriggerDoor(Other);\n\t}\n\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tSavedTrigger = Other;\n\t\tInstigator = EventInstigator;\n\t\tif ( SavedTrigger != None )\n\t\t\tSavedTrigger.BeginEvent();\n\t\tGotoState( 'TriggerOpenTimed', 'Open' );\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tbOpening = false;\n\t}\n\nOpen:\n\tDisable( 'Trigger' );\n\tif ( DelayTime > 0 )\n\t{\n\t\tbDelaying = true;\n\t\tSleep(DelayTime);\n\t}\n\tDoOpen();\n\tFinishInterpolation();\n\tFinishedOpening();\n\tSleep( StayOpenTime );\n\tif( bTriggerOnceOnly )\n\t\tGotoState('');\nClose:\n\tDoClose();\n\tFinishInterpolation();\n\tFinishedClosing();\n\tEnable( 'Trigger' );\n}\n\n// Toggle when triggered.\nstate() TriggerToggle\n{\n\tfunction bool HandleDoor(pawn Other)\n\t{\n\t\treturn HandleTriggerDoor(Other);\n\t}\n\t\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tSavedTrigger = Other;\n\t\tInstigator = EventInstigator;\n\t\tif ( SavedTrigger != None )\n\t\t\tSavedTrigger.BeginEvent();\n\t\tif( KeyNum==0 || KeyNum<PrevKeyNum )\n\t\t\tGotoState( 'TriggerToggle', 'Open' );\n\t\telse\n\t\t\tGotoState( 'TriggerToggle', 'Close' );\n\t}\nOpen:\n\tif ( DelayTime > 0 )\n\t{\n\t\tbDelaying = true;\n\t\tSleep(DelayTime);\n\t}\n\tDoOpen();\n\tFinishInterpolation();\n\tFinishedOpening();\n\tif ( SavedTrigger != None )\n\t\tSavedTrigger.EndEvent();\n\n\t// DEUS_EX CNN - Add bTriggerOnceOnly functionality\n\tif( bTriggerOnceOnly )\n\t\tGotoState('');\n\tStop;\nClose:\t\t\n\tDoClose();\n\tFinishInterpolation();\n\tFinishedClosing();\n}\n\n// Open when triggered, close when get untriggered.\nstate() TriggerControl\n{\n\tfunction bool HandleDoor(pawn Other)\n\t{\n\t\treturn HandleTriggerDoor(Other);\n\t}\n\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tnumTriggerEvents++;\n\t\tSavedTrigger = Other;\n\t\tInstigator = EventInstigator;\n\t\tif ( SavedTrigger != None )\n\t\t\tSavedTrigger.BeginEvent();\n\t\tGotoState( 'TriggerControl', 'Open' );\n\t}\n\tfunction UnTrigger( actor Other, pawn EventInstigator )\n\t{\n\t\tnumTriggerEvents--;\n\t\tif ( numTriggerEvents <=0 )\n\t\t{\n\t\t\tnumTriggerEvents = 0;\n\t\t\tSavedTrigger = Other;\n\t\t\tInstigator = EventInstigator;\n\t\t\tSavedTrigger.BeginEvent();\n\t\t\tGotoState( 'TriggerControl', 'Close' );\n\t\t}\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tnumTriggerEvents = 0;\n\t}\n\nOpen:\n\tif ( DelayTime > 0 )\n\t{\n\t\tbDelaying = true;\n\t\tSleep(DelayTime);\n\t}\n\tDoOpen();\n\tFinishInterpolation();\n\tFinishedOpening();\n\tSavedTrigger.EndEvent();\n\tif( bTriggerOnceOnly )\n\t\tGotoState('');\n\tStop;\nClose:\t\t\n\tDoClose();\n\tFinishInterpolation();\n\tFinishedClosing();\n}\n\n// Start pounding when triggered.\nstate() TriggerPound\n{\n\tfunction bool HandleDoor(pawn Other)\n\t{\n\t\treturn HandleTriggerDoor(Other);\n\t}\n\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tnumTriggerEvents++;\n\t\tSavedTrigger = Other;\n\t\tInstigator = EventInstigator;\n\t\tGotoState( 'TriggerPound', 'Open' );\n\t}\n\tfunction UnTrigger( actor Other, pawn EventInstigator )\n\t{\n\t\tnumTriggerEvents--;\n\t\tif ( numTriggerEvents <= 0 )\n\t\t{\n\t\t\tnumTriggerEvents = 0;\n\t\t\tSavedTrigger = None;\n\t\t\tInstigator = None;\n\t\t\tGotoState( 'TriggerPound', 'Close' );\n\t\t}\n\t}\n\tfunction BeginState()\n\t{\n\t\tnumTriggerEvents = 0;\n\t}\n\nOpen:\n\tif ( DelayTime > 0 )\n\t{\n\t\tbDelaying = true;\n\t\tSleep(DelayTime);\n\t}\n\tDoOpen();\n\tFinishInterpolation();\n\tSleep(OtherTime);\nClose:\n\tDoClose();\n\tFinishInterpolation();\n\tSleep(StayOpenTime);\n\tif( bTriggerOnceOnly )\n\t\tGotoState('');\n\tif( SavedTrigger != None )\n\t\tgoto 'Open';\n}\n\n//-----------------------------------------------------------------------------\n// Bump states.\n\n// Open when bumped, wait, then close.\nstate() BumpOpenTimed\n{\n\tfunction bool HandleDoor(pawn Other)\n\t{\n\t\tif ( (BumpType == BT_PlayerBump) && !Other.bIsPlayer )\n\t\t\treturn false;\n\n\t\tBump(Other);\n\t\tWaitingPawn = Other;\n\t\tOther.SpecialPause = 2.5;\n\t\treturn true;\n\t}\n\n\tfunction Bump( actor Other )\n\t{\n\t\tif ( (BumpType != BT_AnyBump) && (Pawn(Other) == None) )\n\t\t\treturn;\n\t\tif ( (BumpType == BT_PlayerBump) && !Pawn(Other).bIsPlayer )\n\t\t\treturn;\n\t\tif ( (BumpType == BT_PawnBump) && (Other.Mass < 10) )\n\t\t\treturn;\n\t\tGlobal.Bump( Other );\n\t\tSavedTrigger = None;\n\t\tInstigator = Pawn(Other);\n\t\tGotoState( 'BumpOpenTimed', 'Open' );\n\t}\nOpen:\n\tDisable( 'Bump' );\n\tif ( DelayTime > 0 )\n\t{\n\t\tbDelaying = true;\n\t\tSleep(DelayTime);\n\t}\n\tDoOpen();\n\tFinishInterpolation();\n\tFinishedOpening();\n\tSleep( StayOpenTime );\n\tif( bTriggerOnceOnly )\n\t\tGotoState('');\nClose:\n\tDoClose();\n\tFinishInterpolation();\n\tFinishedClosing();\n\tEnable( 'Bump' );\n}\n\n// Open when bumped, close when reset.\nstate() BumpButton\n{\n\tfunction bool HandleDoor(pawn Other)\n\t{\n\t\tif ( (BumpType == BT_PlayerBump) && !Other.bIsPlayer )\n\t\t\treturn false;\n\n\t\tBump(Other);\n\t\treturn false; //let pawn try to move around this button\n\t}\n\n\tfunction Bump( actor Other )\n\t{\n\t\tif ( (BumpType != BT_AnyBump) && (Pawn(Other) == None) )\n\t\t\treturn;\n\t\tif ( (BumpType == BT_PlayerBump) && !Pawn(Other).bIsPlayer )\n\t\t\treturn;\n\t\tif ( (BumpType == BT_PawnBump) && (Other.Mass < 10) )\n\t\t\treturn;\n\t\tGlobal.Bump( Other );\n\t\tSavedTrigger = Other;\n\t\tInstigator = Pawn( Other );\n\t\tGotoState( 'BumpButton', 'Open' );\n\t}\n\tfunction BeginEvent()\n\t{\n\t\tbSlave=true;\n\t}\n\tfunction EndEvent()\n\t{\n\t\tbSlave     = false;\n\t\tInstigator = None;\n\t\tGotoState( 'BumpButton', 'Close' );\n\t}\nOpen:\n\tDisable( 'Bump' );\n\tif ( DelayTime > 0 )\n\t{\n\t\tbDelaying = true;\n\t\tSleep(DelayTime);\n\t}\n\tDoOpen();\n\tFinishInterpolation();\n\tFinishedOpening();\n\tif( bTriggerOnceOnly )\n\t\tGotoState('');\n\tif( bSlave )\n\t\tStop;\nClose:\n\tDoClose();\n\tFinishInterpolation();\n\tFinishedClosing();\n\tEnable( 'Bump' );\n}\n\n//-----------------------------------------------------------------------------\n// Stand states.\n\n// Open when stood on, wait, then close.\nstate() StandOpenTimed\n{\n\tfunction bool HandleDoor(pawn Other)\n\t{\n\t\tif ( bPlayerOnly && !Other.bIsPlayer )\n\t\t\treturn false;\n\t\tOther.SpecialPause = 2.5;\n\t\tWaitingPawn = Other;\n\t\tif ( Other.Base == self )\n\t\t\tAttach(Other);\n\t\treturn true;\n\t}\n\n\tfunction Attach( actor Other )\n\t{\n\t\tlocal pawn  P;\n\n\t\tP = Pawn(Other);\n\t\tif ( (BumpType != BT_AnyBump) && (P == None) )\n\t\t\treturn;\n\t\tif ( (BumpType == BT_PlayerBump) && !P.bIsPlayer )\n\t\t\treturn;\n\t\tif ( (BumpType == BT_PawnBump) && (Other.Mass < 10) )\n\t\t\treturn;\n\t\tSavedTrigger = None;\n\t\tGotoState( 'StandOpenTimed', 'Open' );\n\t}\nOpen:\n\tDisable( 'Attach' );\n\tif ( DelayTime > 0 )\n\t{\n\t\tbDelaying = true;\n\t\tSleep(DelayTime);\n\t}\n\tDoOpen();\n\tFinishInterpolation();\n\tFinishedOpening();\n\tSleep( StayOpenTime );\n\tif( bTriggerOnceOnly )\n\t\tGotoState('');\nClose:\n\tDoClose();\n\tFinishInterpolation();\n\tFinishedClosing();\n\tEnable( 'Attach' );\n}\n\ndefaultproperties\n{\n     MoverEncroachType=ME_ReturnWhenEncroach\n     MoverGlideType=MV_GlideByTime\n     NumKeys=2\n     MoveTime=1.000000\n     StayOpenTime=4.000000\n     bStatic=False\n     Physics=PHYS_MovingBrush\n     RemoteRole=ROLE_SimulatedProxy\n     InitialState=BumpOpenTimed\n     bIsMover=True\n     bAlwaysRelevant=True\n     SoundVolume=228\n     TransientSoundVolume=3.000000\n     CollisionRadius=160.000000\n     CollisionHeight=160.000000\n     bCollideActors=True\n     bBlockActors=True\n     bBlockPlayers=True\n     NetPriority=2.700000\n}\n",
            "name": "Mover.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "MoverEncroachType=ME_ReturnWhenEncroach",
                    "MoverGlideType=MV_GlideByTime",
                    "NumKeys=2",
                    "MoveTime=1.000000",
                    "StayOpenTime=4.000000",
                    "bStatic=False",
                    "Physics=PHYS_MovingBrush",
                    "RemoteRole=ROLE_SimulatedProxy",
                    "InitialState=BumpOpenTimed",
                    "bIsMover=True",
                    "bAlwaysRelevant=True",
                    "SoundVolume=228",
                    "TransientSoundVolume=3.000000",
                    "CollisionRadius=160.000000",
                    "CollisionHeight=160.000000",
                    "bCollideActors=True",
                    "bBlockActors=True",
                    "bBlockPlayers=True",
                    "NetPriority=2.700000"
                ],
                "exec": [],
                "extends": "Brush",
                "functions": {
                    "Attach": {
                        "body": "{\n\n\t\tP = Pawn(Other);\n\t\tif ( (BumpType != BT_AnyBump) && (P == None) )\n\t\t\treturn;\n\t\tif ( (BumpType == BT_PlayerBump) && !P.bIsPlayer )\n\t\t\treturn;\n\t\tif ( (BumpType == BT_PawnBump) && (Other.Mass < 10) )\n\t\t\treturn;\n\t\tSavedTrigger = None;\n\t\tGotoState( 'StandOpenTimed', 'Open' );\n\t}",
                        "locals": [
                            "local pawn  P;"
                        ],
                        "modifiers": [],
                        "name": "Attach",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "BeginEvent": {
                        "body": "{\n\t\tbSlave=true;\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginEvent",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BeginPlay": {
                        "body": "{\n\n\t// timer updates real position every second in network play\n\tif ( Level.NetMode != NM_Standalone )\n\t{\n\t\tif ( Level.NetMode == NM_Client )\n\t\t\tsettimer(4.0, true);\n\t\telse\n\t\t\tsettimer(1.0, true);\n\t\tif ( Role < ROLE_Authority )\n\t\t\treturn;\n\t}\n\n\tif ( Level.NetMode != NM_Client )\n\t{\n\t\tRealPosition = Location;\n\t\tRealRotation = Rotation;\n\t}\n\n\t// Init key info.\n\tSuper.BeginPlay();\n\tKeyNum         = Clamp( KeyNum, 0, ArrayCount(KeyPos)-1 );\n\tPhysAlpha      = 0.0;\n\n\t// Set initial location.\n\tMove( BasePos + KeyPos[KeyNum] - Location );\n\n\t// Initial rotation.\n\tSetRotation( BaseRot + KeyRot[KeyNum] );\n\n\t// find movers in same group\n\tif ( ReturnGroup == '' )\n\t\tReturnGroup = tag;\n}",
                        "locals": [
                            "local rotator R;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "BeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BeginState": {
                        "body": "{\n\t\tnumTriggerEvents = 0;\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Bump": {
                        "body": "{\n\t\tif ( (BumpType != BT_AnyBump) && (Pawn(Other) == None) )\n\t\t\treturn;\n\t\tif ( (BumpType == BT_PlayerBump) && !Pawn(Other).bIsPlayer )\n\t\t\treturn;\n\t\tif ( (BumpType == BT_PawnBump) && (Other.Mass < 10) )\n\t\t\treturn;\n\t\tGlobal.Bump( Other );\n\t\tSavedTrigger = Other;\n\t\tInstigator = Pawn( Other );\n\t\tGotoState( 'BumpButton', 'Open' );\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Bump",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "DoClose": {
                        "body": "{\n\n\tbOpening = false;\n\tbDelaying = false;\n\tInterpolateTo( Max(0,KeyNum-1), MoveTime );\n//\tPlaySound( ClosingSound, SLOT_None );\n\t// DEUS_EX CNN - make the sounds use SoundRadius and SoundVolume\n\tPlaySound( ClosingSound, SLOT_None, TransientSoundVolume*SoundVolume/255.0,, 25.0*(SoundRadius+1) );\n\tif( Event != '' )\n\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\tA.UnTrigger( Self, Instigator );\n\tAmbientSound = MoveAmbientSound;\n}",
                        "locals": [
                            "local actor A;"
                        ],
                        "modifiers": [],
                        "name": "DoClose",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DoOpen": {
                        "body": "{\n\tbOpening = true;\n\tbDelaying = false;\n\tInterpolateTo( 1, MoveTime );\n//\tPlaySound( OpeningSound, SLOT_None );\n\t// DEUS_EX CNN - make the sounds use SoundRadius and SoundVolume\n\tPlaySound( OpeningSound, SLOT_None, TransientSoundVolume*SoundVolume/255.0,, 25.0*(SoundRadius+1) );\n\tAmbientSound = MoveAmbientSound;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "DoOpen",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "EncroachingOn": {
                        "body": "{\n\tif ( Other.IsA('Carcass') || Other.IsA('Decoration') )\n\t{\n\t\tOther.TakeDamage(10000, None, Other.Location, vect(0,0,0), 'Crushed');\n\t\treturn false;\n\t}\n\t// DEUS_EX CNN - Don't destroy inventory items when encroached!\n//\tif ( Other.IsA('Fragment') || (Other.IsA('Inventory') && (Other.Owner == None)) )\n\tif (Other.IsA('Fragment'))\n\t{\n\t\tOther.Destroy();\n\t\treturn false;\n\t}\n\n\t// DEUS_EX CNN - make based actors not stop movers\n\tif (Other.Base == Self)\n\t{\n\t\treturn False;\n\t}\n\n\t// Damage the encroached actor.\n\tif( EncroachDamage != 0 )\n\t\tOther.TakeDamage( EncroachDamage, Instigator, Other.Location, vect(0,0,0), 'Crushed' );\n\n\t// If we have a bump-player event, and Other is a pawn, do the bump thing.\n\tP = Pawn(Other);\n\tif( P!=None && P.bIsPlayer )\n\t{\n\t\tif ( PlayerBumpEvent!='' )\n\t\t\tBump( Other );\n\t\tif ( (MyMarker != None) && (P.Base != self) \n\t\t\t&& (P.Location.Z < MyMarker.Location.Z - P.CollisionHeight - 0.7 * MyMarker.CollisionHeight) )\n\t\t\t// pawn is under lift - tell him to move\n\t\t\tP.UnderLift(self);\n\t}\n\n\t// Stop, return, or whatever.\n\tif( MoverEncroachType == ME_StopWhenEncroach )\n\t{\n\t\tLeader.MakeGroupStop();\n\t\treturn true;\n\t}\n\telse if( MoverEncroachType == ME_ReturnWhenEncroach )\n\t{\n\t\tLeader.MakeGroupReturn();\n\t\tif ( Other.IsA('Pawn') )\n\t\t{\n\t\t\tif ( Pawn(Other).bIsPlayer )\n\t\t\t\tPawn(Other).PlaySound(Pawn(Other).Land, SLOT_None);\t\t\t// DEUS_EX CNN - Changed from SLOT_Talk\n\t\t\telse\n\t\t\t\tPawn(Other).PlaySound(Pawn(Other).HitSound1, SLOT_None);\t// DEUS_EX CNN - Changed from SLOT_Talk\n\t\t}\t\n\t\treturn true;\n\t}\n\telse if( MoverEncroachType == ME_CrushWhenEncroach )\n\t{\n\t\t// Kill it.\n\t\tOther.KilledBy( Instigator );\n\t\treturn false;\n\t}\n\telse if( MoverEncroachType == ME_IgnoreWhenEncroach )\n\t{\n\t\t// Ignore it.\n\t\treturn false;\n\t}\n}",
                        "locals": [
                            "local Pawn P;"
                        ],
                        "modifiers": [],
                        "name": "EncroachingOn",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": "bool"
                    },
                    "EndEvent": {
                        "body": "{\n\t\tbSlave     = false;\n\t\tInstigator = None;\n\t\tGotoState( 'BumpButton', 'Close' );\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "EndEvent",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FindTriggerActor": {
                        "body": "{\n\n\tTriggerActor = None;\n\tTriggerActor2 = None;\n\tForEach AllActors(class 'Actor', A)\n\t\tif ( (A.Event == Tag) && (A.IsA('Trigger') || A.IsA('Mover')) )\n\t\t{\n\t\t\tif ( A.IsA('Counter') || A.IsA('Pawn') )\n\t\t\t{\n\t\t\t\tbPlayerOnly = true;\n\t\t\t\treturn; //FIXME - handle counters\n\t\t\t}\n\t\t\tif (TriggerActor == None)\n\t\t\t\tTriggerActor = A;\n\t\t\telse if ( TriggerActor2 == None )\n\t\t\t\tTriggerActor2 = A;\n\t\t}\n\n\tif ( TriggerActor == None )\n\t{\n\t\tbPlayerOnly = (BumpType == BT_PlayerBump);\n\t\treturn;\n\t}\n\n\tbPlayerOnly = ( TriggerActor.IsA('Trigger') && (Trigger(TriggerActor).TriggerType == TT_PlayerProximity) );\n\tif ( bPlayerOnly && ( TriggerActor2 != None) )\n\t{\n\t\tbPlayerOnly = ( TriggerActor2.IsA('Trigger') && (Trigger(TriggerActor).TriggerType == TT_PlayerProximity) );\n\t\tif ( !bPlayerOnly )\n\t\t{\n\t\t\tA = TriggerActor;\n\t\t\tTriggerActor = TriggerActor2;\n\t\t\tTriggerActor2 = A;\n\t\t}\n\t}\n}",
                        "locals": [
                            "local Actor A;"
                        ],
                        "modifiers": [],
                        "name": "FindTriggerActor",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FinishNotify": {
                        "body": "{\n\n\tif ( StandingCount > 0 )\n\t\tfor ( P=Level.PawnList; P!=None; P=P.nextPawn )\n\t\t\tif ( P.Base == self )\n\t\t\t{\n\t\t\t\tP.StopWaiting();\n\t\t\t\tif ( (P.SpecialGoal == self) || (P.SpecialGoal == myMarker) )\n\t\t\t\t\tP.SpecialGoal = None; \n\t\t\t\tif ( P == WaitingPawn )\n\t\t\t\t\tWaitingPawn = None;\n\t\t\t}\n\n\tif ( WaitingPawn != None )\n\t{\n\t\tWaitingPawn.StopWaiting();\n\t\tif ( (WaitingPawn.SpecialGoal == self) || (WaitingPawn.SpecialGoal == myMarker) )\n\t\t\tWaitingPawn.SpecialGoal = None; \n\t\tWaitingPawn = None;\n\t}\n}",
                        "locals": [
                            "local Pawn P;"
                        ],
                        "modifiers": [],
                        "name": "FinishNotify",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FinishedClosing": {
                        "body": "{\n\t// Update sound effects.\n//\tPlaySound( ClosedSound, SLOT_None );\n\t// DEUS_EX CNN - make the sounds use SoundRadius and SoundVolume\n\tPlaySound( ClosedSound, SLOT_None, TransientSoundVolume*SoundVolume/255.0,, 25.0*(SoundRadius+1) );\n\n\t// Notify our triggering actor that we have completed.\n\tif( SavedTrigger != None )\n\t\tSavedTrigger.EndEvent();\n\tSavedTrigger = None;\n\tInstigator = None;\n\tFinishNotify(); \n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "FinishedClosing",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FinishedOpening": {
                        "body": "{\n\n\t// Update sound effects.\n//\tPlaySound( OpenedSound, SLOT_None );\n\t// DEUS_EX CNN - make the sounds use SoundRadius and SoundVolume\n\tPlaySound( OpenedSound, SLOT_None, TransientSoundVolume*SoundVolume/255.0,, 25.0*(SoundRadius+1) );\n\t\n\t// Trigger any chained movers.\n\tif( Event != '' )\n\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\tA.Trigger( Self, Instigator );\n\n\tFinishNotify();\n}",
                        "locals": [
                            "local actor A;"
                        ],
                        "modifiers": [],
                        "name": "FinishedOpening",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "HandleDoor": {
                        "body": "{\n\t\tif ( bPlayerOnly && !Other.bIsPlayer )\n\t\t\treturn false;\n\t\tOther.SpecialPause = 2.5;\n\t\tWaitingPawn = Other;\n\t\tif ( Other.Base == self )\n\t\t\tAttach(Other);\n\t\treturn true;\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "HandleDoor",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": "bool"
                    },
                    "HandleTriggerDoor": {
                        "body": "{\n\n\tif ( bOpening || bDelaying )\n\t{\n\t\tWaitingPawn = Other;\n\t\tOther.SpecialPause = 2.5;\n\t\treturn true;\n\t}\n\tif ( bPlayerOnly && !Other.bIsPlayer )\n\t\treturn false;\n\tif ( bUseTriggered )\n\t{\n\t\tWaitingPawn = Other;\n\t\tOther.SpecialPause = 2.5;\n\t\tTrigger(Other, Other);\n\t\treturn true;\n\t}\n\tif ( (BumpEvent == tag) || (Other.bIsPlayer && (PlayerBumpEvent == tag)) )\n\t{\n\t\tWaitingPawn = Other;\n\t\tOther.SpecialPause = 2.5;\n\t\tif ( Other.Base == Self )\n\t\t\tTrigger(Other, Other);\n\t\treturn true;\n\t}\n\tif ( bDamageTriggered )\n\t{\n\t\tWaitingPawn = Other;\n\t\tOther.SpecialGoal = self;\n\t\tif ( !Other.bCanDoSpecial || (Other.Weapon == None) )\n\t\t\treturn false;\n\n\t\tOther.Target = self;\n\t\tOther.bShootSpecial = true;\n\t\tOther.FireWeapon();\n\t\tTrigger(Self, Other);\n\t\tOther.bFire = 0;\n\t\tOther.bAltFire = 0;\n\t\treturn true;\n\t}\n\n\tif ( RecommendedTrigger != None )\n\t{\n\t\tOther.SpecialGoal = RecommendedTrigger;\n\t\tOther.MoveTarget = RecommendedTrigger;\n\t\treturn True;\n\t}\n\n\tbOne = ( (TriggerActor != None) \n\t\t\t&& (!TriggerActor.IsA('Trigger') || Trigger(TriggerActor).IsRelevant(Other)) );\n\tbTwo = ( (TriggerActor2 != None) \n\t\t\t&& (!TriggerActor2.IsA('Trigger') || Trigger(TriggerActor2).IsRelevant(Other)) );\n\t\n\tif ( bOne && bTwo )\n\t{\n\t\t// Dotp, dist\n\t\tDist1 = VSize(TriggerActor.Location - Other.Location);\n\t\tDist2 = VSize(TriggerActor2.Location - Other.Location);\n\t\tif ( Dist1 < Dist2 )\n\t\t{\n\t\t\tif ( (Dist1 < 500) && Other.ActorReachable(TriggerActor) )\n\t\t\t\tbTwo = false;\n\t\t}\n\t\telse if ( (Dist2 < 500) && Other.ActorReachable(TriggerActor2) )\n\t\t\tbOne = false;\n\t\t\n\t\tif ( bOne && bTwo )\n\t\t{\n\t\t\tDP1 = Normal(Location - Other.Location) Dot (TriggerActor.Location - Other.Location)/Dist1;\n\t\t\tDP2 = Normal(Location - Other.Location) Dot (TriggerActor2.Location - Other.Location)/Dist2;\n\t\t\tif ( (DP1 > 0) && (DP2 < 0) )\n\t\t\t\tbOne = false;\n\t\t\telse if ( (DP1 < 0) && (DP2 > 0) )\n\t\t\t\tbTwo = false;\n\t\t\telse if ( Dist1 < Dist2 )\n\t\t\t\tbTwo = false;\n\t\t\telse \n\t\t\t\tbOne = false;\n\t\t}\n\t}\n\n\tif ( bOne )\n\t{\n\t\tOther.SpecialGoal = TriggerActor;\n\t\tOther.MoveTarget = TriggerActor;\n\t\treturn True;\n\t}\n\telse if ( bTwo )\n\t{\n\t\tOther.SpecialGoal = TriggerActor2;\n\t\tOther.MoveTarget = TriggerActor2;\n\t\treturn True;\n\t}\n\treturn false;\n}",
                        "locals": [
                            "local bool bOne, bTwo;",
                            "local float DP1, DP2, Dist1, Dist2;"
                        ],
                        "modifiers": [],
                        "name": "HandleTriggerDoor",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": "bool"
                    },
                    "InterpolateEnd": {
                        "body": "{\n\n\tOldKeyNum  = PrevKeyNum;\n\tPrevKeyNum = KeyNum;\n\tPhysAlpha  = 0;\n\tClientUpdate--;\n\n\t// If more than two keyframes, chain them.\n\tif( KeyNum>0 && KeyNum<OldKeyNum )\n\t{\n\t\t// Chain to previous.\n\t\tInterpolateTo(KeyNum-1,MoveTime);\n\t}\n\telse if( KeyNum<NumKeys-1 && KeyNum>OldKeyNum )\n\t{\n\t\t// Chain to next.\n\t\tInterpolateTo(KeyNum+1,MoveTime);\n\t}\n\telse\n\t{\n\t\t// Finished interpolating.\n\t\tAmbientSound = None;\n\t\tif ( (ClientUpdate == 0) && (Level.NetMode != NM_Client) )\n\t\t{\n\t\t\tRealPosition = Location;\n\t\t\tRealRotation = Rotation;\n\t\t}\n\t}\n}",
                        "locals": [
                            "local byte OldKeyNum;"
                        ],
                        "modifiers": [],
                        "name": "InterpolateEnd",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "InterpolateTo": {
                        "body": "{\n\tNewKeyNum = Clamp( NewKeyNum, 0, ArrayCount(KeyPos)-1 );\n\tif( NewKeyNum==PrevKeyNum && KeyNum!=PrevKeyNum )\n\t{\n\t\t// Reverse the movement smoothly.\n\t\tPhysAlpha = 1.0 - PhysAlpha;\n\t\tOldPos    = BasePos + KeyPos[KeyNum];\n\t\tOldRot    = BaseRot + KeyRot[KeyNum];\n\t}\n\telse\n\t{\n\t\t// Start a new movement.\n\t\tOldPos    = Location;\n\t\tOldRot    = Rotation;\n\t\tPhysAlpha = 0.0;\n\t}\n\n\t// Setup physics.\n\tSetPhysics(PHYS_MovingBrush);\n\tbInterpolating   = true;\n\tPrevKeyNum       = KeyNum;\n\tKeyNum\t\t\t = NewKeyNum;\n\tPhysRate         = 1.0 / FMax(Seconds, 0.005);\n\n\tClientUpdate++;\n\tSimOldPos = OldPos;\n\tSimOldRotYaw = OldRot.Yaw;\n\tSimOldRotPitch = OldRot.Pitch;\n\tSimOldRotRoll = OldRot.Roll;\n\tSimInterpolate.X = 100 * PhysAlpha;\n\tSimInterpolate.Y = 100 * FMax(0.01, PhysRate);\n\tSimInterpolate.Z = 256 * PrevKeyNum + KeyNum;\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "InterpolateTo",
                        "native": false,
                        "param": [
                            [
                                "byte",
                                "NewKeyNum"
                            ],
                            [
                                "float",
                                "Seconds"
                            ]
                        ],
                        "return": ""
                    },
                    "MakeGroupReturn": {
                        "body": "{\n\t// Abort move and reverse course.\n\tbInterpolating = false;\n\tAmbientSound = None;\n\tif( KeyNum<PrevKeyNum )\n\t\tGotoState( , 'Open' );\n\telse\n\t\tGotoState( , 'Close' );\n\n\tif ( Follower != None )\n\t\tFollower.MakeGroupReturn();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "MakeGroupReturn",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "MakeGroupStop": {
                        "body": "{\n\t// Stop moving immediately.\n\tbInterpolating = false;\n\tAmbientSound = None;\n\tGotoState( , '' );\n\n\tif ( Follower != None )\n\t\tFollower.MakeGroupStop();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "MakeGroupStop",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\n\t//brushes can't be deleted, so if not relevant, make it invisible and non-colliding\n\tif ( !Level.Game.IsRelevant(self) )\n\t{\n\t\tSetCollision(false, false, false);\n\t\tSetLocation(Location + vect(0,0,20000)); // temp since still in bsp\n\t\tbHidden = true;\n\t}\n\telse\n\t{\n\t\tFindTriggerActor();\n\t\t// Initialize all slaves.\n\t\tif( !bSlave )\n\t\t{\n\t\t\tforeach AllActors( class 'Mover', M, Tag )\n\t\t\t{\n\t\t\t\tif( M.bSlave )\n\t\t\t\t{\n\t\t\t\t\tM.GotoState('');\n\t\t\t\t\tM.SetBase( Self );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( Leader == None )\n\t\t{\t\n\t\t\tLeader = self;\n\t\t\tForEach AllActors( class'Mover', M )\n\t\t\t\tif ( (M != self) && (M.ReturnGroup == ReturnGroup) )\n\t\t\t\t{\n\t\t\t\t\tM.Leader = self;\n\t\t\t\t\tM.Follower = Follower;\n\t\t\t\t\tFollower = M;\n\t\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local mover M;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetKeyframe": {
                        "body": "{\n\tKeyNum         = Clamp( NewKeyNum, 0, ArrayCount(KeyPos)-1 );\n\tKeyPos[KeyNum] = NewLocation;\n\tKeyRot[KeyNum] = NewRotation;\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "SetKeyframe",
                        "native": false,
                        "param": [
                            [
                                "byte",
                                "NewKeyNum"
                            ],
                            [
                                "vector",
                                "NewLocation"
                            ],
                            [
                                "rotator",
                                "NewRotation"
                            ]
                        ],
                        "return": ""
                    },
                    "SpecialHandling": {
                        "body": "{\n\tif ( bDamageTriggered )\t\n\t{\n\t\tif ( !Other.bCanDoSpecial || (Other.Weapon == None) )\n\t\t\treturn None;\n\n\t\tOther.Target = self;\n\t\tOther.bShootSpecial = true;\n\t\tOther.FireWeapon();\n\t\tOther.bFire = 0;\n\t\tOther.bAltFire = 0;\n\t\treturn self;\n\t}\n\n\tif ( BumpType == BT_PlayerBump && !Other.bIsPlayer )\n\t\treturn None;\n\n\treturn self;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SpecialHandling",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": "Actor"
                    },
                    "Timer": {
                        "body": "{\n\tif ( Velocity != vect(0,0,0) )\n\t{\n\t\tbClientPause = false;\n\t\treturn;\t\t\n\t}\n\tif ( Level.NetMode == NM_Client )\n\t{\n\t\tif ( ClientUpdate == 0 ) // not doing a move\n\t\t{\n\t\t\tif ( bClientPause )\n\t\t\t{\n\t\t\t\tif ( VSize(RealPosition - Location) > 3 )\n\t\t\t\t\tSetLocation(RealPosition);\n\t\t\t\telse\n\t\t\t\t\tRealPosition = Location;\n\t\t\t\tSetRotation(RealRotation);\n\t\t\t\tbClientPause = false;\n\t\t\t}\n\t\t\telse if ( RealPosition != Location )\n\t\t\t\tbClientPause = true;\n\t\t}\n\t\telse\n\t\t\tbClientPause = false;\n\t}\n\telse \n\t{\n\t\tRealPosition = Location;\n\t\tRealRotation = Rotation;\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "{\n\t\tnumTriggerEvents++;\n\t\tSavedTrigger = Other;\n\t\tInstigator = EventInstigator;\n\t\tGotoState( 'TriggerPound', 'Open' );\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    },
                    "UnTrigger": {
                        "body": "{\n\t\tnumTriggerEvents--;\n\t\tif ( numTriggerEvents <= 0 )\n\t\t{\n\t\t\tnumTriggerEvents = 0;\n\t\t\tSavedTrigger = None;\n\t\t\tInstigator = None;\n\t\t\tGotoState( 'TriggerPound', 'Close' );\n\t\t}\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UnTrigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 1058,
                "replication": "",
                "states": [],
                "variables": [
                    "var() enum EMoverEncroachType",
                    "var() enum EMoverGlideType",
                    "var() enum EBumpType",
                    "var() byte       KeyNum;           // Current or destination keyframe.",
                    "var byte         PrevKeyNum;       // Previous keyframe.",
                    "var() const byte NumKeys;          // Number of keyframes in total (0-3).",
                    "var() const byte WorldRaytraceKey; // Raytrace the world with the brush here.",
                    "var() const byte BrushRaytraceKey; // Raytrace the brush here.",
                    "var() float      MoveTime;         // Time to spend moving between keyframes.",
                    "var() float      StayOpenTime;     // How long to remain open before closing.",
                    "var() float      OtherTime;        // TriggerPound stay-open time.",
                    "var() int        EncroachDamage;   // How much to damage encroached actors.",
                    "var() bool       bTriggerOnceOnly; // Go dormant after first trigger.",
                    "var() bool       bSlave;           // This brush is a slave.",
                    "var() bool\t\t bUseTriggered;\t\t// Triggered by player grab",
                    "var() bool\t\t bDamageTriggered;\t// Triggered by taking damage",
                    "var() bool       bDynamicLightMover; // Apply dynamic lighting to mover.",
                    "var() name       PlayerBumpEvent;  // Optional event to cause when the player bumps the mover.",
                    "var() name       BumpEvent;\t\t\t// Optional event to cause when any valid bumper bumps the mover.",
                    "var   actor      SavedTrigger;      // Who we were triggered by.",
                    "var() float\t\t DamageThreshold;\t// minimum damage to trigger",
                    "var() name\t\t ReturnGroup;\t\t// if none, same as tag",
                    "var() float\t\t DelayTime;\t\t\t// delay before starting to open",
                    "var(MoverSounds) sound      OpeningSound;     // When start opening.",
                    "var(MoverSounds) sound      OpenedSound;      // When finished opening.",
                    "var(MoverSounds) sound      ClosingSound;     // When start closing.",
                    "var(MoverSounds) sound      ClosedSound;      // When finish closing.",
                    "var(MoverSounds) sound      MoveAmbientSound; // Optional ambient sound when moving.",
                    "var vector       KeyPos[8];",
                    "var rotator      KeyRot[8];",
                    "var vector       BasePos, OldPos, OldPrePivot, SavedPos;",
                    "var rotator      BaseRot, OldRot, SavedRot;",
                    "var       NavigationPoint  myMarker;",
                    "var     rotator\t\t\tRealRotation;"
                ]
            }
        },
        "MusicEvent.uc": {
            "body": "//=============================================================================\n// MusicEvent.\n//=============================================================================\nclass MusicEvent extends Triggers;\n\n// Variables.\nvar() music            Song;\nvar() byte             SongSection;\nvar() byte             CdTrack;\nvar() EMusicTransition Transition;\nvar() bool             bSilence;\nvar() bool             bOnceOnly;\nvar() bool             bAffectAllPlayers;\n\n// When gameplay starts.\nfunction BeginPlay()\n{\n\tif( Song==None )\n\t{\n\t\tSong = Level.Song;\n\t}\n\tif( bSilence )\n\t{\n\t\tSongSection = 255;\n\t\tCdTrack     = 255;\n\t}\n}\n\n// When triggered.\nfunction Trigger( actor Other, pawn EventInstigator )\n{\n\tlocal PlayerPawn P;\n\tlocal Pawn A;\n\n\tif( bAffectAllPlayers )\n\t{\n\t\tA = Level.PawnList;\n\t\tWhile ( A != None )\n\t\t{\n\t\t\tif ( A.IsA('PlayerPawn') )\n\t\t\t\tPlayerPawn(A).ClientSetMusic( Song, SongSection, CdTrack, Transition );\n\t\t\tA = A.nextPawn;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Only affect the one player.\n\t\tP = PlayerPawn(EventInstigator);\n\t\tif( P==None )\n\t\t\treturn;\n\t\t\t\n\t\t// Go to music.\n\t\tP.ClientSetMusic( Song, SongSection, CdTrack, Transition );\n\t}\t\n\n\t// Turn off if once-only.\n\tif( bOnceOnly )\n\t{\n\t\tSetCollision(false,false,false);\n\t\tdisable( 'Trigger' );\n\t}\n}\n\ndefaultproperties\n{\n     CdTrack=255\n     Transition=MTRAN_Fade\n     bAffectAllPlayers=True\n}\n",
            "name": "MusicEvent.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "CdTrack=255",
                    "Transition=MTRAN_Fade",
                    "bAffectAllPlayers=True"
                ],
                "exec": [],
                "extends": "Triggers",
                "functions": {
                    "BeginPlay": {
                        "body": "{\n\tif( Song==None )\n\t{\n\t\tSong = Level.Song;\n\t}\n\tif( bSilence )\n\t{\n\t\tSongSection = 255;\n\t\tCdTrack     = 255;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "{\n\n\tif( bAffectAllPlayers )\n\t{\n\t\tA = Level.PawnList;\n\t\tWhile ( A != None )\n\t\t{\n\t\t\tif ( A.IsA('PlayerPawn') )\n\t\t\t\tPlayerPawn(A).ClientSetMusic( Song, SongSection, CdTrack, Transition );\n\t\t\tA = A.nextPawn;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// Only affect the one player.\n\t\tP = PlayerPawn(EventInstigator);\n\t\tif( P==None )\n\t\t\treturn;\n\t\t\t\n\t\t// Go to music.\n\t\tP.ClientSetMusic( Song, SongSection, CdTrack, Transition );\n\t}\t\n\n\t// Turn off if once-only.\n\tif( bOnceOnly )\n\t{\n\t\tSetCollision(false,false,false);\n\t\tdisable( 'Trigger' );\n\t}\n}",
                        "locals": [
                            "local PlayerPawn P;",
                            "local Pawn A;"
                        ],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 70,
                "replication": "",
                "states": [],
                "variables": [
                    "var() music            Song;",
                    "var() byte             SongSection;",
                    "var() byte             CdTrack;",
                    "var() EMusicTransition Transition;",
                    "var() bool             bSilence;",
                    "var() bool             bOnceOnly;",
                    "var() bool             bAffectAllPlayers;"
                ]
            }
        },
        "Mutator.uc": {
            "body": "//=============================================================================\n// Mutator.\n// called by the IsRelevant() function of DeathMatchPlus\n// by adding new mutators, you can change actors in the level without requiring\n// a new game class.  Multiple mutators can be linked together. \n//=============================================================================\nclass Mutator expands Info\n\tnative;\n\nvar Mutator NextMutator;\nvar Mutator NextDamageMutator;\n\nvar class<Weapon> DefaultWeapon;\n\nevent PreBeginPlay()\n{\n\t//Don't call Actor PreBeginPlay()\n}\n\nsimulated event PostRender( canvas Canvas );\n\nfunction ModifyPlayer(Pawn Other)\n{\n\t// called by GameInfo.RestartPlayer()\n\tif ( NextMutator != None )\n\t\tNextMutator.ModifyPlayer(Other);\n}\n\nfunction ScoreKill(Pawn Killer, Pawn Other)\n{\n\t// called by GameInfo.ScoreKill()\n\tif ( NextMutator != None )\n\t\tNextMutator.ScoreKill(Killer, Other);\n}\n\n// return what should replace the default weapon\n// mutators further down the list override earlier mutators\nfunction Class<Weapon> MutatedDefaultWeapon()\n{\n\tlocal Class<Weapon> W;\n\n\tif ( NextMutator != None )\n\t{\n\t\tW = NextMutator.MutatedDefaultWeapon();\n\t\tif ( W == Level.Game.DefaultWeapon )\n\t\t\tW = MyDefaultWeapon();\n\t}\n\telse\n\t\tW = MyDefaultWeapon();\n\treturn W;\n}\n\nfunction Class<Weapon> MyDefaultWeapon()\n{\n\tif ( DefaultWeapon != None )\n\t\treturn DefaultWeapon;\n\telse\n\t\treturn Level.Game.DefaultWeapon;\n}\n\nfunction AddMutator(Mutator M)\n{\n\tif ( NextMutator == None )\n\t\tNextMutator = M;\n\telse\n\t\tNextMutator.AddMutator(M);\n}\n\n/* ReplaceWith()\nCall this function to replace an actor Other with an actor of aClass.\n*/\nfunction bool ReplaceWith(actor Other, string aClassName)\n{\n\tlocal Actor A;\n\tlocal class<Actor> aClass;\n\n\tif ( Other.IsA('Inventory') && (Other.Location == vect(0,0,0)) )\n\t\treturn false;\n\taClass = class<Actor>(DynamicLoadObject(aClassName, class'Class'));\n\tif ( aClass != None )\n\t\tA = Spawn(aClass,,Other.tag,Other.Location, Other.Rotation);\n\tif ( Other.IsA('Inventory') )\n\t{\n\t\tif ( Inventory(Other).MyMarker != None )\n\t\t{\n\t\t\tInventory(Other).MyMarker.markedItem = Inventory(A);\n\t\t\tif ( Inventory(A) != None )\n\t\t\t{\n\t\t\t\tInventory(A).MyMarker = Inventory(Other).MyMarker;\n\t\t\t\tA.SetLocation(A.Location \n\t\t\t\t\t+ (A.CollisionHeight - Other.CollisionHeight) * vect(0,0,1));\n\t\t\t}\n\t\t\tInventory(Other).MyMarker = None;\n\t\t}\n\t\telse if ( A.IsA('Inventory') )\n\t\t{\n\t\t\tInventory(A).bHeldItem = true;\n\t\t\tInventory(A).Respawntime = 0.0;\n\t\t}\n\t}\n\tif ( A != None )\n\t{\n\t\tA.event = Other.event;\n\t\tA.tag = Other.tag;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* Force game to always keep this actor, even if other mutators want to get rid of it\n*/\nfunction bool AlwaysKeep(Actor Other)\n{\n\tif ( NextMutator != None )\n\t\treturn ( NextMutator.AlwaysKeep(Other) );\n\treturn false;\n}\n\nfunction bool IsRelevant(Actor Other, out byte bSuperRelevant)\n{\n\tlocal bool bResult;\n\n\t// allow mutators to remove actors\n\tbResult = CheckReplacement(Other, bSuperRelevant);\n\tif ( bResult && (NextMutator != None) )\n\t\tbResult = NextMutator.IsRelevant(Other, bSuperRelevant);\n\n\treturn bResult;\n}\n\nfunction bool CheckReplacement(Actor Other, out byte bSuperRelevant)\n{\n\treturn true;\n}\n\nfunction Mutate(string MutateString, PlayerPawn Sender)\n{\n\tif ( NextMutator != None )\n\t\tNextMutator.Mutate(MutateString, Sender);\n}\n\nfunction MutatorTakeDamage( out int ActualDamage, Pawn Victim, Pawn InstigatedBy, out Vector HitLocation, \n\t\t\t\t\t\tout Vector Momentum, name DamageType)\n{\n\tif ( NextDamageMutator != None )\n\t\tNextDamageMutator.MutatorTakeDamage( ActualDamage, Victim, InstigatedBy, HitLocation, Momentum, DamageType );\n}\n\ndefaultproperties\n{\n}\n",
            "name": "Mutator.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Info",
                "functions": {
                    "AddMutator": {
                        "body": "{\n\tif ( NextMutator == None )\n\t\tNextMutator = M;\n\telse\n\t\tNextMutator.AddMutator(M);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AddMutator",
                        "native": false,
                        "param": [
                            [
                                "Mutator",
                                "M"
                            ]
                        ],
                        "return": ""
                    },
                    "AlwaysKeep": {
                        "body": "{\n\tif ( NextMutator != None )\n\t\treturn ( NextMutator.AlwaysKeep(Other) );\n\treturn false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AlwaysKeep",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": "bool"
                    },
                    "CheckReplacement": {
                        "body": "{\n\treturn true;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CheckReplacement",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ],
                            [
                                "out",
                                "byte",
                                "bSuperRelevant"
                            ]
                        ],
                        "return": "bool"
                    },
                    "IsRelevant": {
                        "body": "{\n\n\t// allow mutators to remove actors\n\tbResult = CheckReplacement(Other, bSuperRelevant);\n\tif ( bResult && (NextMutator != None) )\n\t\tbResult = NextMutator.IsRelevant(Other, bSuperRelevant);\n\n\treturn bResult;\n}",
                        "locals": [
                            "local bool bResult;"
                        ],
                        "modifiers": [],
                        "name": "IsRelevant",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ],
                            [
                                "out",
                                "byte",
                                "bSuperRelevant"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ModifyPlayer": {
                        "body": "{\n\t// called by GameInfo.RestartPlayer()\n\tif ( NextMutator != None )\n\t\tNextMutator.ModifyPlayer(Other);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ModifyPlayer",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "Mutate": {
                        "body": "{\n\tif ( NextMutator != None )\n\t\tNextMutator.Mutate(MutateString, Sender);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Mutate",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "MutateString"
                            ],
                            [
                                "PlayerPawn",
                                "Sender"
                            ]
                        ],
                        "return": ""
                    },
                    "MutatedDefaultWeapon": {
                        "body": "{\n\n\tif ( NextMutator != None )\n\t{\n\t\tW = NextMutator.MutatedDefaultWeapon();\n\t\tif ( W == Level.Game.DefaultWeapon )\n\t\t\tW = MyDefaultWeapon();\n\t}\n\telse\n\t\tW = MyDefaultWeapon();\n\treturn W;\n}",
                        "locals": [
                            "local Class<Weapon> W;"
                        ],
                        "modifiers": [],
                        "name": "MutatedDefaultWeapon",
                        "native": false,
                        "param": [],
                        "return": "Class<Weapon>"
                    },
                    "MyDefaultWeapon": {
                        "body": "{\n\tif ( DefaultWeapon != None )\n\t\treturn DefaultWeapon;\n\telse\n\t\treturn Level.Game.DefaultWeapon;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "MyDefaultWeapon",
                        "native": false,
                        "param": [],
                        "return": "Class<Weapon>"
                    },
                    "PostRender": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PostRender",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\t//Don't call Actor PreBeginPlay()\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ReplaceWith": {
                        "body": "{\n\n\tif ( Other.IsA('Inventory') && (Other.Location == vect(0,0,0)) )\n\t\treturn false;\n\taClass = class<Actor>(DynamicLoadObject(aClassName, class'Class'));\n\tif ( aClass != None )\n\t\tA = Spawn(aClass,,Other.tag,Other.Location, Other.Rotation);\n\tif ( Other.IsA('Inventory') )\n\t{\n\t\tif ( Inventory(Other).MyMarker != None )\n\t\t{\n\t\t\tInventory(Other).MyMarker.markedItem = Inventory(A);\n\t\t\tif ( Inventory(A) != None )\n\t\t\t{\n\t\t\t\tInventory(A).MyMarker = Inventory(Other).MyMarker;\n\t\t\t\tA.SetLocation(A.Location \n\t\t\t\t\t+ (A.CollisionHeight - Other.CollisionHeight) * vect(0,0,1));\n\t\t\t}\n\t\t\tInventory(Other).MyMarker = None;\n\t\t}\n\t\telse if ( A.IsA('Inventory') )\n\t\t{\n\t\t\tInventory(A).bHeldItem = true;\n\t\t\tInventory(A).Respawntime = 0.0;\n\t\t}\n\t}\n\tif ( A != None )\n\t{\n\t\tA.event = Other.event;\n\t\tA.tag = Other.tag;\n\t\treturn true;\n\t}\n\treturn false;\n}",
                        "locals": [
                            "local Actor A;",
                            "local class<Actor> aClass;"
                        ],
                        "modifiers": [],
                        "name": "ReplaceWith",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "string",
                                "aClassName"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ScoreKill": {
                        "body": "{\n\t// called by GameInfo.ScoreKill()\n\tif ( NextMutator != None )\n\t\tNextMutator.ScoreKill(Killer, Other);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ScoreKill",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Killer"
                            ],
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 152,
                "replication": "",
                "states": [],
                "variables": [
                    "var Mutator NextMutator;",
                    "var Mutator NextDamageMutator;",
                    "var class<Weapon> DefaultWeapon;"
                ]
            }
        },
        "NavigationPoint.uc": {
            "body": "//=============================================================================\n// NavigationPoint.\n//=============================================================================\nclass NavigationPoint extends Actor\n\tnative;\n\n#exec Texture Import File=Textures\\S_Pickup.pcx Name=S_Pickup Mips=Off Flags=2\n\n//------------------------------------------------------------------------------\n// NavigationPoint variables\nvar() name ownerTeam;\t//creature clan owning this area (area visible from this point)\nvar bool taken; //set when a creature is occupying this spot\nvar int upstreamPaths[16];\nvar int Paths[16]; //index of reachspecs (used by C++ Navigation code)\nvar int PrunedPaths[16];\nvar NavigationPoint VisNoReachPaths[16]; //paths that are visible but not directly reachable\nvar int visitedWeight;\nvar actor routeCache;\nvar const int bestPathWeight;\nvar const NavigationPoint nextNavigationPoint;\nvar const NavigationPoint nextOrdered;\nvar const NavigationPoint prevOrdered;\nvar const NavigationPoint startPath;\nvar const NavigationPoint previousPath;\nvar int cost; //added cost to visit this pathnode\nvar() int ExtraCost;\nvar() bool bPlayerOnly;\t//only players should use this path\n\nvar bool bEndPoint; //used by C++ navigation code\nvar bool bEndPointOnly; //only used as an endpoint in routing network\nvar bool bSpecialCost;\t//if true, navigation code will call SpecialCost function for this navigation point\nvar() bool bOneWayPath;\t//reachspecs from this path only in the direction the path is facing (180 degrees)\nvar() bool bNeverUseStrafing; // shouldn't use bAdvancedTactics going to this point\n\nnative(519) final function describeSpec(int iSpec, out Actor Start, out Actor End, out int ReachFlags, out int Distance); \nevent int SpecialCost(Pawn Seeker);\n\n// Accept an actor that has teleported in.\n// used for random spawning and initial placement of creatures\nevent bool Accept( actor Incoming, actor Source )\n{\n\t// Move the actor here.\n\ttaken = Incoming.SetLocation( Location + vect (0,0,20));\n\tif (taken)\n\t{\n\t\tIncoming.Velocity = vect(0,0,0);\n\t\tIncoming.SetRotation(Rotation);\n\t}\n\t// Play teleport-in effect.\n\tPlayTeleportEffect(Incoming, true);\n\treturn taken;\n}\n\nfunction PlayTeleportEffect(actor Incoming, bool bOut)\n{\n\tLevel.Game.PlayTeleportEffect(Incoming, bOut, false);\n}\n\ndefaultproperties\n{\n     upstreamPaths(0)=-1\n     upstreamPaths(1)=-1\n     upstreamPaths(2)=-1\n     upstreamPaths(3)=-1\n     upstreamPaths(4)=-1\n     upstreamPaths(5)=-1\n     upstreamPaths(6)=-1\n     upstreamPaths(7)=-1\n     upstreamPaths(8)=-1\n     upstreamPaths(9)=-1\n     upstreamPaths(10)=-1\n     upstreamPaths(11)=-1\n     upstreamPaths(12)=-1\n     upstreamPaths(13)=-1\n     upstreamPaths(14)=-1\n     upstreamPaths(15)=-1\n     Paths(0)=-1\n     Paths(1)=-1\n     Paths(2)=-1\n     Paths(3)=-1\n     Paths(4)=-1\n     Paths(5)=-1\n     Paths(6)=-1\n     Paths(7)=-1\n     Paths(8)=-1\n     Paths(9)=-1\n     Paths(10)=-1\n     Paths(11)=-1\n     Paths(12)=-1\n     Paths(13)=-1\n     Paths(14)=-1\n     Paths(15)=-1\n     PrunedPaths(0)=-1\n     PrunedPaths(1)=-1\n     PrunedPaths(2)=-1\n     PrunedPaths(3)=-1\n     PrunedPaths(4)=-1\n     PrunedPaths(5)=-1\n     PrunedPaths(6)=-1\n     PrunedPaths(7)=-1\n     PrunedPaths(8)=-1\n     PrunedPaths(9)=-1\n     PrunedPaths(10)=-1\n     PrunedPaths(11)=-1\n     PrunedPaths(12)=-1\n     PrunedPaths(13)=-1\n     PrunedPaths(14)=-1\n     PrunedPaths(15)=-1\n     bStatic=True\n     bHidden=True\n     bCollideWhenPlacing=True\n     SoundVolume=0\n     CollisionRadius=12.000000\n     CollisionHeight=15.000000\n}\n",
            "name": "NavigationPoint.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "upstreamPaths(0)=-1",
                    "upstreamPaths(1)=-1",
                    "upstreamPaths(2)=-1",
                    "upstreamPaths(3)=-1",
                    "upstreamPaths(4)=-1",
                    "upstreamPaths(5)=-1",
                    "upstreamPaths(6)=-1",
                    "upstreamPaths(7)=-1",
                    "upstreamPaths(8)=-1",
                    "upstreamPaths(9)=-1",
                    "upstreamPaths(10)=-1",
                    "upstreamPaths(11)=-1",
                    "upstreamPaths(12)=-1",
                    "upstreamPaths(13)=-1",
                    "upstreamPaths(14)=-1",
                    "upstreamPaths(15)=-1",
                    "Paths(0)=-1",
                    "Paths(1)=-1",
                    "Paths(2)=-1",
                    "Paths(3)=-1",
                    "Paths(4)=-1",
                    "Paths(5)=-1",
                    "Paths(6)=-1",
                    "Paths(7)=-1",
                    "Paths(8)=-1",
                    "Paths(9)=-1",
                    "Paths(10)=-1",
                    "Paths(11)=-1",
                    "Paths(12)=-1",
                    "Paths(13)=-1",
                    "Paths(14)=-1",
                    "Paths(15)=-1",
                    "PrunedPaths(0)=-1",
                    "PrunedPaths(1)=-1",
                    "PrunedPaths(2)=-1",
                    "PrunedPaths(3)=-1",
                    "PrunedPaths(4)=-1",
                    "PrunedPaths(5)=-1",
                    "PrunedPaths(6)=-1",
                    "PrunedPaths(7)=-1",
                    "PrunedPaths(8)=-1",
                    "PrunedPaths(9)=-1",
                    "PrunedPaths(10)=-1",
                    "PrunedPaths(11)=-1",
                    "PrunedPaths(12)=-1",
                    "PrunedPaths(13)=-1",
                    "PrunedPaths(14)=-1",
                    "PrunedPaths(15)=-1",
                    "bStatic=True",
                    "bHidden=True",
                    "bCollideWhenPlacing=True",
                    "SoundVolume=0",
                    "CollisionRadius=12.000000",
                    "CollisionHeight=15.000000"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\S_Pickup.pcx Name=S_Pickup Mips=Off Flags=2"
                ],
                "extends": "Actor",
                "functions": {
                    "Accept": {
                        "body": "{\n\t// Move the actor here.\n\ttaken = Incoming.SetLocation( Location + vect (0,0,20));\n\tif (taken)\n\t{\n\t\tIncoming.Velocity = vect(0,0,0);\n\t\tIncoming.SetRotation(Rotation);\n\t}\n\t// Play teleport-in effect.\n\tPlayTeleportEffect(Incoming, true);\n\treturn taken;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Accept",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Incoming"
                            ],
                            [
                                "actor",
                                "Source"
                            ]
                        ],
                        "return": "bool"
                    },
                    "PlayTeleportEffect": {
                        "body": "{\n\tLevel.Game.PlayTeleportEffect(Incoming, bOut, false);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayTeleportEffect",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Incoming"
                            ],
                            [
                                "bool",
                                "bOut"
                            ]
                        ],
                        "return": ""
                    },
                    "SpecialCost": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SpecialCost",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Seeker"
                            ]
                        ],
                        "return": "int"
                    },
                    "describeSpec": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "describeSpec",
                        "native": true,
                        "param": [
                            [
                                "int",
                                "iSpec"
                            ],
                            [
                                "out",
                                "Actor",
                                "Start"
                            ],
                            [
                                "out",
                                "Actor",
                                "End"
                            ],
                            [
                                "out",
                                "int",
                                "ReachFlags"
                            ],
                            [
                                "out",
                                "int",
                                "Distance"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 116,
                "replication": "",
                "states": [],
                "variables": [
                    "var() name ownerTeam;\t//creature clan owning this area (area visible from this point)",
                    "var bool taken; //set when a creature is occupying this spot",
                    "var int upstreamPaths[16];",
                    "var int Paths[16]; //index of reachspecs (used by C++ Navigation code)",
                    "var int PrunedPaths[16];",
                    "var NavigationPoint VisNoReachPaths[16]; //paths that are visible but not directly reachable",
                    "var int visitedWeight;",
                    "var actor routeCache;",
                    "var const int bestPathWeight;",
                    "var const NavigationPoint nextNavigationPoint;",
                    "var const NavigationPoint nextOrdered;",
                    "var const NavigationPoint prevOrdered;",
                    "var const NavigationPoint startPath;",
                    "var const NavigationPoint previousPath;",
                    "var int cost; //added cost to visit this pathnode",
                    "var() int ExtraCost;",
                    "var() bool bPlayerOnly;\t//only players should use this path",
                    "var bool bEndPoint; //used by C++ navigation code",
                    "var bool bEndPointOnly; //only used as an endpoint in routing network",
                    "var bool bSpecialCost;\t//if true, navigation code will call SpecialCost function for this navigation point",
                    "var() bool bOneWayPath;\t//reachspecs from this path only in the direction the path is facing (180 degrees)",
                    "var() bool bNeverUseStrafing; // shouldn't use bAdvancedTactics going to this point"
                ]
            }
        },
        "Palette.uc": {
            "body": "//=============================================================================\n// Palette: A 256-color Unreal palette.\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass Palette extends Object\n\tnative\n\tnoexport;\n\nvar native const array<Color> Colors;\n\ndefaultproperties\n{\n}\n",
            "name": "Palette.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Object",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 14,
                "replication": "",
                "states": [],
                "variables": [
                    "var native const array<Color> Colors;"
                ]
            }
        },
        "PathNode.uc": {
            "body": "//=============================================================================\n// PathNode.\n//=============================================================================\nclass PathNode extends NavigationPoint\n\tnative;\n\ndefaultproperties\n{\n     Texture=Texture'Engine.S_Pickup'\n     SoundVolume=128\n}\n",
            "name": "PathNode.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Texture=Texture'Engine.S_Pickup'",
                    "SoundVolume=128"
                ],
                "exec": [],
                "extends": "NavigationPoint",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 12,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "PatrolPoint.uc": {
            "body": "//=============================================================================\n// PatrolPoint.\n//=============================================================================\nclass PatrolPoint extends NavigationPoint;\n\n#exec Texture Import File=Textures\\Pathnode.pcx Name=S_Patrol Mips=Off Flags=2\n\nvar() name Nextpatrol; //next point to go to\nvar() float pausetime; //how long to pause here\nvar\t vector lookdir; //direction to look while stopped\nvar() name PatrolAnim;\nvar() sound PatrolSound;\nvar() byte numAnims;\nvar int\tAnimCount;\nvar PatrolPoint NextPatrolPoint;\n\n\n/*DEUS_EX STM -- fixed a bug involving NextPatrolPoint\nfunction PreBeginPlay()\n{\n\tif (pausetime > 0.0)\n\t\tlookdir = 200 * vector(Rotation);\n\n\t//find the patrol point with the tag specified by Nextpatrol\n\tforeach AllActors(class 'PatrolPoint', NextPatrolPoint, Nextpatrol)\n\t\tbreak; \n\t\n\tSuper.PreBeginPlay();\n}\n*/\nfunction PreBeginPlay()\n{\n\tlocal PatrolPoint CurPoint;\n\n\tlookdir = 200 * vector(Rotation);\n\n\t//find the patrol point with the tag specified by Nextpatrol\n\tNextPatrolPoint = None;\n\tif (NextPatrol != '')\n\t{\n\t\tforeach AllActors(class 'PatrolPoint', CurPoint, Nextpatrol)\n\t\t{\n\t\t\tif (CurPoint != self)\n\t\t\t{\n\t\t\t\tNextPatrolPoint = CurPoint;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tSuper.PreBeginPlay();\n}\n// DEUS_EX STM -- end changes\n\ndefaultproperties\n{\n     bDirectional=True\n     Texture=Texture'Engine.S_Patrol'\n     SoundVolume=128\n}\n",
            "name": "PatrolPoint.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bDirectional=True",
                    "Texture=Texture'Engine.S_Patrol'",
                    "SoundVolume=128"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Pathnode.pcx Name=S_Patrol Mips=Off Flags=2"
                ],
                "extends": "NavigationPoint",
                "functions": {
                    "PreBeginPlay": {
                        "body": "{\n\n\tlookdir = 200 * vector(Rotation);\n\n\t//find the patrol point with the tag specified by Nextpatrol\n\tNextPatrolPoint = None;\n\tif (NextPatrol != '')\n\t{\n\t\tforeach AllActors(class 'PatrolPoint', CurPoint, Nextpatrol)\n\t\t{\n\t\t\tif (CurPoint != self)\n\t\t\t{\n\t\t\t\tNextPatrolPoint = CurPoint;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tSuper.PreBeginPlay();\n}",
                        "locals": [
                            "local PatrolPoint CurPoint;"
                        ],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 61,
                "replication": "",
                "states": [],
                "variables": [
                    "var() name Nextpatrol; //next point to go to",
                    "var() float pausetime; //how long to pause here",
                    "var() name PatrolAnim;",
                    "var() sound PatrolSound;",
                    "var() byte numAnims;",
                    "var int\tAnimCount;",
                    "var PatrolPoint NextPatrolPoint;"
                ]
            }
        },
        "Pawn.uc": {
            "body": "//=============================================================================\n// Pawn, the base class of all actors that can be controlled by players or AI.\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass Pawn extends Actor \n\tabstract\n\tnative\n\tnativereplication;\n\n#exec Texture Import File=Textures\\Pawn.pcx Name=S_Pawn Mips=Off Flags=2\n\n//-----------------------------------------------------------------------------\n// Pawn variables.\n\n// General flags.\nvar bool\t\tbBehindView;    // Outside-the-player view.\nvar bool        bIsPlayer;      // Pawn is a player or a player-bot.\nvar bool\t\tbJustLanded;\t// used by eyeheight adjustment\nvar bool\t\tbUpAndOut;\t\t// used by swimming \nvar bool\t\tbIsWalking;\nvar const bool\tbHitSlopedWall;\t// used by Physics\nvar globalconfig bool\tbNeverSwitchOnPickup;\t// if true, don't automatically switch to picked up weapon\nvar bool\t\tbWarping;\t\t// Set when travelling through warpzone (so shouldn't telefrag)\nvar bool\t\tbUpdatingDisplay; // to avoid infinite recursion through inventory setdisplay\n\n//AI flags\nvar(Combat) bool\tbCanStrafe;\nvar(Orders) bool\tbFixedStart;\nvar const bool\t\tbReducedSpeed;\t\t//used by movement natives\nvar\t\tbool\t\tbCanJump;\nvar\t\tbool \t\tbCanWalk;\nvar\t\tbool\t\tbCanSwim;\nvar\t\tbool\t\tbCanFly;\nvar\t\tbool\t\tbCanOpenDoors;\nvar\t\tbool\t\tbCanDoSpecial;\nvar\t\tbool\t\tbDrowning;\nvar const bool\t\tbLOSflag;\t\t\t// used for alternating LineOfSight traces\nvar \tbool \t\tbFromWall;\nvar\t\tbool\t\tbHunting;\t\t\t// tells navigation code that pawn is hunting another pawn,\n\t\t\t\t\t\t\t\t\t\t//\tso fall back to finding a path to a visible pathnode if none\n\t\t\t\t\t\t\t\t\t\t//\tare reachable\nvar\t\tbool\t\tbAvoidLedges;\t\t// don't get too close to ledges\nvar\t\tbool\t\tbStopAtLedges;\t\t// if bAvoidLedges and bStopAtLedges, Pawn doesn't try to walk along the edge at all\nvar\t\tbool\t\tbJumpOffPawn;\t\t\nvar\t\tbool\t\tbShootSpecial;\nvar\t\tbool\t\tbAutoActivate;\nvar\t\tbool\t\tbIsHuman;\t\t\t// for games which care about whether a pawn is a human\nvar\t\tbool\t\tbIsFemale;\nvar\t\tbool\t\tbIsMultiSkinned;\nvar\t\tbool\t\tbCountJumps;\nvar\t\tbool\t\tbAdvancedTactics;\t// used during movement between pathnodes\nvar\t\tbool\t\tbViewTarget;\nvar\t\tbool\t\tbCanGlide;   // DEUS_EX STM -- added for flying/swimming states\n\n// Ticked pawn timers\nvar\t\tfloat\t\tSightCounter;\t//Used to keep track of when to check player visibility\nvar\t\tfloat       PainTime;\t\t//used for getting PainTimer() messages (for Lava, no air, etc.)\nvar\t\tfloat\t\tSpeechTime;\t\n\n// Physics updating time monitoring (for AI monitoring reaching destinations)\nvar const\tfloat\t\tAvgPhysicsTime;\n\n// Additional pawn region information.\nvar PointRegion FootRegion;\nvar PointRegion HeadRegion;\n\n// Navigation AI\nvar \tfloat\t\tMoveTimer;\nvar \tActor\t\tMoveTarget;\t\t// set by movement natives\nvar\t\tActor\t\tFaceTarget;\t\t// set by strafefacing native\nvar\t\tvector\t \tDestination;\t// set by Movement natives\nvar\t \tvector\t\tFocus;\t\t\t// set by Movement natives\nvar\t\tfloat\t\tDesiredSpeed;\nvar\t\tfloat\t\tMaxDesiredSpeed;\nvar(Combat) float\tMeleeRange; // Max range for melee attack (not including collision radii)\n\n// Player and enemy movement.\nvar(Movement) float      GroundSpeed;     // The maximum ground speed.\nvar(Movement) float      WaterSpeed;      // The maximum swimming speed.\nvar(Movement) float      AirSpeed;        // The maximum flying speed.\nvar(Movement) float\t\t AccelRate;\t\t  // max acceleration rate\nvar(Movement) float\t\t JumpZ;      \t\t// vertical acceleration w/ jump\nvar(Movement) float      MaxStepHeight;   // Maximum size of upward/downward step.\nvar(Movement) float      AirControl;\t\t// amount of AirControl available to the pawn\n\n// AI basics.\nvar\t \tfloat\t\tMinHitWall;\t\t// Minimum HitNormal dot Velocity.Normal to get a HitWall from the\n\t\t\t\t\t\t\t\t\t// physics\nvar() \tbyte       \tVisibility;      //How visible is the pawn? 0 = invisible. \n\t\t\t\t\t\t\t\t\t// 128 = normal.  255 = highly visible.\nvar\t\tfloat\t\tAlertness; // -1 to 1 ->Used within specific states for varying reaction to stimuli \nvar\t\tfloat \t\tStimulus; // Strength of stimulus - Set when stimulus happens, used in Acquisition state \nvar(AI) float\t\tSightRadius;     //Maximum seeing distance.\nvar(AI) float\t\tPeripheralVision;//Cosine of limits of peripheral vision.\nvar(AI) float\t\tHearingThreshold;  //Minimum noise loudness for hearing\nvar\t\tvector\t\tLastSeenPos; \t\t// enemy position when I last saw enemy (auto updated if EnemyNotVisible() enabled)\nvar\t\tvector\t\tLastSeeingPos;\t\t// position where I last saw enemy (auto updated if EnemyNotVisible enabled)\nvar\t\tfloat\t\tLastSeenTime;\nvar\t \tPawn    \tEnemy;\n\n// Player info.\nvar travel Weapon       Weapon;        // The pawn's current weapon.\nvar Weapon\t\t\t\tPendingWeapon;\t// Will become weapon once current weapon is put down\nvar travel Inventory\tSelectedItem;\t// currently selected inventory item\n\n// Movement.\nvar rotator     \tViewRotation;  \t// View rotation.\nvar vector\t\t\tWalkBob;\nvar() float      \tBaseEyeHeight; \t// Base eye height above collision center.\nvar float        \tEyeHeight;     \t// Current eye height, adjusted for bobbing and stairs.\nvar\tconst\tvector\tFloor;\t\t\t// Normal of floor pawn is standing on (only used\n\t\t\t\t\t\t\t\t\t//\tby PHYS_Spider)\nvar float\t\t\tSplashTime;\t\t// time of last splash\n\n// View\nvar float        OrthoZoom;     // Orthogonal/map view zoom factor.\nvar() float      FovAngle;      // X field of view angle in degrees, usually 90.\n\n// Player game statistics.\nvar int\t\t\tDieCount, ItemCount, KillCount, SecretCount, Spree;\n\n//Health\nvar() travel int      Health;          // Health: 100 = normal maximum\n\n// Selection Mesh\nvar() string\t\t\tSelectionMesh;\nvar() string\t\t\tSpecialMesh;\n\n// Inherent Armor (for creatures).\nvar() name\tReducedDamageType; //Either a damagetype name or 'All', 'AllEnvironment' (Burned, Corroded, Frozen)\nvar() float ReducedDamagePct;\n\n// Inventory to drop when killed (for creatures)\nvar() class<inventory> DropWhenKilled;\n\n// Zone pain\nvar(Movement) float\t\tUnderWaterTime;  \t//how much time pawn can go without air (in seconds)\n\nvar(AI) enum EAttitude  //important - order in decreasing importance\n{\n\tATTITUDE_Fear,\t\t//will try to run away\n\tATTITUDE_Hate,\t\t// will attack enemy\n\tATTITUDE_Frenzy,\t//will attack anything, indiscriminately\n\tATTITUDE_Threaten,\t// animations, but no attack\n\tATTITUDE_Ignore,\n\tATTITUDE_Friendly,\n\tATTITUDE_Follow \t//accepts player as leader\n} AttitudeToPlayer;\t//determines how creature will react on seeing player (if in human form)\n\nvar(AI) enum EIntelligence //important - order in increasing intelligence\n{\n\tBRAINS_NONE, //only reacts to immediate stimulus\n\tBRAINS_REPTILE, //follows to last seen position\n\tBRAINS_MAMMAL, //simple navigation (limited path length)\n\tBRAINS_HUMAN   //complex navigation, team coordination, use environment stuff (triggers, etc.)\n}\tIntelligence;\n\nvar(AI) float\t\tSkill;\t\t\t// skill, scaled by game difficulty (add difficulty to this value)\t\nvar\t\tactor\t\tSpecialGoal;\t// used by navigation AI\nvar\t\tfloat\t\tSpecialPause;\n\n// Sound and noise management\nvar const \tvector \t\tnoise1spot;\nvar const \tfloat \t\tnoise1time;\nvar const\tpawn\t\tnoise1other;\nvar const\tfloat\t\tnoise1loudness;\nvar const \tvector \t\tnoise2spot;\nvar const \tfloat \t\tnoise2time;\nvar const\tpawn\t\tnoise2other;\nvar const\tfloat\t\tnoise2loudness;\nvar\t\t\tfloat\t\tLastPainSound;\n\n// chained pawn list\nvar const\tpawn\t\tnextPawn;\n\n// Common sounds\nvar(Sounds)\tsound\tHitSound1;\nvar(Sounds)\tsound\tHitSound2;\nvar(Sounds)\tsound\tLand;\nvar(Sounds)\tsound\tDie;\nvar(Sounds) sound\tWaterStep;\n\n// Input buttons.\nvar input byte\n\tbZoom, bRun, bLook, bDuck, bSnapLevel,\n\tbStrafe, bFire, bAltFire, bFreeLook, \n\tbExtra0, bExtra1, bExtra2, bExtra3;\n\nvar(Combat) float CombatStyle; // -1 to 1 = low means tends to stay off and snipe, high means tends to charge and melee\nvar NavigationPoint home; //set when begin play, used for retreating and attitude checks\n \nvar name NextState; //for queueing states\nvar name NextLabel; //for queueing states\n\nvar float SoundDampening;\nvar float DamageScaling;\n\nvar(Orders) name AlarmTag; // tag of object to go to when see player\nvar(Orders) name SharedAlarmTag;\nvar\ttravel Decoration\tcarriedDecoration;\n\nvar Name PlayerReStartState;\n\nvar() localized  string MenuName; //Name used for this pawn type in menus (e.g. player selection) \nvar() localized  string NameArticle; //article used in conjunction with this class (e.g. \"a\", \"an\")\n\nvar() byte VoicePitch; //for speech\nvar() string VoiceType; //for speech\nvar float OldMessageTime; //to limit frequency of voice messages\n\n// Route Cache for Navigation\nvar NavigationPoint RouteCache[16];\n\n// Replication Info\nvar() class<PlayerReplicationInfo> PlayerReplicationInfoClass;\nvar PlayerReplicationInfo PlayerReplicationInfo;\n\n// shadow decal\nvar Decal Shadow;\n\n//\n// hit extents for Deus Ex - DEUS_EX CNN\n//\nvar() travel int HealthHead;\nvar() travel int HealthTorso;\nvar() travel int HealthLegLeft;\nvar() travel int HealthLegRight;\nvar() travel int HealthArmLeft;\nvar() travel int HealthArmRight;\n\n//\n// lip synching stuff for Deus Ex - DEUS_EX CNN\n//\nvar bool bIsSpeaking;\t\t// are we speaking now\nvar bool bWasSpeaking;\t\t// were we speaking last frame?  (should we close our mouth?)\nvar string lastPhoneme;\t// phoneme last spoken\nvar string nextPhoneme;\t// phoneme to speak next\nvar float animTimer[4];\t\t// misc. timers for ambient anims (blink, head, etc.)\n\n//\n// misc. stuff for Deus Ex - DEUS_EX CNN\n//\nvar bool bOnFire;\nvar float burnTimer;\n\n//\n// additional AI variables - DEUS_EX STM\n//\nvar(AI)        float   AIHorizontalFov;            // degrees\nvar(AI)        float   AspectRatio;                // horizontal/vertical ratio\nvar(AI)        float   AngularResolution;          // degrees\nvar            float   MinAngularSize;             // tan(AngularResolution)^2\nvar(AI)        float   VisibilityThreshold;        // lowest visible brightness (0-1)\nvar(AI)        float   SmellThreshold;             // lowest smellable odor (0-1)\nvar(Alliances) Name    Alliance;                   // alliance tag\nvar            Rotator AIAddViewRotation;          // rotation added to view rotation for AICanSee()\n\n//\n// look direction - DEUS_EX STM\n//\nenum ELookDirection\n{\n\tLOOK_Forward,\n\tLOOK_Left,\n\tLOOK_Right,\n\tLOOK_Up,\n\tLOOK_Down\n};\n\nreplication\n{\n\t// Variables the server should send to the client.\n\treliable if( Role==ROLE_Authority )\n\t\tWeapon, PlayerReplicationInfo, Health, bCanFly, bIsWalking;\n\treliable if( bNetOwner && Role==ROLE_Authority )\n\t\t bIsPlayer, CarriedDecoration, SelectedItem,\n\t\t GroundSpeed, WaterSpeed, AirSpeed, AccelRate, JumpZ, AirControl,\n\t\t bBehindView, PlayerRestartState, HealthHead, HealthTorso, HealthLegLeft, HealthLegRight, HealthArmLeft, HealthArmRight, bOnFire, burnTimer;\n\tunreliable if( (bNetOwner && bIsPlayer && bNetInitial && Role==ROLE_Authority) || bDemoRecording )\n\t\tViewRotation;\n\tunreliable if( bNetOwner && Role==ROLE_Authority )\n         MoveTarget;\n\treliable if( bDemoRecording )\n\t\tEyeHeight;\n\n\t// Functions the server calls on the client side.\n\treliable if( RemoteRole==ROLE_AutonomousProxy ) \n\t\tClientDying, ClientReStart, ClientGameEnded, ClientSetRotation, ClientSetLocation, ClientPutDown;\n\tunreliable if( (!bDemoRecording || bClientDemoRecording && bClientDemoNetFunc) && Role==ROLE_Authority )\n\t\tClientHearSound;\n\treliable if ( (!bDemoRecording || (bClientDemoRecording && bClientDemoNetFunc)) && Role == ROLE_Authority )\n\t\tClientVoiceMessage;\n\treliable if ( (!bDemoRecording || (bClientDemoRecording && bClientDemoNetFunc) || (Level.NetMode==NM_Standalone && IsA('PlayerPawn'))) && Role == ROLE_Authority )\n\t\tClientMessage, TeamMessage, ReceiveLocalizedMessage;\n\n\t// Functions the client calls on the server.\n\tunreliable if( Role<ROLE_Authority )\n\t\tSendVoiceMessage, NextItem, SwitchToBestWeapon, TeamBroadcast;\n   reliable if(Role < ROLE_Authority)\n      DropDecoration;\n}\n\n// Latent Movement.\n//Note that MoveTo sets the actor's Destination, and MoveToward sets the\n//actor's MoveTarget.  Actor will rotate towards destination\n\nnative(500) final latent function MoveTo( vector NewDestination, optional float speed);\nnative(502) final latent function MoveToward(actor NewTarget, optional float speed);\nnative(504) final latent function StrafeTo(vector NewDestination, vector NewFocus, optional float speed);  // DEUS_EX STM - added new param\nnative(506) final latent function StrafeFacing(vector NewDestination, actor NewTarget, optional float speed);  // DEUS_EX STM - added new param\nnative(508) final latent function TurnTo(vector NewFocus);\nnative(510) final latent function TurnToward(actor NewTarget);\n\n// native AI functions\n//LineOfSightTo() returns true if any of several points of Other is visible\n//(but only if they are within 1000 distance units does it do the other checks, unless you use bIgnoreDistance) \n// (origin, top, bottom)\nnative(514) final function bool LineOfSightTo(actor Other, optional bool bIgnoreDistance); \n// CanSee() similar to line of sight, but also takes into account Pawn's peripheral vision\nnative(533) final function bool CanSee(actor Other); \nnative(518) final function Actor FindPathTo(vector aPoint, optional bool bSinglePath, \n\t\t\t\t\t\t\t\t\t\t\t\toptional bool bClearPaths);\nnative(517) final function Actor FindPathToward(actor anActor, optional bool bSinglePath, \n\t\t\t\t\t\t\t\t\t\t\t\toptional bool bClearPaths);\n\nnative(525) final function NavigationPoint FindRandomDest(optional bool bClearPaths);\n\nnative(522) final function ClearPaths();\nnative(523) final function vector EAdjustJump();\n\n//Reachable returns what part of direct path from Actor to aPoint is traversable\n//using the current locomotion method\nnative(521) final function bool pointReachable(vector aPoint);\nnative(520) final function bool actorReachable(actor anActor);\n\n/* PickWallAdjust()\nCheck if could jump up over obstruction (only if there is a knee height obstruction)\nIf so, start jump, and return current destination\nElse, try to step around - return a destination 90 degrees right or left depending on traces\nout and floor checks\n*/\nnative(526) final function bool PickWallAdjust();\nnative(524) final function int FindStairRotation(float DeltaTime);\nnative(527) final latent function WaitForLanding();\nnative(540) final function actor FindBestInventoryPath(out float MinWeight, bool bPredictRespawns);\n\nnative(529) final function AddPawn();\nnative(530) final function RemovePawn();\n\n// Pick best pawn target\nnative(531) final function pawn PickTarget(out float bestAim, out float bestDist, vector FireDir, vector projStart);\nnative(534) final function actor PickAnyTarget(out float bestAim, out float bestDist, vector FireDir, vector projStart);\n\n// New AI functions - DEUS_EX STM\nnative(705) final function float AICanSee(actor other, optional float visibility,\n                                          optional bool bCheckVisibility, optional bool bCheckDir,\n                                          optional bool bCheckCylinder, optional bool bCheckLOS);\nnative(706) final function float AICanHear(actor other, optional float Volume, optional float Radius);\nnative(707) final function float AICanSmell(actor other, optional float smell);\nnative(708) final function bool AIDirectionReachable(vector focus, int yaw, int pitch,\n                                                     float minDist, float maxDist, out vector bestDest);\nnative(709) final function bool AIPickRandomDestination(float minDist, float maxDist,\n                                                        int centralYaw, float yawDistribution,\n                                                        int centralPitch, float pitchDistribution,\n                                                        int tries, float multiplier,\n                                                        out vector dest);\nnative(1004) final iterator function ReachablePathnodes(class<NavigationPoint> BaseClass, out NavigationPoint NavPoint, Actor FromPoint,\n                                                        out float distance, optional bool bUsePrunedPaths);\nnative(1020) final function ComputePathnodeDistances(optional actor startActor);\n\n\n// Force end to sleep\nnative function StopWaiting();\n\nevent MayFall(); //return true if allowed to fall - called by engine when pawn is about to fall\nevent AlterDestination(); // called when using movetoward with bAdvancedTactics true to temporarily modify destination\nfunction EncroachedByMover(Mover encroacher);  // DEUS_EX STM\n\n\nsimulated event RenderOverlays( canvas Canvas )\n{\n\tif ( Weapon != None )\n\t\tWeapon.RenderOverlays(Canvas);\n}\n\nfunction String GetHumanName()\n{\n\tif ( PlayerReplicationInfo != None )\n\t\treturn PlayerReplicationInfo.PlayerName;\n\treturn NameArticle$MenuName;\n}\n\nfunction ClientPutDown(Weapon Current, Weapon Next)\n{\n\tCurrent.ClientPutDown(Next);\n}\n\nfunction SetDisplayProperties(ERenderStyle NewStyle, texture NewTexture, bool bLighting, bool bEnviroMap )\n{\n\tStyle = NewStyle;\n\ttexture = NewTexture;\n\tbUnlit = bLighting;\n\tbMeshEnviromap = bEnviromap;\n\tif ( Weapon != None )\n\t\tWeapon.SetDisplayProperties(Style, Texture, bUnlit, bMeshEnviromap);\n\n\tif ( !bUpdatingDisplay && (Inventory != None) )\n\t{\n\t\tbUpdatingDisplay = true;\n\t\tInventory.SetOwnerDisplay();\n\t}\n\tbUpdatingDisplay = false;\n}\n\nfunction SetDefaultDisplayProperties()\n{\n\tStyle = Default.Style;\n\ttexture = Default.Texture;\n\tbUnlit = Default.bUnlit;\n\tbMeshEnviromap = Default.bMeshEnviromap;\n\tif ( Weapon != None )\n\t\tWeapon.SetDisplayProperties(Weapon.Default.Style, Weapon.Default.Texture, Weapon.Default.bUnlit, Weapon.Default.bMeshEnviromap);\n\n\tif ( !bUpdatingDisplay && (Inventory != None) )\n\t{\n\t\tbUpdatingDisplay = true;\n\t\tInventory.SetOwnerDisplay();\n\t}\n\tbUpdatingDisplay = false;\n}\n\n//\n// Client gateway functions.\n//\nevent ClientMessage( coerce string S, optional name Type, optional bool bBeep );\nevent TeamMessage( PlayerReplicationInfo PRI, coerce string S, name Type, optional bool bBeep );\nevent ReceiveLocalizedMessage( class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject );\n\nfunction BecomeViewTarget()\n{\n\tbViewTarget = true;\n}\n\nevent FellOutOfWorld()\n{\n\tHealth = -1;\n\tSetPhysics(PHYS_None);\n\tWeapon = None;\n\tDied(None, 'Fell', Location);\n}\n\nfunction PlayRecoil(float Rate);\n\nfunction SpecialFire();\n\nfunction bool CheckFutureSight(float DeltaTime)\n{\n\treturn true;\n}\n\nfunction RestartPlayer();\n\n//\n// Broadcast a message to all players, or all on the same team.\n//\nfunction TeamBroadcast( coerce string Msg)\n{\n\tlocal Pawn P;\n\tlocal bool bGlobal;\n\n\tif ( Left(Msg, 1) ~= \"@\" )\n\t{\n\t\tMsg = Right(Msg, Len(Msg)-1);\n\t\tbGlobal = true;\n\t}\n\n\tif ( Left(Msg, 1) ~= \".\" )\n\t\tMsg = \".\"$VoicePitch$Msg;\n\n\tif ( bGlobal || !Level.Game.bTeamGame )\n\t{\n\t\tif ( Level.Game.AllowsBroadcast(self, Len(Msg)) )\n\t\t\tfor( P=Level.PawnList; P!=None; P=P.nextPawn )\n\t\t\t\tif( P.bIsPlayer  || P.IsA('MessagingSpectator') )\n\t\t\t\t\tP.TeamMessage( PlayerReplicationInfo, Msg, 'Say' );\n\t\treturn;\n\t}\n\t\t\n\tif ( Level.Game.AllowsBroadcast(self, Len(Msg)) )\n\t\tfor( P=Level.PawnList; P!=None; P=P.nextPawn )\n\t\t\tif( P.bIsPlayer && (P.PlayerReplicationInfo.Team == PlayerReplicationInfo.Team) )\n\t\t\t{\n\t\t\t\tif ( P.IsA('PlayerPawn') )\n\t\t\t\t\tP.TeamMessage( PlayerReplicationInfo, Msg, 'TeamSay' );\n\t\t\t}\n}\n\n//------------------------------------------------------------------------------\n// Speech related\n\nfunction SendGlobalMessage(PlayerReplicationInfo Recipient, name MessageType, byte MessageID, float Wait)\n{\n\tSendVoiceMessage(PlayerReplicationInfo, Recipient, MessageType, MessageID, 'GLOBAL');\n}\n\n\nfunction SendTeamMessage(PlayerReplicationInfo Recipient, name MessageType, byte MessageID, float Wait)\n{\n\tSendVoiceMessage(PlayerReplicationInfo, Recipient, MessageType, MessageID, 'TEAM');\n}\n\nfunction SendVoiceMessage(PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID, name broadcasttype)\n{\n\tlocal Pawn P;\n\tlocal bool bNoSpeak;\n\n\tif ( Level.TimeSeconds - OldMessageTime < 2.5 )\n\t\tbNoSpeak = true;\n\telse\n\t\tOldMessageTime = Level.TimeSeconds;\n\n\tfor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t{\n\t\tif ( P.IsA('PlayerPawn') )\n\t\t{  \n\t\t\tif ( !bNoSpeak )\n\t\t\t{\n\t\t\t\tif ( (broadcasttype == 'GLOBAL') || !Level.Game.bTeamGame )\n\t\t\t\t\tP.ClientVoiceMessage(Sender, Recipient, messagetype, messageID);\n\t\t\t\telse if ( Sender.Team == P.PlayerReplicationInfo.Team )\n\t\t\t\t\tP.ClientVoiceMessage(Sender, Recipient, messagetype, messageID);\n\t\t\t}\n\t\t}\n\t\telse if ( (P.PlayerReplicationInfo == Recipient) || ((messagetype == 'ORDER') && (Recipient == None)) )\n\t\t\tP.BotVoiceMessage(messagetype, messageID, self);\n\t}\n}\n\nfunction ClientVoiceMessage(PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID);\nfunction BotVoiceMessage(name messagetype, byte MessageID, Pawn Sender);\n\n//***************************************************************\nfunction HandleHelpMessageFrom(Pawn Other);\n\nfunction FearThisSpot(Actor ASpot);\n\nfunction float GetRating()\n{\n\treturn 1000;\n}\n\nfunction AddVelocity( vector NewVelocity)\n{\n\tif (Physics == PHYS_Walking)\n\t\tSetPhysics(PHYS_Falling);\n\tif ( (Velocity.Z > 380) && (NewVelocity.Z > 0) )\n\t\tNewVelocity.Z *= 0.5;\n\tVelocity += NewVelocity;\n}\n\nfunction ClientSetLocation( vector NewLocation, rotator NewRotation )\n{\n\tlocal Pawn P;\n\n\tViewRotation      = NewRotation;\n\tIf ( (ViewRotation.Pitch > RotationRate.Pitch) && (ViewRotation.Pitch < 65536 - RotationRate.Pitch) )\n\t{\n\t\tIf (ViewRotation.Pitch < 32768) \n\t\t\tNewRotation.Pitch = RotationRate.Pitch;\n\t\telse\n\t\t\tNewRotation.Pitch = 65536 - RotationRate.Pitch;\n\t}\n\n\tNewRotation.Roll  = 0;\n\tSetRotation( NewRotation );\n\tSetLocation( NewLocation );\n}\n\nfunction ClientSetRotation( rotator NewRotation )\n{\n\tlocal Pawn P;\n\n\tViewRotation      = NewRotation;\n\tNewRotation.Pitch = 0;\n\tNewRotation.Roll  = 0;\n\tSetRotation( NewRotation );\n}\n\nfunction ClientDying(name DamageType, vector HitLocation)\n{\n\tPlayDying(DamageType, HitLocation);\n\tGotoState('Dying');\n}\n\nfunction ClientReStart()\n{\n\t//log(\"client restart\");\n\n\tVelocity = vect(0,0,0);\n\tAcceleration = vect(0,0,0);\n\tBaseEyeHeight = Default.BaseEyeHeight;\n\tEyeHeight = BaseEyeHeight;\n\tPlayWaiting();\n\n\tif ( Region.Zone.bWaterZone && (PlayerRestartState == 'PlayerWalking') )\n\t{\n\t\tif (HeadRegion.Zone.bWaterZone)\n\t\t\t\tPainTime = UnderWaterTime;\n\t\tsetPhysics(PHYS_Swimming);\n\t\tGotoState('PlayerSwimming');\n\t}\n\telse\n\t\tGotoState(PlayerReStartState);\n}\n\nfunction ClientGameEnded()\n{\n\tGotoState('GameEnded');\n}\n\n//=============================================================================\n// Inventory related functions.\n\nfunction float AdjustDesireFor(Inventory Inv)\n{\n\treturn 0;\n}\n\n// toss out the weapon currently held\nfunction TossWeapon()\n{\n\tlocal vector X,Y,Z;\n\tif ( Weapon == None )\n\t\treturn;\n\tGetAxes(Rotation,X,Y,Z);\n\tWeapon.DropFrom(Location + 0.8 * CollisionRadius * X + - 0.5 * CollisionRadius * Y); \n}\t\n\n// The player/bot wants to select next item\nexec function NextItem()\n{\n\tlocal Inventory Inv;\n\n\t// DEUS_EX CNN - this function is EVIL!\n\treturn;\n\n\tif (SelectedItem==None) {\n\t\tSelectedItem = Inventory.SelectNext();\n\t\tReturn;\n\t}\n\tif (SelectedItem.Inventory!=None)\n\t\tSelectedItem = SelectedItem.Inventory.SelectNext(); \n\telse\n\t\tSelectedItem = Inventory.SelectNext();\n\n\tif ( SelectedItem == None )\n\t\tSelectedItem = Inventory.SelectNext();\n}\n\n// FindInventoryType()\n// returns the inventory item of the requested class\n// if it exists in this pawn's inventory \n\nfunction Inventory FindInventoryType( class DesiredClass )\n{\n\tlocal Inventory Inv;\n\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )   \n\t\tif ( Inv.class == DesiredClass )\n\t\t\treturn Inv;\n\treturn None;\n} \n\n// Add Item to this pawn's inventory. \n// Returns true if successfully added, false if not.\nfunction bool AddInventory( inventory NewItem )\n{\n\t// Skip if already in the inventory.\n\tlocal inventory Inv;\n\t\n\t// The item should not have been destroyed if we get here.\n\tif (NewItem ==None )\n\t\tlog(\"tried to add none inventory to \"$self);\n\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )\n\t\tif( Inv == NewItem )\n\t\t\treturn false;\n\n\t// DEUS_EX AJY\n\t// Update the previous owner's inventory chain\n\tif (NewItem.Owner != None)\n\t\tPawn(NewItem.Owner).DeleteInventory(NewItem);\n\n\t// Add to front of inventory chain.\n\tNewItem.SetOwner(Self);\n\tNewItem.Inventory = Inventory;\n\tInventory = NewItem;\n\n\n\treturn true;\n}\n\n// Remove Item from this pawn's inventory, if it exists.\n// Returns true if it existed and was deleted, false if it did not exist.\nfunction bool DeleteInventory( inventory Item )\n{\n\t// If this item is in our inventory chain, unlink it.\n\tlocal actor Link;\n\n\tif ( Item == Weapon )\n\t\tWeapon = None;\n\tif ( Item == SelectedItem )\n\t\tSelectedItem = None;\n\tfor( Link = Self; Link!=None; Link=Link.Inventory )\n\t{\n\t\tif( Link.Inventory == Item )\n\t\t{\n\t\t\tLink.Inventory = Item.Inventory;\n\t\t\tbreak;\n\t\t}\n\t}\n\tItem.SetOwner(None);\n}\n\n// Just changed to pendingWeapon\nfunction ChangedWeapon()\n{\n\tlocal Weapon OldWeapon;\n\n\tOldWeapon = Weapon;\n\n\tif (Weapon == PendingWeapon)\n\t{\n\t\tif ( Weapon == None )\n\t\t\tSwitchToBestWeapon();\n\t\telse if ( Weapon.IsInState('DownWeapon') ) \n\t\t\tWeapon.BringUp();\n\t\tif ( Weapon != None )\n\t\t\tWeapon.SetDefaultDisplayProperties();\n\t\tInventory.ChangedWeapon(); // tell inventory that weapon changed (in case any effect was being applied)\n\t\tPendingWeapon = None;\n\t\treturn;\n\t}\n\t// removed these lines so you don't automatically pick another weapon - DEUS_EX CNN\n//\tif ( PendingWeapon == None )\n//\t\tPendingWeapon = Weapon;\n\n\tPlayWeaponSwitch(PendingWeapon);\n\tif ( (PendingWeapon != None) && (PendingWeapon.Mass > 20) && (carriedDecoration != None) )\n\t\tDropDecoration();\n\tif ( Weapon != None )\n\t\tWeapon.SetDefaultDisplayProperties();\n\t\t\n\tWeapon = PendingWeapon;\n\tInventory.ChangedWeapon(); // tell inventory that weapon changed (in case any effect was being applied)\n\tif ( Weapon != None )\n\t{\n\t\tWeapon.RaiseUp(OldWeapon);\n\t\tif ( (Level.Game != None) && (Level.Game.Difficulty > 1) )\n\t\t\tMakeNoise(0.1 * Level.Game.Difficulty);\t\t\n\t}\n\tPendingWeapon = None;\n}\n\n//==============\n// Encroachment\nevent bool EncroachingOn( actor Other )\n{\n\tif ( (Other.Brush != None) || (Brush(Other) != None) )\n\t\treturn true;\n\t\t\n\tif ( (!bIsPlayer || bWarping) && (Pawn(Other) != None))\n\t\treturn true;\n\t\t\n\treturn false;\n}\n\nevent EncroachedBy( actor Other )\n{\n\tif ( Pawn(Other) != None )\n\t\tgibbedBy(Other);\n\t\t\n}\n\nfunction gibbedBy(actor Other)\n{\n\tlocal pawn instigatedBy;\n\n\tinstigatedBy = pawn(Other);\n\tif (instigatedBy == None)\n\t\tinstigatedBy = Other.instigator;\n\thealth = -1000; //make sure gibs\n\tDied(instigatedBy, 'Gibbed', Location);\n}\n\nevent PlayerTimeOut()\n{\n\tif (Health > 0)\n\t\tDied(None, 'Suicided', Location);\n}\n\n//Base change - if new base is pawn or decoration, damage based on relative mass and old velocity\n// Also, non-players will jump off pawns immediately\nfunction JumpOffPawn()\n{\n\tVelocity += 60 * VRand();\n\tVelocity.Z = 180;\n\tSetPhysics(PHYS_Falling);\n}\n\nfunction UnderLift(Mover M);\n\nsingular event BaseChange()\n{\n\tlocal float decorMass;\n\n\tif ( (base == None) && (Physics == PHYS_None) )\n\t\tSetPhysics(PHYS_Falling);\n\telse if (Pawn(Base) != None)\n\t{\n\t\tBase.TakeDamage( (1-Velocity.Z/400)* Mass/Base.Mass, Self,Location,0.5 * Velocity , 'stomped');\n\t\tJumpOffPawn();\n\t}\n\telse if ( (Decoration(Base) != None) && (Velocity.Z < -400) )\n\t{\n\t\tdecorMass = FMax(Decoration(Base).Mass, 1);\n\t\tBase.TakeDamage((-2* Mass/decorMass * Velocity.Z/400), Self, Location, 0.5 * Velocity, 'stomped');\n\t}\n}\n\nevent LongFall();\n\n//=============================================================================\n// Network related functions.\n\n\nsimulated event Destroyed()\n{\n\tlocal Inventory Inv;\n\tlocal Pawn OtherPawn;\n\n\tif ( Shadow != None )\n\t\tShadow.Destroy();\n\tRemovePawn();\n\tif ( Role < ROLE_Authority )\n\t\treturn;\n\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )   \n\t\tInv.Destroy();\n\tWeapon = None;\n\tInventory = None;\n\tif ( bIsPlayer && (Level.Game != None) )\n\t\tLevel.Game.logout(self);\n\tif ( PlayerReplicationInfo != None )\n\t\tPlayerReplicationInfo.Destroy();\n\tfor ( OtherPawn=Level.PawnList; OtherPawn!=None; OtherPawn=OtherPawn.nextPawn )\n\t\tOtherPawn.Killed(None, self, '');\n\tSuper.Destroyed();\n}\n\n//=============================================================================\n// functions.\n\n//\n// native client-side functions.\n//\nnative simulated event ClientHearSound ( \n\tactor Actor, \n\tint Id, \n\tsound S, \n\tvector SoundLocation, \n\tvector Parameters \n);\n\n//\n// Called immediately before gameplay begins.\n//\nevent PreBeginPlay()\n{\n\tAddPawn();\n\tSuper.PreBeginPlay();\n\tif ( bDeleteMe )\n\t\treturn;\n\n\t// Added angular size computation - DEUS_EX STM\n\tMinAngularSize = tan(AngularResolution*0.5*Pi/180.0);\n\tMinAngularSize *= MinAngularSize;\n\n\t// Set instigator to self.\n\tInstigator = Self;\n\tDesiredRotation = Rotation;\n\tSightCounter = 0.2 * FRand();  //offset randomly \n\tif ( Level.Game != None )\n\t\tSkill += Level.Game.Difficulty; \n\tSkill = FClamp(Skill, 0, 3);\n\tPreSetMovement();\n\t\n\tif ( DrawScale != Default.Drawscale )\n\t{\n\t\tSetCollisionSize(CollisionRadius*DrawScale/Default.DrawScale, CollisionHeight*DrawScale/Default.DrawScale);\n\t\tHealth = Health * DrawScale/Default.DrawScale;\n\t}\n\n\tif (bIsPlayer)\n\t{\n\t\tif (PlayerReplicationInfoClass != None)\n\t\t\tPlayerReplicationInfo = Spawn(PlayerReplicationInfoClass, Self,,vect(0,0,0),rot(0,0,0));\n\t\telse\n\t\t\tPlayerReplicationInfo = Spawn(class'PlayerReplicationInfo', Self,,vect(0,0,0),rot(0,0,0));\n\t\tInitPlayerReplicationInfo();\n\t}\n\n\tif (!bIsPlayer) \n\t{\n\t\tif ( BaseEyeHeight == 0 )\n\t\t\tBaseEyeHeight = 0.8 * CollisionHeight;\n\t\tEyeHeight = BaseEyeHeight;\n\t\tif (Fatness == 0) //vary monster fatness slightly if at default\n\t\t\tFatness = 120 + Rand(8) + Rand(8);\n\t}\n\n\tif ( menuname == \"\" )\n\t\tmenuname = GetItemName(string(class));\n\n\tif (SelectionMesh == \"\")\n\t\tSelectionMesh = string(Mesh);\n}\n\nevent PostBeginPlay()\n{\n\tSuper.PostBeginPlay();\n\tSplashTime = 0;\n}\n\nsimulated event PostNetBeginPlay()\n{\n   local pawn CurPawn;\n   local bool bAlreadyAdded;\n   \n   Super.PostNetBeginPlay();\n   bAlreadyAdded = false;\n   for (CurPawn = Level.PawnList; CurPawn != None; CurPawn = CurPawn.NextPawn)\n   {\n      if (CurPawn == Self)\n      {\n         bAlreadyAdded = true;\n         break;\n      }\n   }\n   if (!bAlreadyAdded)\n   {\n      AddPawn();\n   }\n   return;\n}\n\n/* PreSetMovement()\ndefault for walking creature.  Re-implement in subclass\nfor swimming/flying capability\n*/\nfunction PreSetMovement()\n{\n\tif (JumpZ > 0)\n\t\tbCanJump = true;\n\tbCanWalk = true;\n\tbCanSwim = false;\n\tbCanFly = false;\n\tMinHitWall = -0.6;\n\tif (Intelligence > BRAINS_Reptile)\n\t\tbCanOpenDoors = true;\n\tif (Intelligence == BRAINS_Human)\n\t\tbCanDoSpecial = true;\n}\n\n//=============================================================================\n// Multiskin support\nstatic function SetMultiSkin( actor SkinActor, string SkinName, string FaceName, byte TeamNum )\n{\n\tlocal Texture NewSkin;\n\n\tif(SkinName != \"\")\n\t{\n\t\tNewSkin = texture(DynamicLoadObject(SkinName, class'Texture'));\n\t\tif ( NewSkin != None )\n\t\t\tSkinActor.Skin = NewSkin;\n\t}\n}\n\nstatic function GetMultiSkin( Actor SkinActor, out string SkinName, out string FaceName )\n{\n\tSkinName = String(SkinActor.Skin);\n\tFaceName = \"\";\n}\n\nstatic function bool SetSkinElement(Actor SkinActor, int SkinNo, string SkinName, string DefaultSkinName)\n{\n\tlocal Texture NewSkin;\n\n\tNewSkin = Texture(DynamicLoadObject(SkinName, class'Texture'));\n\tif ( NewSkin != None )\n\t{\n\t\tSkinActor.Multiskins[SkinNo] = NewSkin;\n\t\treturn True;\n\t}\n\telse\n\t{\n\t\tlog(\"Failed to load \"$SkinName);\n\t\tif(DefaultSkinName != \"\")\n\t\t{\n\t\t\tNewSkin = Texture(DynamicLoadObject(DefaultSkinName, class'Texture'));\n\t\t\tSkinActor.Multiskins[SkinNo] = NewSkin;\n\t\t}\n\t\treturn False;\n\t}\n}\n\n//=============================================================================\n// Replication\nfunction InitPlayerReplicationInfo()\n{\n\tif (PlayerReplicationInfo.PlayerName == \"\")\n\t\tPlayerReplicationInfo.PlayerName = class'GameInfo'.Default.DefaultPlayerName;\n}\n\t\n//=============================================================================\n// Animation playing - should be implemented in subclass, \n//\n// PlayWaiting, PlayRunning, and PlayGutHit, PlayMovingAttack (if used)\n// and PlayDying are required to be implemented in the subclass\n\nfunction PlayRunning()\n{\n\t////log(\"Error - PlayRunning should be implemented in subclass of\"@class);\n}\n\nfunction PlayWalking()\n{\n\tPlayRunning(); \n}\n\nfunction PlayWaiting()\n{\n\t////log(\"Error - PlayWaiting should be implemented in subclass\");\n}\n\nfunction PlayMovingAttack()\n{\n\t////log(\"Error - PlayMovingAttack should be implemented in subclass\");\n\t//Note - must restart attack timer when done with moving attack\n\tPlayRunning();\n}\n\nfunction PlayWaitingAmbush()\n{\n\tPlayWaiting();\n}\n\nfunction TweenToFighter(float tweentime)\n{\n}\n\nfunction TweenToRunning(float tweentime)\n{\n\tTweenToFighter(0.1);\n}\n\nfunction TweenToWalking(float tweentime)\n{\n\tTweenToRunning(tweentime);\n}\n\nfunction TweenToPatrolStop(float tweentime)\n{\n\tTweenToFighter(tweentime);\n}\n\nfunction TweenToWaiting(float tweentime)\n{\n\tTweenToFighter(tweentime);\n}\n\nfunction PlayThreatening()\n{\n\tTweenToFighter(0.1);\n}\n\nfunction PlayPatrolStop()\n{\n\tPlayWaiting();\n}\n\nfunction PlayTurning()\n{\n\tTweenToFighter(0.1);\n}\n\nfunction PlayBigDeath(name DamageType);\nfunction PlayHeadDeath(name DamageType);\nfunction PlayLeftDeath(name DamageType);\nfunction PlayRightDeath(name DamageType);\nfunction PlayGutDeath(name DamageType);\n\nfunction PlayDying(name DamageType, vector HitLoc)\n{\n\tlocal vector X,Y,Z, HitVec, HitVec2D;\n\tlocal float dotp;\n\n\tif ( Velocity.Z > 250 )\n\t{\n\t\tPlayBigDeath(DamageType);\n\t\treturn;\n\t}\n\t\n\tif ( DamageType == 'Decapitated' )\n\t{\n\t\tPlayHeadDeath(DamageType);\n\t\treturn;\n\t}\n\t\t\t\n\tGetAxes(Rotation,X,Y,Z);\n\tX.Z = 0;\n\tHitVec = Normal(HitLoc - Location);\n\tHitVec2D= HitVec;\n\tHitVec2D.Z = 0;\n\tdotp = HitVec2D dot X;\n\n\t//first check for head hit\n\tif ( HitLoc.Z - Location.Z > 0.5 * CollisionHeight )\n\t{\n\t\tif (dotp > 0)\n\t\t\tPlayHeadDeath(DamageType);\n\t\telse\n\t\t\tPlayGutDeath(DamageType);\n\t\treturn;\n\t}\n\t\n\tif (dotp > 0.71) //then hit in front\n\t\tPlayGutDeath(DamageType);\n\telse\n\t{\n\t\tdotp = HitVec dot Y;\n\t\tif (dotp > 0.0)\n\t\t\tPlayLeftDeath(DamageType);\n\t\telse\n\t\t\tPlayRightDeath(DamageType);\n\t}\n}\n\nfunction PlayGutHit(float tweentime)\n{\n\tlog(\"Error - play gut hit must be implemented in subclass of\"@class);\n}\n\nfunction PlayHeadHit(float tweentime)\n{\n\tPlayGutHit(tweentime);\n}\n\nfunction PlayLeftHit(float tweentime)\n{\n\tPlayGutHit(tweentime);\n}\n\nfunction PlayRightHit(float tweentime)\n{\n\tPlayGutHit(tweentime);\n}\n\nfunction FireWeapon();\n\n/* TraceShot - used by instant hit weapons, and monsters \n*/\nfunction actor TraceShot(out vector HitLocation, out vector HitNormal, vector EndTrace, vector StartTrace)\n{\n\tlocal vector realHit;\n\tlocal actor Other;\n\tOther = Trace(HitLocation,HitNormal,EndTrace,StartTrace,True);\n\tif ( Pawn(Other) != None )\n\t{\n\t\trealHit = HitLocation;\n\t\tif ( !Pawn(Other).AdjustHitLocation(HitLocation, EndTrace - StartTrace) )\n\t\t\tOther = Pawn(Other).TraceShot(HitLocation,HitNormal,EndTrace,realHit);\n\t}\n\treturn Other;\n}\n\n/* Adjust hit location - adjusts the hit location in for pawns, and returns\ntrue if it was really a hit, and false if not (for ducking, etc.)\n*/\nsimulated function bool AdjustHitLocation(out vector HitLocation, vector TraceDir)\n{\n\tlocal float adjZ, maxZ;\n\n\tTraceDir = Normal(TraceDir);\n\tHitLocation = HitLocation + 0.4 * CollisionRadius * TraceDir;\n\n/* DEUS_EX STM -- took this out because it fucks up crouching\n\tif ( (GetAnimGroup(AnimSequence) == 'Ducking') && (AnimFrame > -0.03) )\n\t{\n\t\tmaxZ = Location.Z + 0.25 * CollisionHeight;\n\t\tif ( HitLocation.Z > maxZ )\n\t\t{\n\t\t\tif ( TraceDir.Z >= 0 )\n\t\t\t\treturn false;\n\t\t\tadjZ = (maxZ - HitLocation.Z)/TraceDir.Z;\n\t\t\tHitLocation.Z = maxZ;\n\t\t\tHitLocation.X = HitLocation.X + TraceDir.X * adjZ;\n\t\t\tHitLocation.Y = HitLocation.Y + TraceDir.Y * adjZ;\n\t\t\tif ( VSize(HitLocation - Location) > CollisionRadius )\t\n\t\t\t\treturn false;\n\t\t}\n\t}\n*/\n\n\treturn true;\n}\n\t\t\t\nfunction PlayTakeHit(float tweentime, vector HitLoc, int damage)\n{\n\tlocal vector X,Y,Z, HitVec, HitVec2D;\n\tlocal float dotp;\n\t\n\tGetAxes(Rotation,X,Y,Z);\n\tX.Z = 0;\n\tHitVec = Normal(HitLoc - Location);\n\tHitVec2D= HitVec;\n\tHitVec2D.Z = 0;\n\tdotp = HitVec2D dot X;\n\n\t//first check for head hit\n\tif ( HitLoc.Z - Location.Z > 0.5 * CollisionHeight )\n\t{\n\t\tif (dotp > 0)\n\t\t\tPlayHeadHit(tweentime);\n\t\telse\n\t\t\tPlayGutHit(tweentime);\n\t\treturn;\n\t}\n\t\n\tif (dotp > 0.71) //then hit in front\n\t\tPlayGutHit( tweentime);\n\telse if (dotp < -0.71) // then hit in back\n\t\tPlayHeadHit(tweentime);\n\telse\n\t{\n\t\tdotp = HitVec dot Y;\n\t\tif (dotp > 0.0)\n\t\t\tPlayLeftHit(tweentime);\n\t\telse\n\t\t\tPlayRightHit(tweentime);\n\t}\n}\n\nfunction PlayVictoryDance()\n{\n\tTweenToFighter(0.1);\n}\n\nfunction PlayOutOfWater()\n{\n\tTweenToFalling();\n}\n\nfunction PlayDive();\nfunction TweenToFalling();\nfunction PlayInAir();\nfunction PlayDuck();\nfunction PlayCrawling();\n\nfunction PlayLanded(float impactVel)\n{\n\tlocal float landVol;\n\t//default - do nothing (keep playing existing animation)\n\tlandVol = impactVel/JumpZ;\n\tlandVol = 0.005 * Mass * landVol * landVol;\n\tPlaySound(Land, SLOT_Interact, FMin(20, landVol));\n}\n\nfunction PlayFiring();\nfunction PlayWeaponSwitch(Weapon NewWeapon);\nfunction TweenToSwimming(float tweentime);\n\n\n//-----------------------------------------------------------------------------\n// Sound functions\nfunction PlayTakeHitSound(int Damage, name damageType, int Mult)\n{\n\tif ( Level.TimeSeconds - LastPainSound < 0.25 )\n\t\treturn;\n\n\tif (HitSound1 == None)return;\n\tLastPainSound = Level.TimeSeconds;\n\tif (FRand() < 0.5)\n\t\tPlaySound(HitSound1, SLOT_Pain, FMax(Mult * TransientSoundVolume, Mult * 2.0));\n\telse\n\t\tPlaySound(HitSound2, SLOT_Pain, FMax(Mult * TransientSoundVolume, Mult * 2.0));\n}\n\nfunction Gasp();\n\nfunction DropDecoration()\n{\n\tif (CarriedDecoration != None)\n\t{\n\t\tCarriedDecoration.bWasCarried = true;\n\t\tCarriedDecoration.SetBase(None);\n\t\tCarriedDecoration.SetPhysics(PHYS_Falling);\n\t\tCarriedDecoration.Velocity = Velocity + 10 * VRand();\n\t\tCarriedDecoration.Instigator = self;\n\n\t\t// turn off translucency - DEUS_EX CNN\n\t\tCarriedDecoration.Style = CarriedDecoration.Default.Style;\n\t\tCarriedDecoration.ScaleGlow = CarriedDecoration.Default.ScaleGlow;\n\t\tCarriedDecoration.bUnlit = CarriedDecoration.Default.bUnlit;\n\n\t\tCarriedDecoration = None;\n\t}\n}\n\nfunction GrabDecoration()\n{\n\tlocal vector lookDir, HitLocation, HitNormal, T1, T2, extent;\n\tlocal actor HitActor;\n\n\tif ( carriedDecoration == None )\n\t{\n\t\t//first trace to find it\n\t\tlookDir = vector(Rotation);\n\t\tlookDir.Z = 0;\n\t\tT1 = Location + BaseEyeHeight * vect(0,0,1) + lookDir * 0.8 * CollisionRadius;\n\t\tT2 = T1 + lookDir * 1.2 * CollisionRadius;\n\t\tHitActor = Trace(HitLocation, HitNormal, T2, T1, true);\n\t\tif ( HitActor == None )\n\t\t{\n\t\t\tT1 = T2 - (BaseEyeHeight + CollisionHeight - 2) * vect(0,0,1);\n\t\t\tHitActor = Trace(HitLocation, HitNormal, T1, T2, true);\n\t\t}\n\t\telse if ( HitActor == Level )\n\t\t{\n\t\t\tT2 = HitLocation - lookDir;\n\t\t\tT1 = T2 - (BaseEyeHeight + CollisionHeight - 2) * vect(0,0,1);\n\t\t\tHitActor = Trace(HitLocation, HitNormal, T1, T2, true);\n\t\t}\t\n\t\tif ( (HitActor == None) || (HitActor == Level) )\n\t\t{\n\t\t\textent.X = CollisionRadius;\n\t\t\textent.Y = CollisionRadius;\n\t\t\textent.Z = CollisionHeight;\n\t\t\tHitActor = Trace(HitLocation, HitNormal, Location + lookDir * 1.2 * CollisionRadius, Location, true, extent);\n\t\t}\n\n\t\tif ( Mover(HitActor) != None )\n\t\t{\n\t\t\tif ( Mover(HitActor).bUseTriggered )\n\t\t\t\tHitActor.Trigger( self, self );\n\t\t}\t\t\n\t\telse if ( (Decoration(HitActor) != None)  && ((weapon == None) || (weapon.Mass < 20)) )\n\t\t{\n\t\t\tCarriedDecoration = Decoration(HitActor);\n\t\t\tif ( !CarriedDecoration.bPushable || (CarriedDecoration.Mass > 40) \n\t\t\t\t|| (CarriedDecoration.StandingCount > 0) )\n\t\t\t{\n\t\t\t\tCarriedDecoration = None;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlookDir.Z = 0;\t\t\t\t\n\t\t\tif ( CarriedDecoration.SetLocation(Location + (0.5 * CollisionRadius + CarriedDecoration.CollisionRadius) * lookDir) )\n\t\t\t{\n\t\t\t\tCarriedDecoration.SetPhysics(PHYS_None);\n\t\t\t\tCarriedDecoration.SetBase(self);\n\n\t\t\t\t// make it translucent - DEUS_EX CNN\n\t\t\t\tCarriedDecoration.Style = STY_Translucent;\n\t\t\t\tCarriedDecoration.ScaleGlow = 1.0;\n\t\t\t\tCarriedDecoration.bUnlit = True;\n\t\t\t}\n\t\t\telse\n\t\t\t\tCarriedDecoration = None;\n\t\t}\n\t}\n}\n\t\nfunction StopFiring();\n\nfunction ShakeView( float shaketime, float RollMag, float vertmag);\n\nfunction TakeFallingDamage()\n{\n\tif (Velocity.Z < -1.4 * JumpZ)\n\t{\n\t\tMakeNoise(-0.5 * Velocity.Z/(FMax(JumpZ, 150.0)));\n\t\tif (Velocity.Z <= -750 - JumpZ)\n\t\t{\n\t\t\tif ( (Velocity.Z < -1650 - JumpZ) && (ReducedDamageType != 'All') )\n\t\t\t\tTakeDamage(1000, None, Location, vect(0,0,0), 'Fell');\n\t\t\telse if ( Role == ROLE_Authority )\n\t\t\t\tTakeDamage(-0.15 * (Velocity.Z + 700 + JumpZ), None, Location, vect(0,0,0), 'Fell');\n\t\t\tShakeView(0.175 - 0.00007 * Velocity.Z, -0.85 * Velocity.Z, -0.002 * Velocity.Z);\n\t\t}\n\t}\n\telse if ( Velocity.Z > 0.5 * Default.JumpZ )\n\t\tMakeNoise(0.35);\t\t\t\t\n}\n\n/* AdjustAim()\nScriptedPawn version does adjustment for non-controlled pawns. \nPlayerPawn version does the adjustment for player aiming help.\nOnly adjusts aiming at pawns\nallows more error in Z direction (full as defined by AutoAim - only half that difference for XY)\n*/\n\nfunction rotator AdjustAim(float projSpeed, vector projStart, int aimerror, bool bLeadTarget, bool bWarnTarget)\n{\n\treturn ViewRotation;\n}\n\nfunction rotator AdjustToss(float projSpeed, vector projStart, int aimerror, bool bLeadTarget, bool bWarnTarget)\n{\n\treturn ViewRotation;\n}\n\nfunction WarnTarget(Pawn shooter, float projSpeed, vector FireDir)\n{\n\t// AI controlled creatures may duck\n\t// if not falling, and projectile time is long enough\n\t// often pick opposite to current direction (relative to shooter axis)\n}\n\nfunction SetMovementPhysics()\n{\n\t//implemented in sub-class\n}\n\nfunction PlayHit(float Damage, vector HitLocation, name damageType, vector Momentum)\n{\n}\n\nfunction PlayDeathHit(float Damage, vector HitLocation, name damageType, vector Momentum)\n{\n}\n\nfunction TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation, \n\t\t\t\t\t\tVector momentum, name damageType)\n{\n\tlocal int actualDamage;\n\tlocal bool bAlreadyDead;\n\n\tif ( Role < ROLE_Authority )\n\t{\n\t\tlog(self$\" client damage type \"$damageType$\" by \"$instigatedBy);\n\t\treturn;\n\t}\n\n\t//log(self@\"take damage in state\"@GetStateName());\t\n\tbAlreadyDead = (Health <= 0);\n\n\tif (Physics == PHYS_None)\n\t\tSetMovementPhysics();\n\tif (Physics == PHYS_Walking)\n\t\tmomentum.Z = FMax(momentum.Z, 0.4 * VSize(momentum));\n\tif ( instigatedBy == self )\n\t\tmomentum *= 0.6;\n\tmomentum = momentum/Mass;\n\tAddVelocity( momentum ); \n\n\tactualDamage = Level.Game.ReduceDamage(Damage, DamageType, self, instigatedBy);\n\tif ( bIsPlayer )\n\t{\n\t\tif (ReducedDamageType == 'All') //God mode\n\t\t\tactualDamage = 0;\n\t\telse if (Inventory != None) //then check if carrying armor\n\t\t\tactualDamage = Inventory.ReduceDamage(actualDamage, DamageType, HitLocation);\n\t\telse\n\t\t\tactualDamage = Damage;\n\t}\n\telse if ( (InstigatedBy != None) &&\n\t\t\t\t(InstigatedBy.IsA(Class.Name) || self.IsA(InstigatedBy.Class.Name)) )\n\t\tActualDamage = ActualDamage * FMin(1 - ReducedDamagePct, 0.35); \n\telse if ( (ReducedDamageType == 'All') || \n\t\t((ReducedDamageType != '') && (ReducedDamageType == damageType)) )\n\t\tactualDamage = float(actualDamage) * (1 - ReducedDamagePct);\n\t\n\tif ( Level.Game.DamageMutator != None )\n\t\tLevel.Game.DamageMutator.MutatorTakeDamage( ActualDamage, Self, InstigatedBy, HitLocation, Momentum, DamageType );\n\tHealth -= actualDamage;\n\tif (CarriedDecoration != None)\n\t\tDropDecoration();\n\tif ( HitLocation == vect(0,0,0) )\n\t\tHitLocation = Location;\n\tif (Health > 0)\n\t{\n\t\tif ( (instigatedBy != None) && (instigatedBy != Self) )\n\t\t\tdamageAttitudeTo(instigatedBy);\n\t\tPlayHit(actualDamage, hitLocation, damageType, Momentum);\n\t}\n\telse if ( !bAlreadyDead )\n\t{\n\t\t//log(self$\" died\");\n\t\tNextState = '';\n\t\tPlayDeathHit(actualDamage, hitLocation, damageType, Momentum);\n\t\tif ( actualDamage > mass )\n\t\t\tHealth = -1 * actualDamage;\n\t\tif ( (instigatedBy != None) && (instigatedBy != Self) )\n\t\t\tdamageAttitudeTo(instigatedBy);\n\t\tDied(instigatedBy, damageType, HitLocation);\n\t}\n\telse\n\t{\n\t\t//Warn(self$\" took regular damage \"$damagetype$\" from \"$instigator$\" while already dead\");\n\t\t// SpawnGibbedCarcass();\n\t\tif ( bIsPlayer )\n\t\t{\n\t\t\tHidePlayer();\n\t\t\tGotoState('Dying');\n\t\t}\n\t\telse\n\t\t\tDestroy();\n\t}\n\tMakeNoise(1.0); \n}\n\nfunction Died(pawn Killer, name damageType, vector HitLocation)\n{\n\tlocal pawn OtherPawn;\n\tlocal actor A;\n\n\tif ( bDeleteMe )\n\t\treturn; //already destroyed\n\tHealth = Min(0, Health);\n\tfor ( OtherPawn=Level.PawnList; OtherPawn!=None; OtherPawn=OtherPawn.nextPawn )\n\t\tOtherPawn.Killed(Killer, self, damageType);\n\tif ( CarriedDecoration != None )\n\t\tDropDecoration();\n\tlevel.game.Killed(Killer, self, damageType);\n\t//log(class$\" dying\");\n\tif( Event != '' )\n\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\tA.Trigger( Self, Killer );\n\tLevel.Game.DiscardInventory(self);\n\tVelocity.Z *= 1.3;\n   if ( Gibbed(damageType) )\n   {\n      SpawnGibbedCarcass();\n      if ( bIsPlayer )\n         HidePlayer();\n      else\n         Destroy();\n   }\n\tPlayDying(DamageType, HitLocation);\n\tif ( Level.Game.bGameEnded )\n\t\treturn;\n\tif ( RemoteRole == ROLE_AutonomousProxy )\n\t\tClientDying(DamageType, HitLocation);\n\tGotoState('Dying');\n}\n\nfunction bool Gibbed(name damageType)\n{\n\treturn false;\n}\n\nfunction Carcass SpawnCarcass()\n{\n\tlog(self$\" should never call base spawncarcass\");\n\treturn None;\n}\n\nfunction SpawnGibbedCarcass()\n{\n}\n\t\nfunction HidePlayer()\n{\n\tSetCollision(false, false, false);\n\tTweenToFighter(0.01);\n\tbHidden = true;\n}\n\nevent HearNoise( float Loudness, Actor NoiseMaker);\nevent SeePlayer( actor Seen );\nevent UpdateEyeHeight( float DeltaTime );\nevent UpdateTactics(float DeltaTime); // for advanced tactics\nevent EnemyNotVisible();\n\nfunction Killed(pawn Killer, pawn Other, name damageType)\n{\n\tif ( Enemy == Other )\n\t\tEnemy = None;\n}\n\n//Typically implemented in subclass\nfunction string KillMessage( name damageType, pawn Other )\n{\n\tlocal string message;\n\n\tmessage = Level.Game.CreatureKillMessage(damageType, Other);\n\treturn (message$namearticle$menuname);\n}\n\nfunction damageAttitudeTo(pawn Other);\n\nfunction Falling()\n\t{\n\t\t//SetPhysics(PHYS_Falling); //Note - physics changes type to PHYS_Falling by default\n\t\t//log(class$\" Falling\");\n\t\tPlayInAir();\n\t}\n\n//LEGEND:begin\n// Pawn interface called while PHYS_Walking and PHYS_Swimming to update the pawn with \n// the latest information about the walk surface\nevent WalkTexture( texture Texture, vector StepLocation, vector StepNormal );\n//LEGEND:end\n\nevent Landed(vector HitNormal)\n{\n\tSetMovementPhysics();\n\tif ( !IsAnimating() )\n\t\tPlayLanded(Velocity.Z);\n\tif (Velocity.Z < -1.4 * JumpZ)\n\t\tMakeNoise(-0.5 * Velocity.Z/(FMax(JumpZ, 150.0)));\n\tbJustLanded = true;\n}\n\nevent FootZoneChange(ZoneInfo newFootZone)\n{\n\tlocal actor HitActor;\n\tlocal vector HitNormal, HitLocation;\n\tlocal float splashSize;\n\tlocal actor splash;\n\t\n\tif ( Level.NetMode == NM_Client )\n\t\treturn;\n\tif ( Level.TimeSeconds - SplashTime > 0.25 ) \n\t{\n\t\tSplashTime = Level.TimeSeconds;\n\t\tif (Physics == PHYS_Falling)\n\t\t\tMakeNoise(1.0);\n\t\telse\n\t\t\tMakeNoise(0.3);\n\t\tif ( FootRegion.Zone.bWaterZone )\n\t\t{\n\t\t\tif ( !newFootZone.bWaterZone && (Role==ROLE_Authority) )\n\t\t\t{\n\t\t\t\tif ( FootRegion.Zone.ExitSound != None )\n\t\t\t\t\tPlaySound(FootRegion.Zone.ExitSound, SLOT_Interact, 1); \n\t\t\t\tif ( FootRegion.Zone.ExitActor != None )\n\t\t\t\t\tSpawn(FootRegion.Zone.ExitActor,,,Location - CollisionHeight * vect(0,0,1));\n\t\t\t}\n\t\t}\n\t\telse if ( newFootZone.bWaterZone && (Role==ROLE_Authority) )\n\t\t{\n\t\t\tsplashSize = FClamp(0.000025 * Mass * (300 - 0.5 * FMax(-500, Velocity.Z)), 1.0, 4.0 );\n\t\t\tif ( newFootZone.EntrySound != None )\n\t\t\t{\n\t\t\t\tHitActor = Trace(HitLocation, HitNormal, \n\t\t\t\t\t\tLocation - (CollisionHeight + 40) * vect(0,0,0.8), Location - CollisionHeight * vect(0,0,0.8), false);\n\t\t\t\tif ( HitActor == None )\n\t\t\t\t\tPlaySound(newFootZone.EntrySound, SLOT_Misc, 2 * splashSize);\n\t\t\t\telse \n\t\t\t\t\tPlaySound(WaterStep, SLOT_Misc, 1.5 + 0.5 * splashSize);\n\t\t\t}\n\t\t\tif( newFootZone.EntryActor != None )\n\t\t\t{\n\t\t\t\tsplash = Spawn(newFootZone.EntryActor,,,Location - CollisionHeight * vect(0,0,1));\n\t\t\t\tif ( splash != None )\n\t\t\t\t\tsplash.DrawScale = splashSize;\n\t\t\t}\n\t\t\t//log(\"Feet entering water\");\n\t\t}\n\t}\n\t\n\tif (FootRegion.Zone.bPainZone)\n\t{\n\t\tif ( !newFootZone.bPainZone && !HeadRegion.Zone.bWaterZone )\n\t\t\tPainTime = -1.0;\n\t}\n\telse if (newFootZone.bPainZone)\n\t\tPainTime = 0.01;\n}\n\t\nevent HeadZoneChange(ZoneInfo newHeadZone)\n{\n\tif ( Level.NetMode == NM_Client )\n\t\treturn;\n\tif (HeadRegion.Zone.bWaterZone)\n\t{\n\t\tif (!newHeadZone.bWaterZone)\n\t\t{\n\t\t\tif ( bIsPlayer && (PainTime > 0) && (PainTime < 8) )\n\t\t\t\tGasp();\n\t\t\tif ( Inventory != None )\n\t\t\t\tInventory.ReduceDamage(0, 'Breathe', Location); //inform inventory of zone change\n\t\t\tbDrowning = false;\n\t\t\tif ( !FootRegion.Zone.bPainZone )\n\t\t\t\tPainTime = -1.0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (newHeadZone.bWaterZone)\n\t\t{\n\t\t\tif ( !FootRegion.Zone.bPainZone )\n\t\t\t\tPainTime = UnderWaterTime;\n\t\t\tif ( Inventory != None )\n\t\t\t\tInventory.ReduceDamage(0, 'Drowned', Location); //inform inventory of zone change\n\t\t\t//log(\"Can't breathe\");\n\t\t}\n\t}\n}\n\nevent SpeechTimer();\n\n//Pain timer just expired.\n//Check what zone I'm in (and which parts are)\n//based on that cause damage, and reset PainTime\n\t\nevent PainTimer()\n{\n\tlocal float depth;\n\n\t//log(\"Pain Timer\");\n\tif ( (Health < 0) || (Level.NetMode == NM_Client) )\n\t\treturn;\n\t\t\n\tif ( FootRegion.Zone.bPainZone )\n\t{\n\t\tdepth = 0.4;\n\t\tif (Region.Zone.bPainZone)\n\t\t\tdepth += 0.4;\n\t\tif (HeadRegion.Zone.bPainZone)\n\t\t\tdepth += 0.2;\n\n\t\tif (FootRegion.Zone.DamagePerSec > 0)\n\t\t{\n\t\t\tif ( IsA('PlayerPawn') )\n\t\t\t\tLevel.Game.SpecialDamageString = FootRegion.Zone.DamageString;\n\t\t\tTakeDamage(int(float(FootRegion.Zone.DamagePerSec) * depth), None, Location, vect(0,0,0), FootRegion.Zone.DamageType); \n\t\t}\n\t\telse if ( Health < Default.Health )\n\t\t\tHealth = Min(Default.Health, Health - depth * FootRegion.Zone.DamagePerSec);\n\n\t\tif (Health > 0)\n\t\t\tPainTime = 1.0;\n\t}\n\telse if ( HeadRegion.Zone.bWaterZone )\n\t{\n\t\t// DEUS_EX CNN - make drowning damage happen from center\n\t\tTakeDamage(5, None, Location, vect(0,0,0), 'Drowned'); \n\t\tif ( Health > 0 )\n\t\t\tPainTime = 2.0;\n\t}\n}\t\t\n\nfunction bool CheckWaterJump(out vector WallNormal)\n{\n\tlocal actor HitActor;\n\tlocal vector HitLocation, HitNormal, checkpoint, start, checkNorm, Extent;\n\n\tif (CarriedDecoration != None)\n\t\treturn false;\n\tcheckpoint = vector(Rotation);\n\tcheckpoint.Z = 0.0;\n\tcheckNorm = Normal(checkpoint);\n\tcheckPoint = Location + CollisionRadius * checkNorm;\n\tExtent = CollisionRadius * vect(1,1,0);\n\tExtent.Z = CollisionHeight;\n\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, true, Extent);\n\tif ( (HitActor != None) && (Pawn(HitActor) == None) )\n\t{\n\t\tWallNormal = -1 * HitNormal;\n\t\tstart = Location;\n\t\tstart.Z += 1.1 * MaxStepHeight;\n\t\tcheckPoint = start + 2 * CollisionRadius * checkNorm;\n\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, start, true);\n\t\tif (HitActor == None)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nexec function bool SwitchToBestWeapon()\n{\n\tlocal float rating;\n\tlocal int usealt;\n\n\tif ( Inventory == None )\n\t\treturn false;\n\n\tPendingWeapon = Inventory.RecommendWeapon(rating, usealt);\n\tif ( PendingWeapon == Weapon )\n\t\tPendingWeapon = None;\n\tif ( PendingWeapon == None )\n\t\treturn false;\n\n\tif ( Weapon == None )\n\t\tChangedWeapon();\n\tif ( Weapon != PendingWeapon )\n\t\tWeapon.PutDown();\n\n\treturn (usealt > 0);\n}\n\nState Dying\n{\nignores SeePlayer, EnemyNotVisible, HearNoise, KilledBy, Trigger, Bump, HitWall, HeadZoneChange, FootZoneChange, ZoneChange, Falling, WarnTarget, Died, LongFall, PainTimer;\n\n\tfunction TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation, \n\t\t\t\t\t\t\tVector momentum, name damageType)\n\t{\n\t\tif ( bDeleteMe )\n\t\t\treturn;\n\t\tHealth = Health - Damage;\n\t\tMomentum = Momentum/Mass;\n\t\tAddVelocity( momentum ); \n\t\tif ( !bHidden && Gibbed(damageType) )\n\t\t{\n\t\t\tbHidden = true;\n\t\t\tSpawnGibbedCarcass();\n\t\t\tif ( bIsPlayer )\n\t\t\t\tHidePlayer();\n\t\t\telse\n\t\t\t\tDestroy();\n\t\t}\n\t}\n\n\tfunction Timer()\n\t{\n\t\tif ( !bHidden )\n\t\t{\n\t\t\tbHidden = true;\n\t\t\tSpawnCarcass();\n\t\t\tif ( bIsPlayer )\n\t\t\t\tHidePlayer();\n\t\t\telse\n\t\t\t\tDestroy();\n\t\t}\n\t}\n\n\tevent Landed(vector HitNormal)\n\t{\n\t\tSetPhysics(PHYS_None);\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tSetTimer(0.3, false);\n\t}\n}\n\nstate GameEnded\n{\nignores SeePlayer, HearNoise, KilledBy, Bump, HitWall, HeadZoneChange, FootZoneChange, ZoneChange, Falling, TakeDamage, WarnTarget, Died;\n\n\tfunction BeginState()\n\t{\n\t\tSetPhysics(PHYS_None);\n\t\tHidePlayer();\n\t}\n}\n\n//\n// lip synching support - DEUS_EX CNN\n//\nfunction LipSynch(float deltaTime)\n{\n\tlocal name animseq;\n\tlocal float rnd;\n\tlocal float tweentime;\n\n\t// update the animation timers that we are using\n\tanimTimer[0] += deltaTime;\n\tanimTimer[1] += deltaTime;\n\tanimTimer[2] += deltaTime;\n\n\tif (bIsSpeaking)\n\t{\n\t\t// if our framerate is high enough (>20fps), tween the lips smoothly\n\t\tif (Level.TimeSeconds - animTimer[3]  < 0.05)\n\t\t\ttweentime = 0.1;\n\t\telse\n\t\t\ttweentime = 0.0;\n\n\t\t// the last animTimer slot is used to check framerate\n\t\tanimTimer[3] = Level.TimeSeconds;\n\n\t\tif (nextPhoneme == \"A\")\n\t\t\tanimseq = 'MouthA';\n\t\telse if (nextPhoneme == \"E\")\n\t\t\tanimseq = 'MouthE';\n\t\telse if (nextPhoneme == \"F\")\n\t\t\tanimseq = 'MouthF';\n\t\telse if (nextPhoneme == \"M\")\n\t\t\tanimseq = 'MouthM';\n\t\telse if (nextPhoneme == \"O\")\n\t\t\tanimseq = 'MouthO';\n\t\telse if (nextPhoneme == \"T\")\n\t\t\tanimseq = 'MouthT';\n\t\telse if (nextPhoneme == \"U\")\n\t\t\tanimseq = 'MouthU';\n\t\telse if (nextPhoneme == \"X\")\n\t\t\tanimseq = 'MouthClosed';\n\n\t\tif (animseq != '')\n\t\t{\n\t\t\tif (lastPhoneme != nextPhoneme)\n\t\t\t{\n\t\t\t\tlastPhoneme = nextPhoneme;\n\t\t\t\tTweenBlendAnim(animseq, tweentime);\n\t\t\t}\n\t\t}\n\t}\n\telse if (bWasSpeaking)\n\t{\n\t\tbWasSpeaking = False;\n\t\tTweenBlendAnim('MouthClosed', tweentime);\n\t}\n\n\t// blink randomly\n\tif (animTimer[0] > 2.0)\n\t{\n\t\tanimTimer[0] = 0;\n\t\tif (FRand() < 0.4)\n\t\t\tPlayBlendAnim('Blink', 1.0, 0.1, 1);\n\t}\n\n\tLoopHeadConvoAnim();\n\tLoopBaseConvoAnim();\n}\n\n//\n// PlayTurnHead - DEUS_EX STM\n//\n\nfunction bool PlayTurnHead(ELookDirection dir, float rate, float tweentime)\n{\n\tlocal name lookName;\n\tlocal bool bSuccess;\n\n\tif (dir == LOOK_Left)\n\t\tlookName = 'HeadLeft';\n\telse if (dir == LOOK_Right)\n\t\tlookName = 'HeadRight';\n\telse if (dir == LOOK_Up)\n\t\tlookName = 'HeadUp';\n\telse if (dir == LOOK_Down)\n\t\tlookName = 'HeadDown';\n\telse\n\t\tlookName = 'Still';\n\n\tbSuccess = false;\n\tif (BlendAnimSequence[3] != lookName)\n\t{\n\t\tif (animTimer[1] > 0.00)\n\t\t{\n\t\t\tanimTimer[1] = 0;\n\t\t\tif (BlendAnimSequence[3] == '')\n\t\t\t\tBlendAnimSequence[3] = 'Still';\n\t\t\tPlayBlendAnim(lookName, rate, tweentime, 3);\n\t\t\tbSuccess = true;\n\t\t}\n\t}\n\n\treturn (bSuccess);\n}\n\n//\n// LoopHeadConvoAnim - DEUS_EX STM\n//\n\nfunction LoopHeadConvoAnim()\n{\n\tlocal float rnd;\n\n\trnd = FRand();\n\n\t// move head randomly (only while not speaking)\n\tif (!bIsSpeaking && (animTimer[1] > 0.5))\n\t{\n\t\tif (rnd < 0.01)\n\t\t\tPlayTurnHead(LOOK_Left, 1.0, 2.0);\n\t\telse if (rnd < 0.02)\n\t\t\tPlayTurnHead(LOOK_Right, 1.0, 2.0);\n\t\telse\n\t\t\tPlayTurnHead(LOOK_Forward, 1.0, 1.0);\n\t}\n}\n\n//\n// LoopBaseConvoAnim - DEUS_EX CNN\n//\n\nfunction LoopBaseConvoAnim()\n{\n\tlocal float rnd;\n\n\trnd = FRand();\n\n\t// move arms randomly\n\tif (bIsSpeaking)\n\t{\n\t\tif (animTimer[2] > 2.5)\n\t\t{\n\t\t\tanimTimer[2] = 0;\n\t\t\tif (rnd < 0.1)\n\t\t\t\tPlayAnim('GestureLeft', 0.35, 0.4);\n\t\t\telse if (rnd < 0.2)\n\t\t\t\tPlayAnim('GestureRight', 0.35, 0.4);\n\t\t\telse if (rnd < 0.3)\n\t\t\t\tPlayAnim('GestureBoth', 0.35, 0.4);\n\t\t}\n\t}\n\n\t// if we're not playing an animation, loop the breathe\n\tif (!IsAnimating())\n\t\tLoopAnim('BreatheLight',, 0.4);\n}\n\n//\n// LookAtActor - DEUS_EX STM\n//\n\nfunction LookAtActor(Actor targ, bool bRotate,\n                     bool bLookHorizontal, bool bLookVertical,\n                     optional float DelayTime, optional float rate,\n                     optional float LockAngle, optional float AngleOffset)\n{\n\tlocal vector lookTo;\n\n\t// If we're looking at a pawn, look at the head;\n\t// otherwise, look at the center point\n\n\tlookTo = targ.Location;\n\tif (Pawn(targ) != None)\n\t\tlookTo += (vect(0,0,1)*Pawn(targ).BaseEyeHeight);\n\telse if (Decoration(targ) != None)\n\t\tlookTo += (vect(0,0,1)*Decoration(targ).BaseEyeHeight);\n\telse\n\t\tlookTo += (vect(0,0,1)*targ.CollisionHeight*0.75);\n\n\tLookAtVector(lookTo, bRotate, bLookHorizontal, bLookVertical,\n\t             DelayTime, rate, LockAngle, AngleOffset);\n}\n\n//\n// LookAtVector - DEUS_EX STM\n//\n\nfunction LookAtVector(vector lookTo, bool bRotate,\n                      bool bLookHorizontal, bool bLookVertical,\n                      optional float DelayTime, optional float rate,\n                      optional float LockAngle, optional float AngleOffset)\n{\n\tlocal vector         lookFrom;\n\tlocal rotator        lookAngle;\n\tlocal int            hPos, vPos;\n\tlocal int            hAngle, vAngle;\n\tlocal int            hAbs, vAbs;\n\tlocal int            hRot;\n\tlocal ELookDirection lookDir;\n\n\tif (rate <= 0)\n\t\trate = 1.0;\n\n\t// Head movement angles\n\thAngle = 5461;  // 30 degrees horizontally\n\tvAngle = 2731;  // 15 degrees vertically\n\n\t// Determine our angle to the target\n\tlookFrom  = Location + (vect(0,0,1)*CollisionHeight*0.9);\n\tlookAngle = Rotator(lookTo-lookFrom);\n\tlookAngle.Yaw = (lookAngle.Yaw - Rotation.Yaw) & 65535;\n\tif (lookAngle.Yaw > 32767)\n\t\tlookAngle.Yaw -= 65536;\n\tif (lookAngle.Pitch > 32767)\n\t\tlookAngle.Pitch -= 65536;\n\n\t// hPos and vPos determine which way the pawn needs to look\n\t// horizontally and vertically\n\n\thPos = 0;\n\tvPos = 0;\n\n\t// Do we need to look up or down?\n\tif (bLookVertical)\n\t{\n\t\tif (lookAngle.Pitch > vAngle*0.9)\n\t\t\tvPos = 1;\n\t\telse if (lookAngle.Pitch < -vAngle*0.75)\n\t\t\tvPos = -1;\n\t}\n\n\t// Do we need to look left or right?\n\tif (bLookHorizontal)\n\t{\n\t\tif (lookAngle.Yaw > hAngle*0.5)\n\t\t\thPos = 1;\n\t\telse if (lookAngle.Yaw < -hAngle*0.5)\n\t\t\thPos = -1;\n\t}\n\n\thAbs = Abs(lookAngle.Yaw);\n\tvAbs = Abs(lookAngle.Pitch);\n\n\tif (bRotate)\n\t{\n\t\thRot = lookAngle.Yaw;\n\n\t\t// Hack -- NPCs that look horizontally or vertically, AND rotate, will use inexact rotations\n\t\tif (bLookHorizontal && (vPos == 0))\n\t\t{\n\t\t\tif (hRot > hAngle*1.2)\n\t\t\t\thRot -= hAngle*1.2;\n\t\t\telse if (hRot < -hAngle*1.2)\n\t\t\t\thRot += hAngle*1.2;\n\t\t\telse\n\t\t\t\thRot = 0;\n\t\t}\n\t\telse if (bLookVertical && (hPos == 0))\n\t\t{\n\t\t\tif (hRot > hAngle*0.35)\n\t\t\t\thRot -= hAngle*0.35;\n\t\t\telse if (hRot < -hAngle*0.35)\n\t\t\t\thRot += hAngle*0.35;\n\t\t\telse\n\t\t\t\thRot = 0;\n\t\t}\n\n\t\t// Clamp the rotation angle, based on the angles passed in\n\t\tif (AngleOffset > 0)\n\t\t{\n\t\t\thRot = (hRot + (Rotation.Yaw-LockAngle) + 65536*4) & 65535;\n\t\t\tif (hRot > 32767)\n\t\t\t\thRot -= 65536;\n\t\t\tif      (hRot < -AngleOffset)\n\t\t\t\thRot = -AngleOffset;\n\t\t\telse if (hRot > AngleOffset)\n\t\t\t\thRot = AngleOffset;\n\t\t\thRot = (hRot + (LockAngle-Rotation.Yaw) + 65536*4) & 65535;\n\t\t\tif (hRot > 32767)\n\t\t\t\thRot -= 65536;\n\t\t}\n\n\t\t// Compute actual rotation, based on new angle\n\t\thAbs = (65536 + lookAngle.Yaw - hRot) & 65535;\n\t\tif (hAbs > 32767)\n\t\t\thAbs = 65536-hAbs;\n\t}\n\n\t// No rotation\n\telse\n\t\thRot = 0;\n\n\t// We can't look vertically AND horizontally at the same time\n\t// (we need a skeletal animation system!!!)\n\n\tif ((hPos != 0) && (vPos != 0))\n\t{\n\t\tif (hAbs > vAbs)\n\t\t\tvPos = 0;\n\t\telse\n\t\t\thPos = 0;\n\t}\n\n\t// Play head turning animation\n\tif (hPos > 0)\n\t\tlookDir = LOOK_Right;\n\telse if (hPos < 0)\n\t\tlookDir = LOOK_Left;\n\telse if (vPos > 0)\n\t\tlookDir = LOOK_Up;\n\telse if (vPos < 0)\n\t\tlookDir = LOOK_Down;\n\telse\n\t\tlookDir = LOOK_Forward;\n\tif ((bLookHorizontal || bLookVertical) && (animTimer[1] >= DelayTime))\n\t\tPlayTurnHead(lookDir, 1.0, rate);\n\n\t// Turn as necessary\n\tif (bRotate)\n\t\tDesiredRotation = Rotation + rot(0,1,0)*hRot;\n}\n\ndefaultproperties\n{\n     bCanGlide=True\n     AvgPhysicsTime=0.100000\n     MaxDesiredSpeed=1.000000\n     GroundSpeed=320.000000\n     WaterSpeed=200.000000\n     AccelRate=500.000000\n     JumpZ=325.000000\n     MaxStepHeight=25.000000\n     AirControl=0.050000\n     Visibility=128\n     SightRadius=2500.000000\n     OrthoZoom=40000.000000\n     FovAngle=90.000000\n     Health=100\n     AttitudeToPlayer=ATTITUDE_Hate\n     Intelligence=BRAINS_MAMMAL\n     noise1time=-10.000000\n     noise2time=-10.000000\n     SoundDampening=1.000000\n     DamageScaling=1.000000\n     PlayerReStartState=PlayerWalking\n     NameArticle=\" a \"\n     PlayerReplicationInfoClass=Class'Engine.PlayerReplicationInfo'\n     HealthHead=100\n     HealthTorso=100\n     HealthLegLeft=100\n     HealthLegRight=100\n     HealthArmLeft=100\n     HealthArmRight=100\n     AIHorizontalFov=75.000000\n     AspectRatio=1.333333\n     AngularResolution=1.000000\n     SmellThreshold=0.500000\n     bCanTeleport=True\n     bIsKillGoal=True\n     bStasis=True\n     bIsPawn=True\n     RemoteRole=ROLE_SimulatedProxy\n     AnimSequence=Fighter\n     bDirectional=True\n     Texture=Texture'Engine.S_Pawn'\n     SoundRadius=9\n     SoundVolume=240\n     TransientSoundVolume=2.000000\n     bCollideActors=True\n     bCollideWorld=True\n     bBlockActors=True\n     bBlockPlayers=True\n     bProjTarget=True\n     bRotateToDesired=True\n     RotationRate=(Pitch=4096,Yaw=50000,Roll=3072)\n     bVisionImportant=True\n     NetPriority=2.000000\n}\n",
            "name": "Pawn.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bCanGlide=True",
                    "AvgPhysicsTime=0.100000",
                    "MaxDesiredSpeed=1.000000",
                    "GroundSpeed=320.000000",
                    "WaterSpeed=200.000000",
                    "AccelRate=500.000000",
                    "JumpZ=325.000000",
                    "MaxStepHeight=25.000000",
                    "AirControl=0.050000",
                    "Visibility=128",
                    "SightRadius=2500.000000",
                    "OrthoZoom=40000.000000",
                    "FovAngle=90.000000",
                    "Health=100",
                    "AttitudeToPlayer=ATTITUDE_Hate",
                    "Intelligence=BRAINS_MAMMAL",
                    "noise1time=-10.000000",
                    "noise2time=-10.000000",
                    "SoundDampening=1.000000",
                    "DamageScaling=1.000000",
                    "PlayerReStartState=PlayerWalking",
                    "NameArticle=\" a \"",
                    "PlayerReplicationInfoClass=Class'Engine.PlayerReplicationInfo'",
                    "HealthHead=100",
                    "HealthTorso=100",
                    "HealthLegLeft=100",
                    "HealthLegRight=100",
                    "HealthArmLeft=100",
                    "HealthArmRight=100",
                    "AIHorizontalFov=75.000000",
                    "AspectRatio=1.333333",
                    "AngularResolution=1.000000",
                    "SmellThreshold=0.500000",
                    "bCanTeleport=True",
                    "bIsKillGoal=True",
                    "bStasis=True",
                    "bIsPawn=True",
                    "RemoteRole=ROLE_SimulatedProxy",
                    "AnimSequence=Fighter",
                    "bDirectional=True",
                    "Texture=Texture'Engine.S_Pawn'",
                    "SoundRadius=9",
                    "SoundVolume=240",
                    "TransientSoundVolume=2.000000",
                    "bCollideActors=True",
                    "bCollideWorld=True",
                    "bBlockActors=True",
                    "bBlockPlayers=True",
                    "bProjTarget=True",
                    "bRotateToDesired=True",
                    "RotationRate=(Pitch=4096,Yaw=50000,Roll=3072)",
                    "bVisionImportant=True",
                    "NetPriority=2.000000"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Pawn.pcx Name=S_Pawn Mips=Off Flags=2"
                ],
                "extends": "Actor",
                "functions": {
                    "AICanHear": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AICanHear",
                        "native": true,
                        "param": [
                            [
                                "actor",
                                "other"
                            ],
                            [
                                "optional",
                                "float",
                                "Volume"
                            ],
                            [
                                "optional",
                                "float",
                                "Radius"
                            ]
                        ],
                        "return": ""
                    },
                    "AICanSmell": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AICanSmell",
                        "native": true,
                        "param": [
                            [
                                "actor",
                                "other"
                            ],
                            [
                                "optional",
                                "float",
                                "smell"
                            ]
                        ],
                        "return": ""
                    },
                    "AddInventory": {
                        "body": "{\n\t// Skip if already in the inventory.\n\t\n\t// The item should not have been destroyed if we get here.\n\tif (NewItem ==None )\n\t\tlog(\"tried to add none inventory to \"$self);\n\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )\n\t\tif( Inv == NewItem )\n\t\t\treturn false;\n\n\t// DEUS_EX AJY\n\t// Update the previous owner's inventory chain\n\tif (NewItem.Owner != None)\n\t\tPawn(NewItem.Owner).DeleteInventory(NewItem);\n\n\t// Add to front of inventory chain.\n\tNewItem.SetOwner(Self);\n\tNewItem.Inventory = Inventory;\n\tInventory = NewItem;\n\n\n\treturn true;\n}",
                        "locals": [
                            "local inventory Inv;"
                        ],
                        "modifiers": [],
                        "name": "AddInventory",
                        "native": false,
                        "param": [
                            [
                                "inventory",
                                "NewItem"
                            ]
                        ],
                        "return": "bool"
                    },
                    "AddPawn": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "AddPawn",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "AddVelocity": {
                        "body": "{\n\tif (Physics == PHYS_Walking)\n\t\tSetPhysics(PHYS_Falling);\n\tif ( (Velocity.Z > 380) && (NewVelocity.Z > 0) )\n\t\tNewVelocity.Z *= 0.5;\n\tVelocity += NewVelocity;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AddVelocity",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "NewVelocity"
                            ]
                        ],
                        "return": ""
                    },
                    "AdjustAim": {
                        "body": "{\n\treturn ViewRotation;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AdjustAim",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "projSpeed"
                            ],
                            [
                                "vector",
                                "projStart"
                            ],
                            [
                                "int",
                                "aimerror"
                            ],
                            [
                                "bool",
                                "bLeadTarget"
                            ],
                            [
                                "bool",
                                "bWarnTarget"
                            ]
                        ],
                        "return": "rotator"
                    },
                    "AdjustDesireFor": {
                        "body": "{\n\treturn 0;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AdjustDesireFor",
                        "native": false,
                        "param": [
                            [
                                "Inventory",
                                "Inv"
                            ]
                        ],
                        "return": "float"
                    },
                    "AdjustHitLocation": {
                        "body": "{\n\n\tTraceDir = Normal(TraceDir);\n\tHitLocation = HitLocation + 0.4 * CollisionRadius * TraceDir;\n\n/* DEUS_EX STM -- took this out because it fucks up crouching\n\tif ( (GetAnimGroup(AnimSequence) == 'Ducking') && (AnimFrame > -0.03) )\n\t{\n\t\tmaxZ = Location.Z + 0.25 * CollisionHeight;\n\t\tif ( HitLocation.Z > maxZ )\n\t\t{\n\t\t\tif ( TraceDir.Z >= 0 )\n\t\t\t\treturn false;\n\t\t\tadjZ = (maxZ - HitLocation.Z)/TraceDir.Z;\n\t\t\tHitLocation.Z = maxZ;\n\t\t\tHitLocation.X = HitLocation.X + TraceDir.X * adjZ;\n\t\t\tHitLocation.Y = HitLocation.Y + TraceDir.Y * adjZ;\n\t\t\tif ( VSize(HitLocation - Location) > CollisionRadius )\t\n\t\t\t\treturn false;\n\t\t}\n\t}\n*/\n\n\treturn true;\n}",
                        "locals": [
                            "local float adjZ, maxZ;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "AdjustHitLocation",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "vector",
                                "HitLocation"
                            ],
                            [
                                "vector",
                                "TraceDir"
                            ]
                        ],
                        "return": "bool"
                    },
                    "AdjustToss": {
                        "body": "{\n\treturn ViewRotation;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AdjustToss",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "projSpeed"
                            ],
                            [
                                "vector",
                                "projStart"
                            ],
                            [
                                "int",
                                "aimerror"
                            ],
                            [
                                "bool",
                                "bLeadTarget"
                            ],
                            [
                                "bool",
                                "bWarnTarget"
                            ]
                        ],
                        "return": "rotator"
                    },
                    "BaseChange": {
                        "body": "{\n\n\tif ( (base == None) && (Physics == PHYS_None) )\n\t\tSetPhysics(PHYS_Falling);\n\telse if (Pawn(Base) != None)\n\t{\n\t\tBase.TakeDamage( (1-Velocity.Z/400)* Mass/Base.Mass, Self,Location,0.5 * Velocity , 'stomped');\n\t\tJumpOffPawn();\n\t}\n\telse if ( (Decoration(Base) != None) && (Velocity.Z < -400) )\n\t{\n\t\tdecorMass = FMax(Decoration(Base).Mass, 1);\n\t\tBase.TakeDamage((-2* Mass/decorMass * Velocity.Z/400), Self, Location, 0.5 * Velocity, 'stomped');\n\t}\n}",
                        "locals": [
                            "local float decorMass;"
                        ],
                        "modifiers": [
                            "singular"
                        ],
                        "name": "BaseChange",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BecomeViewTarget": {
                        "body": "{\n\tbViewTarget = true;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BecomeViewTarget",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BeginState": {
                        "body": "{\n\t\tSetPhysics(PHYS_None);\n\t\tHidePlayer();\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BotVoiceMessage": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "BotVoiceMessage",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "messagetype"
                            ],
                            [
                                "byte",
                                "MessageID"
                            ],
                            [
                                "Pawn",
                                "Sender"
                            ]
                        ],
                        "return": ""
                    },
                    "CanSee": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "CanSee",
                        "native": true,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangedWeapon": {
                        "body": "{\n\n\tOldWeapon = Weapon;\n\n\tif (Weapon == PendingWeapon)\n\t{\n\t\tif ( Weapon == None )\n\t\t\tSwitchToBestWeapon();\n\t\telse if ( Weapon.IsInState('DownWeapon') ) \n\t\t\tWeapon.BringUp();\n\t\tif ( Weapon != None )\n\t\t\tWeapon.SetDefaultDisplayProperties();\n\t\tInventory.ChangedWeapon(); // tell inventory that weapon changed (in case any effect was being applied)\n\t\tPendingWeapon = None;\n\t\treturn;\n\t}\n\t// removed these lines so you don't automatically pick another weapon - DEUS_EX CNN\n//\tif ( PendingWeapon == None )\n//\t\tPendingWeapon = Weapon;\n\n\tPlayWeaponSwitch(PendingWeapon);\n\tif ( (PendingWeapon != None) && (PendingWeapon.Mass > 20) && (carriedDecoration != None) )\n\t\tDropDecoration();\n\tif ( Weapon != None )\n\t\tWeapon.SetDefaultDisplayProperties();\n\t\t\n\tWeapon = PendingWeapon;\n\tInventory.ChangedWeapon(); // tell inventory that weapon changed (in case any effect was being applied)\n\tif ( Weapon != None )\n\t{\n\t\tWeapon.RaiseUp(OldWeapon);\n\t\tif ( (Level.Game != None) && (Level.Game.Difficulty > 1) )\n\t\t\tMakeNoise(0.1 * Level.Game.Difficulty);\t\t\n\t}\n\tPendingWeapon = None;\n}",
                        "locals": [
                            "local Weapon OldWeapon;"
                        ],
                        "modifiers": [],
                        "name": "ChangedWeapon",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CheckFutureSight": {
                        "body": "{\n\treturn true;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CheckFutureSight",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": "bool"
                    },
                    "CheckWaterJump": {
                        "body": "{\n\n\tif (CarriedDecoration != None)\n\t\treturn false;\n\tcheckpoint = vector(Rotation);\n\tcheckpoint.Z = 0.0;\n\tcheckNorm = Normal(checkpoint);\n\tcheckPoint = Location + CollisionRadius * checkNorm;\n\tExtent = CollisionRadius * vect(1,1,0);\n\tExtent.Z = CollisionHeight;\n\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, true, Extent);\n\tif ( (HitActor != None) && (Pawn(HitActor) == None) )\n\t{\n\t\tWallNormal = -1 * HitNormal;\n\t\tstart = Location;\n\t\tstart.Z += 1.1 * MaxStepHeight;\n\t\tcheckPoint = start + 2 * CollisionRadius * checkNorm;\n\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, start, true);\n\t\tif (HitActor == None)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
                        "locals": [
                            "local actor HitActor;",
                            "local vector HitLocation, HitNormal, checkpoint, start, checkNorm, Extent;"
                        ],
                        "modifiers": [],
                        "name": "CheckWaterJump",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "vector",
                                "WallNormal"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ClearPaths": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClearPaths",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "ClientDying": {
                        "body": "{\n\tPlayDying(DamageType, HitLocation);\n\tGotoState('Dying');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientDying",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "DamageType"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientGameEnded": {
                        "body": "{\n\tGotoState('GameEnded');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientGameEnded",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ClientMessage": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientMessage",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "S"
                            ],
                            [
                                "optional",
                                "name",
                                "Type"
                            ],
                            [
                                "optional",
                                "bool",
                                "bBeep"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientPutDown": {
                        "body": "{\n\tCurrent.ClientPutDown(Next);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientPutDown",
                        "native": false,
                        "param": [
                            [
                                "Weapon",
                                "Current"
                            ],
                            [
                                "Weapon",
                                "Next"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientReStart": {
                        "body": "{\n\t//log(\"client restart\");\n\n\tVelocity = vect(0,0,0);\n\tAcceleration = vect(0,0,0);\n\tBaseEyeHeight = Default.BaseEyeHeight;\n\tEyeHeight = BaseEyeHeight;\n\tPlayWaiting();\n\n\tif ( Region.Zone.bWaterZone && (PlayerRestartState == 'PlayerWalking') )\n\t{\n\t\tif (HeadRegion.Zone.bWaterZone)\n\t\t\t\tPainTime = UnderWaterTime;\n\t\tsetPhysics(PHYS_Swimming);\n\t\tGotoState('PlayerSwimming');\n\t}\n\telse\n\t\tGotoState(PlayerReStartState);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientReStart",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ClientSetLocation": {
                        "body": "{\n\n\tViewRotation      = NewRotation;\n\tIf ( (ViewRotation.Pitch > RotationRate.Pitch) && (ViewRotation.Pitch < 65536 - RotationRate.Pitch) )\n\t{\n\t\tIf (ViewRotation.Pitch < 32768) \n\t\t\tNewRotation.Pitch = RotationRate.Pitch;\n\t\telse\n\t\t\tNewRotation.Pitch = 65536 - RotationRate.Pitch;\n\t}\n\n\tNewRotation.Roll  = 0;\n\tSetRotation( NewRotation );\n\tSetLocation( NewLocation );\n}",
                        "locals": [
                            "local Pawn P;"
                        ],
                        "modifiers": [],
                        "name": "ClientSetLocation",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "NewLocation"
                            ],
                            [
                                "rotator",
                                "NewRotation"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientSetRotation": {
                        "body": "{\n\n\tViewRotation      = NewRotation;\n\tNewRotation.Pitch = 0;\n\tNewRotation.Roll  = 0;\n\tSetRotation( NewRotation );\n}",
                        "locals": [
                            "local Pawn P;"
                        ],
                        "modifiers": [],
                        "name": "ClientSetRotation",
                        "native": false,
                        "param": [
                            [
                                "rotator",
                                "NewRotation"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientVoiceMessage": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientVoiceMessage",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "Sender"
                            ],
                            [
                                "PlayerReplicationInfo",
                                "Recipient"
                            ],
                            [
                                "name",
                                "messagetype"
                            ],
                            [
                                "byte",
                                "messageID"
                            ]
                        ],
                        "return": ""
                    },
                    "ComputePathnodeDistances": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ComputePathnodeDistances",
                        "native": true,
                        "param": [
                            [
                                "optional",
                                "actor",
                                "startActor"
                            ]
                        ],
                        "return": ""
                    },
                    "DeleteInventory": {
                        "body": "{\n\t// If this item is in our inventory chain, unlink it.\n\n\tif ( Item == Weapon )\n\t\tWeapon = None;\n\tif ( Item == SelectedItem )\n\t\tSelectedItem = None;\n\tfor( Link = Self; Link!=None; Link=Link.Inventory )\n\t{\n\t\tif( Link.Inventory == Item )\n\t\t{\n\t\t\tLink.Inventory = Item.Inventory;\n\t\t\tbreak;\n\t\t}\n\t}\n\tItem.SetOwner(None);\n}",
                        "locals": [
                            "local actor Link;"
                        ],
                        "modifiers": [],
                        "name": "DeleteInventory",
                        "native": false,
                        "param": [
                            [
                                "inventory",
                                "Item"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Destroyed": {
                        "body": "{\n\n\tif ( Shadow != None )\n\t\tShadow.Destroy();\n\tRemovePawn();\n\tif ( Role < ROLE_Authority )\n\t\treturn;\n\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )   \n\t\tInv.Destroy();\n\tWeapon = None;\n\tInventory = None;\n\tif ( bIsPlayer && (Level.Game != None) )\n\t\tLevel.Game.logout(self);\n\tif ( PlayerReplicationInfo != None )\n\t\tPlayerReplicationInfo.Destroy();\n\tfor ( OtherPawn=Level.PawnList; OtherPawn!=None; OtherPawn=OtherPawn.nextPawn )\n\t\tOtherPawn.Killed(None, self, '');\n\tSuper.Destroyed();\n}",
                        "locals": [
                            "local Inventory Inv;",
                            "local Pawn OtherPawn;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Destroyed",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Died": {
                        "body": "{\n\n\tif ( bDeleteMe )\n\t\treturn; //already destroyed\n\tHealth = Min(0, Health);\n\tfor ( OtherPawn=Level.PawnList; OtherPawn!=None; OtherPawn=OtherPawn.nextPawn )\n\t\tOtherPawn.Killed(Killer, self, damageType);\n\tif ( CarriedDecoration != None )\n\t\tDropDecoration();\n\tlevel.game.Killed(Killer, self, damageType);\n\t//log(class$\" dying\");\n\tif( Event != '' )\n\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\tA.Trigger( Self, Killer );\n\tLevel.Game.DiscardInventory(self);\n\tVelocity.Z *= 1.3;\n   if ( Gibbed(damageType) )\n   {\n      SpawnGibbedCarcass();\n      if ( bIsPlayer )\n         HidePlayer();\n      else\n         Destroy();\n   }\n\tPlayDying(DamageType, HitLocation);\n\tif ( Level.Game.bGameEnded )\n\t\treturn;\n\tif ( RemoteRole == ROLE_AutonomousProxy )\n\t\tClientDying(DamageType, HitLocation);\n\tGotoState('Dying');\n}",
                        "locals": [
                            "local pawn OtherPawn;",
                            "local actor A;"
                        ],
                        "modifiers": [],
                        "name": "Died",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "name",
                                "damageType"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ]
                        ],
                        "return": ""
                    },
                    "DropDecoration": {
                        "body": "{\n\tif (CarriedDecoration != None)\n\t{\n\t\tCarriedDecoration.bWasCarried = true;\n\t\tCarriedDecoration.SetBase(None);\n\t\tCarriedDecoration.SetPhysics(PHYS_Falling);\n\t\tCarriedDecoration.Velocity = Velocity + 10 * VRand();\n\t\tCarriedDecoration.Instigator = self;\n\n\t\t// turn off translucency - DEUS_EX CNN\n\t\tCarriedDecoration.Style = CarriedDecoration.Default.Style;\n\t\tCarriedDecoration.ScaleGlow = CarriedDecoration.Default.ScaleGlow;\n\t\tCarriedDecoration.bUnlit = CarriedDecoration.Default.bUnlit;\n\n\t\tCarriedDecoration = None;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "DropDecoration",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "EAdjustJump": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "EAdjustJump",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "EncroachedBy": {
                        "body": "{\n\tif ( Pawn(Other) != None )\n\t\tgibbedBy(Other);\n\t\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "EncroachedBy",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "EncroachingOn": {
                        "body": "{\n\tif ( (Other.Brush != None) || (Brush(Other) != None) )\n\t\treturn true;\n\t\t\n\tif ( (!bIsPlayer || bWarping) && (Pawn(Other) != None))\n\t\treturn true;\n\t\t\n\treturn false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "EncroachingOn",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": "bool"
                    },
                    "EnemyNotVisible": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "EnemyNotVisible",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Falling": {
                        "body": "{\n\t\t//SetPhysics(PHYS_Falling); //Note - physics changes type to PHYS_Falling by default\n\t\t//log(class$\" Falling\");\n\t\tPlayInAir();\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Falling",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FearThisSpot": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "FearThisSpot",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "ASpot"
                            ]
                        ],
                        "return": ""
                    },
                    "FellOutOfWorld": {
                        "body": "{\n\tHealth = -1;\n\tSetPhysics(PHYS_None);\n\tWeapon = None;\n\tDied(None, 'Fell', Location);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "FellOutOfWorld",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FindBestInventoryPath": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "FindBestInventoryPath",
                        "native": true,
                        "param": [
                            [
                                "out",
                                "float",
                                "MinWeight"
                            ],
                            [
                                "bool",
                                "bPredictRespawns"
                            ]
                        ],
                        "return": ""
                    },
                    "FindRandomDest": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "FindRandomDest",
                        "native": true,
                        "param": [
                            [
                                "optional",
                                "bool",
                                "bClearPaths"
                            ]
                        ],
                        "return": ""
                    },
                    "FindStairRotation": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "FindStairRotation",
                        "native": true,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "FireWeapon": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "FireWeapon",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FootZoneChange": {
                        "body": "{\n\t\n\tif ( Level.NetMode == NM_Client )\n\t\treturn;\n\tif ( Level.TimeSeconds - SplashTime > 0.25 ) \n\t{\n\t\tSplashTime = Level.TimeSeconds;\n\t\tif (Physics == PHYS_Falling)\n\t\t\tMakeNoise(1.0);\n\t\telse\n\t\t\tMakeNoise(0.3);\n\t\tif ( FootRegion.Zone.bWaterZone )\n\t\t{\n\t\t\tif ( !newFootZone.bWaterZone && (Role==ROLE_Authority) )\n\t\t\t{\n\t\t\t\tif ( FootRegion.Zone.ExitSound != None )\n\t\t\t\t\tPlaySound(FootRegion.Zone.ExitSound, SLOT_Interact, 1); \n\t\t\t\tif ( FootRegion.Zone.ExitActor != None )\n\t\t\t\t\tSpawn(FootRegion.Zone.ExitActor,,,Location - CollisionHeight * vect(0,0,1));\n\t\t\t}\n\t\t}\n\t\telse if ( newFootZone.bWaterZone && (Role==ROLE_Authority) )\n\t\t{\n\t\t\tsplashSize = FClamp(0.000025 * Mass * (300 - 0.5 * FMax(-500, Velocity.Z)), 1.0, 4.0 );\n\t\t\tif ( newFootZone.EntrySound != None )\n\t\t\t{\n\t\t\t\tHitActor = Trace(HitLocation, HitNormal, \n\t\t\t\t\t\tLocation - (CollisionHeight + 40) * vect(0,0,0.8), Location - CollisionHeight * vect(0,0,0.8), false);\n\t\t\t\tif ( HitActor == None )\n\t\t\t\t\tPlaySound(newFootZone.EntrySound, SLOT_Misc, 2 * splashSize);\n\t\t\t\telse \n\t\t\t\t\tPlaySound(WaterStep, SLOT_Misc, 1.5 + 0.5 * splashSize);\n\t\t\t}\n\t\t\tif( newFootZone.EntryActor != None )\n\t\t\t{\n\t\t\t\tsplash = Spawn(newFootZone.EntryActor,,,Location - CollisionHeight * vect(0,0,1));\n\t\t\t\tif ( splash != None )\n\t\t\t\t\tsplash.DrawScale = splashSize;\n\t\t\t}\n\t\t\t//log(\"Feet entering water\");\n\t\t}\n\t}\n\t\n\tif (FootRegion.Zone.bPainZone)\n\t{\n\t\tif ( !newFootZone.bPainZone && !HeadRegion.Zone.bWaterZone )\n\t\t\tPainTime = -1.0;\n\t}\n\telse if (newFootZone.bPainZone)\n\t\tPainTime = 0.01;\n}",
                        "locals": [
                            "local actor HitActor;",
                            "local vector HitNormal, HitLocation;",
                            "local float splashSize;",
                            "local actor splash;"
                        ],
                        "modifiers": [],
                        "name": "FootZoneChange",
                        "native": false,
                        "param": [
                            [
                                "ZoneInfo",
                                "newFootZone"
                            ]
                        ],
                        "return": ""
                    },
                    "Gasp": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Gasp",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GetHumanName": {
                        "body": "{\n\tif ( PlayerReplicationInfo != None )\n\t\treturn PlayerReplicationInfo.PlayerName;\n\treturn NameArticle$MenuName;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetHumanName",
                        "native": false,
                        "param": [],
                        "return": "String"
                    },
                    "GetMultiSkin": {
                        "body": "{\n\tSkinName = String(SkinActor.Skin);\n\tFaceName = \"\";\n}",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "GetMultiSkin",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "SkinActor"
                            ],
                            [
                                "out",
                                "string",
                                "SkinName"
                            ],
                            [
                                "out",
                                "string",
                                "FaceName"
                            ]
                        ],
                        "return": ""
                    },
                    "GetRating": {
                        "body": "{\n\treturn 1000;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetRating",
                        "native": false,
                        "param": [],
                        "return": "float"
                    },
                    "Gibbed": {
                        "body": "{\n\treturn false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Gibbed",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": "bool"
                    },
                    "GrabDecoration": {
                        "body": "{\n\n\tif ( carriedDecoration == None )\n\t{\n\t\t//first trace to find it\n\t\tlookDir = vector(Rotation);\n\t\tlookDir.Z = 0;\n\t\tT1 = Location + BaseEyeHeight * vect(0,0,1) + lookDir * 0.8 * CollisionRadius;\n\t\tT2 = T1 + lookDir * 1.2 * CollisionRadius;\n\t\tHitActor = Trace(HitLocation, HitNormal, T2, T1, true);\n\t\tif ( HitActor == None )\n\t\t{\n\t\t\tT1 = T2 - (BaseEyeHeight + CollisionHeight - 2) * vect(0,0,1);\n\t\t\tHitActor = Trace(HitLocation, HitNormal, T1, T2, true);\n\t\t}\n\t\telse if ( HitActor == Level )\n\t\t{\n\t\t\tT2 = HitLocation - lookDir;\n\t\t\tT1 = T2 - (BaseEyeHeight + CollisionHeight - 2) * vect(0,0,1);\n\t\t\tHitActor = Trace(HitLocation, HitNormal, T1, T2, true);\n\t\t}\t\n\t\tif ( (HitActor == None) || (HitActor == Level) )\n\t\t{\n\t\t\textent.X = CollisionRadius;\n\t\t\textent.Y = CollisionRadius;\n\t\t\textent.Z = CollisionHeight;\n\t\t\tHitActor = Trace(HitLocation, HitNormal, Location + lookDir * 1.2 * CollisionRadius, Location, true, extent);\n\t\t}\n\n\t\tif ( Mover(HitActor) != None )\n\t\t{\n\t\t\tif ( Mover(HitActor).bUseTriggered )\n\t\t\t\tHitActor.Trigger( self, self );\n\t\t}\t\t\n\t\telse if ( (Decoration(HitActor) != None)  && ((weapon == None) || (weapon.Mass < 20)) )\n\t\t{\n\t\t\tCarriedDecoration = Decoration(HitActor);\n\t\t\tif ( !CarriedDecoration.bPushable || (CarriedDecoration.Mass > 40) \n\t\t\t\t|| (CarriedDecoration.StandingCount > 0) )\n\t\t\t{\n\t\t\t\tCarriedDecoration = None;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlookDir.Z = 0;\t\t\t\t\n\t\t\tif ( CarriedDecoration.SetLocation(Location + (0.5 * CollisionRadius + CarriedDecoration.CollisionRadius) * lookDir) )\n\t\t\t{\n\t\t\t\tCarriedDecoration.SetPhysics(PHYS_None);\n\t\t\t\tCarriedDecoration.SetBase(self);\n\n\t\t\t\t// make it translucent - DEUS_EX CNN\n\t\t\t\tCarriedDecoration.Style = STY_Translucent;\n\t\t\t\tCarriedDecoration.ScaleGlow = 1.0;\n\t\t\t\tCarriedDecoration.bUnlit = True;\n\t\t\t}\n\t\t\telse\n\t\t\t\tCarriedDecoration = None;\n\t\t}\n\t}\n}",
                        "locals": [
                            "local vector lookDir, HitLocation, HitNormal, T1, T2, extent;",
                            "local actor HitActor;"
                        ],
                        "modifiers": [],
                        "name": "GrabDecoration",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "HandleHelpMessageFrom": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "HandleHelpMessageFrom",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "HeadZoneChange": {
                        "body": "{\n\tif ( Level.NetMode == NM_Client )\n\t\treturn;\n\tif (HeadRegion.Zone.bWaterZone)\n\t{\n\t\tif (!newHeadZone.bWaterZone)\n\t\t{\n\t\t\tif ( bIsPlayer && (PainTime > 0) && (PainTime < 8) )\n\t\t\t\tGasp();\n\t\t\tif ( Inventory != None )\n\t\t\t\tInventory.ReduceDamage(0, 'Breathe', Location); //inform inventory of zone change\n\t\t\tbDrowning = false;\n\t\t\tif ( !FootRegion.Zone.bPainZone )\n\t\t\t\tPainTime = -1.0;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (newHeadZone.bWaterZone)\n\t\t{\n\t\t\tif ( !FootRegion.Zone.bPainZone )\n\t\t\t\tPainTime = UnderWaterTime;\n\t\t\tif ( Inventory != None )\n\t\t\t\tInventory.ReduceDamage(0, 'Drowned', Location); //inform inventory of zone change\n\t\t\t//log(\"Can't breathe\");\n\t\t}\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "HeadZoneChange",
                        "native": false,
                        "param": [
                            [
                                "ZoneInfo",
                                "newHeadZone"
                            ]
                        ],
                        "return": ""
                    },
                    "HearNoise": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "HearNoise",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Loudness"
                            ],
                            [
                                "Actor",
                                "NoiseMaker"
                            ]
                        ],
                        "return": ""
                    },
                    "HidePlayer": {
                        "body": "{\n\tSetCollision(false, false, false);\n\tTweenToFighter(0.01);\n\tbHidden = true;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "HidePlayer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "InitPlayerReplicationInfo": {
                        "body": "{\n\tif (PlayerReplicationInfo.PlayerName == \"\")\n\t\tPlayerReplicationInfo.PlayerName = class'GameInfo'.Default.DefaultPlayerName;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "InitPlayerReplicationInfo",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "JumpOffPawn": {
                        "body": "{\n\tVelocity += 60 * VRand();\n\tVelocity.Z = 180;\n\tSetPhysics(PHYS_Falling);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "JumpOffPawn",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "KillMessage": {
                        "body": "{\n\n\tmessage = Level.Game.CreatureKillMessage(damageType, Other);\n\treturn (message$namearticle$menuname);\n}",
                        "locals": [
                            "local string message;"
                        ],
                        "modifiers": [],
                        "name": "KillMessage",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "damageType"
                            ],
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": "string"
                    },
                    "Killed": {
                        "body": "{\n\tif ( Enemy == Other )\n\t\tEnemy = None;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Killed",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "pawn",
                                "Other"
                            ],
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": ""
                    },
                    "Landed": {
                        "body": "{\n\t\tSetPhysics(PHYS_None);\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Landed",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "HitNormal"
                            ]
                        ],
                        "return": ""
                    },
                    "LineOfSightTo": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "LineOfSightTo",
                        "native": true,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "optional",
                                "bool",
                                "bIgnoreDistance"
                            ]
                        ],
                        "return": ""
                    },
                    "LipSynch": {
                        "body": "{\n\n\t// update the animation timers that we are using\n\tanimTimer[0] += deltaTime;\n\tanimTimer[1] += deltaTime;\n\tanimTimer[2] += deltaTime;\n\n\tif (bIsSpeaking)\n\t{\n\t\t// if our framerate is high enough (>20fps), tween the lips smoothly\n\t\tif (Level.TimeSeconds - animTimer[3]  < 0.05)\n\t\t\ttweentime = 0.1;\n\t\telse\n\t\t\ttweentime = 0.0;\n\n\t\t// the last animTimer slot is used to check framerate\n\t\tanimTimer[3] = Level.TimeSeconds;\n\n\t\tif (nextPhoneme == \"A\")\n\t\t\tanimseq = 'MouthA';\n\t\telse if (nextPhoneme == \"E\")\n\t\t\tanimseq = 'MouthE';\n\t\telse if (nextPhoneme == \"F\")\n\t\t\tanimseq = 'MouthF';\n\t\telse if (nextPhoneme == \"M\")\n\t\t\tanimseq = 'MouthM';\n\t\telse if (nextPhoneme == \"O\")\n\t\t\tanimseq = 'MouthO';\n\t\telse if (nextPhoneme == \"T\")\n\t\t\tanimseq = 'MouthT';\n\t\telse if (nextPhoneme == \"U\")\n\t\t\tanimseq = 'MouthU';\n\t\telse if (nextPhoneme == \"X\")\n\t\t\tanimseq = 'MouthClosed';\n\n\t\tif (animseq != '')\n\t\t{\n\t\t\tif (lastPhoneme != nextPhoneme)\n\t\t\t{\n\t\t\t\tlastPhoneme = nextPhoneme;\n\t\t\t\tTweenBlendAnim(animseq, tweentime);\n\t\t\t}\n\t\t}\n\t}\n\telse if (bWasSpeaking)\n\t{\n\t\tbWasSpeaking = False;\n\t\tTweenBlendAnim('MouthClosed', tweentime);\n\t}\n\n\t// blink randomly\n\tif (animTimer[0] > 2.0)\n\t{\n\t\tanimTimer[0] = 0;\n\t\tif (FRand() < 0.4)\n\t\t\tPlayBlendAnim('Blink', 1.0, 0.1, 1);\n\t}\n\n\tLoopHeadConvoAnim();\n\tLoopBaseConvoAnim();\n}",
                        "locals": [
                            "local name animseq;",
                            "local float rnd;",
                            "local float tweentime;"
                        ],
                        "modifiers": [],
                        "name": "LipSynch",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "deltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "LongFall": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "LongFall",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "LoopBaseConvoAnim": {
                        "body": "{\n\n\trnd = FRand();\n\n\t// move arms randomly\n\tif (bIsSpeaking)\n\t{\n\t\tif (animTimer[2] > 2.5)\n\t\t{\n\t\t\tanimTimer[2] = 0;\n\t\t\tif (rnd < 0.1)\n\t\t\t\tPlayAnim('GestureLeft', 0.35, 0.4);\n\t\t\telse if (rnd < 0.2)\n\t\t\t\tPlayAnim('GestureRight', 0.35, 0.4);\n\t\t\telse if (rnd < 0.3)\n\t\t\t\tPlayAnim('GestureBoth', 0.35, 0.4);\n\t\t}\n\t}\n\n\t// if we're not playing an animation, loop the breathe\n\tif (!IsAnimating())\n\t\tLoopAnim('BreatheLight',, 0.4);\n}",
                        "locals": [
                            "local float rnd;"
                        ],
                        "modifiers": [],
                        "name": "LoopBaseConvoAnim",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "LoopHeadConvoAnim": {
                        "body": "{\n\n\trnd = FRand();\n\n\t// move head randomly (only while not speaking)\n\tif (!bIsSpeaking && (animTimer[1] > 0.5))\n\t{\n\t\tif (rnd < 0.01)\n\t\t\tPlayTurnHead(LOOK_Left, 1.0, 2.0);\n\t\telse if (rnd < 0.02)\n\t\t\tPlayTurnHead(LOOK_Right, 1.0, 2.0);\n\t\telse\n\t\t\tPlayTurnHead(LOOK_Forward, 1.0, 1.0);\n\t}\n}",
                        "locals": [
                            "local float rnd;"
                        ],
                        "modifiers": [],
                        "name": "LoopHeadConvoAnim",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "MoveTo": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "MoveTo",
                        "native": true,
                        "param": [
                            [
                                "vector",
                                "NewDestination"
                            ],
                            [
                                "optional",
                                "float",
                                "speed"
                            ]
                        ],
                        "return": ""
                    },
                    "MoveToward": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "MoveToward",
                        "native": true,
                        "param": [
                            [
                                "actor",
                                "NewTarget"
                            ],
                            [
                                "optional",
                                "float",
                                "speed"
                            ]
                        ],
                        "return": ""
                    },
                    "NextItem": {
                        "body": "{\n\n\t// DEUS_EX CNN - this function is EVIL!\n\treturn;\n\n\tif (SelectedItem==None) {\n\t\tSelectedItem = Inventory.SelectNext();\n\t\tReturn;\n\t}",
                        "locals": [
                            "local Inventory Inv;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "NextItem",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PainTimer": {
                        "body": "{\n\n\t//log(\"Pain Timer\");\n\tif ( (Health < 0) || (Level.NetMode == NM_Client) )\n\t\treturn;\n\t\t\n\tif ( FootRegion.Zone.bPainZone )\n\t{\n\t\tdepth = 0.4;\n\t\tif (Region.Zone.bPainZone)\n\t\t\tdepth += 0.4;\n\t\tif (HeadRegion.Zone.bPainZone)\n\t\t\tdepth += 0.2;\n\n\t\tif (FootRegion.Zone.DamagePerSec > 0)\n\t\t{\n\t\t\tif ( IsA('PlayerPawn') )\n\t\t\t\tLevel.Game.SpecialDamageString = FootRegion.Zone.DamageString;\n\t\t\tTakeDamage(int(float(FootRegion.Zone.DamagePerSec) * depth), None, Location, vect(0,0,0), FootRegion.Zone.DamageType); \n\t\t}\n\t\telse if ( Health < Default.Health )\n\t\t\tHealth = Min(Default.Health, Health - depth * FootRegion.Zone.DamagePerSec);\n\n\t\tif (Health > 0)\n\t\t\tPainTime = 1.0;\n\t}\n\telse if ( HeadRegion.Zone.bWaterZone )\n\t{\n\t\t// DEUS_EX CNN - make drowning damage happen from center\n\t\tTakeDamage(5, None, Location, vect(0,0,0), 'Drowned'); \n\t\tif ( Health > 0 )\n\t\t\tPainTime = 2.0;\n\t}\n}",
                        "locals": [
                            "local float depth;"
                        ],
                        "modifiers": [],
                        "name": "PainTimer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PickAnyTarget": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PickAnyTarget",
                        "native": true,
                        "param": [
                            [
                                "out",
                                "float",
                                "bestAim"
                            ],
                            [
                                "out",
                                "float",
                                "bestDist"
                            ],
                            [
                                "vector",
                                "FireDir"
                            ],
                            [
                                "vector",
                                "projStart"
                            ]
                        ],
                        "return": ""
                    },
                    "PickTarget": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PickTarget",
                        "native": true,
                        "param": [
                            [
                                "out",
                                "float",
                                "bestAim"
                            ],
                            [
                                "out",
                                "float",
                                "bestDist"
                            ],
                            [
                                "vector",
                                "FireDir"
                            ],
                            [
                                "vector",
                                "projStart"
                            ]
                        ],
                        "return": ""
                    },
                    "PickWallAdjust": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PickWallAdjust",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "PlayBigDeath": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayBigDeath",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "DamageType"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayCrawling": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayCrawling",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayDeathHit": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayDeathHit",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Damage"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ],
                            [
                                "name",
                                "damageType"
                            ],
                            [
                                "vector",
                                "Momentum"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayDive": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayDive",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayDuck": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayDuck",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayDying": {
                        "body": "{\n\n\tif ( Velocity.Z > 250 )\n\t{\n\t\tPlayBigDeath(DamageType);\n\t\treturn;\n\t}\n\t\n\tif ( DamageType == 'Decapitated' )\n\t{\n\t\tPlayHeadDeath(DamageType);\n\t\treturn;\n\t}\n\t\t\t\n\tGetAxes(Rotation,X,Y,Z);\n\tX.Z = 0;\n\tHitVec = Normal(HitLoc - Location);\n\tHitVec2D= HitVec;\n\tHitVec2D.Z = 0;\n\tdotp = HitVec2D dot X;\n\n\t//first check for head hit\n\tif ( HitLoc.Z - Location.Z > 0.5 * CollisionHeight )\n\t{\n\t\tif (dotp > 0)\n\t\t\tPlayHeadDeath(DamageType);\n\t\telse\n\t\t\tPlayGutDeath(DamageType);\n\t\treturn;\n\t}\n\t\n\tif (dotp > 0.71) //then hit in front\n\t\tPlayGutDeath(DamageType);\n\telse\n\t{\n\t\tdotp = HitVec dot Y;\n\t\tif (dotp > 0.0)\n\t\t\tPlayLeftDeath(DamageType);\n\t\telse\n\t\t\tPlayRightDeath(DamageType);\n\t}\n}",
                        "locals": [
                            "local vector X,Y,Z, HitVec, HitVec2D;",
                            "local float dotp;"
                        ],
                        "modifiers": [],
                        "name": "PlayDying",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "DamageType"
                            ],
                            [
                                "vector",
                                "HitLoc"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayFiring": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayFiring",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayGutDeath": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayGutDeath",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "DamageType"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayGutHit": {
                        "body": "{\n\tlog(\"Error - play gut hit must be implemented in subclass of\"@class);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayGutHit",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "tweentime"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayHeadDeath": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayHeadDeath",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "DamageType"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayHeadHit": {
                        "body": "{\n\tPlayGutHit(tweentime);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayHeadHit",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "tweentime"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayHit": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayHit",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Damage"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ],
                            [
                                "name",
                                "damageType"
                            ],
                            [
                                "vector",
                                "Momentum"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayInAir": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayInAir",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayLanded": {
                        "body": "{\n\t//default - do nothing (keep playing existing animation)\n\tlandVol = impactVel/JumpZ;\n\tlandVol = 0.005 * Mass * landVol * landVol;\n\tPlaySound(Land, SLOT_Interact, FMin(20, landVol));\n}",
                        "locals": [
                            "local float landVol;"
                        ],
                        "modifiers": [],
                        "name": "PlayLanded",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "impactVel"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayLeftDeath": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayLeftDeath",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "DamageType"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayLeftHit": {
                        "body": "{\n\tPlayGutHit(tweentime);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayLeftHit",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "tweentime"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayMovingAttack": {
                        "body": "{\n\t////log(\"Error - PlayMovingAttack should be implemented in subclass\");\n\t//Note - must restart attack timer when done with moving attack\n\tPlayRunning();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayMovingAttack",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayOutOfWater": {
                        "body": "{\n\tTweenToFalling();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayOutOfWater",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayPatrolStop": {
                        "body": "{\n\tPlayWaiting();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayPatrolStop",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayRecoil": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayRecoil",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Rate"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayRightDeath": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayRightDeath",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "DamageType"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayRightHit": {
                        "body": "{\n\tPlayGutHit(tweentime);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayRightHit",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "tweentime"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayRunning": {
                        "body": "{\n\t////log(\"Error - PlayRunning should be implemented in subclass of\"@class);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayRunning",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayTakeHit": {
                        "body": "{\n\t\n\tGetAxes(Rotation,X,Y,Z);\n\tX.Z = 0;\n\tHitVec = Normal(HitLoc - Location);\n\tHitVec2D= HitVec;\n\tHitVec2D.Z = 0;\n\tdotp = HitVec2D dot X;\n\n\t//first check for head hit\n\tif ( HitLoc.Z - Location.Z > 0.5 * CollisionHeight )\n\t{\n\t\tif (dotp > 0)\n\t\t\tPlayHeadHit(tweentime);\n\t\telse\n\t\t\tPlayGutHit(tweentime);\n\t\treturn;\n\t}\n\t\n\tif (dotp > 0.71) //then hit in front\n\t\tPlayGutHit( tweentime);\n\telse if (dotp < -0.71) // then hit in back\n\t\tPlayHeadHit(tweentime);\n\telse\n\t{\n\t\tdotp = HitVec dot Y;\n\t\tif (dotp > 0.0)\n\t\t\tPlayLeftHit(tweentime);\n\t\telse\n\t\t\tPlayRightHit(tweentime);\n\t}\n}",
                        "locals": [
                            "local vector X,Y,Z, HitVec, HitVec2D;",
                            "local float dotp;"
                        ],
                        "modifiers": [],
                        "name": "PlayTakeHit",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "tweentime"
                            ],
                            [
                                "vector",
                                "HitLoc"
                            ],
                            [
                                "int",
                                "damage"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayTakeHitSound": {
                        "body": "{\n\tif ( Level.TimeSeconds - LastPainSound < 0.25 )\n\t\treturn;\n\n\tif (HitSound1 == None)return;\n\tLastPainSound = Level.TimeSeconds;\n\tif (FRand() < 0.5)\n\t\tPlaySound(HitSound1, SLOT_Pain, FMax(Mult * TransientSoundVolume, Mult * 2.0));\n\telse\n\t\tPlaySound(HitSound2, SLOT_Pain, FMax(Mult * TransientSoundVolume, Mult * 2.0));\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayTakeHitSound",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Damage"
                            ],
                            [
                                "name",
                                "damageType"
                            ],
                            [
                                "int",
                                "Mult"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayThreatening": {
                        "body": "{\n\tTweenToFighter(0.1);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayThreatening",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayTurnHead": {
                        "body": "{\n\n\tif (dir == LOOK_Left)\n\t\tlookName = 'HeadLeft';\n\telse if (dir == LOOK_Right)\n\t\tlookName = 'HeadRight';\n\telse if (dir == LOOK_Up)\n\t\tlookName = 'HeadUp';\n\telse if (dir == LOOK_Down)\n\t\tlookName = 'HeadDown';\n\telse\n\t\tlookName = 'Still';\n\n\tbSuccess = false;\n\tif (BlendAnimSequence[3] != lookName)\n\t{\n\t\tif (animTimer[1] > 0.00)\n\t\t{\n\t\t\tanimTimer[1] = 0;\n\t\t\tif (BlendAnimSequence[3] == '')\n\t\t\t\tBlendAnimSequence[3] = 'Still';\n\t\t\tPlayBlendAnim(lookName, rate, tweentime, 3);\n\t\t\tbSuccess = true;\n\t\t}\n\t}\n\n\treturn (bSuccess);\n}",
                        "locals": [
                            "local name lookName;",
                            "local bool bSuccess;"
                        ],
                        "modifiers": [],
                        "name": "PlayTurnHead",
                        "native": false,
                        "param": [
                            [
                                "ELookDirection",
                                "dir"
                            ],
                            [
                                "float",
                                "rate"
                            ],
                            [
                                "float",
                                "tweentime"
                            ]
                        ],
                        "return": "bool"
                    },
                    "PlayTurning": {
                        "body": "{\n\tTweenToFighter(0.1);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayTurning",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayVictoryDance": {
                        "body": "{\n\tTweenToFighter(0.1);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayVictoryDance",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayWaiting": {
                        "body": "{\n\t////log(\"Error - PlayWaiting should be implemented in subclass\");\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayWaiting",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayWaitingAmbush": {
                        "body": "{\n\tPlayWaiting();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayWaitingAmbush",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayWalking": {
                        "body": "{\n\tPlayRunning(); \n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayWalking",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayWeaponSwitch": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayWeaponSwitch",
                        "native": false,
                        "param": [
                            [
                                "Weapon",
                                "NewWeapon"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayerTimeOut": {
                        "body": "{\n\tif (Health > 0)\n\t\tDied(None, 'Suicided', Location);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayerTimeOut",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\tSuper.PostBeginPlay();\n\tSplashTime = 0;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostNetBeginPlay": {
                        "body": "{\n   \n   Super.PostNetBeginPlay();\n   bAlreadyAdded = false;\n   for (CurPawn = Level.PawnList; CurPawn != None; CurPawn = CurPawn.NextPawn)\n   {\n      if (CurPawn == Self)\n      {\n         bAlreadyAdded = true;\n         break;\n      }\n   }\n   if (!bAlreadyAdded)\n   {\n      AddPawn();\n   }\n   return;\n}",
                        "locals": [
                            "local pawn CurPawn;",
                            "local bool bAlreadyAdded;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PostNetBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tAddPawn();\n\tSuper.PreBeginPlay();\n\tif ( bDeleteMe )\n\t\treturn;\n\n\t// Added angular size computation - DEUS_EX STM\n\tMinAngularSize = tan(AngularResolution*0.5*Pi/180.0);\n\tMinAngularSize *= MinAngularSize;\n\n\t// Set instigator to self.\n\tInstigator = Self;\n\tDesiredRotation = Rotation;\n\tSightCounter = 0.2 * FRand();  //offset randomly \n\tif ( Level.Game != None )\n\t\tSkill += Level.Game.Difficulty; \n\tSkill = FClamp(Skill, 0, 3);\n\tPreSetMovement();\n\t\n\tif ( DrawScale != Default.Drawscale )\n\t{\n\t\tSetCollisionSize(CollisionRadius*DrawScale/Default.DrawScale, CollisionHeight*DrawScale/Default.DrawScale);\n\t\tHealth = Health * DrawScale/Default.DrawScale;\n\t}\n\n\tif (bIsPlayer)\n\t{\n\t\tif (PlayerReplicationInfoClass != None)\n\t\t\tPlayerReplicationInfo = Spawn(PlayerReplicationInfoClass, Self,,vect(0,0,0),rot(0,0,0));\n\t\telse\n\t\t\tPlayerReplicationInfo = Spawn(class'PlayerReplicationInfo', Self,,vect(0,0,0),rot(0,0,0));\n\t\tInitPlayerReplicationInfo();\n\t}\n\n\tif (!bIsPlayer) \n\t{\n\t\tif ( BaseEyeHeight == 0 )\n\t\t\tBaseEyeHeight = 0.8 * CollisionHeight;\n\t\tEyeHeight = BaseEyeHeight;\n\t\tif (Fatness == 0) //vary monster fatness slightly if at default\n\t\t\tFatness = 120 + Rand(8) + Rand(8);\n\t}\n\n\tif ( menuname == \"\" )\n\t\tmenuname = GetItemName(string(class));\n\n\tif (SelectionMesh == \"\")\n\t\tSelectionMesh = string(Mesh);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreSetMovement": {
                        "body": "{\n\tif (JumpZ > 0)\n\t\tbCanJump = true;\n\tbCanWalk = true;\n\tbCanSwim = false;\n\tbCanFly = false;\n\tMinHitWall = -0.6;\n\tif (Intelligence > BRAINS_Reptile)\n\t\tbCanOpenDoors = true;\n\tif (Intelligence == BRAINS_Human)\n\t\tbCanDoSpecial = true;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreSetMovement",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ReceiveLocalizedMessage": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ReceiveLocalizedMessage",
                        "native": false,
                        "param": [
                            [
                                "class<LocalMessage>",
                                "Message"
                            ],
                            [
                                "optional",
                                "int",
                                "Switch"
                            ],
                            [
                                "optional",
                                "PlayerReplicationInfo",
                                "RelatedPRI_1"
                            ],
                            [
                                "optional",
                                "PlayerReplicationInfo",
                                "RelatedPRI_2"
                            ],
                            [
                                "optional",
                                "Object",
                                "OptionalObject"
                            ]
                        ],
                        "return": ""
                    },
                    "RemovePawn": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "RemovePawn",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "RenderOverlays": {
                        "body": "{\n\tif ( Weapon != None )\n\t\tWeapon.RenderOverlays(Canvas);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "RenderOverlays",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "RestartPlayer": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "RestartPlayer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SeePlayer": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SeePlayer",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Seen"
                            ]
                        ],
                        "return": ""
                    },
                    "SendGlobalMessage": {
                        "body": "{\n\tSendVoiceMessage(PlayerReplicationInfo, Recipient, MessageType, MessageID, 'GLOBAL');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SendGlobalMessage",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "Recipient"
                            ],
                            [
                                "name",
                                "MessageType"
                            ],
                            [
                                "byte",
                                "MessageID"
                            ],
                            [
                                "float",
                                "Wait"
                            ]
                        ],
                        "return": ""
                    },
                    "SendTeamMessage": {
                        "body": "{\n\tSendVoiceMessage(PlayerReplicationInfo, Recipient, MessageType, MessageID, 'TEAM');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SendTeamMessage",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "Recipient"
                            ],
                            [
                                "name",
                                "MessageType"
                            ],
                            [
                                "byte",
                                "MessageID"
                            ],
                            [
                                "float",
                                "Wait"
                            ]
                        ],
                        "return": ""
                    },
                    "SendVoiceMessage": {
                        "body": "{\n\n\tif ( Level.TimeSeconds - OldMessageTime < 2.5 )\n\t\tbNoSpeak = true;\n\telse\n\t\tOldMessageTime = Level.TimeSeconds;\n\n\tfor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t{\n\t\tif ( P.IsA('PlayerPawn') )\n\t\t{  \n\t\t\tif ( !bNoSpeak )\n\t\t\t{\n\t\t\t\tif ( (broadcasttype == 'GLOBAL') || !Level.Game.bTeamGame )\n\t\t\t\t\tP.ClientVoiceMessage(Sender, Recipient, messagetype, messageID);\n\t\t\t\telse if ( Sender.Team == P.PlayerReplicationInfo.Team )\n\t\t\t\t\tP.ClientVoiceMessage(Sender, Recipient, messagetype, messageID);\n\t\t\t}\n\t\t}\n\t\telse if ( (P.PlayerReplicationInfo == Recipient) || ((messagetype == 'ORDER') && (Recipient == None)) )\n\t\t\tP.BotVoiceMessage(messagetype, messageID, self);\n\t}\n}",
                        "locals": [
                            "local Pawn P;",
                            "local bool bNoSpeak;"
                        ],
                        "modifiers": [],
                        "name": "SendVoiceMessage",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "Sender"
                            ],
                            [
                                "PlayerReplicationInfo",
                                "Recipient"
                            ],
                            [
                                "name",
                                "messagetype"
                            ],
                            [
                                "byte",
                                "messageID"
                            ],
                            [
                                "name",
                                "broadcasttype"
                            ]
                        ],
                        "return": ""
                    },
                    "SetDefaultDisplayProperties": {
                        "body": "{\n\tStyle = Default.Style;\n\ttexture = Default.Texture;\n\tbUnlit = Default.bUnlit;\n\tbMeshEnviromap = Default.bMeshEnviromap;\n\tif ( Weapon != None )\n\t\tWeapon.SetDisplayProperties(Weapon.Default.Style, Weapon.Default.Texture, Weapon.Default.bUnlit, Weapon.Default.bMeshEnviromap);\n\n\tif ( !bUpdatingDisplay && (Inventory != None) )\n\t{\n\t\tbUpdatingDisplay = true;\n\t\tInventory.SetOwnerDisplay();\n\t}\n\tbUpdatingDisplay = false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetDefaultDisplayProperties",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetDisplayProperties": {
                        "body": "{\n\tStyle = NewStyle;\n\ttexture = NewTexture;\n\tbUnlit = bLighting;\n\tbMeshEnviromap = bEnviromap;\n\tif ( Weapon != None )\n\t\tWeapon.SetDisplayProperties(Style, Texture, bUnlit, bMeshEnviromap);\n\n\tif ( !bUpdatingDisplay && (Inventory != None) )\n\t{\n\t\tbUpdatingDisplay = true;\n\t\tInventory.SetOwnerDisplay();\n\t}\n\tbUpdatingDisplay = false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetDisplayProperties",
                        "native": false,
                        "param": [
                            [
                                "ERenderStyle",
                                "NewStyle"
                            ],
                            [
                                "texture",
                                "NewTexture"
                            ],
                            [
                                "bool",
                                "bLighting"
                            ],
                            [
                                "bool",
                                "bEnviroMap"
                            ]
                        ],
                        "return": ""
                    },
                    "SetMovementPhysics": {
                        "body": "{\n\t//implemented in sub-class\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetMovementPhysics",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetMultiSkin": {
                        "body": "{\n\n\tif(SkinName != \"\")\n\t{\n\t\tNewSkin = texture(DynamicLoadObject(SkinName, class'Texture'));\n\t\tif ( NewSkin != None )\n\t\t\tSkinActor.Skin = NewSkin;\n\t}\n}",
                        "locals": [
                            "local Texture NewSkin;"
                        ],
                        "modifiers": [
                            "static"
                        ],
                        "name": "SetMultiSkin",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "SkinActor"
                            ],
                            [
                                "string",
                                "SkinName"
                            ],
                            [
                                "string",
                                "FaceName"
                            ],
                            [
                                "byte",
                                "TeamNum"
                            ]
                        ],
                        "return": ""
                    },
                    "SetSkinElement": {
                        "body": "{\n\n\tNewSkin = Texture(DynamicLoadObject(SkinName, class'Texture'));\n\tif ( NewSkin != None )\n\t{\n\t\tSkinActor.Multiskins[SkinNo] = NewSkin;\n\t\treturn True;\n\t}\n\telse\n\t{\n\t\tlog(\"Failed to load \"$SkinName);\n\t\tif(DefaultSkinName != \"\")\n\t\t{\n\t\t\tNewSkin = Texture(DynamicLoadObject(DefaultSkinName, class'Texture'));\n\t\t\tSkinActor.Multiskins[SkinNo] = NewSkin;\n\t\t}\n\t\treturn False;\n\t}\n}",
                        "locals": [
                            "local Texture NewSkin;"
                        ],
                        "modifiers": [
                            "static"
                        ],
                        "name": "SetSkinElement",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "SkinActor"
                            ],
                            [
                                "int",
                                "SkinNo"
                            ],
                            [
                                "string",
                                "SkinName"
                            ],
                            [
                                "string",
                                "DefaultSkinName"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ShakeView": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ShakeView",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "shaketime"
                            ],
                            [
                                "float",
                                "RollMag"
                            ],
                            [
                                "float",
                                "vertmag"
                            ]
                        ],
                        "return": ""
                    },
                    "SpawnCarcass": {
                        "body": "{\n\tlog(self$\" should never call base spawncarcass\");\n\treturn None;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SpawnCarcass",
                        "native": false,
                        "param": [],
                        "return": "Carcass"
                    },
                    "SpawnGibbedCarcass": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SpawnGibbedCarcass",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpecialFire": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SpecialFire",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpeechTimer": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "SpeechTimer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StopFiring": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "StopFiring",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StopWaiting": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "StopWaiting",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "SwitchToBestWeapon": {
                        "body": "{\n\n\tif ( Inventory == None )\n\t\treturn false;\n\n\tPendingWeapon = Inventory.RecommendWeapon(rating, usealt);\n\tif ( PendingWeapon == Weapon )\n\t\tPendingWeapon = None;\n\tif ( PendingWeapon == None )\n\t\treturn false;\n\n\tif ( Weapon == None )\n\t\tChangedWeapon();\n\tif ( Weapon != PendingWeapon )\n\t\tWeapon.PutDown();\n\n\treturn (usealt > 0);\n}",
                        "locals": [
                            "local float rating;",
                            "local int usealt;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SwitchToBestWeapon",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "TakeFallingDamage": {
                        "body": "{\n\tif (Velocity.Z < -1.4 * JumpZ)\n\t{\n\t\tMakeNoise(-0.5 * Velocity.Z/(FMax(JumpZ, 150.0)));\n\t\tif (Velocity.Z <= -750 - JumpZ)\n\t\t{\n\t\t\tif ( (Velocity.Z < -1650 - JumpZ) && (ReducedDamageType != 'All') )\n\t\t\t\tTakeDamage(1000, None, Location, vect(0,0,0), 'Fell');\n\t\t\telse if ( Role == ROLE_Authority )\n\t\t\t\tTakeDamage(-0.15 * (Velocity.Z + 700 + JumpZ), None, Location, vect(0,0,0), 'Fell');\n\t\t\tShakeView(0.175 - 0.00007 * Velocity.Z, -0.85 * Velocity.Z, -0.002 * Velocity.Z);\n\t\t}\n\t}\n\telse if ( Velocity.Z > 0.5 * Default.JumpZ )\n\t\tMakeNoise(0.35);\t\t\t\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TakeFallingDamage",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TeamBroadcast": {
                        "body": "{\n\n\tif ( Left(Msg, 1) ~= \"@\" )\n\t{\n\t\tMsg = Right(Msg, Len(Msg)-1);\n\t\tbGlobal = true;\n\t}\n\n\tif ( Left(Msg, 1) ~= \".\" )\n\t\tMsg = \".\"$VoicePitch$Msg;\n\n\tif ( bGlobal || !Level.Game.bTeamGame )\n\t{\n\t\tif ( Level.Game.AllowsBroadcast(self, Len(Msg)) )\n\t\t\tfor( P=Level.PawnList; P!=None; P=P.nextPawn )\n\t\t\t\tif( P.bIsPlayer  || P.IsA('MessagingSpectator') )\n\t\t\t\t\tP.TeamMessage( PlayerReplicationInfo, Msg, 'Say' );\n\t\treturn;\n\t}\n\t\t\n\tif ( Level.Game.AllowsBroadcast(self, Len(Msg)) )\n\t\tfor( P=Level.PawnList; P!=None; P=P.nextPawn )\n\t\t\tif( P.bIsPlayer && (P.PlayerReplicationInfo.Team == PlayerReplicationInfo.Team) )\n\t\t\t{\n\t\t\t\tif ( P.IsA('PlayerPawn') )\n\t\t\t\t\tP.TeamMessage( PlayerReplicationInfo, Msg, 'TeamSay' );\n\t\t\t}\n}",
                        "locals": [
                            "local Pawn P;",
                            "local bool bGlobal;"
                        ],
                        "modifiers": [],
                        "name": "TeamBroadcast",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "Msg"
                            ]
                        ],
                        "return": ""
                    },
                    "TeamMessage": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TeamMessage",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "PRI"
                            ],
                            [
                                "coerce",
                                "string",
                                "S"
                            ],
                            [
                                "name",
                                "Type"
                            ],
                            [
                                "optional",
                                "bool",
                                "bBeep"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\t\tif ( !bHidden )\n\t\t{\n\t\t\tbHidden = true;\n\t\t\tSpawnCarcass();\n\t\t\tif ( bIsPlayer )\n\t\t\t\tHidePlayer();\n\t\t\telse\n\t\t\t\tDestroy();\n\t\t}\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TossWeapon": {
                        "body": "{\n\tif ( Weapon == None )\n\t\treturn;\n\tGetAxes(Rotation,X,Y,Z);\n\tWeapon.DropFrom(Location + 0.8 * CollisionRadius * X + - 0.5 * CollisionRadius * Y); \n}",
                        "locals": [
                            "local vector X,Y,Z;"
                        ],
                        "modifiers": [],
                        "name": "TossWeapon",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TraceShot": {
                        "body": "{\n\tOther = Trace(HitLocation,HitNormal,EndTrace,StartTrace,True);\n\tif ( Pawn(Other) != None )\n\t{\n\t\trealHit = HitLocation;\n\t\tif ( !Pawn(Other).AdjustHitLocation(HitLocation, EndTrace - StartTrace) )\n\t\t\tOther = Pawn(Other).TraceShot(HitLocation,HitNormal,EndTrace,realHit);\n\t}\n\treturn Other;\n}",
                        "locals": [
                            "local vector realHit;",
                            "local actor Other;"
                        ],
                        "modifiers": [],
                        "name": "TraceShot",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "vector",
                                "HitLocation"
                            ],
                            [
                                "out",
                                "vector",
                                "HitNormal"
                            ],
                            [
                                "vector",
                                "EndTrace"
                            ],
                            [
                                "vector",
                                "StartTrace"
                            ]
                        ],
                        "return": "actor"
                    },
                    "TurnTo": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TurnTo",
                        "native": true,
                        "param": [
                            [
                                "vector",
                                "NewFocus"
                            ]
                        ],
                        "return": ""
                    },
                    "TurnToward": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TurnToward",
                        "native": true,
                        "param": [
                            [
                                "actor",
                                "NewTarget"
                            ]
                        ],
                        "return": ""
                    },
                    "TweenToFalling": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TweenToFalling",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TweenToFighter": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TweenToFighter",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "tweentime"
                            ]
                        ],
                        "return": ""
                    },
                    "TweenToPatrolStop": {
                        "body": "{\n\tTweenToFighter(tweentime);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TweenToPatrolStop",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "tweentime"
                            ]
                        ],
                        "return": ""
                    },
                    "TweenToRunning": {
                        "body": "{\n\tTweenToFighter(0.1);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TweenToRunning",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "tweentime"
                            ]
                        ],
                        "return": ""
                    },
                    "TweenToSwimming": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TweenToSwimming",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "tweentime"
                            ]
                        ],
                        "return": ""
                    },
                    "TweenToWaiting": {
                        "body": "{\n\tTweenToFighter(tweentime);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TweenToWaiting",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "tweentime"
                            ]
                        ],
                        "return": ""
                    },
                    "TweenToWalking": {
                        "body": "{\n\tTweenToRunning(tweentime);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TweenToWalking",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "tweentime"
                            ]
                        ],
                        "return": ""
                    },
                    "UnderLift": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "UnderLift",
                        "native": false,
                        "param": [
                            [
                                "Mover",
                                "M"
                            ]
                        ],
                        "return": ""
                    },
                    "UpdateEyeHeight": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateEyeHeight",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "WaitForLanding": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "WaitForLanding",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "WalkTexture": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "WalkTexture",
                        "native": false,
                        "param": [
                            [
                                "texture",
                                "Texture"
                            ],
                            [
                                "vector",
                                "StepLocation"
                            ],
                            [
                                "vector",
                                "StepNormal"
                            ]
                        ],
                        "return": ""
                    },
                    "WarnTarget": {
                        "body": "{\n\t// AI controlled creatures may duck\n\t// if not falling, and projectile time is long enough\n\t// often pick opposite to current direction (relative to shooter axis)\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "WarnTarget",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "shooter"
                            ],
                            [
                                "float",
                                "projSpeed"
                            ],
                            [
                                "vector",
                                "FireDir"
                            ]
                        ],
                        "return": ""
                    },
                    "actorReachable": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "actorReachable",
                        "native": true,
                        "param": [
                            [
                                "actor",
                                "anActor"
                            ]
                        ],
                        "return": ""
                    },
                    "damageAttitudeTo": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "damageAttitudeTo",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "gibbedBy": {
                        "body": "{\n\n\tinstigatedBy = pawn(Other);\n\tif (instigatedBy == None)\n\t\tinstigatedBy = Other.instigator;\n\thealth = -1000; //make sure gibs\n\tDied(instigatedBy, 'Gibbed', Location);\n}",
                        "locals": [
                            "local pawn instigatedBy;"
                        ],
                        "modifiers": [],
                        "name": "gibbedBy",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "pointReachable": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "pointReachable",
                        "native": true,
                        "param": [
                            [
                                "vector",
                                "aPoint"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 2241,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool\t\tbBehindView;    // Outside-the-player view.",
                    "var bool        bIsPlayer;      // Pawn is a player or a player-bot.",
                    "var bool\t\tbJustLanded;\t// used by eyeheight adjustment",
                    "var bool\t\tbUpAndOut;\t\t// used by swimming",
                    "var bool\t\tbIsWalking;",
                    "var const bool\tbHitSlopedWall;\t// used by Physics",
                    "var globalconfig bool\tbNeverSwitchOnPickup;\t// if true, don't automatically switch to picked up weapon",
                    "var bool\t\tbWarping;\t\t// Set when travelling through warpzone (so shouldn't telefrag)",
                    "var bool\t\tbUpdatingDisplay; // to avoid infinite recursion through inventory setdisplay",
                    "var(Combat) bool\tbCanStrafe;",
                    "var(Orders) bool\tbFixedStart;",
                    "var const bool\t\tbReducedSpeed;\t\t//used by movement natives",
                    "var const bool\t\tbLOSflag;\t\t\t// used for alternating LineOfSight traces",
                    "var \tbool \t\tbFromWall;",
                    "var const\tfloat\t\tAvgPhysicsTime;",
                    "var PointRegion FootRegion;",
                    "var PointRegion HeadRegion;",
                    "var \tfloat\t\tMoveTimer;",
                    "var \tActor\t\tMoveTarget;\t\t// set by movement natives",
                    "var(Combat) float\tMeleeRange; // Max range for melee attack (not including collision radii)",
                    "var(Movement) float      GroundSpeed;     // The maximum ground speed.",
                    "var(Movement) float      WaterSpeed;      // The maximum swimming speed.",
                    "var(Movement) float      AirSpeed;        // The maximum flying speed.",
                    "var(Movement) float\t\t AccelRate;\t\t  // max acceleration rate",
                    "var(Movement) float\t\t JumpZ;      \t\t// vertical acceleration w/ jump",
                    "var(Movement) float      MaxStepHeight;   // Maximum size of upward/downward step.",
                    "var(Movement) float      AirControl;\t\t// amount of AirControl available to the pawn",
                    "var() \tbyte       \tVisibility;      //How visible is the pawn? 0 = invisible.",
                    "var(AI) float\t\tSightRadius;     //Maximum seeing distance.",
                    "var(AI) float\t\tPeripheralVision;//Cosine of limits of peripheral vision.",
                    "var(AI) float\t\tHearingThreshold;  //Minimum noise loudness for hearing",
                    "var travel Weapon       Weapon;        // The pawn's current weapon.",
                    "var Weapon\t\t\t\tPendingWeapon;\t// Will become weapon once current weapon is put down",
                    "var travel Inventory\tSelectedItem;\t// currently selected inventory item",
                    "var rotator     \tViewRotation;  \t// View rotation.",
                    "var vector\t\t\tWalkBob;",
                    "var() float      \tBaseEyeHeight; \t// Base eye height above collision center.",
                    "var float        \tEyeHeight;     \t// Current eye height, adjusted for bobbing and stairs.",
                    "var float\t\t\tSplashTime;\t\t// time of last splash",
                    "var float        OrthoZoom;     // Orthogonal/map view zoom factor.",
                    "var() float      FovAngle;      // X field of view angle in degrees, usually 90.",
                    "var int\t\t\tDieCount, ItemCount, KillCount, SecretCount, Spree;",
                    "var() travel int      Health;          // Health: 100 = normal maximum",
                    "var() string\t\t\tSelectionMesh;",
                    "var() string\t\t\tSpecialMesh;",
                    "var() name\tReducedDamageType; //Either a damagetype name or 'All', 'AllEnvironment' (Burned, Corroded, Frozen)",
                    "var() float ReducedDamagePct;",
                    "var() class<inventory> DropWhenKilled;",
                    "var(Movement) float\t\tUnderWaterTime;  \t//how much time pawn can go without air (in seconds)",
                    "var(AI) enum EAttitude  //important - order in decreasing importance",
                    "var(AI) enum EIntelligence //important - order in increasing intelligence",
                    "var(AI) float\t\tSkill;\t\t\t// skill, scaled by game difficulty (add difficulty to this value)",
                    "var const \tvector \t\tnoise1spot;",
                    "var const \tfloat \t\tnoise1time;",
                    "var const\tpawn\t\tnoise1other;",
                    "var const\tfloat\t\tnoise1loudness;",
                    "var const \tvector \t\tnoise2spot;",
                    "var const \tfloat \t\tnoise2time;",
                    "var const\tpawn\t\tnoise2other;",
                    "var const\tfloat\t\tnoise2loudness;",
                    "var const\tpawn\t\tnextPawn;",
                    "var(Sounds)\tsound\tHitSound1;",
                    "var(Sounds)\tsound\tHitSound2;",
                    "var(Sounds)\tsound\tLand;",
                    "var(Sounds)\tsound\tDie;",
                    "var(Sounds) sound\tWaterStep;",
                    "var input byte",
                    "var(Combat) float CombatStyle; // -1 to 1 = low means tends to stay off and snipe, high means tends to charge and melee",
                    "var NavigationPoint home; //set when begin play, used for retreating and attitude checks",
                    "var name NextState; //for queueing states",
                    "var name NextLabel; //for queueing states",
                    "var float SoundDampening;",
                    "var float DamageScaling;",
                    "var(Orders) name AlarmTag; // tag of object to go to when see player",
                    "var(Orders) name SharedAlarmTag;",
                    "var Name PlayerReStartState;",
                    "var() localized  string MenuName; //Name used for this pawn type in menus (e.g. player selection)",
                    "var() localized  string NameArticle; //article used in conjunction with this class (e.g. \"a\", \"an\")",
                    "var() byte VoicePitch; //for speech",
                    "var() string VoiceType; //for speech",
                    "var float OldMessageTime; //to limit frequency of voice messages",
                    "var NavigationPoint RouteCache[16];",
                    "var() class<PlayerReplicationInfo> PlayerReplicationInfoClass;",
                    "var PlayerReplicationInfo PlayerReplicationInfo;",
                    "var Decal Shadow;",
                    "var() travel int HealthHead;",
                    "var() travel int HealthTorso;",
                    "var() travel int HealthLegLeft;",
                    "var() travel int HealthLegRight;",
                    "var() travel int HealthArmLeft;",
                    "var() travel int HealthArmRight;",
                    "var bool bIsSpeaking;\t\t// are we speaking now",
                    "var bool bWasSpeaking;\t\t// were we speaking last frame?  (should we close our mouth?)",
                    "var string lastPhoneme;\t// phoneme last spoken",
                    "var string nextPhoneme;\t// phoneme to speak next",
                    "var float animTimer[4];\t\t// misc. timers for ambient anims (blink, head, etc.)",
                    "var bool bOnFire;",
                    "var float burnTimer;",
                    "var(AI)        float   AIHorizontalFov;            // degrees",
                    "var(AI)        float   AspectRatio;                // horizontal/vertical ratio",
                    "var(AI)        float   AngularResolution;          // degrees",
                    "var            float   MinAngularSize;             // tan(AngularResolution)^2",
                    "var(AI)        float   VisibilityThreshold;        // lowest visible brightness (0-1)",
                    "var(AI)        float   SmellThreshold;             // lowest smellable odor (0-1)",
                    "var(Alliances) Name    Alliance;                   // alliance tag",
                    "var            Rotator AIAddViewRotation;          // rotation added to view rotation for AICanSee()"
                ]
            }
        },
        "Pickup.uc": {
            "body": "//=============================================================================\n// Pickup items.\n//=============================================================================\nclass Pickup extends Inventory\n\tabstract;\n\nvar inventory Inv;\nvar travel int NumCopies;\nvar() bool bCanHaveMultipleCopies;  // if player can possess more than one of this\nvar() bool bCanActivate;\t\t\t// Item can be selected and activated\nvar() localized String ExpireMessage; // Messages shown when pickup charge runs out\nvar() bool bAutoActivate;\n\nreplication\n{\n\t// Things the server should send to the client.\n\treliable if( Role==ROLE_Authority && bNetOwner )\n\t\tNumCopies;\n}\n\nfunction TravelPostAccept()\n{\n\tSuper.TravelPostAccept();\n\tPickupFunction(Pawn(Owner));\n}\n\n//\n// Advanced function which lets existing items in a pawn's inventory\n// prevent the pawn from picking something up. Return true to abort pickup\n// or if item handles the pickup\nfunction bool HandlePickupQuery( inventory Item )\n{\n\tif (item.class == class) \n\t{\n\t\tif (bCanHaveMultipleCopies) \n\t\t{   // for items like Artifact\n\t\t\tNumCopies++;\n\t\t\tif (Level.Game.LocalLog != None)\n\t\t\t\tLevel.Game.LocalLog.LogPickup(Item, Pawn(Owner));\n\t\t\tif (Level.Game.WorldLog != None)\n\t\t\t\tLevel.Game.WorldLog.LogPickup(Item, Pawn(Owner));\n\t\t\tif ( Item.PickupMessageClass == None )\n\t\t\t\t// DEUS_EX CNN - use the itemArticle and itemName\n//\t\t\t\tPawn(Owner).ClientMessage(item.PickupMessage, 'Pickup');\n\t\t\t\tPawn(Owner).ClientMessage(item.PickupMessage @ item.itemArticle @ item.itemName, 'Pickup');\n\t\t\telse\n\t\t\t\tPawn(Owner).ReceiveLocalizedMessage( item.PickupMessageClass, 0, None, None, item.Class );\n\t\t\tItem.PlaySound (Item.PickupSound,,2.0);\n\t\t\tItem.SetRespawn();\n\t\t}\n\t\t/* DEUS_EX AJY\n\t\telse if ( bDisplayableInv ) \n\t\t{\t\t\n\t\t\tif ( Charge<Item.Charge )\t\n\t\t\t\tCharge= Item.Charge;\n\t\t\tif (Level.Game.LocalLog != None)\n\t\t\t\tLevel.Game.LocalLog.LogPickup(Item, Pawn(Owner));\n\t\t\tif (Level.Game.WorldLog != None)\n\t\t\t\tLevel.Game.WorldLog.LogPickup(Item, Pawn(Owner));\n\t\t\tif ( Item.PickupMessageClass == None )\n\t\t\t\tPawn(Owner).ClientMessage(item.PickupMessage, 'Pickup');\n\t\t\telse\n\t\t\t\tPawn(Owner).ReceiveLocalizedMessage( item.PickupMessageClass, 0, None, None, item.Class );\n\t\t\tItem.PlaySound (item.PickupSound,,2.0);\n\t\t\tItem.SetReSpawn();\n\t\t}\n\t\t*/\n\t\telse if ( bDisplayableInv ) \n\t\t\treturn false;\n\n\t\treturn true;\t\t\t\t\n\t}\n\tif ( Inventory == None )\n\t\treturn false;\n\n\treturn Inventory.HandlePickupQuery(Item);\n}\n\nfunction SetRespawn()\n{\n\tif( Level.Game.ShouldRespawn(self) )\n\t{\n\t\tGotoState('Sleeping');\n\t}\n\telse\n\t{\n\t\t//because of latent destroy, we just need to make sure num copies is 0 and then \n\t\t//you at least won't be able to doublefrob.\n\t\tNumCopies = 0;\n\t\tDestroy();\n\t}\n}\n\nfunction float UseCharge(float Amount);\n\nfunction inventory SpawnCopy( pawn Other )\n{\n\tlocal inventory Copy;\n\n\tCopy = Super.SpawnCopy(Other);\n\tCopy.Charge = Charge;\n\treturn Copy;\n}\n\nauto state Pickup\n{\t\n\t// changed from Touch to Frob - DEUS_EX CNN\n\tfunction Frob(Actor Other, Inventory frobWith)\n//\tfunction Touch( actor Other )\n\t{\n\t\tlocal Inventory Copy;\n\t\tif ( ValidTouch(Other) ) \n\t\t{\n\t\t\tCopy = SpawnCopy(Pawn(Other));\n\t\t\tif (Level.Game.LocalLog != None)\n\t\t\t\tLevel.Game.LocalLog.LogPickup(Self, Pawn(Other));\n\t\t\tif (Level.Game.WorldLog != None)\n\t\t\t\tLevel.Game.WorldLog.LogPickup(Self, Pawn(Other));\n//\t\t\tif (bActivatable && Pawn(Other).SelectedItem==None) \n//\t\t\t\tPawn(Other).SelectedItem=Copy;\n\t\t\tif (bActivatable && bAutoActivate && Pawn(Other).bAutoActivate) Copy.Activate();\n\t\t\tif ( PickupMessageClass == None )\n\t\t\t\t// DEUS_EX CNN - use the itemArticle and itemName\n//\t\t\t\tPawn(Other).ClientMessage(PickupMessage, 'Pickup');\n\t\t\t\tPawn(Other).ClientMessage(PickupMessage @ itemArticle @ itemName, 'Pickup');\n\t\t\telse\n\t\t\t\tPawn(Other).ReceiveLocalizedMessage( PickupMessageClass, 0, None, None, Self.Class );\n\t\t\tPlaySound (PickupSound,,2.0);\t\n\t\t\tPickup(Copy).PickupFunction(Pawn(Other));\n\t\t}\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tSuper.BeginState();\n\n\t\t// NumCopies = 1 means we have ONE of this item now\n\t\t// DEUS_EX AJY\n\n//\t\tNumCopies = 0;\n\t}\n}\n\nfunction PickupFunction(Pawn Other)\n{\n}\n\n//\n// This is called when a usable inventory item has used up it's charge.\n//\nfunction UsedUp()\n{\n\tif ( Pawn(Owner) != None )\n\t{\n\t\tbActivatable = false;\n\t\tPawn(Owner).NextItem();\n\t\tif (Pawn(Owner).SelectedItem == Self) {\n\t\t\tPawn(Owner).NextItem();\t\n\t\t\tif (Pawn(Owner).SelectedItem == Self) Pawn(Owner).SelectedItem=None;\n\t\t}\n\t\tif (Level.Game.LocalLog != None)\n\t\t\tLevel.Game.LocalLog.LogItemDeactivate(Self, Pawn(Owner));\n\t\tif (Level.Game.WorldLog != None)\n\t\t\tLevel.Game.WorldLog.LogItemDeactivate(Self, Pawn(Owner));\n\t\tif ( ItemMessageClass != None )\n\t\t\tPawn(Owner).ReceiveLocalizedMessage( ItemMessageClass, 0, None, None, Self.Class );\n\t\telse\n\t\t\tPawn(Owner).ClientMessage(ExpireMessage);\t\n\t}\n\tOwner.PlaySound(DeactivateSound);\n\tDestroy();\n}\n\n\nstate Activated\n{\n\tfunction Activate()\n\t{\n\t\tif ( (Pawn(Owner) != None) && Pawn(Owner).bAutoActivate \n\t\t\t&& bAutoActivate && (Charge>0) )\n\t\t\t\treturn;\n\n\t\tSuper.Activate();\t\n\t}\n}\n\ndefaultproperties\n{\n     bRotatingPickup=False\n}\n",
            "name": "Pickup.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bRotatingPickup=False"
                ],
                "exec": [],
                "extends": "Inventory",
                "functions": {
                    "Activate": {
                        "body": "{\n\t\tif ( (Pawn(Owner) != None) && Pawn(Owner).bAutoActivate \n\t\t\t&& bAutoActivate && (Charge>0) )\n\t\t\t\treturn;\n\n\t\tSuper.Activate();\t\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Activate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BeginState": {
                        "body": "{\n\t\tSuper.BeginState();\n\n\t\t// NumCopies = 1 means we have ONE of this item now\n\t\t// DEUS_EX AJY\n\n//\t\tNumCopies = 0;\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Frob": {
                        "body": "//\tfunction Touch( actor Other )",
                        "locals": [],
                        "modifiers": [],
                        "name": "Frob",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ],
                            [
                                "Inventory",
                                "frobWith"
                            ]
                        ],
                        "return": ""
                    },
                    "HandlePickupQuery": {
                        "body": "{\n\tif (item.class == class) \n\t{\n\t\tif (bCanHaveMultipleCopies) \n\t\t{   // for items like Artifact\n\t\t\tNumCopies++;\n\t\t\tif (Level.Game.LocalLog != None)\n\t\t\t\tLevel.Game.LocalLog.LogPickup(Item, Pawn(Owner));\n\t\t\tif (Level.Game.WorldLog != None)\n\t\t\t\tLevel.Game.WorldLog.LogPickup(Item, Pawn(Owner));\n\t\t\tif ( Item.PickupMessageClass == None )\n\t\t\t\t// DEUS_EX CNN - use the itemArticle and itemName\n//\t\t\t\tPawn(Owner).ClientMessage(item.PickupMessage, 'Pickup');\n\t\t\t\tPawn(Owner).ClientMessage(item.PickupMessage @ item.itemArticle @ item.itemName, 'Pickup');\n\t\t\telse\n\t\t\t\tPawn(Owner).ReceiveLocalizedMessage( item.PickupMessageClass, 0, None, None, item.Class );\n\t\t\tItem.PlaySound (Item.PickupSound,,2.0);\n\t\t\tItem.SetRespawn();\n\t\t}\n\t\t/* DEUS_EX AJY\n\t\telse if ( bDisplayableInv ) \n\t\t{\t\t\n\t\t\tif ( Charge<Item.Charge )\t\n\t\t\t\tCharge= Item.Charge;\n\t\t\tif (Level.Game.LocalLog != None)\n\t\t\t\tLevel.Game.LocalLog.LogPickup(Item, Pawn(Owner));\n\t\t\tif (Level.Game.WorldLog != None)\n\t\t\t\tLevel.Game.WorldLog.LogPickup(Item, Pawn(Owner));\n\t\t\tif ( Item.PickupMessageClass == None )\n\t\t\t\tPawn(Owner).ClientMessage(item.PickupMessage, 'Pickup');\n\t\t\telse\n\t\t\t\tPawn(Owner).ReceiveLocalizedMessage( item.PickupMessageClass, 0, None, None, item.Class );\n\t\t\tItem.PlaySound (item.PickupSound,,2.0);\n\t\t\tItem.SetReSpawn();\n\t\t}\n\t\t*/\n\t\telse if ( bDisplayableInv ) \n\t\t\treturn false;\n\n\t\treturn true;\t\t\t\t\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "HandlePickupQuery",
                        "native": false,
                        "param": [
                            [
                                "inventory",
                                "Item"
                            ]
                        ],
                        "return": "bool"
                    },
                    "PickupFunction": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PickupFunction",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "SetRespawn": {
                        "body": "{\n\tif( Level.Game.ShouldRespawn(self) )\n\t{\n\t\tGotoState('Sleeping');\n\t}\n\telse\n\t{\n\t\t//because of latent destroy, we just need to make sure num copies is 0 and then \n\t\t//you at least won't be able to doublefrob.\n\t\tNumCopies = 0;\n\t\tDestroy();\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetRespawn",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpawnCopy": {
                        "body": "{\n\n\tCopy = Super.SpawnCopy(Other);\n\tCopy.Charge = Charge;\n\treturn Copy;\n}",
                        "locals": [
                            "local inventory Copy;"
                        ],
                        "modifiers": [],
                        "name": "SpawnCopy",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": "inventory"
                    },
                    "TravelPostAccept": {
                        "body": "{\n\tSuper.TravelPostAccept();\n\tPickupFunction(Pawn(Owner));\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TravelPostAccept",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "UseCharge": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "UseCharge",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Amount"
                            ]
                        ],
                        "return": "float"
                    },
                    "UsedUp": {
                        "body": "{\n\tif ( Pawn(Owner) != None )\n\t{\n\t\tbActivatable = false;\n\t\tPawn(Owner).NextItem();\n\t\tif (Pawn(Owner).SelectedItem == Self) {\n\t\t\tPawn(Owner).NextItem();\t\n\t\t\tif (Pawn(Owner).SelectedItem == Self) Pawn(Owner).SelectedItem=None;\n\t\t}\n\t\tif (Level.Game.LocalLog != None)\n\t\t\tLevel.Game.LocalLog.LogItemDeactivate(Self, Pawn(Owner));\n\t\tif (Level.Game.WorldLog != None)\n\t\t\tLevel.Game.WorldLog.LogItemDeactivate(Self, Pawn(Owner));\n\t\tif ( ItemMessageClass != None )\n\t\t\tPawn(Owner).ReceiveLocalizedMessage( ItemMessageClass, 0, None, None, Self.Class );\n\t\telse\n\t\t\tPawn(Owner).ClientMessage(ExpireMessage);\t\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UsedUp",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 191,
                "replication": "",
                "states": [],
                "variables": [
                    "var inventory Inv;",
                    "var travel int NumCopies;",
                    "var() bool bCanHaveMultipleCopies;  // if player can possess more than one of this",
                    "var() bool bCanActivate;\t\t\t// Item can be selected and activated",
                    "var() localized String ExpireMessage; // Messages shown when pickup charge runs out",
                    "var() bool bAutoActivate;"
                ]
            }
        },
        "Player.uc": {
            "body": "//=============================================================================\n// Player: Corresponds to a real player (a local camera or remote net player).\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass Player extends Object\n\tnative\n\tnoexport;\n\n//-----------------------------------------------------------------------------\n// Player properties.\n\n// Internal.\nvar native const int vfOut;\nvar native const int vfExec;\n\n// The actor this player controls.\nvar transient const playerpawn Actor;\nvar transient const console Console;\n\n// Window input variables\nvar transient const bool bWindowsMouseAvailable;\nvar bool bShowWindowsMouse;\nvar bool bSuspendPrecaching;\nvar transient const float WindowsMouseX;\nvar transient const float WindowsMouseY;\nvar int CurrentNetSpeed;\nvar globalconfig int ConfiguredInternetSpeed, ConfiguredLanSpeed;\nvar float StaticUpdateInterval, DynamicUpdateInterval;\nvar byte SelectedCursor;\n\nconst IDC_ARROW=0;\nconst IDC_SIZEALL=1;\nconst IDC_SIZENESW=2;\nconst IDC_SIZENS=3;\nconst IDC_SIZENWSE=4;\nconst IDC_SIZEWE=5;\nconst IDC_WAIT=6;\n\ndefaultproperties\n{\n     ConfiguredInternetSpeed=2600\n     ConfiguredLanSpeed=20000\n}\n",
            "name": "Player.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "ConfiguredInternetSpeed=2600",
                    "ConfiguredLanSpeed=20000"
                ],
                "exec": [],
                "extends": "Object",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 44,
                "replication": "",
                "states": [],
                "variables": [
                    "var native const int vfOut;",
                    "var native const int vfExec;",
                    "var transient const playerpawn Actor;",
                    "var transient const console Console;",
                    "var transient const bool bWindowsMouseAvailable;",
                    "var bool bShowWindowsMouse;",
                    "var bool bSuspendPrecaching;",
                    "var transient const float WindowsMouseX;",
                    "var transient const float WindowsMouseY;",
                    "var int CurrentNetSpeed;",
                    "var globalconfig int ConfiguredInternetSpeed, ConfiguredLanSpeed;",
                    "var float StaticUpdateInterval, DynamicUpdateInterval;",
                    "var byte SelectedCursor;"
                ]
            }
        },
        "PlayerPawn.uc": {
            "body": "//=============================================================================\n// PlayerPawn.\n// player controlled pawns\n// Note that Pawns which implement functions for the PlayerTick messages\n// must handle player control in these functions\n//=============================================================================\nclass PlayerPawn expands Pawn\n\tconfig(user)\n\tnative\n\tnativereplication;\n\n// Player info.\nvar const player Player;\nvar\tglobalconfig string Password;\t// for restarting coop savegames\n\nvar\ttravel\t  float DodgeClickTimer; // max double click interval for dodge move\nvar(Movement) globalconfig float\tDodgeClickTime;\nvar(Movement) globalconfig float Bob;\nvar\t\t\t  float\t\t\t\tLandBob, AppliedBob;\nvar float bobtime;\n\n// Camera info.\nvar int ShowFlags;\nvar int RendMap;\nvar int Misc1;\nvar int Misc2;\n\nvar actor ViewTarget;\nvar vector FlashScale, FlashFog;\nvar HUD\tmyHUD;\nvar ScoreBoard Scoring;\nvar class<hud> HUDType;\nvar class<scoreboard> ScoringType;\n\nvar float DesiredFlashScale, ConstantGlowScale, InstantFlash;\nvar vector DesiredFlashFog, ConstantGlowFog, InstantFog;\nvar globalconfig float DesiredFOV;\nvar globalconfig float DefaultFOV;\n\n// Music info.\nvar music Song;\nvar byte  SongSection;\nvar byte  CdTrack;\nvar EMusicTransition Transition;\n\nvar float shaketimer; // player uses this for shaking view\nvar int shakemag;\t// max magnitude in degrees of shaking\nvar float shakevert; // max vertical shake magnitude\nvar float maxshake;\nvar float verttimer;\nvar(Pawn) class<carcass> CarcassType;\nvar travel float MyAutoAim;\nvar travel globalconfig float Handedness;\nvar(Sounds) sound JumpSound;\n\n// Player control flags\nvar bool\t\tbAdmin;\nvar() globalconfig bool \t\tbLookUpStairs;\t// look up/down stairs (player)\nvar() globalconfig bool\t\tbSnapToLevel;\t// Snap to level eyeheight when not mouselooking\nvar() globalconfig bool\t\tbAlwaysMouseLook;\nvar globalconfig bool \t\tbKeyboardLook;\t// no snapping when true\nvar bool\t\tbWasForward;\t// used for dodge move \nvar bool\t\tbWasBack;\nvar bool\t\tbWasLeft;\nvar bool\t\tbWasRight;\nvar bool\t\tbEdgeForward;\nvar bool\t\tbEdgeBack;\nvar bool\t\tbEdgeLeft;\nvar bool \t\tbEdgeRight;\nvar bool\t\tbIsCrouching;\nvar\tbool\t\tbShakeDir;\t\t\t\nvar bool\t\tbAnimTransition;\nvar bool\t\tbIsTurning;\nvar bool\t\tbFrozen;\nvar bool        bBadConnectionAlert;\nvar globalconfig bool\tbInvertMouse;\nvar bool\t\tbShowScores;\nvar bool\t\tbShowMenu;\nvar bool\t\tbSpecialMenu;\nvar bool\t\tbWokeUp;\nvar bool\t\tbPressedJump;\nvar bool\t\tbUpdatePosition;\nvar bool\t\tbDelayedCommand;\nvar bool\t\tbRising;\nvar bool\t\tbReducedVis;\nvar bool\t\tbCenterView;\nvar() globalconfig bool bMaxMouseSmoothing;\nvar bool\t\tbMouseZeroed;\nvar bool\t\tbReadyToPlay;\nvar bool bNoFlash;\nvar globalconfig bool bNoVoices;\nvar globalconfig bool bMessageBeep;\nvar bool\t\tbZooming;\nvar() bool\t\tbSinglePlayer;\t\t// this class allowed in single player\nvar bool\t\tbJustFired;\nvar bool\t\tbJustAltFired;\nvar bool\t\tbIsTyping;\nvar bool\t\tbFixedCamera;\nvar globalconfig bool\tbNeverAutoSwitch;\t// if true, don't automatically switch to picked up weapon\nvar bool\t\tbJumpStatus;\t// used in net games\nvar\tbool\t\tbUpdating;\nvar bool\t\tbCheatsEnabled;  // DEUS_EX STM - added globalconfig (CNN - removed for command line cheats)\n\nvar float\t\tZoomLevel;\nvar const Actor   AdditionalViews[3]; // If the pawn can see from the point of view of any additional actors.\n\nvar class<menu> SpecialMenu;\nvar string DelayedCommand;\nvar globalconfig float\tMouseSensitivity;\n\nvar globalconfig name\tWeaponPriority[20]; //weapon class priorities (9 is highest)\n\nvar float SmoothMouseX, SmoothMouseY, BorrowedMouseX, BorrowedMouseY;\nvar() globalconfig float MouseSmoothThreshold;\nvar float MouseZeroTime;\n\n// Input axes.\nvar input float \n\taBaseX, aBaseY, aBaseZ,\n\taMouseX, aMouseY,\n\taForward, aTurn, aStrafe, aUp, \n\taLookUp, aExtra4, aExtra3, aExtra2,\n\taExtra1, aExtra0;\n\n// Move Buffering.\nvar SavedMove SavedMoves;\nvar SavedMove FreeMoves;\nvar SavedMove PendingMove;\nvar float CurrentTimeStamp,LastUpdateTime,ServerTimeStamp,TimeMargin, ClientUpdateTime;\nvar globalconfig float MaxTimeMargin;\n\n// Progess Indicator.\nvar string ProgressMessage[8];\nvar color ProgressColor[8];\nvar float ProgressTimeOut;\n\n// Localized strings\nvar localized string QuickSaveString;\nvar localized string NoPauseMessage;\nvar localized string ViewingFrom;\nvar localized string OwnCamera;\nvar localized string FailedView;\n\n// ReplicationInfo\nvar GameReplicationInfo GameReplicationInfo;\n\n// ngWorldStats Logging\nvar() globalconfig string ngWorldSecret;\nvar() globalconfig bool ngSecretSet;\n\n// Remote Pawn ViewTargets\nvar rotator TargetViewRotation; \nvar float TargetEyeHeight;\nvar vector TargetWeaponViewOffset;\n\n// Demo recording view rotation\nvar int DemoViewPitch;\nvar int DemoViewYaw;\n\nvar float LastPlaySound;\nvar float TurnRateAdjuster;\n\nreplication\n{\n\t// Things the server should send to the client.\n\treliable if( bNetOwner && Role==ROLE_Authority )\n\t\tViewTarget, ScoringType, HUDType, GameReplicationInfo, bFixedCamera, bCheatsEnabled;\n\tunreliable if ( bNetOwner && Role==ROLE_Authority )\n\t\tTargetViewRotation, TargetEyeHeight, TargetWeaponViewOffset;\n\treliable if( bDemoRecording && Role==ROLE_Authority )\n\t\tDemoViewPitch, DemoViewYaw;\n\n\t// Things the client should send to the server\n\treliable if ( Role<ROLE_Authority )\n\t\tPassword, bReadyToPlay, AdditionalViews;\n\n\t// Functions client can call.\n\tunreliable if( Role<ROLE_Authority )\n\t\tCallForHelp;\n\treliable if( Role<ROLE_Authority )\n\t\tShowPath, RememberSpot, Speech, Say, RestartLevel, SwitchWeapon, Pause, SetPause, ServerSetHandedness,\n\t\tPrevItem, ActivateItem, ShowInventory, Grab, ServerFeignDeath, ServerSetWeaponPriority,\n\t\tChangeName, ChangeTeam, God, Suicide, ViewClass, ViewPlayerNum, ViewSelf, ViewPlayer, ServerSetSloMo, ServerAddBots,\n\t\tPlayersOnly, ThrowWeapon, ServerRestartPlayer, NeverSwitchOnPickup, BehindView, ServerNeverSwitchOnPickup, \n\t\tPrevWeapon, NextWeapon, GetWeapon, ServerReStartGame, ServerUpdateWeapons, ServerTaunt, ServerChangeSkin,\n\t\tSwitchLevel, SwitchCoopLevel, Kick, KickBan, KillAll, Summon, ActivateTranslator, Admin, AdminLogin, AdminLogout, Typing, Mutate;\n\tunreliable if( Role<ROLE_Authority )\n\t\tServerMove, Fly, Walk, Ghost;\n\n\t// Functions server can call.\n\treliable if( Role==ROLE_Authority && !bDemoRecording )\n\t\tClientTravel;\n\treliable if( Role==ROLE_Authority )\n\t\tClientReliablePlaySound, ClientReplicateSkins, ClientAdjustGlow, ClientChangeTeam, ClientSetMusic, StartZoom, ToggleZoom, StopZoom, EndZoom, SetDesiredFOV, ClearProgressMessages, SetProgressColor, SetProgressMessage, SetProgressTime, ClientWeaponEvent;\n\tunreliable if( Role==ROLE_Authority )\n\t\tSetFOVAngle, ClientShake, ClientFlash, ClientInstantFlash;\n\tunreliable if( Role==ROLE_Authority && !bDemoRecording )\n\t\tClientPlaySound;\n\tunreliable if( RemoteRole==ROLE_AutonomousProxy )//***\n\t\tClientAdjustPosition;\n}\n\n//\n// native client-side functions.\n//\nnative event ClientTravel( string URL, ETravelType TravelType, bool bItems );\nnative(544) final function ResetKeyboard();\nnative(546) final function UpdateURL(string NewOption, string NewValue, bool bSaveDefault);\nnative final function string GetDefaultURL(string Option);\nnative final function LevelInfo GetEntryLevel();\nnative final function string GetPlayerNetworkAddress();\n// Execute a console command in the context of this player, then forward to Actor.ConsoleCommand.\nnative function string ConsoleCommand( string Command );\nnative function CopyToClipboard( string Text );\nnative function string PasteFromClipboard();\n\nfunction InitPlayerReplicationInfo()\n{\n\tSuper.InitPlayerReplicationInfo();\n\n\tPlayerReplicationInfo.bAdmin = bAdmin;\n}\n\nevent PreClientTravel()\n{\n}\n\nexec function Ping()\n{\n\tClientMessage(\"Current ping is\"@PlayerReplicationInfo.Ping);\n}\n\nfunction ClientWeaponEvent(name EventType)\n{\n\tif ( Weapon != None )\n\t\tWeapon.ClientWeaponEvent(EventType);\n}\n\nsimulated event RenderOverlays( canvas Canvas )\n{\n\tif ( Weapon != None )\n\t\tWeapon.RenderOverlays(Canvas);\n\n\tif ( myHUD != None )\n\t\tmyHUD.RenderOverlays(Canvas);\n}\n\nfunction ClientReplicateSkins(texture Skin1, optional texture Skin2, optional texture Skin3, optional texture Skin4)\n{\n\t// do nothing (just loading other player skins onto client)\n\tlog(\"Getting \"$Skin1$\", \"$Skin2$\", \"$Skin3$\", \"$Skin4);\n\treturn;\n}\n\nfunction CheckBob(float DeltaTime, float Speed2D, vector Y)\n{\n\tlocal float OldBobTime;\n\n\tOldBobTime = BobTime;\n\tif ( Speed2D < 10 )\n\t\tBobTime += 0.2 * DeltaTime;\n\telse\n\t\tBobTime += DeltaTime * (0.3 + 0.7 * Speed2D/GroundSpeed);\n\tWalkBob = Y * 0.65 * Bob * Speed2D * sin(6 * BobTime);\n\tAppliedBob = AppliedBob * (1 - FMin(1, 16 * deltatime));\n\tif ( LandBob > 0.01 )\n\t{\n\t\tAppliedBob += FMin(1, 16 * deltatime) * LandBob;\n\t\tLandBob *= (1 - 8*Deltatime);\n\t}\n\tif ( Speed2D < 10 )\n\t\tWalkBob.Z = 0; // AppliedBob + Bob * 30 * sin(12 * BobTime);   // take out the \"breathe\" effect - DEUS_EX CNN\n\telse\n\t\tWalkBob.Z = AppliedBob + Bob * Speed2D * sin(12 * BobTime);\n}\n\nexec function ViewPlayerNum(optional int num)\n{\n\tlocal Pawn P;\n\n\tif ( !PlayerReplicationInfo.bIsSpectator && !Level.Game.bTeamGame )\n\t\treturn;\n\tif ( num >= 0 )\n\t{\n\t\tP = Pawn(ViewTarget);\n\t\tif ( (P != None) && P.bIsPlayer && (P.PlayerReplicationInfo.TeamID == num) )\n\t\t{\n\t\t\tViewTarget = None;\n\t\t\tbBehindView = false;\n\t\t\treturn;\n\t\t}\n\t\tfor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t\t\tif ( P.bIsPlayer && (P.PlayerReplicationInfo.Team == PlayerReplicationInfo.Team)\n\t\t\t\t&& !P.PlayerReplicationInfo.bIsSpectator\n\t\t\t\t&& (P.PlayerReplicationInfo.TeamID == num) )\n\t\t\t{\n\t\t\t\tif ( P != self )\n\t\t\t\t{\n\t\t\t\t\tViewTarget = P;\n\t\t\t\t\tbBehindView = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\treturn;\n\t}\n\tif ( Role == ROLE_Authority )\n\t{\n\t\tViewClass(class'Pawn', true);\n\t\tWhile ( (ViewTarget != None) \n\t\t\t\t&& (!Pawn(ViewTarget).bIsPlayer || Pawn(ViewTarget).PlayerReplicationInfo.bIsSpectator) )\n\t\t\tViewClass(class'Pawn', true);\n\n\t\tif ( ViewTarget != None )\n\t\t\tClientMessage(ViewingFrom@Pawn(ViewTarget).PlayerReplicationInfo.PlayerName, 'Event', true);\n\t\telse\n\t\t\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n\t}\n}\n\nexec function Profile()\n{\n\t//TEMP for performance measurement\n\n\tlog(\"Average AI Time\"@Level.AvgAITime);\n\tlog(\" < 5% \"$Level.AIProfile[0]);\n\tlog(\" < 10% \"$Level.AIProfile[1]);\n\tlog(\" < 15% \"$Level.AIProfile[2]);\n\tlog(\" < 20% \"$Level.AIProfile[3]);\n\tlog(\" < 25% \"$Level.AIProfile[4]);\n\tlog(\" < 30% \"$Level.AIProfile[5]);\n\tlog(\" < 35% \"$Level.AIProfile[6]);\n\tlog(\" > 35% \"$Level.AIProfile[7]);\n}\n\n// Execute an administrative console command on the server.\nexec function Admin( string CommandLine )\n{\n\tlocal string Result;\n\tif( bAdmin )\n\t\tResult = ConsoleCommand( CommandLine );\n\tif( Result!=\"\" )\n\t\tClientMessage( Result );\n}\n\n// Login as the administrator.\nexec function AdminLogin( string Password )\n{\n\tLevel.Game.AdminLogin( Self, Password );\n}\n\n// Logout as the administrator.\nexec function AdminLogout()\n{\n\tLevel.Game.AdminLogout( Self );\n}\n\nexec function SShot()\n{\n\tlocal float b;\n\tb = float(ConsoleCommand(\"get ini:Engine.Engine.ViewportManager Brightness\"));\n\tConsoleCommand(\"set ini:Engine.Engine.ViewportManager Brightness 1\");\n\tConsoleCommand(\"flush\");\n\tConsoleCommand(\"shot\");\n\tConsoleCommand(\"set ini:Engine.Engine.ViewportManager Brightness \"$string(B));\n\tConsoleCommand(\"flush\");\n}\n\nexec function PlayerList()\n{\n\tlocal PlayerReplicationInfo PRI;\n\n\tlog(\"Player List:\");\n\tForEach AllActors(class'PlayerReplicationInfo', PRI)\n\t\tClientMessage(PRI.PlayerName$\"(\"$PRI.PlayerID$\")\");\n}\n\n//\n// Native ClientSide Functions\n//\n\nevent ReceiveLocalizedMessage( class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject )\n{\n\tMessage.Static.ClientReceive( Self, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );\n}\n\nevent ClientMessage( coerce string S, optional Name Type, optional bool bBeep )\n{\n\tif (Player == None)\n\t\treturn;\n\n\tif (Type == '')\n\t\tType = 'Event';\n\n\tif (Player.Console != None)\n\t\tPlayer.Console.Message( PlayerReplicationInfo, S, Type );\n\n\tif (bBeep && bMessageBeep)\n\t\tPlayBeepSound();\n\tif ( myHUD != None )\n\t\tmyHUD.Message( PlayerReplicationInfo, S, Type );\n}\n\nevent TeamMessage( PlayerReplicationInfo PRI, coerce string S, name Type, optional bool bBeep  )\n{\n\tif (Player.Console != None)\n\t\tPlayer.Console.Message ( PRI, S, Type );\n\tif (bBeep && bMessageBeep)\n\t\tPlayBeepSound();\n\tif ( myHUD != None )\n\t\tmyHUD.Message( PRI, S, Type );\n}\n\nfunction ClientVoiceMessage(PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID)\n{\n\tlocal VoicePack V;\n\n\tif ( (Sender.voicetype == None) || (Player.Console == None) )\n\t\treturn;\n\t\t\n\tV = Spawn(Sender.voicetype, self);\n\tif ( V != None )\n\t\tV.ClientInitialize(Sender, Recipient, messagetype, messageID);\n}\n\nsimulated function PlayBeepSound();\n\n// DEUS_EX AMSD Quick test for whether velocity has changed signifciantly.\nfunction bool VelocityChanged(vector OldVel, vector NewVel)\n{\n   local float NormDot, OldSize, NewSize;\n\n   OldSize = VSize(OldVel);\n   NewSize = VSize(NewVel);\n\n   // If both are tiny, just return (also handles zero case where the normal is zero).\n   if ((OldSize < 1) && (NewSize < 1))\n   {\n      return false;\n   }\n\n   if (OldSize > 1.1 * NewSize)\n      return true;\n\n   if (NewSize > 1.1 * OldSize)\n      return true;\n\n   NormDot = Normal(OldVel) dot Normal(NewVel);\n\n   // if they are close to each other, don't bother with the update.\n   return (NormDot < 0.99);\n}\n\n//\n// Send movement to the server.\n// Passes acceleration in components so it doesn't get rounded.\n//\nfunction ServerMove\n(\n\tfloat TimeStamp, \n\tvector InAccel, \n\tvector ClientLoc,\n\tbool NewbRun,\n\tbool NewbDuck,\n\tbool NewbJumpStatus, \n\tbool bFired,\n\tbool bAltFired,\n\tbool bForceFire,\n\tbool bForceAltFire,\n\teDodgeDir DodgeMove, \n\tbyte ClientRoll, \n\tint View,\n\toptional byte OldTimeDelta,\n\toptional int OldAccel\n)\n{\n\tlocal float DeltaTime, clientErr, OldTimeStamp;\n\tlocal rotator DeltaRot, Rot;\n\tlocal vector Accel, LocDiff;\n\tlocal int maxPitch, ViewPitch, ViewYaw;\n\tlocal actor OldBase;\n\tlocal bool NewbPressedJump, OldbRun, OldbDuck;\n\tlocal eDodgeDir OldDodgeMove;\n\n\t// If this move is outdated, discard it.\n\tif ( CurrentTimeStamp >= TimeStamp )\n\t\treturn;\n\n\t// if OldTimeDelta corresponds to a lost packet, process it first\n\tif (  OldTimeDelta != 0 )\n\t{\n\t\tOldTimeStamp = TimeStamp - float(OldTimeDelta)/500 - 0.001;\n\t\tif ( CurrentTimeStamp < OldTimeStamp - 0.001 )\n\t\t{\n\t\t\t// split out components of lost move (approx)\n\t\t\tAccel.X = OldAccel >>> 23;\n\t\t\tif ( Accel.X > 127 )\n\t\t\t\tAccel.X = -1 * (Accel.X - 128);\n\t\t\tAccel.Y = (OldAccel >>> 15) & 255;\n\t\t\tif ( Accel.Y > 127 )\n\t\t\t\tAccel.Y = -1 * (Accel.Y - 128);\n\t\t\tAccel.Z = (OldAccel >>> 7) & 255;\n\t\t\tif ( Accel.Z > 127 )\n\t\t\t\tAccel.Z = -1 * (Accel.Z - 128);\n\t\t\tAccel *= 20;\n\t\t\t\n\t\t\tOldbRun = ( (OldAccel & 64) != 0 );\n\t\t\tOldbDuck = ( (OldAccel & 32) != 0 );\n\t\t\tNewbPressedJump = ( (OldAccel & 16) != 0 );\n\t\t\tif ( NewbPressedJump )\n\t\t\t\tbJumpStatus = NewbJumpStatus;\n\n\t\t\tswitch (OldAccel & 7)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\tOldDodgeMove = DODGE_None;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tOldDodgeMove = DODGE_Left;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tOldDodgeMove = DODGE_Right;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tOldDodgeMove = DODGE_Forward;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tOldDodgeMove = DODGE_Back;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//log(\"Recovered move from \"$OldTimeStamp$\" acceleration \"$Accel$\" from \"$OldAccel);\n\t\t\tMoveAutonomous(OldTimeStamp - CurrentTimeStamp, OldbRun, OldbDuck, NewbPressedJump, OldDodgeMove, Accel, rot(0,0,0));\n\t\t\tCurrentTimeStamp = OldTimeStamp;\n\t\t}\n\t}\t\t\n\n\t// View components\n\tViewPitch = View/32768;\n\tViewYaw = 2 * (View - 32768 * ViewPitch);\n\tViewPitch *= 2;\n\t// Make acceleration.\n\tAccel = InAccel/10;\n\n\tNewbPressedJump = (bJumpStatus != NewbJumpStatus);\n\tbJumpStatus = NewbJumpStatus;\n\n\t// handle firing and alt-firing\n\tif ( bFired )\n\t{\n\t\tif ( bForceFire && (Weapon != None) )\n\t\t\tWeapon.ForceFire();\n\t\telse if ( bFire == 0 )\n\t\t\tFire(0);\n\t\tbFire = 1;\n\t}\n\telse\n\t\tbFire = 0;\n\n\n\tif ( bAltFired )\n\t{\n\t\tif ( bForceAltFire && (Weapon != None) )\n\t\t\tWeapon.ForceAltFire();\n\t\telse if ( bAltFire == 0 )\n\t\t\tAltFire(0);\n\t\tbAltFire = 1;\n\t}\n\telse\n\t\tbAltFire = 0;\n\n\t// Save move parameters.\n\tDeltaTime = TimeStamp - CurrentTimeStamp;\n\tif ( ServerTimeStamp > 0 )\n\t{\n\t\t// allow 1% error\n\t\tTimeMargin += DeltaTime - 1.01 * (Level.TimeSeconds - ServerTimeStamp);\n\t\tif ( TimeMargin > MaxTimeMargin )\n\t\t{\n\t\t\t// player is too far ahead\n\t\t\tTimeMargin -= DeltaTime;\n\t\t\tif ( TimeMargin < 0.5 )\n\t\t\t\tMaxTimeMargin = Default.MaxTimeMargin;\n\t\t\telse\n\t\t\t\tMaxTimeMargin = 0.5;\n\t\t\tDeltaTime = 0;\n\t\t}\n\t}\n\n\tCurrentTimeStamp = TimeStamp;\n\tServerTimeStamp = Level.TimeSeconds;\n\tRot.Roll = 256 * ClientRoll;\n\tRot.Yaw = ViewYaw;\n\tif ( (Physics == PHYS_Swimming) || (Physics == PHYS_Flying) )\n\t\tmaxPitch = 2;\n\telse\n\t\tmaxPitch = 1;\n\tIf ( (ViewPitch > maxPitch * RotationRate.Pitch) && (ViewPitch < 65536 - maxPitch * RotationRate.Pitch) )\n\t{\n\t\tIf (ViewPitch < 32768) \n\t\t\tRot.Pitch = maxPitch * RotationRate.Pitch;\n\t\telse\n\t\t\tRot.Pitch = 65536 - maxPitch * RotationRate.Pitch;\n\t}\n\telse\n\t\tRot.Pitch = ViewPitch;\n\n\t// From what I gather, this should have been the case in single player as well since\n\t// pitch is zeroed out in UpdateRotation.  Oh well, now it doesn't look goofy in mp\n\t// MBCODE\n\tif ( Level.NetMode != NM_Standalone )\n\t\tRot.Pitch = 0;\n\n\tDeltaRot = (Rotation - Rot);\n\tViewRotation.Pitch = ViewPitch;\n\tViewRotation.Yaw = ViewYaw;\n\tViewRotation.Roll = 0;\n\tSetRotation(Rot);\n\n\tOldBase = Base;\n\n\t// Perform actual movement.\n\tif ( (Level.Pauser == \"\") && (DeltaTime > 0) )\n\t\tMoveAutonomous(DeltaTime, NewbRun, NewbDuck, NewbPressedJump, DodgeMove, Accel, DeltaRot);\n\n\t// Accumulate movement error.\n\t//if ( Level.TimeSeconds - LastUpdateTime > 500.0/Player.CurrentNetSpeed )\n\t//\tClientErr = 10000;\n\t//else       \n\n   //Update every 2 seconds or so, regardless of anything else.\n   if ( Level.TimeSeconds - LastUpdateTime > 2 )\n      ClientErr = 10000;\n   else if ( Level.TimeSeconds - LastUpdateTime > 180.0/Player.CurrentNetSpeed )\n   {\n      LocDiff = Location - ClientLoc;\n      ClientErr = LocDiff Dot LocDiff;\n   }\n\n\t// If client has accumulated a noticeable positional error, correct him.\n\tif ( ClientErr > 3 )\n\t{\n\t\tif ( Mover(Base) != None )\n\t\t\tClientLoc = Location - Base.Location;\n\t\telse\n\t\t\tClientLoc = Location;\n\t   //log(\"Client Error at \"$TimeStamp$\" is \"$ClientErr$\" with acceleration \"$Accel$\" LocDiff \"$LocDiff$\" Physics \"$Physics);\n      LastUpdateTime = Level.TimeSeconds;\n\t\tClientAdjustPosition\n\t\t(\n\t\t\tTimeStamp, \n\t\t\tGetStateName(), \n\t\t\tPhysics, \n\t\t\tClientLoc.X, \n\t\t\tClientLoc.Y, \n\t\t\tClientLoc.Z, \n\t\t\tVelocity.X, \n\t\t\tVelocity.Y, \n\t\t\tVelocity.Z,\n\t\t\tBase\n\t\t);\n\t}\n   // DEUS_EX AMSD Do any ticking which needs to be done.\n   MultiplayerTick(DeltaTime);\n\t//log(\"Server \"$Role$\" moved \"$self$\" stamp \"$TimeStamp$\" location \"$Location$\" Acceleration \"$Acceleration$\" Velocity \"$Velocity);\n}\t\n\nfunction ProcessMove ( float DeltaTime, vector newAccel, eDodgeDir DodgeMove, rotator DeltaRot)\n{\n\tAcceleration = newAccel;\n}\n\nfinal function MoveAutonomous\n(\t\n\tfloat DeltaTime, \t\n\tbool NewbRun,\n\tbool NewbDuck,\n\tbool NewbPressedJump, \n\teDodgeDir DodgeMove, \n\tvector newAccel, \n\trotator DeltaRot\n)\n{\n\tif ( NewbRun )\n\t\tbRun = 1;\n\telse\n\t\tbRun = 0;\n\n\tif ( NewbDuck )\n\t\tbDuck = 1;\n\telse\n\t\tbDuck = 0;\n\tbPressedJump = NewbPressedJump;\n\n\tHandleWalking();\n\tProcessMove(DeltaTime, newAccel, DodgeMove, DeltaRot);\t\n\tAutonomousPhysics(DeltaTime);\n\t//log(\"Role \"$Role$\" moveauto time \"$100 * DeltaTime$\" (\"$Level.TimeDilation$\")\");\n}\n\n// ClientAdjustPosition - pass newloc and newvel in components so they don't get rounded\n\nfunction ClientAdjustPosition\n(\n\tfloat TimeStamp, \n\tname newState, \n\tEPhysics newPhysics,\n\tfloat NewLocX, \n\tfloat NewLocY, \n\tfloat NewLocZ, \n\tfloat NewVelX, \n\tfloat NewVelY, \n\tfloat NewVelZ,\n\tActor NewBase\n)\n{\n\tlocal Decoration Carried;\n\tlocal vector OldLoc, NewLocation;\n\n\tif ( CurrentTimeStamp > TimeStamp )\n\t\treturn;\n\tCurrentTimeStamp = TimeStamp;\n\n\tNewLocation.X = NewLocX;\n\tNewLocation.Y = NewLocY;\n\tNewLocation.Z = NewLocZ;\n\tVelocity.X = NewVelX;\n\tVelocity.Y = NewVelY;\n\tVelocity.Z = NewVelZ;\n\n\tSetBase(NewBase);\n\tif ( Mover(NewBase) != None )\n\t\tNewLocation += NewBase.Location;\n\n\t//log(\"Client \"$Role$\" adjust \"$self$\" stamp \"$TimeStamp$\" location \"$Location);\n\tCarried = CarriedDecoration;\n\tOldLoc = Location;\n\tbCanTeleport = false;\n\tSetLocation(NewLocation);\n\tbCanTeleport = true;\n\tif ( Carried != None )\n\t{\n\t\tCarriedDecoration = Carried;\n\t\tCarriedDecoration.SetLocation(NewLocation + CarriedDecoration.Location - OldLoc);\n\t\tCarriedDecoration.SetPhysics(PHYS_None);\n\t\tCarriedDecoration.SetBase(self);\n\t}\n\tSetPhysics(newPhysics);\n\n\tif ( !IsInState(newState) )\n\t\tGotoState(newState);\n\n\tbUpdatePosition = true;\n}\n\nfunction ClientUpdatePosition()\n{\n\tlocal SavedMove CurrentMove;\n\tlocal int realbRun, realbDuck;\n\tlocal bool bRealJump;\n\n\tlocal float AdjPCol, SavedRadius, TotalTime;\n\tlocal pawn SavedPawn, P;\n\tlocal vector Dist;\n\n\tbUpdatePosition = false;\n\trealbRun= bRun;\n\trealbDuck = bDuck;\n\tbRealJump = bPressedJump;\n\tCurrentMove = SavedMoves;\n\tbUpdating = true;\n\twhile ( CurrentMove != None )\n\t{\n\t\tif ( CurrentMove.TimeStamp <= CurrentTimeStamp )\n\t\t{\n\t\t\tSavedMoves = CurrentMove.NextMove;\n\t\t\tCurrentMove.NextMove = FreeMoves;\n\t\t\tFreeMoves = CurrentMove;\n\t\t\tFreeMoves.Clear();\n\t\t\tCurrentMove = SavedMoves;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// adjust radius of nearby players with uncertain location\n\t\t\tif ( TotalTime > 0 )\n               // XXXDEUS_EX AMSD Slow Pawn Iterator\n\t\t\t\t//ForEach AllActors(class'Pawn', P)\n            for (p = Level.PawnList; p != None; p = p.NextPawn)\n               if ( (P != self) && (P.Velocity != vect(0,0,0)) && P.bBlockPlayers )\n\t\t\t\t\t{\n\t\t\t\t\t\tDist = P.Location - Location;\n\t\t\t\t\t\tAdjPCol = 0.0004 * PlayerReplicationInfo.Ping * ((P.Velocity - Velocity) Dot Normal(Dist));\n\t\t\t\t\t\tif ( VSize(Dist) < AdjPCol + P.CollisionRadius + CollisionRadius + CurrentMove.Delta * GroundSpeed * (Normal(Velocity) Dot Normal(Dist)) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSavedPawn = P;\n\t\t\t\t\t\t\tSavedRadius = P.CollisionRadius;\n\t\t\t\t\t\t\tDist.Z = 0;\n\t\t\t\t\t\t\tP.SetCollisionSize(FClamp(AdjPCol + P.CollisionRadius, 0.5 * P.CollisionRadius, VSize(Dist) - CollisionRadius - P.CollisionRadius), P.CollisionHeight);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\tTotalTime += CurrentMove.Delta;\n\t\t\tMoveAutonomous(CurrentMove.Delta, CurrentMove.bRun, CurrentMove.bDuck, CurrentMove.bPressedJump, CurrentMove.DodgeMove, CurrentMove.Acceleration, rot(0,0,0));\n\t\t\tCurrentMove = CurrentMove.NextMove;\n\t\t\tif ( SavedPawn != None )\n\t\t\t{\n\t\t\t\tSavedPawn.SetCollisionSize(SavedRadius, P.CollisionHeight);\n\t\t\t\tSavedPawn = None;\n\t\t\t}\n\t\t}\n      // DEUS_EX AMSD Must also do the pending move that we've been building up.\n      if ((CurrentMove == None) && (PendingMove != None))\n      {\n         CurrentMove = PendingMove;\n         PendingMove = None;\n      }\n\t}\n\tbUpdating = false;\n\tbDuck = realbDuck;\n\tbRun = realbRun;\n\tbPressedJump = bRealJump;\n   //DEUS_EX AMSD Whenever we adjust our position, we need to reset pending moves as well.\n   PendingMove = None;\n\t//log(\"Client adjusted \"$self$\" stamp \"$CurrentTimeStamp$\" location \"$Location$\" dodge \"$DodgeDir);\n}\n\nfinal function SavedMove GetFreeMove()\n{\n\tlocal SavedMove s;\n\n\tif ( FreeMoves == None )\n\t\treturn Spawn(class'SavedMove');\n\telse\n\t{\n\t\ts = FreeMoves;\n\t\tFreeMoves = FreeMoves.NextMove;\n\t\ts.NextMove = None;\n\t\treturn s;\n\t}\t\n}\n\nfunction int CompressAccel(int C)\n{\n\tif ( C >= 0 )\n\t\tC = Min(C, 127);\n\telse\n\t\tC = Min(abs(C), 127) + 128;\n\treturn C;\n}\n\n//\n// Replicate this client's desired movement to the server.\n//\nfunction ReplicateMove\n(\n\tfloat DeltaTime, \n\tvector NewAccel, \n\teDodgeDir DodgeMove, \n\trotator DeltaRot\n)\n{\n\tlocal SavedMove NewMove, OldMove, LastMove;\n\tlocal byte ClientRoll;\n\tlocal int i;\n\tlocal float OldTimeDelta, TotalTime, NetMoveDelta;\n\tlocal int OldAccel;\n\tlocal vector BuildAccel, AccelNorm, prevloc, prevvelocity;\n\n\tlocal float AdjPCol, SavedRadius;\n\tlocal pawn SavedPawn, P;\n\tlocal vector Dist;\n   local bool HighVelocityDelta;\n\n\n   HighVelocityDelta = false;\n   // Get a SavedMove actor to store the movement in.\n\tif ( PendingMove != None )\n\t{\n\t\t//add this move to the pending move\n\t\tPendingMove.TimeStamp = Level.TimeSeconds; \n\t\tif ( VSize(NewAccel) > 3072 )\n\t\t\tNewAccel = 3072 * Normal(NewAccel);\n\t\tTotalTime = PendingMove.Delta + DeltaTime;\n\t\tPendingMove.Acceleration = (DeltaTime * NewAccel + PendingMove.Delta * PendingMove.Acceleration)/TotalTime;\n\n\t\t// Set this move's data.\n\t\tif ( PendingMove.DodgeMove == DODGE_None )\n\t\t\tPendingMove.DodgeMove = DodgeMove;\n\t\tPendingMove.bRun = (bRun > 0);\n\t\tPendingMove.bDuck = (bDuck > 0);\n\t\tPendingMove.bPressedJump = bPressedJump || PendingMove.bPressedJump;\n\t\tPendingMove.bFire = PendingMove.bFire || bJustFired || (bFire != 0);\n\t\tPendingMove.bForceFire = PendingMove.bForceFire || bJustFired;\n\t\tPendingMove.bAltFire = PendingMove.bAltFire || bJustAltFired || (bAltFire != 0);\n\t\tPendingMove.bForceAltFire = PendingMove.bForceAltFire || bJustFired;\n\t\tPendingMove.Delta = TotalTime;\n\t}\n\tif ( SavedMoves != None )\n\t{\n\t\tNewMove = SavedMoves;\n\t\tAccelNorm = Normal(NewAccel);\n\t\twhile ( NewMove.NextMove != None )\n\t\t{\n\t\t\t// find most recent interesting move to send redundantly\n\t\t\tif ( NewMove.bPressedJump || ((NewMove.DodgeMove != Dodge_NONE) && (NewMove.DodgeMove < 5))\n\t\t\t\t|| ((NewMove.Acceleration != NewAccel) && ((normal(NewMove.Acceleration) Dot AccelNorm) < 0.95)) )\n\t\t\t\tOldMove = NewMove;\n\t\t\tNewMove = NewMove.NextMove;\n\t\t}\n\t\tif ( NewMove.bPressedJump || ((NewMove.DodgeMove != Dodge_NONE) && (NewMove.DodgeMove < 5))\n\t\t\t|| ((NewMove.Acceleration != NewAccel) && ((normal(NewMove.Acceleration) Dot AccelNorm) < 0.95)) )\n\t\t\tOldMove = NewMove;\n\t}\n\n\tLastMove = NewMove;\n\tNewMove = GetFreeMove();\n\tNewMove.Delta = DeltaTime;\n\tif ( VSize(NewAccel) > 3072 )\n\t\tNewAccel = 3072 * Normal(NewAccel);\n\tNewMove.Acceleration = NewAccel;\n\n\t// Set this move's data.\n\tNewMove.DodgeMove = DodgeMove;\n\tNewMove.TimeStamp = Level.TimeSeconds;\n\tNewMove.bRun = (bRun > 0);\n\tNewMove.bDuck = (bDuck > 0);\n\tNewMove.bPressedJump = bPressedJump;\n\tNewMove.bFire = (bJustFired || (bFire != 0));\n\tNewMove.bForceFire = bJustFired;\n\tNewMove.bAltFire = (bJustAltFired || (bAltFire != 0));\n\tNewMove.bForceAltFire = bJustAltFired;\n\tif ( Weapon != None ) // approximate pointing so don't have to replicate\n\t\tWeapon.bPointing = ((bFire != 0) || (bAltFire != 0));\n\tbJustFired = false;\n\tbJustAltFired = false;\n\t\n\t// adjust radius of nearby players with uncertain location\n   // XXXDEUS_EX AMSD Slow Pawn Iterator\n//\tForEach AllActors(class'Pawn', P)\n   for (p = Level.PawnList; p != None; p = p.NextPawn)\n\t\tif ( (P != self) && (P.Velocity != vect(0,0,0)) && P.bBlockPlayers )\n\t\t{\n\t\t\tDist = P.Location - Location;\n\t\t\tAdjPCol = 0.0004 * PlayerReplicationInfo.Ping * ((P.Velocity - Velocity) Dot Normal(Dist));\n\t\t\tif ( VSize(Dist) < AdjPCol + P.CollisionRadius + CollisionRadius + NewMove.Delta * GroundSpeed * (Normal(Velocity) Dot Normal(Dist)) )\n\t\t\t{\n\t\t\t\tSavedPawn = P;\n\t\t\t\tSavedRadius = P.CollisionRadius;\n\t\t\t\tDist.Z = 0;\n\t\t\t\tP.SetCollisionSize(FClamp(AdjPCol + P.CollisionRadius, 0.5 * P.CollisionRadius, VSize(Dist) - CollisionRadius - P.CollisionRadius), P.CollisionHeight);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} \n      \n   // Simulate the movement locally.\n   \n   prevloc = Location;\n   prevvelocity = Velocity;\n\tProcessMove(NewMove.Delta, NewMove.Acceleration, NewMove.DodgeMove, DeltaRot * (NewMove.Delta / DeltaTime));\n\tAutonomousPhysics(NewMove.Delta);\n   HighVelocityDelta = VelocityChanged(prevvelocity,Velocity);\n\n   if ( SavedPawn != None )\n\t\tSavedPawn.SetCollisionSize(SavedRadius, P.CollisionHeight);\n\n\t//log(\"Role \"$Role$\" repmove at \"$Level.TimeSeconds$\" Move time \"$100 * DeltaTime$\" (\"$Level.TimeDilation$\")\");\n\n\t// Decide whether to hold off on move\n\t// send if dodge, jump, or fire unless really too soon, or if newmove.delta big enough\n\t// on client side, save extra buffered time in LastUpdateTime\n\tif ( PendingMove == None )\n\t\tPendingMove = NewMove;\n\telse\n\t{\n\t\tNewMove.NextMove = FreeMoves;\n\t\tFreeMoves = NewMove;\n\t\tFreeMoves.Clear();\n\t\tNewMove = PendingMove;\n\t}\n\n\tNetMoveDelta = FMax(64.0/Player.CurrentNetSpeed, 0.011); //was 0.011\n\n   // DEUS_EX AMSD If this move is not particularly important, then up the netmove delta\n   // don't do this when falling either.\n   if (!PendingMove.bForceFire && !PendingMove.bForceAltFire && !PendingMove.bPressedJump && !(Physics == PHYS_Falling))\n   {\n      if ((VSize(Velocity)<5.0) && (!HighVelocityDelta))\n      {\n         NetMoveDelta = FMax(NetMoveDelta, Player.StaticUpdateInterval);\n      }\n      else if (!HighVelocityDelta)\n      {\n         NetMoveDelta = FMax(NetMoveDelta, Player.DynamicUpdateInterval);\n      }\n   }\n\n   // If the net move delta has shrunk enough that \n   // client update time is bigger, then we haven't\n   // sent a packet THAT recently, so make sure we do.\n   if (ClientUpdateTime < (-1 * NetMoveDelta))\n      ClientUpdateTime = 0;\n\n\n\tif ( !PendingMove.bForceFire && !PendingMove.bForceAltFire && !PendingMove.bPressedJump\n\t\t&& (PendingMove.Delta < NetMoveDelta - ClientUpdateTime) )\n\t{\n\t\t// save as pending move\n\t\treturn;\n\t}\n\telse if ( (ClientUpdateTime < 0) && (PendingMove.Delta < NetMoveDelta - ClientUpdateTime) )\n\t\treturn;\n\telse\n\t{\n      ClientUpdateTime = PendingMove.Delta - NetMoveDelta;\n\n      if ( SavedMoves == None )\n         SavedMoves = PendingMove;\n      else\n         LastMove.NextMove = PendingMove;      \n      PendingMove = None;\n   }\n\n\n\t// check if need to redundantly send previous move\n\tif ( OldMove != None )\n\t{\n\t\t// log(\"Redundant send timestamp \"$OldMove.TimeStamp$\" accel \"$OldMove.Acceleration$\" at \"$Level.Timeseconds$\" New accel \"$NewAccel);\n\t\t// old move important to replicate redundantly\n\t\tOldTimeDelta = FMin(255, (Level.TimeSeconds - OldMove.TimeStamp) * 500);\n\t\tBuildAccel = 0.05 * OldMove.Acceleration + vect(0.5, 0.5, 0.5);\n\t\tOldAccel = (CompressAccel(BuildAccel.X) << 23) \n\t\t\t\t\t+ (CompressAccel(BuildAccel.Y) << 15) \n\t\t\t\t\t+ (CompressAccel(BuildAccel.Z) << 7);\n\t\tif ( OldMove.bRun )\n\t\t\tOldAccel += 64;\n\t\tif ( OldMove.bDuck )\n\t\t\tOldAccel += 32;\n\t\tif ( OldMove.bPressedJump )\n\t\t\tOldAccel += 16;\n\t\tOldAccel += OldMove.DodgeMove;\n\t}\n\t//else\n\t//\tlog(\"No redundant timestamp at \"$Level.TimeSeconds$\" with accel \"$NewAccel);\n\n\t// Send to the server\n\tClientRoll = (Rotation.Roll >> 8) & 255;\n\tif ( NewMove.bPressedJump )\n\t\tbJumpStatus = !bJumpStatus;\n\tServerMove\n\t(\n\t\tNewMove.TimeStamp, \n\t\tNewMove.Acceleration * 10, \n\t\tLocation, \n\t\tNewMove.bRun,\n\t\tNewMove.bDuck,\n\t\tbJumpStatus, \n\t\tNewMove.bFire,\n\t\tNewMove.bAltFire,\n\t\tNewMove.bForceFire,\n\t\tNewMove.bForceAltFire,\n\t\tNewMove.DodgeMove, \n\t\tClientRoll,\n\t\t(32767 & (ViewRotation.Pitch/2)) * 32768 + (32767 & (ViewRotation.Yaw/2)),\n\t\tOldTimeDelta,\n\t\tOldAccel \n\t);\n\t//log(\"Replicated \"$self$\" stamp \"$NewMove.TimeStamp$\" location \"$Location$\" dodge \"$NewMove.DodgeMove$\" to \"$DodgeDir);\n}\n\nfunction HandleWalking()\n{\n\tlocal rotator carried;\n\n\t// this is changed from Unreal -- default is now walk - DEUS_EX CNN\n\tbIsWalking = ((bRun == 0) || (bDuck != 0)) && !Region.Zone.IsA('WarpZoneInfo'); \n\n\tif ( CarriedDecoration != None )\n\t{\n\t\tif ( (Role == ROLE_Authority) && (standingcount == 0) ) \n\t\t\tCarriedDecoration = None;\n\t\tif ( CarriedDecoration != None ) //verify its still in front\n\t\t{\n\t\t\tbIsWalking = true;\n\t\t\tif ( Role == ROLE_Authority )\n\t\t\t{\n\t\t\t\tcarried = Rotator(CarriedDecoration.Location - Location);\n\t\t\t\tcarried.Yaw = ((carried.Yaw & 65535) - (Rotation.Yaw & 65535)) & 65535;\n\t\t\t\tif ( (carried.Yaw > 3072) && (carried.Yaw < 62463) )\n\t\t\t\t\tDropDecoration();\n\t\t\t}\n\t\t}\n\t}\n}\n\n//----------------------------------------------\n\nsimulated event Destroyed()\n{\n\tSuper.Destroyed();\n\tif ( myHud != None )\n\t\tmyHud.Destroy();\n\tif ( Scoring != None )\n\t\tScoring.Destroy();\n\n\tWhile ( FreeMoves != None )\n\t{\n\t\tFreeMoves.Destroy();\n\t\tFreeMoves = FreeMoves.NextMove;\n\t}\n\n\tWhile ( SavedMoves != None )\n\t{\n\t\tSavedMoves.Destroy();\n\t\tSavedMoves = SavedMoves.NextMove;\n\t}\n}\n\nfunction ServerReStartGame()\n{\n\tLevel.Game.RestartGame();\n}\n\nfunction PlayHit(float Damage, vector HitLocation, name damageType, vector Momentum)\n{\n\tLevel.Game.SpecialDamageString = \"\";\n}\n\nfunction SetFOVAngle(float newFOV)\n{\n\tFOVAngle = newFOV;\n}\n\t \nfunction ClientFlash( float scale, vector fog )\n{\n\tDesiredFlashScale = scale;\n\tDesiredFlashFog = 0.001 * fog;\n}\n\nfunction ClientInstantFlash( float scale, vector fog )\n{\n\tInstantFlash = scale;\n\tInstantFog = 0.001 * fog;\n}\n\n//Play a sound client side (so only client will hear it\nsimulated function ClientPlaySound(sound ASound, optional bool bInterrupt, optional bool bVolumeControl )\n{\t\n\tlocal actor SoundPlayer;\n\n\tLastPlaySound = Level.TimeSeconds;\t// so voice messages won't overlap\n\tif ( ViewTarget != None )\n\t\tSoundPlayer = ViewTarget;\n\telse\n\t\tSoundPlayer = self;\n\n\tSoundPlayer.PlaySound(ASound, SLOT_None, 16.0, bInterrupt);\n\tSoundPlayer.PlaySound(ASound, SLOT_Interface, 16.0, bInterrupt);\n\tSoundPlayer.PlaySound(ASound, SLOT_Misc, 16.0, bInterrupt);\n\tSoundPlayer.PlaySound(ASound, SLOT_Talk, 16.0, bInterrupt);\n}\n\nsimulated function ClientReliablePlaySound(sound ASound, optional bool bInterrupt, optional bool bVolumeControl )\n{\n\tClientPlaySound(ASound, bInterrupt, bVolumeControl);\n}\n   \nfunction ClientAdjustGlow( float scale, vector fog )\n{\n\tConstantGlowScale += scale;\n\tConstantGlowFog += 0.001 * fog;\n}\n\nfunction ClientShake(vector shake)\n{\n\tif ( (shakemag < shake.X) || (shaketimer <= 0.01 * shake.Y) )\n\t{\n\t\tshakemag = shake.X;\n\t\tshaketimer = 0.01 * shake.Y;\t\n\t\tmaxshake = 0.01 * shake.Z;\n\t\tverttimer = 0;\n\t\tShakeVert = -1.1 * maxshake;\n\t}\n}\n\nfunction ShakeView( float shaketime, float RollMag, float vertmag)\n{\n\tlocal vector shake;\n\n\tshake.X = RollMag;\n\tshake.Y = 100 * shaketime;\n\tshake.Z = 100 * vertmag;\n\tClientShake(shake);\n}\n\nfunction ClientSetMusic( music NewSong, byte NewSection, byte NewCdTrack, EMusicTransition NewTransition )\n{\n\tSong        = NewSong;\n\tSongSection = NewSection;\n\tCdTrack     = NewCdTrack;\n\tTransition  = NewTransition;\n}\n\nfunction ServerFeignDeath()\n{\n\tlocal Weapon W;\n\n\tW = Weapon;\n\tPendingWeapon = None;\n\tif ( Weapon != None )\n\t\tWeapon.PutDown();\n\tPendingWeapon = W;\n\tGotoState('FeigningDeath');\n}\n\nfunction ServerSetHandedness( float hand)\n{\n\tHandedness = hand;\n\tif ( Weapon != None )\n\t{\n\t\tWeapon.SetHand(Handedness);\n\t\tif (( Level.NetMode != NM_Standalone ) && ( Role == ROLE_Authority ))\n\t\t\tWeapon.ClientSetHandedness(Handedness);\n\t}\n}\n\nfunction ServerReStartPlayer()\n{\n}\n\nfunction ServerChangeSkin( coerce string SkinName, coerce string FaceName, byte TeamNum )\n{\n\tlocal string MeshName;\n\n\tMeshName = GetItemName(string(Mesh));\n\tif ( Level.Game.bCanChangeSkin )\n\t{\n\t\tSelf.static.SetMultiSkin(Self, SkinName, FaceName, TeamNum );\n\t}\n}\n\n//*************************************************************************************\n// Normal gameplay execs\n// Type the name of the exec function at the console to execute it\n\nexec function ShowSpecialMenu( string ClassName )\n{\n\tlocal class<menu> aMenuClass;\n\n\taMenuClass = class<menu>( DynamicLoadObject( ClassName, class'Class' ) );\n\tif( aMenuClass!=None )\n\t{\n\t\tbSpecialMenu = true;\n\t\tSpecialMenu = aMenuClass;\n\t\tShowMenu();\n\t}\n}\n\n//\n// Say\n//\nexec function Say( string Msg )\n{\n\tlocal Pawn P;\n\tlocal String str;\n\n\tstr = PlayerReplicationInfo.PlayerName $ \": \" $ Msg;\n\n\tif ( Role == ROLE_Authority )\n\t\tlog( \"Say>\" $ str );\n\n\tfor( P = Level.PawnList; P != None; P = P.nextPawn )\n\t{\n\t\tif( P.bIsPlayer )\n\t\t\tP.ClientMessage( str, 'Say', true );\n\t}\n\n\treturn;\n}\n\nexec function Jump( optional float F )\n{\n\tif ( !bShowMenu && (Level.Pauser == PlayerReplicationInfo.PlayerName) )\n\t\tSetPause(False);\n\telse\n\t\tbPressedJump = true;\n}\n\nexec function CauseEvent( name N )\n{\n\tlocal actor A;\n\tif( !bCheatsEnabled )\n\t\treturn;\n\tif( (bAdmin || (Level.Netmode == NM_Standalone)) && (N != '') )\n\t\tforeach AllActors( class 'Actor', A, N )\n\t\t\tA.Trigger( Self, Self );\n}\n\nexec function Taunt( name Sequence )\n{\n\tif ( GetAnimGroup(Sequence) == 'Gesture' ) \n\t{\n\t\tServerTaunt(Sequence);\n\t\tPlayAnim(Sequence, 0.7, 0.2);\n\t}\n}\n\nfunction ServerTaunt(name Sequence )\n{\n\tPlayAnim(Sequence, 0.7, 0.2);\n}\n\nexec function FeignDeath()\n{\n}\n\nexec function CallForHelp()\n{\n\tlocal Pawn P;\n\n\tif ( !Level.Game.bTeamGame || (Enemy == None) || (Enemy.Health <= 0) )\n\t\treturn;\n\n\tfor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t\tif ( P.bIsPlayer && (P.PlayerReplicationInfo.Team == PlayerReplicationInfo.Team) )\n\t\t\tP.HandleHelpMessageFrom(self);\n}\n\nfunction damageAttitudeTo(pawn Other)\n{\n\tif ( Other != Self )\n\t\tEnemy = Other;\n}\n\nexec function Grab()\n{\n\tif (CarriedDecoration == None)\n\t\tGrabDecoration();\n\telse\n\t\tDropDecoration();\n}\n\n// Send a voice message of a certain type to a certain player.\nexec function Speech( int Type, int Index, int Callsign )\n{\n\tlocal VoicePack V;\n\n\tV = Spawn( PlayerReplicationInfo.VoiceType, Self );\n\tif (V != None)\n\t\tV.PlayerSpeech( Type, Index, Callsign );\n}\n\nfunction PlayChatting();\n\nfunction Typing( bool bTyping )\n{\n\tbIsTyping = bTyping;\n\tif (bTyping)\n\t{\n\t\tif (Level.Game.WorldLog != None)\n\t\t\tLevel.Game.WorldLog.LogTypingEvent(True, Self);\n\t\tif (Level.Game.LocalLog != None)\n\t\t\tLevel.Game.LocalLog.LogTypingEvent(True, Self);\n\t\tPlayChatting();\n\t} \n\telse \n\t{\n\t\tif (Level.Game.WorldLog != None)\n\t\t\tLevel.Game.WorldLog.LogTypingEvent(False, Self);\n\t\tif (Level.Game.LocalLog != None)\n\t\t\tLevel.Game.LocalLog.LogTypingEvent(False, Self);\n\t}\n}\n\nexec function RestartLevel()\n{\n\tif( bAdmin || Level.Netmode==NM_Standalone )\n\t\tClientTravel( \"?restart\", TRAVEL_Relative, false );\n}\n\nexec function LocalTravel( string URL )\n{\n\tif( bAdmin || Level.Netmode==NM_Standalone )\n\t\tClientTravel( URL, TRAVEL_Relative, true );\n}\n\nexec function ThrowWeapon()\n{\n\tif( Level.NetMode == NM_Client )\n\t\treturn;\n\tif( Weapon==None || (Weapon.Class==Level.Game.BaseMutator.MutatedDefaultWeapon())\n\t\t|| !Weapon.bCanThrow )\n\t\treturn;\n\tWeapon.Velocity = Vector(ViewRotation) * 500 + vect(0,0,220);\n\tWeapon.bTossedOut = true;\n\tTossWeapon();\n\tif ( Weapon == None )\n\t\tSwitchToBestWeapon();\n}\n\nfunction ToggleZoom()\n{\n\tif ( DefaultFOV != DesiredFOV )\n\t\tEndZoom();\n\telse\n\t\tStartZoom();\n}\n\t\nfunction StartZoom()\n{\n\tZoomLevel = 0.0;\n\tbZooming = true;\n}\n\nfunction StopZoom()\n{\n\tbZooming = false;\n}\n\nfunction EndZoom()\n{\n\tbZooming = false;\n\tDesiredFOV = DefaultFOV;\n}\n\nexec function FOV(float F)\n{\n\tSetDesiredFOV(F);\n}\n\t\nexec function SetDesiredFOV(float F)\n{\n\tif( (F >= 80.0) || Level.bAllowFOV || bAdmin || (Level.Netmode==NM_Standalone) )\n\t{\n\t\tDefaultFOV = FClamp(F, 1, 170);\n\t\tDesiredFOV = DefaultFOV;\n\t\tSaveConfig();\n\t}\n}\n\n/* PrevWeapon()\n- switch to previous inventory group weapon\n*/\nexec function PrevWeapon()\n{\n\tlocal int prevGroup;\n\tlocal Inventory inv;\n\tlocal Weapon realWeapon, w, Prev;\n\tlocal bool bFoundWeapon;\n\n\tif( bShowMenu || Level.Pauser!=\"\" )\n\t\treturn;\n\tif ( Weapon == None )\n\t{\n\t\tSwitchToBestWeapon();\n\t\treturn;\n\t}\n\tprevGroup = 0;\n\trealWeapon = Weapon;\n\tif ( PendingWeapon != None )\n\t\tWeapon = PendingWeapon;\n\tPendingWeapon = None;\n\t\n\tfor (inv=Inventory; inv!=None; inv=inv.Inventory)\n\t{\n\t\tw = Weapon(inv);\n\t\tif ( w != None )\n\t\t{\n\t\t\tif ( w.InventoryGroup == Weapon.InventoryGroup )\n\t\t\t{\n\t\t\t\tif ( w == Weapon )\n\t\t\t\t{\n\t\t\t\t\tbFoundWeapon = true;\n\t\t\t\t\tif ( Prev != None )\n\t\t\t\t\t{\n\t\t\t\t\t\tPendingWeapon = Prev;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( !bFoundWeapon && ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) )\n\t\t\t\t\tPrev = W;\n\t\t\t}\n\t\t\telse if ( (w.InventoryGroup < Weapon.InventoryGroup) \n\t\t\t\t\t&& ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) \n\t\t\t\t\t&& (w.InventoryGroup >= prevGroup) )\n\t\t\t{\n\t\t\t\tprevGroup = w.InventoryGroup;\n\t\t\t\tPendingWeapon = w;\n\t\t\t}\n\t\t}\n\t}\n\tbFoundWeapon = false;\n\tprevGroup = Weapon.InventoryGroup;\n\tif ( PendingWeapon == None )\n\t\tfor (inv=Inventory; inv!=None; inv=inv.Inventory)\n\t\t{\n\t\t\tw = Weapon(inv);\n\t\t\tif ( w != None )\n\t\t\t{\n\t\t\t\tif ( w.InventoryGroup == Weapon.InventoryGroup )\n\t\t\t\t{\n\t\t\t\t\tif ( w == Weapon )\n\t\t\t\t\t\tbFoundWeapon = true;\n\t\t\t\t\telse if ( bFoundWeapon && (PendingWeapon == None) && ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) )\n\t\t\t\t\t\tPendingWeapon = W;\n\t\t\t\t}\n\t\t\t\telse if ( (w.InventoryGroup > PrevGroup) \n\t\t\t\t\t\t&& ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) ) \n\t\t\t\t{\n\t\t\t\t\tprevGroup = w.InventoryGroup;\n\t\t\t\t\tPendingWeapon = w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tWeapon = realWeapon;\n\tif ( PendingWeapon == None )\n\t\treturn;\n\n\tWeapon.PutDown();\n}\n\n/* NextWeapon()\n- switch to next inventory group weapon\n*/\nexec function NextWeapon()\n{\n\tlocal int nextGroup;\n\tlocal Inventory inv;\n\tlocal Weapon realWeapon, w, Prev;\n\tlocal bool bFoundWeapon;\n\n\tif( bShowMenu || Level.Pauser!=\"\" )\n\t\treturn;\n\tif ( Weapon == None )\n\t{\n\t\tSwitchToBestWeapon();\n\t\treturn;\n\t}\n\tnextGroup = 100;\n\trealWeapon = Weapon;\n\tif ( PendingWeapon != None )\n\t\tWeapon = PendingWeapon;\n\tPendingWeapon = None;\n\n\tfor (inv=Inventory; inv!=None; inv=inv.Inventory)\n\t{\n\t\tw = Weapon(inv);\n\t\tif ( w != None )\n\t\t{\n\t\t\tif ( w.InventoryGroup == Weapon.InventoryGroup )\n\t\t\t{\n\t\t\t\tif ( w == Weapon )\n\t\t\t\t\tbFoundWeapon = true;\n\t\t\t\telse if ( bFoundWeapon && ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) )\n\t\t\t\t{\n\t\t\t\t\tPendingWeapon = W;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( (w.InventoryGroup > Weapon.InventoryGroup) \n\t\t\t\t\t&& ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) \n\t\t\t\t\t&& (w.InventoryGroup < nextGroup) )\n\t\t\t{\n\t\t\t\tnextGroup = w.InventoryGroup;\n\t\t\t\tPendingWeapon = w;\n\t\t\t}\n\t\t}\n\t}\n\n\tbFoundWeapon = false;\n\tnextGroup = Weapon.InventoryGroup;\n\tif ( PendingWeapon == None )\n\t\tfor (inv=Inventory; inv!=None; inv=inv.Inventory)\n\t\t{\n\t\t\tw = Weapon(Inv);\n\t\t\tif ( w != None )\n\t\t\t{\n\t\t\t\tif ( w.InventoryGroup == Weapon.InventoryGroup )\n\t\t\t\t{\n\t\t\t\t\tif ( w == Weapon )\n\t\t\t\t\t{\n\t\t\t\t\t\tbFoundWeapon = true;\n\t\t\t\t\t\tif ( Prev != None )\n\t\t\t\t\t\t\tPendingWeapon = Prev;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( !bFoundWeapon && (PendingWeapon == None) && ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) )\n\t\t\t\t\t\tPrev = W;\n\t\t\t\t}\n\t\t\t\telse if ( (w.InventoryGroup < nextGroup) \n\t\t\t\t\t&& ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) ) \n\t\t\t\t{\n\t\t\t\t\tnextGroup = w.InventoryGroup;\n\t\t\t\t\tPendingWeapon = w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tWeapon = realWeapon;\n\tif ( PendingWeapon == None )\n\t\treturn;\n\n\tWeapon.PutDown();\n}\n\nexec function Mutate(string MutateString)\n{\n\tif( Level.NetMode == NM_Client )\n\t\treturn;\n\tLevel.Game.BaseMutator.Mutate(MutateString, Self);\n}\n\nexec function QuickSave()\n{\n\tif ( (Health > 0) \n\t\t&& (Level.NetMode == NM_Standalone)\n\t\t&& !Level.Game.bDeathMatch )\n\t{\n\t\tClientMessage(QuickSaveString);\n\t\tConsoleCommand(\"SaveGame 9\");\n\t}\n}\n\nexec function QuickLoad()\n{\n\tif ( (Level.NetMode == NM_Standalone)\n\t\t&& !Level.Game.bDeathMatch )\n\t\tClientTravel( \"?load=9\", TRAVEL_Absolute, false);\n}\n\nexec function Kick( string KickString ) \n{\n\tlocal Pawn aPawn;\n\tif( !bAdmin )\n\t\treturn;\n\n\tfor( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )\n\t\tif\n\t\t(\taPawn.bIsPlayer\n\t\t    &&  string(aPawn.PlayerReplicationInfo.PlayerID) ~= KickString\n\t\t\t&&\t(PlayerPawn(aPawn)==None || NetConnection(PlayerPawn(aPawn).Player)!=None ) )\n\t\t{\n\t\t\taPawn.Destroy();\n\t\t\treturn;\n\t\t}\n}\n\nexec function KickBan( string KickString ) \n{\n\tlocal Pawn aPawn;\n\tlocal string IP;\n\tlocal int j;\n\tif( !bAdmin )\n\t\treturn;\n\tfor( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )\n\t\tif\n\t\t(\taPawn.bIsPlayer\n\t\t    &&  string(aPawn.PlayerReplicationInfo.PlayerID) ~= KickString\n\t\t\t&&\t(PlayerPawn(aPawn)==None || NetConnection(PlayerPawn(aPawn).Player)!=None ) )\n\t\t{\n\t\t\tIP = PlayerPawn(aPawn).GetPlayerNetworkAddress();\n\t\t\tif(Level.Game.CheckIPPolicy(IP))\n\t\t\t{\n\t\t\t\tIP = Left(IP, InStr(IP, \":\"));\n\t\t\t\tLog(\"Adding IP Ban for: \"$IP);\n\t\t\t\tfor(j=0;j<50;j++)\n\t\t\t\t\tif(Level.Game.IPPolicies[j] == \"\")\n\t\t\t\t\t\tbreak;\n\t\t\t\tif(j < 50)\n\t\t\t\t\tLevel.Game.IPPolicies[j] = \"DENY,\"$IP;\n\t\t\t\tLevel.Game.SaveConfig();\n\t\t\t}\n\t\t\taPawn.Destroy();\n\t\t\treturn;\n\t\t}\n}\n\n// Try to set the pause state; returns success indicator.\nfunction bool SetPause( BOOL bPause )\n{\n\treturn Level.Game.SetPause(bPause, self);\n}\n\nexec function SetMouseSmoothThreshold( float F )\n{\n\tMouseSmoothThreshold = FClamp(F, 0, 0.1);\n\tSaveConfig();\n}\n\nexec function SetMaxMouseSmoothing( bool B )\n{\n\tbMaxMouseSmoothing = B;\n\tSaveConfig();\n}\n\n// Try to pause the game.\nexec function Pause()\n{\n\t// Don't pause in multiplayer\n\tif ( Level.NetMode == NM_Standalone )\n\t{\n\t\tif ( bShowMenu )\n\t\t\treturn;\n\t\tif( !SetPause(Level.Pauser==\"\") )\n\t\t\tClientMessage(NoPauseMessage);\n\t}\n}\n\n// Activate specific inventory item\nexec function ActivateInventoryItem( class InvItem )\n{\n\tlocal Inventory Inv;\n\n\tInv = FindInventoryType(InvItem);\n\tif ( Inv != None )\n\t\tInv.Activate();\n}\n\n// Translator Hotkey\nexec function ActivateTranslator()\n{\n\tif ( bShowMenu || Level.Pauser!=\"\" )\n\t\treturn;\n\tIf (Inventory!=None) Inventory.ActivateTranslator(False);\n}\n\n// Translator Hotkey\nexec function ActivateHint()\n{\n\tif ( bShowMenu || Level.Pauser!=\"\" )\n\t\treturn;\n\tIf (Inventory!=None) Inventory.ActivateTranslator(True);\n}\n\n// HUD\nexec function ChangeHud()\n{\n\tif ( myHud != None )\n\t\tmyHUD.ChangeHud(1);\n\tmyHUD.SaveConfig();\n}\n\n// Crosshair\nexec function ChangeCrosshair()\n{\n\tif ( myHud != None ) \n\t\tmyHUD.ChangeCrosshair(1);\n\tmyHUD.SaveConfig();\n}\n\n\nevent PreRender( canvas Canvas )\n{\n\tif ( myHud != None )\t\n\t\tmyHUD.PreRender(Canvas);\n\telse if ( (Viewport(Player) != None) && (HUDType != None) )\n\t\tmyHUD = spawn(HUDType, self);\n}\n\n// DEUS_EX STM\nevent PostRenderFlash( canvas Canvas )\n{\n}\n\nevent PostRender( canvas Canvas )\n{\n\tif ( myHud != None )\t\n\t\tmyHUD.PostRender(Canvas);\n\telse if ( (Viewport(Player) != None) && (HUDType != None) )\n\t\tmyHUD = spawn(HUDType, self);\n}\n\n//=============================================================================\n// Inventory-related input notifications.\n\n// Handle function keypress for F1-F10.\nexec function FunctionKey( byte Num )\n{\n}\n\n// The player wants to switch to weapon group numer I.\nexec function SwitchWeapon (byte F )\n{\n\tlocal weapon newWeapon;\n\n\tif ( bShowMenu || Level.Pauser!=\"\" )\n\t{\n\t\tif ( myHud != None )\n\t\t\tmyHud.InputNumber(F);\n\t\treturn;\n\t}\n\tif ( Inventory == None )\n\t\treturn;\n\tif ( (Weapon != None) && (Weapon.Inventory != None) )\n\t\tnewWeapon = Weapon.Inventory.WeaponChange(F);\n\telse\n\t\tnewWeapon = None;\t\n\tif ( newWeapon == None )\n\t\tnewWeapon = Inventory.WeaponChange(F);\n\tif ( newWeapon == None )\n\t\treturn;\n\n\tif ( Weapon == None )\n\t{\n\t\tPendingWeapon = newWeapon;\n\t\tChangedWeapon();\n\t}\n\telse if ( Weapon != newWeapon )\n\t{\n\t\tPendingWeapon = newWeapon;\n\t\tif ( !Weapon.PutDown() )\n\t\t\tPendingWeapon = None;\n\t}\n}\n\nexec function GetWeapon(class<Weapon> NewWeaponClass )\n{\n\tlocal Inventory Inv;\n\n\tif ( (Inventory == None) || (NewWeaponClass == None)\n\t\t|| ((Weapon != None) && (Weapon.Class == NewWeaponClass)) )\n\t\treturn;\n\n\tfor ( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )\n\t\tif ( Inv.Class == NewWeaponClass )\n\t\t{\n\t\t\tPendingWeapon = Weapon(Inv);\n\t\t\tif ( (PendingWeapon.AmmoType != None) && (PendingWeapon.AmmoType.AmmoAmount <= 0) )\n\t\t\t{\n\t\t\t\tPawn(Owner).ClientMessage( PendingWeapon.ItemName$PendingWeapon.MessageNoAmmo );\n\t\t\t\tPendingWeapon = None;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tWeapon.PutDown();\n\t\t\treturn;\n\t\t}\n}\n\t\n// The player wants to select previous item\nexec function PrevItem()\n{\n\tlocal Inventory Inv, LastItem;\n\n\t// DEUS_EX CNN - this function is EVIL!\n\treturn;\n\n\tif ( bShowMenu || Level.Pauser!=\"\" )\n\t\treturn;\n\tif (SelectedItem==None) {\n\t\tSelectedItem = Inventory.SelectNext();\n\t\tReturn;\n\t}\n\tif (SelectedItem.Inventory!=None) \n\t\tfor( Inv=SelectedItem.Inventory; Inv!=None; Inv=Inv.Inventory ) {\n\t\t\tif (Inv==None) Break;\n\t\t\tif (Inv.bActivatable) LastItem=Inv;\n\t\t}\n\tfor( Inv=Inventory; Inv!=SelectedItem; Inv=Inv.Inventory ) {\n\t\tif (Inv==None) Break;\n\t\tif (Inv.bActivatable) LastItem=Inv;\n\t}\n\tif (LastItem!=None) {\n\t\tSelectedItem = LastItem;\n\t\tClientMessage(SelectedItem.ItemName$SelectedItem.M_Selected);\n\t}\n}\n\n// The player wants to active selected item\nexec function ActivateItem()\n{\n\tif( bShowMenu || Level.Pauser!=\"\" )\n\t\treturn;\n\tif (SelectedItem!=None) \n\t\tSelectedItem.Activate();\n}\n\n// The player wants to fire.\nexec function Fire( optional float F )\n{\n\tbJustFired = true;\n\tif( bShowMenu || (Level.Pauser!=\"\") || (Role < ROLE_Authority) )\n\t{\n\t\tif( (Role < ROLE_Authority) && (Weapon!=None) )\n\t\t\tbJustFired = Weapon.ClientFire(F);\n\t\tif ( !bShowMenu && (Level.Pauser == PlayerReplicationInfo.PlayerName)  )\n\t\t\tSetPause(False);\n\t\treturn;\n\t}\n\tif( Weapon!=None )\n\t{\n\t\tWeapon.bPointing = true;\n\t\tPlayFiring();\n\t\tif (( Level.NetMode == NM_Standalone ) || ( Level.NetMode == NM_ListenServer ))\t// Handled through client as an mp client\n\t\t\tWeapon.Fire(F);\n\t}\n}\n\n// The player wants to alternate-fire.\nexec function AltFire( optional float F )\n{\n\tbJustAltFired = true;\n\tif( bShowMenu || (Level.Pauser!=\"\") || (Role < ROLE_Authority) )\n\t{\n\t\tif( (Role < ROLE_Authority) && (Weapon!=None) )\n\t\t\tbJustAltFired = Weapon.ClientAltFire(F);\n\t\tif ( !bShowMenu && (Level.Pauser == PlayerReplicationInfo.PlayerName) )\n\t\t\tSetPause(False);\n\t\treturn;\n\t}\n\tif( Weapon!=None )\n\t{\n\t\tWeapon.bPointing = true;\n\t\tPlayFiring();\n\t\tWeapon.AltFire(F);\n\t}\n}\n\n//Player Jumped\nfunction DoJump( optional float F )\n{\n\tif ( CarriedDecoration != None )\n\t\treturn;\n\tif ( !bIsCrouching && (Physics == PHYS_Walking) )\n\t{\n\t\tif ( !bUpdating )\n\t\t\tPlayOwnedSound(JumpSound, SLOT_Talk, 1.5, true, 1200, 1.0 );\n\t\tif ( (Level.Game != None) && (Level.Game.Difficulty > 0) )\n\t\t\tMakeNoise(0.1 * Level.Game.Difficulty);\n\t\tPlayInAir();\n\t\tif ( bCountJumps && (Role == ROLE_Authority) && (Inventory != None) )\n\t\t\tInventory.OwnerJumped();\n\t\tVelocity.Z = JumpZ;\n\t\tif ( (Base != Level) && (Base != None) )\n\t\t\tVelocity.Z += Base.Velocity.Z; \n\t\tSetPhysics(PHYS_Falling);\n\t}\n}\n\nexec function Suicide()\n{\n\tKilledBy( None );\n}\n\nexec function AlwaysMouseLook( Bool B )\n{\n\tChangeAlwaysMouseLook(B);\n\tSaveConfig();\n}\n\nfunction ChangeAlwaysMouseLook(Bool B)\n{\n\tbAlwaysMouseLook = B;\n\tif ( bAlwaysMouseLook )\n\t\tbLookUpStairs = false;\n}\n\t\nexec function SnapView( bool B )\n{\n\tChangeSnapView(B);\n\tSaveConfig();\n}\n\nfunction ChangeSnapView( bool B )\n{\n\tbSnapToLevel = B;\n}\n\t\nexec function StairLook( bool B )\n{\n\tChangeStairLook(B);\n\tSaveConfig();\n}\n\nfunction ChangeStairLook( bool B )\n{\n\tbLookUpStairs = B;\n\tif ( bLookUpStairs )\n\t\tbAlwaysMouseLook = false;\n}\n\nexec function SetDodgeClickTime( float F )\n{\n\tChangeDodgeClickTime(F);\n\tSaveConfig();\n}\n\nfunction ChangeDodgeClickTime( float F )\n{\n\tDodgeClickTime = FMin(0.3, F);\n}\n\nexec function SetName( coerce string S )\n{\n\tChangeName(S);\n\tUpdateURL(\"Name\", S, true);\n\tSaveConfig();\n}\n\nexec function Name( coerce string S )\n{\n\tSetName(S);\n}\n\nfunction ChangeName( coerce string S )\n{\n\tLevel.Game.ChangeName( self, S, false );\n}\n\nfunction ChangeTeam( int N )\n{\n\tlocal int OldTeam;\n\n\tOldTeam = PlayerReplicationInfo.Team;\n\tLevel.Game.ChangeTeam(self, N);\n\tif ( Level.Game.bTeamGame && (PlayerReplicationInfo.Team != OldTeam) )\n   {\n      //Gib the player if he changes teams.\n      Health = -1000;\n\t\tDied( None, 'Gibbed', Location );\n      PlayerReplicationInfo.Score = 0;\n      PlayerReplicationInfo.Deaths = 0;\n      PlayerReplicationInfo.Streak = 0;\n   }\n}\n\nfunction ClientChangeTeam( int N )\n{\n\tlocal Pawn P;\n\t\t\n\tif ( PlayerReplicationInfo != None )\n\t\tPlayerReplicationInfo.Team = N;\n\n\t// if listen server, this may be called for non-local players that are logging in\n\t// if so, don't update URL\n\tif ( (Level.NetMode == NM_ListenServer) && (Player == None) )\n\t{\n\t\t// check if any other players exist\n\t\tfor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t\t\tif ( P.IsA('PlayerPawn') && (ViewPort(PlayerPawn(P).Player) != None) )\n\t\t\t\treturn;\n\t}\n\t\t\n\tUpdateURL(\"Team\",string(N), true);\t\n}\n\nexec function SetAutoAim( float F )\n{\n\tChangeAutoAim(F);\n\tSaveConfig();\n}\n\nfunction ChangeAutoAim( float F )\n{\n\tMyAutoAim = FMax(Level.Game.AutoAim, F);\n}\n\nexec function PlayersOnly()\n{\n\t// DEUS_EX CNN - This needs to be here!\n\tif (!bCheatsEnabled)\n\t\treturn;\n\n\tif ( Level.Netmode != NM_Standalone )\n\t\treturn;\n\n\tLevel.bPlayersOnly = !Level.bPlayersOnly;\n}\n\nexec function SetHand( string S )\n{\n\tChangeSetHand(S);\n\tSaveConfig();\n}\n\nfunction ChangeSetHand( string S )\n{\n\tif ( S ~= \"Left\" )\n\t\tHandedness = 1;\n\telse if ( S~= \"Right\" )\n\t\tHandedness = -1;\n\telse if ( S ~= \"Center\" )\n\t\tHandedness = 0;\n\telse if ( S ~= \"Hidden\" )\n\t\tHandedness = 2;\n\tServerSetHandedness(Handedness);\n}\n\nexec function ViewPlayer( string S )\n{\n\tlocal pawn P;\n\n\tfor ( P=Level.pawnList; P!=None; P= P.NextPawn )\n\t\tif ( P.bIsPlayer && (P.PlayerReplicationInfo.PlayerName ~= S) )\n\t\t\tbreak;\n\n\tif ( (P != None) && Level.Game.CanSpectate(self, P) )\n\t{\n\t\tClientMessage(ViewingFrom@P.PlayerReplicationInfo.PlayerName, 'Event', true);\n\t\tif ( P == self)\n\t\t\tViewTarget = None;\n\t\telse\n\t\t\tViewTarget = P;\n\t}\n\telse\n\t\tClientMessage(FailedView);\n\n\tbBehindView = ( ViewTarget != None );\n\tif ( bBehindView )\n\t\tViewTarget.BecomeViewTarget();\n}\n\nexec function CheatView( class<actor> aClass )\n{\n\tlocal actor other, first;\n\tlocal bool bFound;\n\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif( !bAdmin && Level.NetMode!=NM_Standalone )\n\t\treturn;\n\n\tfirst = None;\n\tForEach AllActors( aClass, other )\n\t{\n\t\tif ( (first == None) && (other != self) )\n\t\t{\n\t\t\tfirst = other;\n\t\t\tbFound = true;\n\t\t}\n\t\tif ( other == ViewTarget ) \n\t\t\tfirst = None;\n\t}  \n\n\tif ( first != None )\n\t{\n\t\tif ( first.IsA('Pawn') && Pawn(first).bIsPlayer && (Pawn(first).PlayerReplicationInfo.PlayerName != \"\") )\n\t\t\tClientMessage(ViewingFrom@Pawn(first).PlayerReplicationInfo.PlayerName, 'Event', true);\n\t\telse\n\t\t\tClientMessage(ViewingFrom@first, 'Event', true);\n\t\tViewTarget = first;\n\t}\n\telse\n\t{\n\t\tif ( bFound )\n\t\t\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n\t\telse\n\t\t\tClientMessage(FailedView, 'Event', true);\n\t\tViewTarget = None;\n\t}\n\n\tbBehindView = ( ViewTarget != None );\n\tif ( bBehindView )\n\t\tViewTarget.BecomeViewTarget();\n}\n\nexec function ViewSelf()\n{\n\tbBehindView = false;\n\tViewtarget = None;\n\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n}\n\nexec function ViewClass( class<actor> aClass, optional bool bQuiet )\n{\n\tlocal actor other, first;\n\tlocal bool bFound;\n\n\tif ( (Level.Game != None) && !Level.Game.bCanViewOthers )\n\t\treturn;\n\n\tfirst = None;\n\tForEach AllActors( aClass, other )\n\t{\n\t\tif ( (first == None) && (other != self)\n\t\t\t && ( (bAdmin && Level.Game==None) || Level.Game.CanSpectate(self, other) ) )\n\t\t{\n\t\t\tfirst = other;\n\t\t\tbFound = true;\n\t\t}\n\t\tif ( other == ViewTarget ) \n\t\t\tfirst = None;\n\t}  \n\n\tif ( first != None )\n\t{\n\t\tif ( !bQuiet )\n\t\t{\n\t\t\tif ( first.IsA('Pawn') && Pawn(first).bIsPlayer && (Pawn(first).PlayerReplicationInfo.PlayerName != \"\") )\n\t\t\t\tClientMessage(ViewingFrom@Pawn(first).PlayerReplicationInfo.PlayerName, 'Event', true);\n\t\t\telse\n\t\t\t\tClientMessage(ViewingFrom@first, 'Event', true);\n\t\t}\n\t\tViewTarget = first;\n\t}\n\telse\n\t{\n\t\tif ( !bQuiet )\n\t\t{\n\t\t\tif ( bFound )\n\t\t\t\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n\t\t\telse\n\t\t\t\tClientMessage(FailedView, 'Event', true);\n\t\t}\n\t\tViewTarget = None;\n\t}\n\n\tbBehindView = ( ViewTarget != None );\n\tif ( bBehindView )\n\t\tViewTarget.BecomeViewTarget();\n}\n\nexec function NeverSwitchOnPickup( bool B )\n{\n\tbNeverAutoSwitch = B;\n\tbNeverSwitchOnPickup = B;\n\tServerNeverSwitchOnPickup(B);\n\tSaveConfig();\n}\n\t\nfunction ServerNeverSwitchOnPickup(bool B)\n{\n\tbNeverSwitchOnPickup = B;\n}\n\nexec function InvertMouse( bool B )\n{\n\tbInvertMouse = B;\n\tSaveConfig();\n}\n\nexec function SwitchLevel( string URL )\n{\n\tif( bAdmin || Level.NetMode==NM_Standalone || Level.netMode==NM_ListenServer )\n\t\tLevel.ServerTravel( URL, false );\n}\n\nexec function SwitchCoopLevel( string URL )\n{\n\tif( bAdmin || Level.NetMode==NM_Standalone || Level.netMode==NM_ListenServer )\n\t\tLevel.ServerTravel( URL, true );\n}\n\nexec function ShowMenu()\n{\n\tWalkBob = vect(0,0,0);\n\tbShowMenu = true; // menu is responsible for turning this off\n\tPlayer.Console.GotoState('Menuing');\n\t\t\n\tif( Level.Netmode == NM_Standalone )\n\t\tSetPause(true);\n}\n\nexec function ShowLoadMenu()\n{\n\tShowMenu();\n}\n\nexec function AddBots(int N)\n{\n\tServerAddBots(N);\n}\n\nfunction ServerAddBots(int N)\n{\n\tlocal int i;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\n\tif ( !Level.Game.bDeathMatch )\n\t\treturn;\n\n\tfor ( i=0; i<N; i++ )\n\t\tLevel.Game.ForceAddBot();\n}\n\n\t\n//*************************************************************************************\n// Special purpose/cheat execs\n\n// DEUS_EX CNN - moved from Console to allow cheats to affect it\nexec function Type()\n{\n\tif (!bCheatsEnabled)\n\t\treturn;\n\n\tPlayer.Console.TypedStr=\"\";\n\tPlayer.Console.GotoState( 'Typing' );\n}\n\nexec function ClearProgressMessages()\n{\n\tlocal int i;\n\n\tfor (i=0; i<8; i++)\n\t{\n\t\tProgressMessage[i] = \"\";\n\t\tProgressColor[i].R = 255;\n\t\tProgressColor[i].G = 255;\n\t\tProgressColor[i].B = 255;\n\t}\n}\n\nexec function SetProgressMessage( string S, int Index )\n{\n\tif (Index < 8)\n\t\tProgressMessage[Index] = S;\n}\n\nexec function SetProgressColor( color C, int Index )\n{\n\tif (Index < 8)\n\t\tProgressColor[Index] = C;\n}\n\nexec function SetProgressTime( float T )\n{\n\tProgressTimeOut = T + Level.TimeSeconds;\n}\n\nfunction ShowProgress()\n{\n}\n\nexec event ShowUpgradeMenu();\n\nexec function Amphibious()\n{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tUnderwaterTime = +999999.0;\n}\n\t\nexec function Fly()\n{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\t\t\n\tUnderWaterTime = Default.UnderWaterTime;\t\n\tClientMessage(\"You feel much lighter\");\n\tSetCollision(true, true , true);\n\tbCollideWorld = true;\n\tGotoState('CheatFlying');\n}\n\nexec function SetWeaponStay( bool B)\n{\n\tlocal Weapon W;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\n\tLevel.Game.bCoopWeaponMode = B;\n\tForEach AllActors(class'Weapon', W)\n\t{\n\t\tW.bWeaponStay = false;\n\t\tW.SetWeaponStay();\n\t}\n}\n\nexec function Walk()\n{\t\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\n\tStartWalk();\n}\n\nfunction StartWalk()\n{\n\tUnderWaterTime = Default.UnderWaterTime;\t\n\tSetCollision(true, true , true);\n\tSetPhysics(PHYS_Walking);\n\tbCollideWorld = true;\n\tClientReStart();\t\n}\n\nexec function Ghost()\n{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\t\n\tUnderWaterTime = -1.0;\t\n\tClientMessage(\"You feel ethereal\");\n\tSetCollision(false, false, false);\n\tbCollideWorld = false;\n\tGotoState('CheatFlying');\n}\n\nexec function ShowInventory()\n{\n\tlocal Inventory Inv;\n\t\n\tif( Weapon!=None )\n\t\tlog( \"   Weapon: \" $ Weapon.Class );\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory ) \n\t\tlog( \"Inv: \"$Inv $ \" state \"$Inv.GetStateName());\n\tif ( SelectedItem != None )\n\t\tlog( \"Selected Item\"@SelectedItem@\"Charge\"@SelectedItem.Charge );\n}\n\nexec function AllAmmo()\n{\n\tlocal Inventory Inv;\n\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\n\t// DEUS_EX CNN - make this be limited by the MaxAmmo per ammo instead of 999\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory ) \n\t\tif (Ammo(Inv)!=None) \n\t\t\tAmmo(Inv).AmmoAmount  = Ammo(Inv).MaxAmmo;\n}\t\n\nexec function Invisible(bool B)\n{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\n\tif (B)\n\t{\n\t\tbHidden = true;\n\t\tVisibility = 0;\n\t\t// DEUS_EX STM - added AI invisibility\n\t\tbDetectable = false;\n\t\t// DEUS_EX CNN - added message\n\t\tClientMessage(\"Player is now invisible\");\n\t}\n\telse\n\t{\n\t\tbHidden = false;\n\t\tVisibility = Default.Visibility;\n\t\t// DEUS_EX STM - added AI invisibility\n\t\tbDetectable = true;\n\t\t// DEUS_EX CNN - added message\n\t\tClientMessage(\"Player is now visible\");\n\t}\t\n}\n\t\nexec function God()\n{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\n\tif ( ReducedDamageType == 'All' )\n\t{\n\t\tReducedDamageType = '';\n\t\tClientMessage(\"God mode off\");\n\t\treturn;\n\t}\n\n\tReducedDamageType = 'All'; \n\tClientMessage(\"God Mode on\");\n}\n\nexec function BehindView( Bool B )\n{\n\t// DEUS_EX CNN - This needs to be here!\n\tif (!bCheatsEnabled)\n\t\treturn;\n\n\tbBehindView = B;\n}\n\nexec function SetBob(float F)\n{\n\tUpdateBob(F);\n\tSaveConfig();\n}\n\nfunction UpdateBob(float F)\n{\n\tBob = FClamp(F,0,0.032);\n}\n\nexec function SetSensitivity(float F)\n{\n\tUpdateSensitivity(F);\n\tSaveConfig();\n}\n\nfunction UpdateSensitivity(float F)\n{\n\tMouseSensitivity = FMax(0,F);\n}\n\nexec function SloMo( float T )\n{\n\t// DEUS_EX CNN - This needs to be here!\n\tif (!bCheatsEnabled)\n\t\treturn;\n\n\tServerSetSloMo(T);\n}\n\nfunction ServerSetSloMo(float T)\n{\n\tif ( bAdmin || (Level.Netmode == NM_Standalone) )\n\t{\n\t\tLevel.Game.SetGameSpeed(T);\n\t\tLevel.Game.SaveConfig(); \n\t\tLevel.Game.GameReplicationInfo.SaveConfig();\n\t}\n}\n\nexec function SetJumpZ( float F )\n{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tJumpZ = F;\n}\n\nexec function SetFriction( float F )\n{\n\tlocal ZoneInfo Z;\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tForEach AllActors(class'ZoneInfo', Z)\n\t\tZ.ZoneGroundFriction = F;\n}\n\nexec function SetSpeed( float F )\n{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tGroundSpeed = Default.GroundSpeed * f;\n\tWaterSpeed = Default.WaterSpeed * f;\n}\n\nexec function KillAll(class<actor> aClass)\n{\n\tlocal Actor A;\n\n\tif( !bCheatsEnabled )\n\t\treturn;\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tForEach AllActors(class 'Actor', A)\n\t\tif ( ClassIsChildOf(A.class, aClass) )\n\t\t\tA.Destroy();\n}\n\nexec function KillPawns()\n{\n\tlocal Pawn P;\n\t\n\tif( !bCheatsEnabled )\n\t\treturn;\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tForEach AllActors(class 'Pawn', P)\n\t\tif (PlayerPawn(P) == None)\n\t\t\tP.Destroy();\n}\n\nexec function Summon( string ClassName )\n{\n\tlocal class<actor> NewClass;\n\tif( !bCheatsEnabled )\n\t\treturn;\n\tif( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tlog( \"Fabricate \" $ ClassName );\n\tNewClass = class<actor>( DynamicLoadObject( ClassName, class'Class' ) );\n\tif( NewClass!=None )\n\t\t// DEUS_EX STM\n\t\t//Spawn( NewClass,,,Location + 72 * Vector(Rotation) + vect(0,0,1) * 15 );\n\t\tSpawn( NewClass,,,Location + (CollisionRadius+NewClass.Default.CollisionRadius+30) * Vector(Rotation) + vect(0,0,1) * 15 );\n}\n\n\n//==============\n// Navigation Aids\nexec function ShowPath()\n{\n\t//find next path to remembered spot\n\tlocal Actor node;\n\tnode = FindPathTo(Destination);\n\tif (node != None)\n\t{\n\t\tlog(\"found path\");\n\t\tSpawn(class 'WayBeacon', self, '', node.location);\n\t}\n\telse\n\t\tlog(\"didn't find path\");\n}\n\nexec function RememberSpot()\n{\n\t//remember spot\n\tDestination = Location;\n}\n\t\n//=============================================================================\n// Input related functions.\n\n// Postprocess the player's input.\n\nevent PlayerInput( float DeltaTime )\n{\n\tlocal float SmoothTime, FOVScale, MouseScale, AbsSmoothX, AbsSmoothY, MouseTime;\n\n\tif ( bShowMenu && (myHud != None) ) \n\t{\n\t\tif ( myHud.MainMenu != None )\n\t\t\tmyHud.MainMenu.MenuTick( DeltaTime );\n\t\t// clear inputs\n\t\tbEdgeForward = false;\n\t\tbEdgeBack = false;\n\t\tbEdgeLeft = false;\n\t\tbEdgeRight = false;\n\t\tbWasForward = false;\n\t\tbWasBack = false;\n\t\tbWasLeft = false;\n\t\tbWasRight = false;\n\t\taStrafe = 0;\n\t\taTurn = 0;\n\t\taForward = 0;\n\t\taLookUp = 0;\n\t\treturn;\n\t}\n\telse if ( bDelayedCommand )\n\t{\n\t\tbDelayedCommand = false;\n\t\tConsoleCommand(DelayedCommand);\n\t}\n\t\t\t\t\n\t// Check for Dodge move\n\t// flag transitions\n\tbEdgeForward = (bWasForward ^^ (aBaseY > 0));\n\tbEdgeBack = (bWasBack ^^ (aBaseY < 0));\n\tbEdgeLeft = (bWasLeft ^^ (aStrafe > 0));\n\tbEdgeRight = (bWasRight ^^ (aStrafe < 0));\n\tbWasForward = (aBaseY > 0);\n\tbWasBack = (aBaseY < 0);\n\tbWasLeft = (aStrafe > 0);\n\tbWasRight = (aStrafe < 0);\n\t\n\t// Smooth and amplify mouse movement\n\tSmoothTime = FMin(0.2, 3 * DeltaTime * Level.TimeDilation);\n\tFOVScale = DesiredFOV * 0.01111; \n\tMouseScale = MouseSensitivity * FOVScale;\n\n\taMouseX *= MouseScale;\n\taMouseY *= MouseScale;\n\n//************************************************************************\n\n\t//log(\"X \"$aMouseX$\" Smooth \"$SmoothMouseX$\" Borrowed \"$BorrowedMouseX$\" zero time \"$(Level.TimeSeconds - MouseZeroTime)$\" vs \"$MouseSmoothThreshold);\n\tAbsSmoothX = SmoothMouseX;\n\tAbsSmoothY = SmoothMouseY;\n\tMouseTime = (Level.TimeSeconds - MouseZeroTime)/Level.TimeDilation;\n\tif ( bMaxMouseSmoothing && (aMouseX == 0) && (MouseTime < MouseSmoothThreshold) )\n\t{\n\t\tSmoothMouseX = 0.5 * (MouseSmoothThreshold - MouseTime) * AbsSmoothX/MouseSmoothThreshold;\n\t\tBorrowedMouseX += SmoothMouseX;\n\t}\n\telse\n\t{\n\t\tif ( (SmoothMouseX == 0) || (aMouseX == 0) \n\t\t\t\t|| ((SmoothMouseX > 0) != (aMouseX > 0)) )\n\t\t{\n\t\t\tSmoothMouseX = aMouseX;\n\t\t\tBorrowedMouseX = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSmoothMouseX = 0.5 * (SmoothMouseX + aMouseX - BorrowedMouseX);\n\t\t\tif ( (SmoothMouseX > 0) != (aMouseX > 0) )\n\t\t\t{\n\t\t\t\tif ( AMouseX > 0 )\n\t\t\t\t\tSmoothMouseX = 1;\n\t\t\t\telse\n\t\t\t\t\tSmoothMouseX = -1;\n\t\t\t} \n\t\t\tBorrowedMouseX = SmoothMouseX - aMouseX;\n\t\t}\n\t\tAbsSmoothX = SmoothMouseX;\n\t}\n\tif ( bMaxMouseSmoothing && (aMouseY == 0) && (MouseTime < MouseSmoothThreshold) )\n\t{\n\t\tSmoothMouseY = 0.5 * (MouseSmoothThreshold - MouseTime) * AbsSmoothY/MouseSmoothThreshold;\n\t\tBorrowedMouseY += SmoothMouseY;\n\t}\n\telse\n\t{\n\t\tif ( (SmoothMouseY == 0) || (aMouseY == 0) \n\t\t\t\t|| ((SmoothMouseY > 0) != (aMouseY > 0)) )\n\t\t{\n\t\t\tSmoothMouseY = aMouseY;\n\t\t\tBorrowedMouseY = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSmoothMouseY = 0.5 * (SmoothMouseY + aMouseY - BorrowedMouseY);\n\t\t\tif ( (SmoothMouseY > 0) != (aMouseY > 0) )\n\t\t\t{\n\t\t\t\tif ( AMouseY > 0 )\n\t\t\t\t\tSmoothMouseY = 1;\n\t\t\t\telse\n\t\t\t\t\tSmoothMouseY = -1;\n\t\t\t} \n\t\t\tBorrowedMouseY = SmoothMouseY - aMouseY;\n\t\t}\n\t\tAbsSmoothY = SmoothMouseY;\n\t}\n\tif ( (aMouseX != 0) || (aMouseY != 0) )\n\t\tMouseZeroTime = Level.TimeSeconds;\n\n\t// adjust keyboard and joystick movements\n\taLookUp *= FOVScale;\n\taTurn   *= FOVScale;\n\n\t// Remap raw x-axis movement.\n\tif( bStrafe!=0 )\n\t{\n\t\t// Strafe.\n\t\taStrafe += aBaseX + SmoothMouseX;\n\t\taBaseX   = 0;\n\t}\n\telse\n\t{\n\t\t// Forward.\n\t\taTurn  += aBaseX * FOVScale + SmoothMouseX;\n\t\tif ( Level.NetMode != NM_Standalone )\n\t\t\taTurn *= TurnRateAdjuster;\n\t\taBaseX  = 0;\n\t}\n\n\t// Remap mouse y-axis movement.\n\tif( (bStrafe == 0) && (bAlwaysMouseLook || (bLook!=0)) )\n\t{\n\t\t// Look up/down.\n\t\tif ( bInvertMouse )\n\t\t\taLookUp -= SmoothMouseY;\n\t\telse\n\t\t\taLookUp += SmoothMouseY;\n\t\tif ( Level.NetMode != NM_Standalone )\n\t\t\taLookUp *= TurnRateAdjuster;\n\t}\n\telse\n\t{\n\t\t// Move forward/backward.\n\t\taForward += SmoothMouseY;\n\t}\n\tSmoothMouseX = AbsSmoothX;\n\tSmoothMouseY = AbsSmoothY;\n\n\tif ( bSnapLevel != 0 )\n\t{\n\t\tbCenterView = true;\n\t\tbKeyboardLook = false;\n\t}\n\telse if (aLookUp != 0)\n\t{\n\t\tbCenterView = false;\n\t\tbKeyboardLook = true;\n\t}\n\telse if ( bSnapToLevel && !bAlwaysMouseLook )\n\t{\n\t\tbCenterView = true;\n\t\tbKeyboardLook = false;\n\t}\n\n\t// Remap other y-axis movement.\n\tif ( bFreeLook != 0 )\n\t{\n\t\tbKeyboardLook = true;\n\t\taLookUp += 0.5 * aBaseY * FOVScale;\n\t}\n\telse\n\t\taForward += aBaseY;\n\n\taBaseY = 0;\n\n\t// Handle walking.\n\tHandleWalking();\n}\n\n//=============================================================================\n// functions.\n\nevent UpdateEyeHeight(float DeltaTime)\n{\n\tlocal float smooth, bound;\n\t\n\t// smooth up/down stairs\n\tIf( (Physics==PHYS_Walking) && !bJustLanded )\n\t{\n\t\tsmooth = FMin(1.0, 10.0 * DeltaTime/Level.TimeDilation);\n\t\tEyeHeight = (EyeHeight - Location.Z + OldLocation.Z) * (1 - smooth) + ( ShakeVert + BaseEyeHeight) * smooth;\n\t\t// DEUS_EX CNN - remove bound testing to improve smoothness of crouching and stairs\n//\t\tbound = -0.5 * CollisionHeight;\n//\t\tif (EyeHeight < bound)\n//\t\t\tEyeHeight = bound;\n//\t\telse\n//\t\t{\n//\t\t\tbound = CollisionHeight + FClamp((OldLocation.Z - Location.Z), 0.0, MaxStepHeight); \n//\t\t\tif ( EyeHeight > bound )\n//\t\t\t\tEyeHeight = bound;\n//\t\t}\n\t}\n\telse\n\t{\n\t\tsmooth = FClamp(10.0 * DeltaTime/Level.TimeDilation, 0.35,1.0);\n\t\tbJustLanded = false;\n\t\tEyeHeight = EyeHeight * ( 1 - smooth) + (BaseEyeHeight + ShakeVert) * smooth;\n\t}\n\n\t// teleporters affect your FOV, so adjust it back down\n\tif ( FOVAngle != DesiredFOV )\n\t{\n\t\tif ( FOVAngle > DesiredFOV )\n\t\t\tFOVAngle = FOVAngle - FMax(7, 0.9 * DeltaTime * (FOVAngle - DesiredFOV)); \n\t\telse \n\t\t\tFOVAngle = FOVAngle - FMin(-7, 0.9 * DeltaTime * (FOVAngle - DesiredFOV)); \n\t\tif ( Abs(FOVAngle - DesiredFOV) <= 10 )\n\t\t\tFOVAngle = DesiredFOV;\n\t}\n\n\t// adjust FOV for weapon zooming\n\tif ( bZooming )\n\t{\t\n\t\tZoomLevel += DeltaTime * 1.0;\n\t\tif (ZoomLevel > 0.9)\n\t\t\tZoomLevel = 0.9;\n\t\tDesiredFOV = FClamp(90.0 - (ZoomLevel * 88.0), 1, 170);\n\t} \n}\n\nevent PlayerTimeOut()\n{\n\tif (Health > 0)\n\t\tDied(None, 'Suicided', Location);\n}\n\n// Just changed to pendingWeapon\nfunction ChangedWeapon()\n{\n\tSuper.ChangedWeapon();\n\tif ( PendingWeapon != None )\n\t{\n\t\tPendingWeapon.SetHand(Handedness);\n\t\tif (( Level.NetMode != NM_Standalone ) && (Role == ROLE_Authority))\n\t\t\tPendingWeapon.ClientSetHandedness(Handedness);\n\t}\n}\n\nfunction JumpOffPawn()\n{\n\tVelocity += 60 * VRand();\n\tVelocity.Z = 120;\n\tSetPhysics(PHYS_Falling);\n}\n\nevent TravelPostAccept()\n{\n\tif ( Health <= 0 )\n\t\tHealth = Default.Health;\n}\n\n// This pawn was possessed by a player.\nevent Possess()\n{\n\tif ( Level.Netmode == NM_Client )\n\t{\n\t\t// replicate client weapon preferences to server\n\t\tServerNeverSwitchOnPickup(bNeverAutoSwitch);\n\t\tServerSetHandedness(Handedness);\n\t\tUpdateWeaponPriorities();\n\t}\n\tServerUpdateWeapons();\n\tbIsPlayer = true;\n\tDodgeClickTime = FMin(0.3, DodgeClickTime);\n\tEyeHeight = BaseEyeHeight;\n\tNetPriority = 3;\n\tStartWalk();\n}\n\nfunction UpdateWeaponPriorities()\n{\n\tlocal byte i;\n\n\t// send new priorities to server\n\tif ( Level.Netmode == NM_Client )\n\t\tfor ( i=0; i<ArrayCount(WeaponPriority); i++ )\n\t\t\tServerSetWeaponPriority(i, WeaponPriority[i]);\n}\n\nfunction ServerSetWeaponPriority(byte i, name WeaponName )\n{\n\tlocal inventory inv;\n\n\tWeaponPriority[i] = WeaponName;\n\n\tfor ( inv=Inventory; inv!=None; inv=inv.inventory )\n\t\tif ( inv.class.name == WeaponName )\n\t\t\tWeapon(inv).SetSwitchPriority(self);\n}\n\n// This pawn was unpossessed by a player.\nevent UnPossess()\n{\n\tlog(Self$\" being unpossessed\");\n\tif ( myHUD != None )\n\t\tmyHUD.Destroy();\n\tbIsPlayer = false;\n\tEyeHeight = 0.8 * CollisionHeight;\n}\n\nfunction Carcass SpawnCarcass()\n{\n\tlocal carcass carc;\n\n\tcarc = Spawn(CarcassType);\n\tif ( carc == None )\n\t\treturn None;\n\tcarc.Initfor(self);\n\tif (Player != None)\n\t\tcarc.bPlayerCarcass = true;\n\tif ( !Level.Game.bGameEnded && (Carcass(ViewTarget) == None) )\n\t\tViewTarget = carc; //for Player 3rd person views\n\treturn carc;\n}\n\nfunction bool Gibbed(name damageType)\n{\n\tif ( (damageType == 'decapitated') || (damageType == 'shot') )\n\t\treturn false; \t\n\tif ( (Health < -80) || ((Health < -40) && (FRand() < 0.6)) )\n\t\treturn true;\n\treturn false;\n}\n\nfunction SpawnGibbedCarcass()\n{\n\tlocal carcass carc;\n\n\tcarc = Spawn(CarcassType);\n\tif ( carc != None )\n\t{\n\t\tcarc.Initfor(self);\n\t\tcarc.ChunkUp(-1 * Health);\n\t}\n}\n\nevent PlayerTick( float Time );\n\n//\n// Called immediately before gameplay begins.\n//\nevent PreBeginPlay()\n{\n\tbIsPlayer = true;\n\tSuper.PreBeginPlay();\n}\n\nevent PostBeginPlay()\n{\n\tSuper.PostBeginPlay();\n\tif (Level.LevelEnterText != \"\" )\n\t\tClientMessage(Level.LevelEnterText);\n\tif ( Level.NetMode != NM_Client )\n\t{\n\t\tHUDType = Level.Game.HUDType;\n\t\tScoringType = Level.Game.ScoreboardType;\n\t\tMyAutoAim = FMax(MyAutoAim, Level.Game.AutoAim);\n\t}\n\tbIsPlayer = true;\n\tDodgeClickTime = FMin(0.3, DodgeClickTime);\n\tDesiredFOV = DefaultFOV;\n\tEyeHeight = BaseEyeHeight;\n\tif ( Level.Game.IsA('SinglePlayer') && (Level.NetMode == NM_Standalone) )\n\t\tFlashScale = vect(0,0,0);\n}\n\nfunction ServerUpdateWeapons()\n{\n\tlocal inventory Inv;\n\n\tFor ( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )\n\t\tif ( Inv.IsA('Weapon') )\n\t\t\tWeapon(Inv).SetSwitchPriority(self); \n}\n\n//=============================================================================\n// Animation playing - should be implemented in subclass, \n//\n\nfunction PlayDodge(eDodgeDir DodgeMove)\n{\n\tPlayDuck();\n}\n\nfunction PlayTurning();\n\nfunction PlaySwimming()\n{\n\tPlayRunning();\n}\n\nfunction PlayFeignDeath();\nfunction PlayRising();\n\n/* Adjust hit location - adjusts the hit location in for pawns, and returns\ntrue if it was really a hit, and false if not (for ducking, etc.)\n*/\nsimulated function bool AdjustHitLocation(out vector HitLocation, vector TraceDir)\n{\n\tlocal float adjZ, maxZ, scale;\n\tlocal Vector adjTraceDir;\n\n\tif ( Level.NetMode != NM_Standalone )\n\t{\n\t\tTraceDir = Normal(TraceDir);\n\t\tAdjTraceDir = TraceDir;\n\t\tAdjTraceDir.Z = 0.0;\n\t\tAdjTraceDir = Normal(AdjTraceDir);\n\t\tscale = TraceDir dot AdjTraceDir;\n\t\tHitLocation = HitLocation + ( CollisionRadius * 0.60 * TraceDir ) / scale;\n\t\tif ( BaseEyeHeight == Default.BaseEyeHeight )\n\t\t\treturn true;\n\n\t\tmaxZ = Location.Z + EyeHeight + 0.25 * CollisionHeight;\n\t\tif ( HitLocation.Z > maxZ )\n\t\t{\n\t\t\tif ( TraceDir.Z >= 0 )\n\t\t\t\treturn false;\n\t\t\tadjZ = (maxZ - HitLocation.Z)/TraceDir.Z;\n\t\t\tHitLocation.Z = maxZ;\n\t\t\tHitLocation.X = HitLocation.X + TraceDir.X * adjZ;\n\t\t\tHitLocation.Y = HitLocation.Y + TraceDir.Y * adjZ;\n\t\t\tif ( VSize(HitLocation - Location) > CollisionRadius )\t\n\t\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tTraceDir = Normal(TraceDir);\n\t\tHitLocation = HitLocation + 0.5 * CollisionRadius * TraceDir;\n\t\tif ( BaseEyeHeight == Default.BaseEyeHeight )\n\t\t\treturn true;\n\t\tmaxZ = Location.Z + EyeHeight + 0.25 * CollisionHeight;\n\t\tif ( HitLocation.Z > maxZ )\n\t\t{\n\t\t\tif ( TraceDir.Z >= 0 )\n\t\t\t\treturn false;\n\t\t\tadjZ = (maxZ - HitLocation.Z)/TraceDir.Z;\n\t\t\tHitLocation.Z = maxZ;\n\t\t\tHitLocation.X = HitLocation.X + TraceDir.X * adjZ;\n\t\t\tHitLocation.Y = HitLocation.Y + TraceDir.Y * adjZ;\n\t\t\tif ( VSize(HitLocation - Location) > CollisionRadius )\t\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/* AdjustAim()\nCalls this version for player aiming help.\nAimerror not used in this version.\nOnly adjusts aiming at pawns\n*/\n\nfunction rotator AdjustAim(float projSpeed, vector projStart, int aimerror, bool bLeadTarget, bool bWarnTarget)\n{\n\tlocal vector FireDir, AimSpot, HitNormal, HitLocation;\n\tlocal actor BestTarget;\n\tlocal float bestAim, bestDist;\n\tlocal actor HitActor;\n\t\n\tFireDir = vector(ViewRotation);\n\tHitActor = Trace(HitLocation, HitNormal, projStart + 4000 * FireDir, projStart, true);\n\tif ( (HitActor != None) && HitActor.bProjTarget )\n\t{\n\t\tif ( bWarnTarget && HitActor.IsA('Pawn') )\n\t\t\tPawn(HitActor).WarnTarget(self, projSpeed, FireDir);\n\t\treturn ViewRotation;\n\t}\n\n\tbestAim = FMin(0.93, MyAutoAim);\n\tBestTarget = PickTarget(bestAim, bestDist, FireDir, projStart);\n\n\tif ( bWarnTarget && (Pawn(BestTarget) != None) )\n\t\tPawn(BestTarget).WarnTarget(self, projSpeed, FireDir);\t\n\n\tif ( (Level.NetMode != NM_Standalone) || (Level.Game.Difficulty > 2) \n\t\t|| bAlwaysMouseLook || ((BestTarget != None) && (bestAim < MyAutoAim)) || (MyAutoAim >= 1) )\n\t\treturn ViewRotation;\n\t\n\tif ( BestTarget == None )\n\t{\n\t\tbestAim = MyAutoAim;\n\t\tBestTarget = PickAnyTarget(bestAim, bestDist, FireDir, projStart);\n\t\tif ( BestTarget == None )\n\t\t\treturn ViewRotation;\n\t}\n\n\tAimSpot = projStart + FireDir * bestDist;\n\tAimSpot.Z = BestTarget.Location.Z + 0.3 * BestTarget.CollisionHeight;\n\n\treturn rotator(AimSpot - projStart);\n}\n\nfunction Falling()\n\t{\n\t\t//SetPhysics(PHYS_Falling); //Note - physics changes type to PHYS_Falling by default\n\t\t//log(class$\" Falling\");\n\t\tPlayInAir();\n\t}\n\nfunction Landed(vector HitNormal)\n{\n\t//Note - physics changes type to PHYS_Walking by default for landed pawns\n\tif ( bUpdating )\n\t\treturn;\n\tPlayLanded(Velocity.Z);\n\tLandBob = FMin(50, 0.055 * Velocity.Z); \n\tTakeFallingDamage();\n\tbJustLanded = true;\n}\n\nfunction Died(pawn Killer, name damageType, vector HitLocation)\n{\n\tStopZoom();\n\n\tSuper.Died(Killer, damageType, HitLocation);\t\n}\n\nfunction eAttitude AttitudeTo(Pawn Other)\n{\n\tif (Other.bIsPlayer)\n\t\treturn AttitudeToPlayer;\n\telse \n\t\treturn Other.AttitudeToPlayer;\n}\n\n\nfunction string KillMessage( name damageType, pawn Other )\n{\n\treturn ( Level.Game.PlayerKillMessage(damageType, Other.PlayerReplicationInfo)$PlayerReplicationInfo.PlayerName );\n}\n\t\n//=============================================================================\n// Player Control\n\nfunction KilledBy( pawn EventInstigator )\n{\n\tHealth = 0;\n\tDied( EventInstigator, 'Suicided', Location );\n}\n\n// Player view.\n// Compute the rendering viewpoint for the player.\n//\n\nfunction CalcBehindView(out vector CameraLocation, out rotator CameraRotation, float Dist)\n{\n\tlocal vector View,HitLocation,HitNormal;\n\tlocal float ViewDist;\n\n\tCameraRotation = ViewRotation;\n\tView = vect(1,0,0) >> CameraRotation;\n\tif( Trace( HitLocation, HitNormal, CameraLocation - (Dist + 30) * vector(CameraRotation), CameraLocation ) != None )\n\t\tViewDist = FMin( (CameraLocation - HitLocation) Dot View, Dist );\n\telse\n\t\tViewDist = Dist;\n\tCameraLocation -= (ViewDist - 30) * View; \n}\n\nevent PlayerCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )\n{\n\tlocal Pawn PTarget;\n\n\tif ( ViewTarget != None )\n\t{\n\t\tViewActor = ViewTarget;\n\t\tCameraLocation = ViewTarget.Location;\n\t\tCameraRotation = ViewTarget.Rotation;\n\t\tPTarget = Pawn(ViewTarget);\n\t\tif ( PTarget != None )\n\t\t{\n\t\t\tif ( Level.NetMode == NM_Client )\n\t\t\t{\n\t\t\t\tif ( PTarget.bIsPlayer )\n\t\t\t\t\tPTarget.ViewRotation = TargetViewRotation;\n\t\t\t\tPTarget.EyeHeight = TargetEyeHeight;\n\t\t\t\tif ( PTarget.Weapon != None )\n\t\t\t\t\tPTarget.Weapon.PlayerViewOffset = TargetWeaponViewOffset;\n\t\t\t}\n\t\t\tif ( PTarget.bIsPlayer )\n\t\t\t\tCameraRotation = PTarget.ViewRotation;\n\t\t\tif ( !bBehindView )\n\t\t\t\tCameraLocation.Z += PTarget.EyeHeight;\n\t\t}\n\t\tif ( bBehindView )\n\t\t\tCalcBehindView(CameraLocation, CameraRotation, 180);\n\t\treturn;\n\t}\n\n\tViewActor = Self;\n\tCameraLocation = Location;\n\n\tif( bBehindView ) //up and behind\n\t\tCalcBehindView(CameraLocation, CameraRotation, 150);\n\telse\n\t{\n\t\t// First-person view.\n\t\tCameraRotation = ViewRotation;\n\t\tCameraLocation.Z += EyeHeight;\n\t\tCameraLocation += WalkBob;\n\t}\n}\n\nexec function SetViewFlash(bool B)\n{\n\tbNoFlash = !B;\n}\n\nfunction ViewFlash(float DeltaTime)\n{\n\tlocal vector goalFog;\n\tlocal float goalscale, delta;\n\n\tif ( bNoFlash )\n\t{\n\t\tInstantFlash = 0;\n\t\tInstantFog = vect(0,0,0);\n\t}\n\n\tdelta = FMin(0.1, DeltaTime);\n\tgoalScale = 1 + DesiredFlashScale + ConstantGlowScale + HeadRegion.Zone.ViewFlash.X; \n\tgoalFog = DesiredFlashFog + ConstantGlowFog + HeadRegion.Zone.ViewFog;\n\tDesiredFlashScale -= DesiredFlashScale * 2 * delta;  \n\tDesiredFlashFog -= DesiredFlashFog * 2 * delta;\n\tFlashScale.X += (goalScale - FlashScale.X + InstantFlash) * 10 * delta;\n\tFlashFog += (goalFog - FlashFog + InstantFog) * 10 * delta;\n\tInstantFlash = 0;\n\tInstantFog = vect(0,0,0);\n\n\tif ( FlashScale.X > 0.981 )\n\t\tFlashScale.X = 1;\n\tFlashScale = FlashScale.X * vect(1,1,1);\n\n\tif ( FlashFog.X < 0.019 )\n\t\tFlashFog.X = 0;\n\tif ( FlashFog.Y < 0.019 )\n\t\tFlashFog.Y = 0;\n\tif ( FlashFog.Z < 0.019 )\n\t\tFlashFog.Z = 0;\n}\n\nfunction ViewShake(float DeltaTime)\n{\n\tif (shaketimer > 0.0) //shake view\n\t{\n\t\tshaketimer -= DeltaTime;\n\t\tif ( verttimer == 0 )\n\t\t{\n\t\t\tverttimer = 0.1;\n\t\t\tShakeVert = -1.1 * maxshake;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tverttimer -= DeltaTime;\n\t\t\tif ( verttimer < 0 )\n\t\t\t{\n\t\t\t\tverttimer = 0.2 * FRand();\n\t\t\t\tshakeVert = (2 * FRand() - 1) * maxshake;  \n\t\t\t}\n\t\t}\n\t\tViewRotation.Roll = ViewRotation.Roll & 65535;\n\t\tif (bShakeDir)\n\t\t{\n\t\t\tViewRotation.Roll += Int( 10 * shakemag * FMin(0.1, DeltaTime));\n\t\t\tbShakeDir = (ViewRotation.Roll > 32768) || (ViewRotation.Roll < (0.5 + FRand()) * shakemag);\n\t\t\tif ( (ViewRotation.Roll < 32768) && (ViewRotation.Roll > 1.3 * shakemag) )\n\t\t\t{\n\t\t\t\tViewRotation.Roll = 1.3 * shakemag;\n\t\t\t\tbShakeDir = false;\n\t\t\t}\n\t\t\telse if (FRand() < 3 * DeltaTime)\n\t\t\t\tbShakeDir = !bShakeDir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tViewRotation.Roll -= Int( 10 * shakemag * FMin(0.1, DeltaTime));\n\t\t\tbShakeDir = (ViewRotation.Roll > 32768) && (ViewRotation.Roll < 65535 - (0.5 + FRand()) * shakemag);\n\t\t\tif ( (ViewRotation.Roll > 32768) && (ViewRotation.Roll < 65535 - 1.3 * shakemag) )\n\t\t\t{\n\t\t\t\tViewRotation.Roll = 65535 - 1.3 * shakemag;\n\t\t\t\tbShakeDir = true;\n\t\t\t}\n\t\t\telse if (FRand() < 3 * DeltaTime)\n\t\t\t\tbShakeDir = !bShakeDir;\n\t\t}\n\t}\n\telse\n\t{\n\t\tShakeVert = 0;\n\t\tViewRotation.Roll = ViewRotation.Roll & 65535;\n\t\tif (ViewRotation.Roll < 32768)\n\t\t{\n\t\t\tif ( ViewRotation.Roll > 0 )\n\t\t\t\tViewRotation.Roll = Max(0, ViewRotation.Roll - (Max(ViewRotation.Roll,500) * 10 * FMin(0.1,DeltaTime)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tViewRotation.Roll += ((65536 - Max(500,ViewRotation.Roll)) * 10 * FMin(0.1,DeltaTime));\n\t\t\tif ( ViewRotation.Roll > 65534 )\n\t\t\t\tViewRotation.Roll = 0;\n\t\t}\n\t} \n}\n\nfunction UpdateRotation(float DeltaTime, float maxPitch)\n{\n\tlocal rotator newRotation;\n\t\n\tDesiredRotation = ViewRotation; //save old rotation\n\tViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;\n\tViewRotation.Pitch = ViewRotation.Pitch & 65535;\n\tIf ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))\n\t{\n\t\tIf (aLookUp > 0) \n\t\t\tViewRotation.Pitch = 18000;\n\t\telse\n\t\t\tViewRotation.Pitch = 49152;\n\t}\n\tViewRotation.Yaw += 32.0 * DeltaTime * aTurn;\n\tViewShake(deltaTime);\n\tViewFlash(deltaTime);\n\t\t\n\tnewRotation = Rotation;\n\tnewRotation.Yaw = ViewRotation.Yaw;\n\tnewRotation.Pitch = ViewRotation.Pitch;\n\tIf ( (newRotation.Pitch > maxPitch * RotationRate.Pitch) && (newRotation.Pitch < 65536 - maxPitch * RotationRate.Pitch) )\n\t{\n\t\tIf (ViewRotation.Pitch < 32768) \n\t\t\tnewRotation.Pitch = maxPitch * RotationRate.Pitch;\n\t\telse\n\t\t\tnewRotation.Pitch = 65536 - maxPitch * RotationRate.Pitch;\n\t}\n    // added to keep the player's model from pitching or rolling - DEUS_EX CNN\n\tnewRotation.Pitch = 0;\n\tnewRotation.Roll = 0;\n\n\tsetRotation(newRotation);\n}\n\nfunction SwimAnimUpdate(bool bNotForward)\n{\n\tif ( !bAnimTransition && (GetAnimGroup(AnimSequence) != 'Gesture') )\n\t{\n\t\tif ( bNotForward )\n\t \t{\n\t\t \t if ( GetAnimGroup(AnimSequence) != 'Waiting' )\n\t\t\t\tTweenToWaiting(0.1);\n\t\t}\n\t\telse if ( GetAnimGroup(AnimSequence) == 'Waiting' )\n\t\t\tTweenToSwimming(0.1);\n\t}\n}\n\nauto state InvalidState\n{\n\tevent PlayerTick( float DeltaTime )\n\t{\n\t\tlog(self$\" invalid state\");\n\t\tif ( bUpdatePosition )\n\t\t\tClientUpdatePosition();\n\n\t\tPlayerMove(DeltaTime);\n\t}\n\n\tfunction PlayerMove( float DeltaTime )\n\t{\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, vect(0,0,0), Dodge_None, rot(0,0,0));\n\t}\n}\n\n// Player movement.\n// Player Standing, walking, running, falling.\nstate PlayerWalking\n{\nignores SeePlayer, HearNoise, Bump;\n\n\texec function FeignDeath()\n\t{\n\t\tif ( Physics == PHYS_Walking )\n\t\t{\n\t\t\tServerFeignDeath();\n\t\t\tAcceleration = vect(0,0,0);\n\t\t\tGotoState('FeigningDeath');\n\t\t}\n\t}\n\n\tfunction ZoneChange( ZoneInfo NewZone )\n\t{\n\t\tlocal actor HitActor;\n\t\tlocal vector HitLocation, HitNormal, checkpoint;\n\n\t\t// DEUS_EX CNN - make sure if we crouch in shallow water, we don't swim\n\t\t// Note that we must be standing on solid ground for this to work,\n\t\t// otherwise we should assume that we actually are swimming\n\t\tif (!HeadRegion.Zone.bWaterZone && bIsCrouching)\n\t\t{\n\t\t\tcheckpoint = Location;\n\t\t\tcheckpoint.Z -= (CollisionHeight + 6.0);\n\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, false);\n\t\t\tif (HitActor != None)\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (NewZone.bWaterZone)\n\t\t{\n\t\t\tsetPhysics(PHYS_Swimming);\n\t\t\tGotoState('PlayerSwimming');\n\t\t}\n\t}\n\n\tfunction AnimEnd()\n\t{\n\t\tlocal name MyAnimGroup;\n\n\t\tbAnimTransition = false;\n\t\tif (Physics == PHYS_Walking)\n\t\t{\n\t\t\tif (bIsCrouching)\n\t\t\t{\n\t\t\t\tif ( !bIsTurning && ((Velocity.X * Velocity.X + Velocity.Y * Velocity.Y) < 1000) )\n\t\t\t\t\tPlayDuck();\t\n\t\t\t\telse\n\t\t\t\t\tPlayCrawling();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMyAnimGroup = GetAnimGroup(AnimSequence);\n\t\t\t\tif ((Velocity.X * Velocity.X + Velocity.Y * Velocity.Y) < 1000)\n\t\t\t\t{\n\t\t\t\t\tif ( MyAnimGroup == 'Waiting' )\n\t\t\t\t\t\tPlayWaiting();\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbAnimTransition = true;\n\t\t\t\t\t\tTweenToWaiting(0.2);\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t\telse if (bIsWalking)\n\t\t\t\t{\n\t\t\t\t\tif ( (MyAnimGroup == 'Waiting') || (MyAnimGroup == 'Landing') || (MyAnimGroup == 'Gesture') || (MyAnimGroup == 'TakeHit')  )\n\t\t\t\t\t{\n\t\t\t\t\t\tTweenToWalking(0.1);\n\t\t\t\t\t\tbAnimTransition = true;\n\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t\tPlayWalking();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ( (MyAnimGroup == 'Waiting') || (MyAnimGroup == 'Landing') || (MyAnimGroup == 'Gesture') || (MyAnimGroup == 'TakeHit')  )\n\t\t\t\t\t{\n\t\t\t\t\t\tbAnimTransition = true;\n\t\t\t\t\t\tTweenToRunning(0.1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tPlayRunning();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tPlayInAir();\n\t}\n\n\tfunction Landed(vector HitNormal)\n\t{\n\t\tGlobal.Landed(HitNormal);\n\t\tif (DodgeDir == DODGE_Active)\n\t\t{\n\t\t\tDodgeDir = DODGE_Done;\n\t\t\tDodgeClickTimer = 0.0;\n\t\t\tVelocity *= 0.1;\n\t\t}\n\t\telse\n\t\t\tDodgeDir = DODGE_None;\n\t}\n\n\tfunction Dodge(eDodgeDir DodgeMove)\n\t{\n\t\tlocal vector X,Y,Z;\n\n\t\tif ( bIsCrouching || (Physics != PHYS_Walking) )\n\t\t\treturn;\n\n\t\tGetAxes(Rotation,X,Y,Z);\n\t\tif (DodgeMove == DODGE_Forward)\n\t\t\tVelocity = 1.5*GroundSpeed*X + (Velocity Dot Y)*Y;\n\t\telse if (DodgeMove == DODGE_Back)\n\t\t\tVelocity = -1.5*GroundSpeed*X + (Velocity Dot Y)*Y; \n\t\telse if (DodgeMove == DODGE_Left)\n\t\t\tVelocity = 1.5*GroundSpeed*Y + (Velocity Dot X)*X; \n\t\telse if (DodgeMove == DODGE_Right)\n\t\t\tVelocity = -1.5*GroundSpeed*Y + (Velocity Dot X)*X; \n\n\t\tVelocity.Z = 160;\n\t\tPlayOwnedSound(JumpSound, SLOT_Talk, 1.0, true, 800, 1.0 );\n\t\tPlayDodge(DodgeMove);\n\t\tDodgeDir = DODGE_Active;\n\t\tSetPhysics(PHYS_Falling);\n\t}\n\t\n\tfunction ProcessMove(float DeltaTime, vector NewAccel, eDodgeDir DodgeMove, rotator DeltaRot)\t\n\t{\n\t\tlocal vector OldAccel;\n\t\t      \n\t\tOldAccel = Acceleration;\n\t\tAcceleration = NewAccel;\n\t\tbIsTurning = ( Abs(DeltaRot.Yaw/DeltaTime) > 5000 );\n\t\tif ( (DodgeMove == DODGE_Active) && (Physics == PHYS_Falling) )\n\t\t\tDodgeDir = DODGE_Active;\t\n\t\telse if ( (DodgeMove != DODGE_None) && (DodgeMove < DODGE_Active) )\n\t\t\tDodge(DodgeMove);\n\n\t\tif ( bPressedJump )\n\t\t\tDoJump();\n\t\tif ( (Physics == PHYS_Walking) && (GetAnimGroup(AnimSequence) != 'Dodge') )\n\t\t{\n\t\t\tif (!bIsCrouching)\n\t\t\t{\n\t\t\t\tif (bDuck != 0)\n\t\t\t\t{\n\t\t\t\t\tbIsCrouching = true;\n\t\t\t\t\tPlayDuck();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (bDuck == 0)\n\t\t\t{\n\t\t\t\tOldAccel = vect(0,0,0);\n\t\t\t\tbIsCrouching = false;\n\t\t\t\tTweenToRunning(0.1);\n\t\t\t}\n\n\t\t\tif ( !bIsCrouching )\n\t\t\t{\n\t\t\t\tif ( (!bAnimTransition || (AnimFrame > 0)) && (GetAnimGroup(AnimSequence) != 'Landing') )\n\t\t\t\t{\n\t\t\t\t\tif ( Acceleration != vect(0,0,0) )\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( (GetAnimGroup(AnimSequence) == 'Waiting') || (GetAnimGroup(AnimSequence) == 'Gesture') || (GetAnimGroup(AnimSequence) == 'TakeHit') )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbAnimTransition = true;\n\t\t\t\t\t\t\tTweenToRunning(0.1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t \t\telse if ( (Velocity.X * Velocity.X + Velocity.Y * Velocity.Y < 1000) \n\t\t\t\t\t\t&& (GetAnimGroup(AnimSequence) != 'Gesture') ) \n\t\t\t \t\t{\n\t\t\t \t\t\tif ( GetAnimGroup(AnimSequence) == 'Waiting' )\n\t\t\t \t\t\t{\n\t\t\t\t\t\t\tif ( bIsTurning && (AnimFrame >= 0) ) \n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbAnimTransition = true;\n\t\t\t\t\t\t\t\tPlayTurning();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t \t\t\telse if ( !bIsTurning ) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbAnimTransition = true;\n\t\t\t\t\t\t\tTweenToWaiting(0.2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ( (OldAccel == vect(0,0,0)) && (Acceleration != vect(0,0,0)) )\n\t\t\t\t\tPlayCrawling();\n\t\t\t \telse if ( !bIsTurning && (Acceleration == vect(0,0,0)) && (AnimFrame > 0.1) )\n\t\t\t\t\tPlayDuck();\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\n\tevent PlayerTick( float DeltaTime )\n\t{\n\t\tif ( bUpdatePosition )\n\t\t\tClientUpdatePosition();\n\n\t\tPlayerMove(DeltaTime);\n\t}\n\n\tfunction PlayerMove( float DeltaTime )\n\t{\n\t\tlocal vector X,Y,Z, NewAccel;\n\t\tlocal EDodgeDir OldDodge;\n\t\tlocal eDodgeDir DodgeMove;\n\t\tlocal rotator OldRotation;\n\t\tlocal float Speed2D;\n\t\tlocal bool\tbSaveJump;\n\t\tlocal name AnimGroupName;\n\n\t\tGetAxes(Rotation,X,Y,Z);\n\n\t\taForward *= 0.4;\n\t\taStrafe  *= 0.4;\n\t\taLookup  *= 0.24;\n\t\taTurn    *= 0.24;\n\n\t\t// Update acceleration.\n\t\tNewAccel = aForward*X + aStrafe*Y; \n\t\tNewAccel.Z = 0;\n\t\t// Check for Dodge move\n\t\tif ( DodgeDir == DODGE_Active )\n\t\t\tDodgeMove = DODGE_Active;\n\t\telse\n\t\t\tDodgeMove = DODGE_None;\n\t\tif (DodgeClickTime > 0.0)\n\t\t{\n\t\t\tif ( DodgeDir < DODGE_Active )\n\t\t\t{\n\t\t\t\tOldDodge = DodgeDir;\n\t\t\t\tDodgeDir = DODGE_None;\n\t\t\t\tif (bEdgeForward && bWasForward)\n\t\t\t\t\tDodgeDir = DODGE_Forward;\n\t\t\t\tif (bEdgeBack && bWasBack)\n\t\t\t\t\tDodgeDir = DODGE_Back;\n\t\t\t\tif (bEdgeLeft && bWasLeft)\n\t\t\t\t\tDodgeDir = DODGE_Left;\n\t\t\t\tif (bEdgeRight && bWasRight)\n\t\t\t\t\tDodgeDir = DODGE_Right;\n\t\t\t\tif ( DodgeDir == DODGE_None)\n\t\t\t\t\tDodgeDir = OldDodge;\n\t\t\t\telse if ( DodgeDir != OldDodge )\n\t\t\t\t\tDodgeClickTimer = DodgeClickTime + 0.5 * DeltaTime;\n\t\t\t\telse \n\t\t\t\t\tDodgeMove = DodgeDir;\n\t\t\t}\n\t\n\t\t\tif (DodgeDir == DODGE_Done)\n\t\t\t{\n\t\t\t\tDodgeClickTimer -= DeltaTime;\n\t\t\t\tif (DodgeClickTimer < -0.35) \n\t\t\t\t{\n\t\t\t\t\tDodgeDir = DODGE_None;\n\t\t\t\t\tDodgeClickTimer = DodgeClickTime;\n\t\t\t\t}\n\t\t\t}\t\t\n\t\t\telse if ((DodgeDir != DODGE_None) && (DodgeDir != DODGE_Active))\n\t\t\t{\n\t\t\t\tDodgeClickTimer -= DeltaTime;\t\t\t\n\t\t\t\tif (DodgeClickTimer < 0)\n\t\t\t\t{\n\t\t\t\t\tDodgeDir = DODGE_None;\n\t\t\t\t\tDodgeClickTimer = DodgeClickTime;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tAnimGroupName = GetAnimGroup(AnimSequence);\t\t\n\t\tif ( (Physics == PHYS_Walking) && (AnimGroupName != 'Dodge') )\n\t\t{\n\t\t\t//if walking, look up/down stairs - unless player is rotating view\n\t\t\tif ( !bKeyboardLook && (bLook == 0) )\n\t\t\t{\n\t\t\t\tif ( bLookUpStairs )\n\t\t\t\t\tViewRotation.Pitch = FindStairRotation(deltaTime);\n\t\t\t\telse if ( bCenterView )\n\t\t\t\t{\n\t\t\t\t\tViewRotation.Pitch = ViewRotation.Pitch & 65535;\n\t\t\t\t\tif (ViewRotation.Pitch > 32768)\n\t\t\t\t\t\tViewRotation.Pitch -= 65536;\n\t\t\t\t\tViewRotation.Pitch = ViewRotation.Pitch * (1 - 12 * FMin(0.0833, deltaTime));\n\t\t\t\t\tif ( Abs(ViewRotation.Pitch) < 1000 )\n\t\t\t\t\t\tViewRotation.Pitch = 0;\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSpeed2D = Sqrt(Velocity.X * Velocity.X + Velocity.Y * Velocity.Y);\n\t\t\t//add bobbing when walking\n\t\t\tif ( !bShowMenu )\n\t\t\t\tCheckBob(DeltaTime, Speed2D, Y);\n\n\t\t}\t\n\t\telse if ( !bShowMenu )\n\t\t{ \n\t\t\tBobTime = 0;\n\t\t\tWalkBob = WalkBob * (1 - FMin(1, 8 * deltatime));\n\t\t}\n\n\t\t// Update rotation.\n\t\tOldRotation = Rotation;\n\t\tUpdateRotation(DeltaTime, 1);\n\n\t\tif ( bPressedJump && (AnimGroupName == 'Dodge') )\n\t\t{\n\t\t\tbSaveJump = true;\n\t\t\tbPressedJump = false;\n\t\t}\n\t\telse\n\t\t\tbSaveJump = false;\n\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, NewAccel, DodgeMove, OldRotation - Rotation);\n\t\telse\n\t\t\tProcessMove(DeltaTime, NewAccel, DodgeMove, OldRotation - Rotation);\n\t\tbPressedJump = bSaveJump;\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tif ( Mesh == None )\n\t\t\tMesh = Default.Mesh;\n\t\tWalkBob = vect(0,0,0);\n\t\tDodgeDir = DODGE_None;\n\t\tbIsCrouching = false;\n\t\tbIsTurning = false;\n\t\tbPressedJump = false;\n\n//\t\tif (Physics != PHYS_Falling) SetPhysics(PHYS_Walking);\n\t\t// why doesn't this just work dammit? - DEUS_EX CNN\n\t\t// force us to fall when level begins\n\t\tSetPhysics(PHYS_Falling);\n\n\t\tif ( !IsAnimating() )\n\t\t\tPlayWaiting();\n\t}\n\t\n\tfunction EndState()\n\t{\n\t\tWalkBob = vect(0,0,0);\n\t\tbIsCrouching = false;\n\t}\n}\n\nstate FeigningDeath\n{\nignores SeePlayer, HearNoise, Bump;\n\n\tfunction ZoneChange( ZoneInfo NewZone )\n\t{\n\t\tif (NewZone.bWaterZone)\n\t\t{\n\t\t\tsetPhysics(PHYS_Swimming);\n\t\t\tGotoState('PlayerSwimming');\n\t\t}\n\t}\n\n\texec function Fire( optional float F )\n\t{\n\t\tbJustFired = true;\n\t}\n\n\texec function AltFire( optional float F )\n\t{\n\t\tbJustFired = true;\n\t}\n\n\tfunction PlayChatting()\n\t{\n\t}\n\n\texec function Taunt( name Sequence )\n\t{\n\t}\n\n\tfunction AnimEnd()\n\t{\n\t\tif ( (Role == ROLE_Authority) && (Health > 0) )\n\t\t{\n\t\t\tGotoState('PlayerWalking');\n\t\t\tPendingWeapon.SetDefaultDisplayProperties();\n\t\t\tChangedWeapon();\n\t\t}\n\t}\n\t\n\tfunction Landed(vector HitNormal)\n\t{\n\t\tif ( Role == ROLE_Authority )\n\t\t\tPlaySound(Land, SLOT_Interact, 0.3, false, 800, 1.0);\n\t\tif ( bUpdating )\n\t\t\treturn;\n\t\tTakeFallingDamage();\n\t\tbJustLanded = true;\t\t\t\t\n\t}\n\n\tfunction Rise()\n\t{\n\t\tif ( !bRising )\n\t\t{\n\t\t\tEnable('AnimEnd');\n\t\t\tBaseEyeHeight = Default.BaseEyeHeight;\n\t\t\tbRising = true;\n\t\t\tPlayRising();\n\t\t}\n\t}\n\n\tfunction ProcessMove(float DeltaTime, vector NewAccel, eDodgeDir DodgeMove, rotator DeltaRot)\t\n\t{\n\t\tif ( bJustFired || bPressedJump || (NewAccel.Z > 0) )\n\t\t\tRise();\n\t\tAcceleration = vect(0,0,0);\n\t}\n\n\tevent PlayerTick( float DeltaTime )\n\t{\n\t\tWeapon = None; // in case client confused because of weapon switch just before feign death\n\t\tif ( bUpdatePosition )\n\t\t\tClientUpdatePosition();\n\t\t\n\t\tPlayerMove(DeltaTime);\n\t}\n\n\tfunction ServerMove\n\t(\n\t\tfloat TimeStamp, \n\t\tvector Accel, \n\t\tvector ClientLoc,\n\t\tbool NewbRun,\n\t\tbool NewbDuck,\n\t\tbool NewbJumpStatus, \n\t\tbool bFired,\n\t\tbool bAltFired,\n\t\tbool bForceFire,\n\t\tbool bForceAltFire,\n\t\teDodgeDir DodgeMove, \n\t\tbyte ClientRoll, \n\t\tint View,\n\t\toptional byte OldTimeDelta,\n\t\toptional int OldAccel\n\t)\n\t{\n\t\tGlobal.ServerMove(TimeStamp, Accel, ClientLoc, NewbRun, NewbDuck, NewbJumpStatus,\n\t\t\t\t\t\t\tbFired, bAltFired, bForceFire, bForceAltFire, DodgeMove, ClientRoll, (32767 & (Rotation.Pitch/2)) * 32768 + (32767 & (Rotation.Yaw/2)));\n\t}\n\n\tfunction PlayerMove( float DeltaTime)\n\t{\n\t\tlocal rotator currentRot;\n\t\tlocal vector NewAccel;\n\n\t\taLookup  *= 0.24;\n\t\taTurn    *= 0.24;\n\n\t\t// Update acceleration.\n\t\tif ( !IsAnimating() && (aForward != 0) || (aStrafe != 0) )\n\t\t\tNewAccel = vect(0,0,1);\n\t\telse\n\t\t\tNewAccel = vect(0,0,0);\n\n\t\t// Update view rotation.\n\t\tcurrentRot = Rotation;\n\t\tUpdateRotation(DeltaTime, 1);\n\t\tSetRotation(currentRot);\n\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, NewAccel, DODGE_None, Rot(0,0,0));\n\t\telse\n\t\t\tProcessMove(DeltaTime, NewAccel, DODGE_None, Rot(0,0,0));\n\t\tbPressedJump = false;\n\t}\n\n\tfunction PlayTakeHit(float tweentime, vector HitLoc, int Damage)\n\t{\n\t\tif ( IsAnimating() )\n\t\t{\n\t\t\tEnable('AnimEnd');\n\t\t\tGlobal.PlayTakeHit(tweentime, HitLoc, Damage);\n\t\t}\n\t}\n\t\n\tfunction PlayDying(name DamageType, vector HitLocation)\n\t{\n\t\tBaseEyeHeight = Default.BaseEyeHeight;\n\t}\n\t\n\tfunction ChangedWeapon()\n\t{\n\t\tWeapon = None;\n\t\tInventory.ChangedWeapon();\n\t}\n\n\tfunction EndState()\n\t{\n\t\tbJustFired = false;\n\t\tPlayerReplicationInfo.bFeigningDeath = false;\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tlocal rotator NewRot;\n\t\tif ( carriedDecoration != None )\n\t\t\tDropDecoration();\n\t\tNewRot = Rotation;\n\t\tNewRot.Pitch = 0;\n\t\tSetRotation(NewRot);\n\t\tBaseEyeHeight = -0.5 * CollisionHeight;\n\t\tbIsCrouching = false;\n\t\tbPressedJump = false;\n\t\tbJustFired = false;\n\t\tbRising = false;\n\t\tDisable('AnimEnd');\n\t\tPlayFeignDeath();\n\t\tPlayerReplicationInfo.bFeigningDeath = true;\n\t}\n}\n\n// Player movement.\n// Player Swimming\nstate PlayerSwimming\n{\nignores SeePlayer, HearNoise, Bump;\n\n\tevent UpdateEyeHeight(float DeltaTime)\n\t{\n\t\tlocal float smooth, bound;\n\t\t\n\t\t// smooth up/down stairs\n\t\tif( !bJustLanded )\n\t\t{\n\t\t\tsmooth = FMin(1.0, 10.0 * DeltaTime/Level.TimeDilation);\n\t\t\tEyeHeight = (EyeHeight - Location.Z + OldLocation.Z) * (1 - smooth) + ( ShakeVert + BaseEyeHeight) * smooth;\n\t\t\tbound = -0.5 * CollisionHeight;\n\t\t\tif (EyeHeight < bound)\n\t\t\t\tEyeHeight = bound;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbound = CollisionHeight + FClamp((OldLocation.Z - Location.Z), 0.0, MaxStepHeight); \n\t\t\t\t if ( EyeHeight > bound )\n\t\t\t\t\tEyeHeight = bound;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsmooth = FClamp(10.0 * DeltaTime/Level.TimeDilation, 0.35, 1.0);\n\t\t\tbJustLanded = false;\n\t\t\tEyeHeight = EyeHeight * ( 1 - smooth) + (BaseEyeHeight + ShakeVert) * smooth;\n\t\t}\n\n\t\t// teleporters affect your FOV, so adjust it back down\n\t\tif ( FOVAngle != DesiredFOV )\n\t\t{\n\t\t\tif ( FOVAngle > DesiredFOV )\n\t\t\t\tFOVAngle = FOVAngle - FMax(7, 0.9 * DeltaTime * (FOVAngle - DesiredFOV)); \n\t\t\telse \n\t\t\t\tFOVAngle = FOVAngle - FMin(-7, 0.9 * DeltaTime * (FOVAngle - DesiredFOV)); \n\t\t\tif ( Abs(FOVAngle - DesiredFOV) <= 10 )\n\t\t\t\tFOVAngle = DesiredFOV;\n\t\t}\n\n\t\t// adjust FOV for weapon zooming\n\t\tif ( bZooming )\n\t\t{\t\n\t\t\tZoomLevel += DeltaTime * 1.0;\n\t\t\tif (ZoomLevel > 0.9)\n\t\t\t\tZoomLevel = 0.9;\n\t\t\tDesiredFOV = FClamp(90.0 - (ZoomLevel * 88.0), 1, 170);\n\t\t} \n\t}\n\n\tfunction Landed(vector HitNormal)\n\t{\n\t\tif ( !bUpdating )\n\t\t{\n\t\t\t//log(class$\" Landed while swimming\");\n\t\t\tPlayLanded(Velocity.Z);\n\t\t\tTakeFallingDamage();\n\t\t\tbJustLanded = true;\n\t\t}\n\t\tif ( Region.Zone.bWaterZone )\n\t\t\tSetPhysics(PHYS_Swimming);\n\t\telse\n\t\t{\n\t\t\tGotoState('PlayerWalking');\n\t\t\tAnimEnd();\n\t\t}\n\t}\n\n\tfunction AnimEnd()\n\t{\n\t\tlocal vector X,Y,Z;\n\t\tGetAxes(Rotation, X,Y,Z);\n\t\tif ( (Acceleration Dot X) <= 0 )\n\t\t{\n\t\t\tif ( GetAnimGroup(AnimSequence) == 'TakeHit' )\n\t\t\t{\n\t\t\t\tbAnimTransition = true;\n\t\t\t\tTweenToWaiting(0.2);\n\t\t\t} \n\t\t\telse\n\t\t\t\tPlayWaiting();\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\tif ( GetAnimGroup(AnimSequence) == 'TakeHit' )\n\t\t\t{\n\t\t\t\tbAnimTransition = true;\n\t\t\t\tTweenToSwimming(0.2);\n\t\t\t} \n\t\t\telse\n\t\t\t\tPlaySwimming();\n\t\t}\n\t}\n\t\n\tfunction ZoneChange( ZoneInfo NewZone )\n\t{\n\t\tlocal actor HitActor;\n\t\tlocal vector HitLocation, HitNormal, checkpoint;\n\n\t\tif (!NewZone.bWaterZone)\n\t\t{\n\t\t\tSetPhysics(PHYS_Falling);\n\t\t\tif (bUpAndOut && CheckWaterJump(HitNormal)) //check for waterjump\n\t\t\t{\n\t\t\t\tvelocity.Z = 330 + 2 * CollisionRadius; //set here so physics uses this for remainder of tick\n\t\t\t\tPlayDuck();\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t}\t\t\t\t\n\t\t\telse if (!FootRegion.Zone.bWaterZone || (Velocity.Z > 160) )\n\t\t\t{\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t\tAnimEnd();\n\t\t\t}\n\t\t\telse //check if in deep water\n\t\t\t{\n\t\t\t\tcheckpoint = Location;\n\t\t\t\tcheckpoint.Z -= (CollisionHeight + 6.0);\n\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, false);\n\t\t\t\tif (HitActor != None)\n\t\t\t\t{\n\t\t\t\t\tGotoState('PlayerWalking');\n\t\t\t\t\tAnimEnd();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tEnable('Timer');\n\t\t\t\t\tSetTimer(0.7,false);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//log(\"Out of water\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDisable('Timer');\n\t\t\tSetPhysics(PHYS_Swimming);\n\t\t}\n\t}\n\n\tfunction ProcessMove(float DeltaTime, vector NewAccel, eDodgeDir DodgeMove, rotator DeltaRot)\t\n\t{\n\t\tlocal vector X,Y,Z, Temp;\n\t\n\t\tGetAxes(ViewRotation,X,Y,Z);\n\t\tAcceleration = NewAccel;\n\n\t\tSwimAnimUpdate( (X Dot Acceleration) <= 0 );\n\n\t\t// DEUS_EX CNN - changed water jump to require positive Z accel. AND at least a 22.5 degree pitch\n//\t\tbUpAndOut = ((X Dot Acceleration) > 0) && ((Acceleration.Z > 0) || (ViewRotation.Pitch > 2048));\n\t\tbUpAndOut = ((X Dot Acceleration) > 0) && (Acceleration.Z > 0) && (ViewRotation.Pitch > 4096);\n\t\tif ( bUpAndOut && !Region.Zone.bWaterZone && CheckWaterJump(Temp) ) //check for waterjump\n\t\t{\n\t\t\tvelocity.Z = 330 + 2 * CollisionRadius; //set here so physics uses this for remainder of tick\n\t\t\tPlayDuck();\n\t\t\tGotoState('PlayerWalking');\n\t\t}\t\t\t\t\n\t}\n\n\tevent PlayerTick( float DeltaTime )\n\t{\n\t\tif ( bUpdatePosition )\n\t\t\tClientUpdatePosition();\n\t\t\n\t\tPlayerMove(DeltaTime);\n\t}\n\n\tfunction PlayerMove(float DeltaTime)\n\t{\n\t\tlocal rotator oldRotation;\n\t\tlocal vector X,Y,Z, NewAccel;\n\t\tlocal float Speed2D;\n\t\n\t\tGetAxes(ViewRotation,X,Y,Z);\n\n\t\taForward *= 0.2;\n\t\taStrafe  *= 0.1;\n\t\taLookup  *= 0.24;\n\t\taTurn    *= 0.24;\n\t\taUp\t\t *= 0.1;  \n\t\t\n\t\tNewAccel = aForward*X + aStrafe*Y + aUp*vect(0,0,1); \n\t\n\t\t//add bobbing when swimming\n\t\tif ( !bShowMenu )\n\t\t{\n\t\t\tSpeed2D = Sqrt(Velocity.X * Velocity.X + Velocity.Y * Velocity.Y);\n\t\t\tWalkBob = Y * Bob *  0.5 * Speed2D * sin(4.0 * Level.TimeSeconds);\n\t\t\tWalkBob.Z = Bob * 1.5 * Speed2D * sin(8.0 * Level.TimeSeconds);\n\t\t}\n\n\t\t// Update rotation.\n\t\toldRotation = Rotation;\n\t\tUpdateRotation(DeltaTime, 2);\n\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, NewAccel, DODGE_None, OldRotation - Rotation);\n\t\telse\n\t\t\tProcessMove(DeltaTime, NewAccel, DODGE_None, OldRotation - Rotation);\n\t\tbPressedJump = false;\n\t}\n\n\tfunction Timer()\n\t{\n\t\tif ( !Region.Zone.bWaterZone && (Role == ROLE_Authority) )\n\t\t{\n\t\t\t//log(\"timer out of water\");\n\t\t\tGotoState('PlayerWalking');\n\t\t\tAnimEnd();\n\t\t}\n\t\n\t\tDisable('Timer');\n\t}\n\t\n\tfunction BeginState()\n\t{\n\t\tDisable('Timer');\n\t\tif ( !IsAnimating() )\n\t\t\tTweenToWaiting(0.3);\n\t\t//log(\"player swimming\");\n\t}\n}\n\nstate PlayerFlying\n{\nignores SeePlayer, HearNoise, Bump;\n\t\t\n\tfunction AnimEnd()\n\t{\n\t\tPlaySwimming();\n\t}\n\t\n\tevent PlayerTick( float DeltaTime )\n\t{\n\t\tif ( bUpdatePosition )\n\t\t\tClientUpdatePosition();\n\t\n\t\tPlayerMove(DeltaTime);\n\t}\n\n\tfunction PlayerMove(float DeltaTime)\n\t{\n\t\tlocal rotator newRotation;\n\t\tlocal vector X,Y,Z;\n\n\t\tGetAxes(Rotation,X,Y,Z);\n\n\t\taForward *= 0.2;\n\t\taStrafe  *= 0.2;\n\t\taLookup  *= 0.24;\n\t\taTurn    *= 0.24;\n\n\t\tAcceleration = aForward*X + aStrafe*Y;  \n\t\t// Update rotation.\n\t\tUpdateRotation(DeltaTime, 2);\n\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, Acceleration, DODGE_None, rot(0,0,0));\n\t\telse\n\t\t\tProcessMove(DeltaTime, Acceleration, DODGE_None, rot(0,0,0));\n\t}\n\t\n\tfunction BeginState()\n\t{\n\t\tSetPhysics(PHYS_Flying);\n\t\tif  ( !IsAnimating() ) PlayWalking();\n\t\t//log(\"player flying\");\n\t}\n}\n\nstate CheatFlying\n{\nignores SeePlayer, HearNoise, Bump, TakeDamage;\n\t\t\n\tfunction AnimEnd()\n\t{\n\t\tPlaySwimming();\n\t}\n\t\n\tfunction ProcessMove(float DeltaTime, vector NewAccel, eDodgeDir DodgeMove, rotator DeltaRot)\t\n\t{\n\t\tAcceleration = Normal(NewAccel);\n\t\tVelocity = Normal(NewAccel) * 300;\n\t\tAutonomousPhysics(DeltaTime);\n\t}\n\n\tevent PlayerTick( float DeltaTime )\n\t{\n\t\tif ( bUpdatePosition )\n\t\t\tClientUpdatePosition();\n\n\t\tPlayerMove(DeltaTime);\n\t}\n\n\tfunction PlayerMove(float DeltaTime)\n\t{\n\t\tlocal rotator newRotation;\n\t\tlocal vector X,Y,Z;\n\n\t\tGetAxes(ViewRotation,X,Y,Z);\n\n\t\taForward *= 0.1;\n\t\taStrafe  *= 0.1;\n\t\taLookup  *= 0.24;\n\t\taTurn    *= 0.24;\n\t\taUp\t\t *= 0.1;\n\t\n\t\tAcceleration = aForward*X + aStrafe*Y + aUp*vect(0,0,1);  \n\n\t\tUpdateRotation(DeltaTime, 1);\n\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, Acceleration, DODGE_None, rot(0,0,0));\n\t\telse\n\t\t\tProcessMove(DeltaTime, Acceleration, DODGE_None, rot(0,0,0));\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tEyeHeight = BaseEyeHeight;\n\t\tSetPhysics(PHYS_Flying);\n\t\tif  ( !IsAnimating() ) PlaySwimming();\n\t\t// log(\"cheat flying\");\n\t}\n}\n\nstate PlayerWaiting\n{\nignores SeePlayer, HearNoise, Bump, TakeDamage, Died, ZoneChange, FootZoneChange;\n\n\texec function Jump( optional float F )\n\t{\n\t}\n\n\texec function Suicide()\n\t{\n\t}\n\n\tfunction ChangeTeam( int N )\n\t{\n\t\tLevel.Game.ChangeTeam(self, N);\n\t}\n\n\texec function Fire(optional float F)\n\t{\n\t\tbReadyToPlay = true;\n\t}\n\t\n\texec function AltFire(optional float F)\n\t{\n\t\tbReadyToPlay = true;\n\t}\n\t\t\n\tfunction ProcessMove(float DeltaTime, vector NewAccel, eDodgeDir DodgeMove, rotator DeltaRot)\t\n\t{\n\t\tAcceleration = NewAccel;\n\t\tMoveSmooth(Acceleration * DeltaTime);\n\t}\n\n\tfunction PlayWaiting() {}\n\n\tevent PlayerTick( float DeltaTime )\n\t{\n\t\tif ( bUpdatePosition )\n\t\t\tClientUpdatePosition();\n\n\t\tPlayerMove(DeltaTime);\n\t}\n\n\tfunction PlayerMove(float DeltaTime)\n\t{\n\t\tlocal rotator newRotation;\n\t\tlocal vector X,Y,Z;\n\n\t\tGetAxes(ViewRotation,X,Y,Z);\n\n\t\taForward *= 0.1;\n\t\taStrafe  *= 0.1;\n\t\taLookup  *= 0.24;\n\t\taTurn    *= 0.24;\n\t\taUp\t\t *= 0.1;\n\t\n\t\tAcceleration = aForward*X + aStrafe*Y + aUp*vect(0,0,1);  \n\n\t\tUpdateRotation(DeltaTime, 1);\n\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, Acceleration, DODGE_None, rot(0,0,0));\n\t\telse\n\t\t\tProcessMove(DeltaTime, Acceleration, DODGE_None, rot(0,0,0));\n\t}\n\n\tfunction EndState()\n\t{\n\t\tMesh = Default.Mesh;\n\t\tPlayerReplicationInfo.bIsSpectator = false;\n\t\tPlayerReplicationInfo.bWaitingPlayer = false;\n\t\tSetCollision(true,true,true);\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tMesh = None;\n\t\tif ( PlayerReplicationInfo != None )\n\t\t{\n\t\t\tPlayerReplicationInfo.bIsSpectator = true;\n\t\t\tPlayerReplicationInfo.bWaitingPlayer = true;\n\t\t}\n\t\tSetCollision(false,false,false);\n\t\tEyeHeight = BaseEyeHeight;\n\t\tSetPhysics(PHYS_None);\n\t}\n}\n\nstate PlayerSpectating\n{\nignores SeePlayer, HearNoise, Bump, TakeDamage, Died, ZoneChange, FootZoneChange;\n\n\texec function Suicide()\n\t{\n\t}\n\n\tfunction SendVoiceMessage(PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID, name broadcasttype)\n\t{\n\t}\n\n\texec function AltFire( optional float F )\n\t{\n\t\tbBehindView = false;\n\t\tViewtarget = None;\n\t\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n\t}\n\n\tfunction ChangeTeam( int N )\n\t{\n\t\tLevel.Game.ChangeTeam(self, N);\n\t}\n\n\texec function Fire( optional float F )\n\t{\n\t\tif ( Role == ROLE_Authority )\n\t\t{\n\t\t\tViewPlayerNum(-1);\n\t\t\tbBehindView = true;\n\t\t}\n\t} \n\n\tfunction ProcessMove(float DeltaTime, vector NewAccel, eDodgeDir DodgeMove, rotator DeltaRot)\t\n\t{\n\t\tAcceleration = NewAccel;\n\t\tMoveSmooth(Acceleration * DeltaTime);\n\t}\n\n\tevent PlayerTick( float DeltaTime )\n\t{\n\t\tif ( bUpdatePosition )\n\t\t\tClientUpdatePosition();\n\n\t\tPlayerMove(DeltaTime);\n\t}\n\n\tfunction PlayerMove(float DeltaTime)\n\t{\n\t\tlocal rotator newRotation;\n\t\tlocal vector X,Y,Z;\n\n\t\tGetAxes(ViewRotation,X,Y,Z);\n\n\t\taForward *= 0.1;\n\t\taStrafe  *= 0.1;\n\t\taLookup  *= 0.24;\n\t\taTurn    *= 0.24;\n\t\taUp\t\t *= 0.1;\n\t\n\t\tAcceleration = aForward*X + aStrafe*Y + aUp*vect(0,0,1);  \n\n\t\tUpdateRotation(DeltaTime, 1);\n\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, Acceleration, DODGE_None, rot(0,0,0));\n\t\telse\n\t\t\tProcessMove(DeltaTime, Acceleration, DODGE_None, rot(0,0,0));\n\t}\n\n\tfunction EndState()\n\t{\n\t\tPlayerReplicationInfo.bIsSpectator = false;\n\t\tPlayerReplicationInfo.bWaitingPlayer = false;\n\t\tMesh = Default.Mesh;\n\t\tSetCollision(true,true,true);\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tPlayerReplicationInfo.bIsSpectator = true;\n\t\tPlayerReplicationInfo.bWaitingPlayer = true;\n\t\tbShowScores = true;\n\t\tMesh = None;\n\t\tSetCollision(false,false,false);\n\t\tEyeHeight = Default.BaseEyeHeight;\n\t\tSetPhysics(PHYS_None);\n\t}\n}\n//===============================================================================\nstate PlayerWaking\n{\nignores SeePlayer, HearNoise, KilledBy, Bump, HitWall, HeadZoneChange, FootZoneChange, ZoneChange, SwitchWeapon, Falling;\n\n\tfunction Timer()\n\t{\n\t\tBaseEyeHeight = Default.BaseEyeHeight;\n\t}\n\n\tevent PlayerTick( float DeltaTime )\n\t{\n\t\tif ( bUpdatePosition )\n\t\t\tClientUpdatePosition();\n\n\t\tPlayerMove(DeltaTime);\n\t}\n\n\tfunction PlayerMove(Float DeltaTime)\n\t{\n\t\tViewFlash(deltaTime * 0.5);\n\t\tif ( TimerRate == 0 )\n\t\t{\n\t\t\tViewRotation.Pitch -= DeltaTime * 12000;\n\t\t\tif ( ViewRotation.Pitch < 0 )\n\t\t\t{\n\t\t\t\tViewRotation.Pitch = 0;\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t}\n\t\t}\n\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, vect(0,0,0), DODGE_None, rot(0,0,0));\n\t\telse\n\t\t\tProcessMove(DeltaTime, vect(0,0,0), DODGE_None, rot(0,0,0));\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tif ( bWokeUp )\n\t\t{\n\t\t\tViewRotation.Pitch = 0;\n\t\t\tSetTimer(0, false);\n\t\t\treturn;\n\t\t}\n\t\tBaseEyeHeight = 0;\n\t\tEyeHeight = 0;\n\t\tSetTimer(3.0, false);\n\t\tbWokeUp = true;\n\t}\n}\n\nstate Dying\n{\nignores SeePlayer, HearNoise, KilledBy, Bump, HitWall, HeadZoneChange, FootZoneChange, ZoneChange, SwitchWeapon, Falling, PainTimer;\n\n\tfunction ServerReStartPlayer()\n\t{\n\t\t//log(\"calling restartplayer in dying with netmode \"$Level.NetMode);\n\t\tif ( Level.NetMode == NM_Client )\n\t\t\treturn;\n\t\tif( Level.Game.RestartPlayer(self) )\n\t\t{\n\t\t\tServerTimeStamp = 0;\n\t\t\tTimeMargin = 0;\n\t\t\tEnemy = None;\n\t\t\tLevel.Game.StartPlayer(self);\n\t\t\tif ( Mesh != None )\n\t\t\t\tPlayWaiting();\n\t\t\tClientReStart();\n\t\t}\n\t\telse\n\t\t\tlog(\"Restartplayer failed\");\n\t}\n\n\texec function Fire( optional float F )\n\t{\n\t\tif ( (Level.NetMode == NM_Standalone) && !Level.Game.bDeathMatch )\n\t\t{\n\t\t\tif ( bFrozen )\n\t\t\t\treturn;\n\t\t\tShowLoadMenu();\n\t\t}\n\t\telse if ( !bFrozen || (FRand() < 0.2) )\n\t\t\tServerReStartPlayer();\n\t}\n\t\n\texec function AltFire( optional float F )\n\t{\n\t\tFire(F);\n\t}\n\n\tfunction PlayChatting()\n\t{\n\t}\n\n\texec function Taunt( name Sequence )\n\t{\n\t}\n\n\tfunction ServerMove\n\t(\n\t\tfloat TimeStamp, \n\t\tvector Accel, \n\t\tvector ClientLoc,\n\t\tbool NewbRun,\n\t\tbool NewbDuck,\n\t\tbool NewbJumpStatus,\n\t\tbool bFired,\n\t\tbool bAltFired,\n\t\tbool bForceFire,\n\t\tbool bForceAltFire,\n\t\teDodgeDir DodgeMove, \n\t\tbyte ClientRoll, \n\t\tint View,\n\t\toptional byte OldTimeDelta,\n\t\toptional int OldAccel\n\t)\n\t{\n\t\tGlobal.ServerMove(\n\t\t\t\t\tTimeStamp,\n\t\t\t\t\tAccel, \n\t\t\t\t\tClientLoc,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse, \n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tfalse,\n\t\t\t\t\tDodgeMove, \n\t\t\t\t\tClientRoll, \n\t\t\t\t\tView);\n\t}\n\n\tfunction PlayerCalcView(out actor ViewActor, out vector CameraLocation, out rotator CameraRotation )\n\t{\n\t\tlocal vector View,HitLocation,HitNormal, FirstHit, spot;\n\t\tlocal float DesiredDist, ViewDist, WallOutDist;\n\t\tlocal actor HitActor;\n\t\tlocal Pawn PTarget;\n\n\t\tif ( ViewTarget != None )\n\t\t{\n\t\t\tViewActor = ViewTarget;\n\t\t\tCameraLocation = ViewTarget.Location;\n\t\t\tCameraRotation = ViewTarget.Rotation;\n\t\t\tPTarget = Pawn(ViewTarget);\n\t\t\tif ( PTarget != None )\n\t\t\t{\n\t\t\t\tif ( Level.NetMode == NM_Client )\n\t\t\t\t{\n\t\t\t\t\tif ( PTarget.bIsPlayer )\n\t\t\t\t\t\tPTarget.ViewRotation = TargetViewRotation;\n\t\t\t\t\tPTarget.EyeHeight = TargetEyeHeight;\n\t\t\t\t\tif ( PTarget.Weapon != None )\n\t\t\t\t\t\tPTarget.Weapon.PlayerViewOffset = TargetWeaponViewOffset;\n\t\t\t\t}\n\t\t\t\tif ( PTarget.bIsPlayer )\n\t\t\t\t\tCameraRotation = PTarget.ViewRotation;\n\t\t\t\tCameraLocation.Z += PTarget.EyeHeight;\n\t\t\t}\n\n\t\t\tif ( Carcass(ViewTarget) != None )\n\t\t\t{\n\t\t\t\tif ( bBehindView || (ViewTarget.Physics == PHYS_None) )\n\t\t\t\t\tCameraRotation = ViewRotation;\n\t\t\t\telse \n\t\t\t\t\tViewRotation = CameraRotation;\n\t\t\t\tif ( bBehindView )\n\t\t\t\t\tCalcBehindView(CameraLocation, CameraRotation, 190);\n\t\t\t}\n\t\t\telse if ( bBehindView )\n\t\t\t\tCalcBehindView(CameraLocation, CameraRotation, 180);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// View rotation.\n\t\tCameraRotation = ViewRotation;\n\t\tDesiredFOV = DefaultFOV;\t\t\n\t\tViewActor = self;\n\t\tif( bBehindView ) //up and behind (for death scene)\n\t\t\tCalcBehindView(CameraLocation, CameraRotation, 180);\n\t\telse\n\t\t{\n\t\t\t// First-person view.\n\t\t\tCameraLocation = Location;\n\t\t\tCameraLocation.Z += Default.BaseEyeHeight;\n\t\t}\n\t}\n\n\tevent PlayerTick( float DeltaTime )\n\t{\n\t\tif ( bUpdatePosition )\n\t\t\tClientUpdatePosition();\n\t\t\n\t\tPlayerMove(DeltaTime);\n\t}\n\n\tfunction PlayerMove(float DeltaTime)\n\t{\n\t\tlocal vector X,Y,Z;\n\n\t\tif ( !bFrozen )\n\t\t{\n\t\t\tif ( bPressedJump )\n\t\t\t{\n\t\t\t\tFire(0);\n\t\t\t\tbPressedJump = false;\n\t\t\t}\n\t\t\tGetAxes(ViewRotation,X,Y,Z);\n\t\t\t// Update view rotation.\n\t\t\taLookup  *= 0.24;\n\t\t\taTurn    *= 0.24;\n\t\t\tViewRotation.Yaw += 32.0 * DeltaTime * aTurn;\n\t\t\tViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;\n\t\t\tViewRotation.Pitch = ViewRotation.Pitch & 65535;\n\t\t\tIf ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))\n\t\t\t{\n\t\t\t\tIf (aLookUp > 0) \n\t\t\t\t\tViewRotation.Pitch = 18000;\n\t\t\t\telse\n\t\t\t\t\tViewRotation.Pitch = 49152;\n\t\t\t}\n\t\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\t\tReplicateMove(DeltaTime, vect(0,0,0), DODGE_None, rot(0,0,0));\n\t\t}\n\t\tViewShake(DeltaTime);\n\t\tViewFlash(DeltaTime);\n\t}\n\n\tfunction FindGoodView()\n\t{\n\t\tlocal vector cameraLoc;\n\t\tlocal rotator cameraRot;\n\t\tlocal int tries, besttry;\n\t\tlocal float bestdist, newdist;\n\t\tlocal int startYaw;\n\t\tlocal actor ViewActor;\n\t\t\n\t\t//fixme - try to pick view with killer visible\n\t\t//fixme - also try varying starting pitch\n\t\t////log(\"Find good death scene view\");\n\t\tViewRotation.Pitch = 56000;\n\t\ttries = 0;\n\t\tbesttry = 0;\n\t\tbestdist = 0.0;\n\t\tstartYaw = ViewRotation.Yaw;\n\t\t\n\t\tfor (tries=0; tries<16; tries++)\n\t\t{\n\t\t\tcameraLoc = Location;\n\t\t\tPlayerCalcView(ViewActor, cameraLoc, cameraRot);\n\t\t\tnewdist = VSize(cameraLoc - Location);\n\t\t\tif (newdist > bestdist)\n\t\t\t{\n\t\t\t\tbestdist = newdist;\t\n\t\t\t\tbesttry = tries;\n\t\t\t}\n\t\t\tViewRotation.Yaw += 4096;\n\t\t}\n\t\t\t\n\t\tViewRotation.Yaw = startYaw + besttry * 4096;\n\t}\n\t\n\tfunction TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation, \n\t\t\t\t\t\t\tVector momentum, name damageType)\n\t{\n\t\tif ( !bHidden )\n\t\t\tSuper.TakeDamage(Damage, instigatedBy, hitlocation, momentum, damageType);\n\t}\n\t\n\tfunction Timer()\n\t{\n\t\tbFrozen = false;\n\t\tbShowScores = true;\n\t\tbPressedJump = false;\n\t}\n\t\n\tfunction BeginState()\n\t{\n\t\tBaseEyeheight = Default.BaseEyeHeight;\n\t\tEyeHeight = BaseEyeHeight;\n\t\tif ( Carcass(ViewTarget) == None )\n\t\t\tbBehindView = true;\n\t\tbFrozen = true;\n\t\tbPressedJump = false;\n\t\tbJustFired = false;\n\t\tbJustAltFired = false;\n\t\tFindGoodView();\n\t\tif ( (Role == ROLE_Authority) && !bHidden )\n\t\t\tSuper.Timer(); \n\t\tSetTimer(1.0, false);\n\n\t\t// clean out saved moves\n\t\twhile ( SavedMoves != None )\n\t\t{\n\t\t\tSavedMoves.Destroy();\n\t\t\tSavedMoves = SavedMoves.NextMove;\n\t\t}\n\t\tif ( PendingMove != None )\n\t\t{\n\t\t\tPendingMove.Destroy();\n\t\t\tPendingMove = None;\n\t\t}\n\t}\n\t\n\tfunction EndState()\n\t{\n\t\t// clean out saved moves\n\t\twhile ( SavedMoves != None )\n\t\t{\n\t\t\tSavedMoves.Destroy();\n\t\t\tSavedMoves = SavedMoves.NextMove;\n\t\t}\n\t\tif ( PendingMove != None )\n\t\t{\n\t\t\tPendingMove.Destroy();\n\t\t\tPendingMove = None;\n\t\t}\n\t\tVelocity = vect(0,0,0);\n\t\tAcceleration = vect(0,0,0);\n\t\tbBehindView = false;\n\t\tbShowScores = false;\n\t\tbJustFired = false;\n\t\tbJustAltFired = false;\n\t\tbPressedJump = false;\n\t\tif ( Carcass(ViewTarget) != None )\n\t\t\tViewTarget = None;\n\t\t//Log(self$\" exiting dying with remote role \"$RemoteRole$\" and role \"$Role);\n\t}\n}\n\nstate GameEnded\n{\nignores SeePlayer, HearNoise, KilledBy, Bump, HitWall, HeadZoneChange, FootZoneChange, ZoneChange, Falling, TakeDamage, PainTimer, Died, Suicide;\n\n\texec function ThrowWeapon()\n\t{\n\t}\n\n\texec function Taunt( name Sequence )\n\t{\n\t\tif ( Health > 0 )\n\t\t\tGlobal.Taunt(Sequence);\n\t}\n\n\texec function ViewClass( class<actor> aClass, optional bool bQuiet )\n\t{\n\t}\n\texec function ViewPlayer( string S )\n\t{\n\t}\n\texec function Fire( optional float F )\n\t{\n\t\tif ( Role < ROLE_Authority)\n\t\t\treturn;\n\t\tif ( !bFrozen )\n\t\t\tServerReStartGame();\n\t\telse if ( TimerRate <= 0 )\n\t\t\tSetTimer(1.5, false);\n\t}\n\t\n\texec function AltFire( optional float F )\n\t{\n\t\tFire(F);\n\t}\n\n\tevent PlayerTick( float DeltaTime )\n\t{\n\t\tif ( bUpdatePosition )\n\t\t\tClientUpdatePosition();\n\n\t\tPlayerMove(DeltaTime);\n\t}\n\n\tfunction PlayerMove(float DeltaTime)\n\t{\n\t\tlocal vector X,Y,Z;\n\t\t\n\t\tGetAxes(ViewRotation,X,Y,Z);\n\t\t// Update view rotation.\n\n\t\tif ( !bFixedCamera )\n\t\t{\n\t\t\taLookup  *= 0.24;\n\t\t\taTurn    *= 0.24;\n\t\t\tViewRotation.Yaw += 32.0 * DeltaTime * aTurn;\n\t\t\tViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;\n\t\t\tViewRotation.Pitch = ViewRotation.Pitch & 65535;\n\t\t\tIf ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))\n\t\t\t{\n\t\t\t\tIf (aLookUp > 0) \n\t\t\t\t\tViewRotation.Pitch = 18000;\n\t\t\t\telse\n\t\t\t\t\tViewRotation.Pitch = 49152;\n\t\t\t}\n\t\t}\n\t\telse if ( ViewTarget != None )\n\t\t\tViewRotation = ViewTarget.Rotation;\n\n\t\tViewShake(DeltaTime);\n\t\tViewFlash(DeltaTime);\n\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, vect(0,0,0), DODGE_None, rot(0,0,0));\n\t\telse\n\t\t\tProcessMove(DeltaTime, vect(0,0,0), DODGE_None, rot(0,0,0));\n\t\tbPressedJump = false;\n\t}\n\n\tfunction ServerMove\n\t(\n\t\tfloat TimeStamp, \n\t\tvector InAccel, \n\t\tvector ClientLoc,\n\t\tbool NewbRun,\n\t\tbool NewbDuck,\n\t\tbool NewbJumpStatus, \n\t\tbool bFired,\n\t\tbool bAltFired,\n\t\tbool bForceFire,\n\t\tbool bForceAltFire,\n\t\teDodgeDir DodgeMove, \n\t\tbyte ClientRoll, \n\t\tint View,\n\t\toptional byte OldTimeDelta,\n\t\toptional int OldAccel\n\t)\n\t{\n\t\tGlobal.ServerMove(TimeStamp, InAccel, ClientLoc, NewbRun, NewbDuck, NewbJumpStatus,\n\t\t\t\t\t\t\tbFired, bAltFired, bForceFire, bForceAltFire, DodgeMove, ClientRoll, (32767 & (ViewRotation.Pitch/2)) * 32768 + (32767 & (ViewRotation.Yaw/2)) );\n\n\t}\n\n\tfunction FindGoodView()\n\t{\n\t\tlocal vector cameraLoc;\n\t\tlocal rotator cameraRot;\n\t\tlocal int tries, besttry;\n\t\tlocal float bestdist, newdist;\n\t\tlocal int startYaw;\n\t\tlocal actor ViewActor;\n\t\t\n\t\tViewRotation.Pitch = 56000;\n\t\ttries = 0;\n\t\tbesttry = 0;\n\t\tbestdist = 0.0;\n\t\tstartYaw = ViewRotation.Yaw;\n\t\t\n\t\tfor (tries=0; tries<16; tries++)\n\t\t{\n\t\t\tif ( ViewTarget != None )\n\t\t\t\tcameraLoc = ViewTarget.Location;\n\t\t\telse\n\t\t\t\tcameraLoc = Location;\n\t\t\tPlayerCalcView(ViewActor, cameraLoc, cameraRot);\n\t\t\tnewdist = VSize(cameraLoc - Location);\n\t\t\tif (newdist > bestdist)\n\t\t\t{\n\t\t\t\tbestdist = newdist;\t\n\t\t\t\tbesttry = tries;\n\t\t\t}\n\t\t\tViewRotation.Yaw += 4096;\n\t\t}\n\t\t\t\n\t\tViewRotation.Yaw = startYaw + besttry * 4096;\n\t}\n\t\n\tfunction Timer()\n\t{\n\t\tbFrozen = false;\n\t}\n\t\n\tfunction BeginState()\n\t{\n\t\tEndZoom();\n\t\tAnimRate = 0.0;\n\t\tSimAnim.Y = 0;\n\t\tbFire = 0;\n\t\tbAltFire = 0;\n\t\tSetCollision(false,false,false);\n\t\tbShowScores = true;\n\t\tbFrozen = true;\n\t\tif ( !bFixedCamera )\n\t\t{\n\t\t\tFindGoodView();\n\t\t\tbBehindView = true;\n\t\t}\n\t\tSetTimer(1.5, false);\n\t\tSetPhysics(PHYS_None);\n\t}\n}\n\n// ----------------------------------------------------\n// MultiplayerTick\n// Support for calling it on the server side(servermove)\n// ----------------------------------------------------\nfunction MultiplayerTick(float DeltaTime)\n{\n}\n\ndefaultproperties\n{\n     Password=\"momsblend\"\n     DodgeClickTime=0.100000\n     FlashScale=(X=1.000000,Y=1.000000,Z=1.000000)\n     DesiredFOV=90.000000\n     DefaultFOV=90.000000\n     CdTrack=255\n     MyAutoAim=1.000000\n     Handedness=-1.000000\n     bAlwaysMouseLook=True\n     bKeyboardLook=True\n     bNoFlash=True\n     bMessageBeep=True\n     MouseSensitivity=3.000000\n     WeaponPriority(0)=WeaponEMPGrenade\n     WeaponPriority(1)=WeaponGasGrenade\n     WeaponPriority(2)=WeaponLAM\n     WeaponPriority(3)=CBPWeaponRifle\n     WeaponPriority(4)=NailGun\n     WeaponPriority(5)=WeaponDesertEagle\n     MouseSmoothThreshold=0.160000\n     MaxTimeMargin=1.000000\n     QuickSaveString=\"Quick Saving\"\n     NoPauseMessage=\"Game is not pauseable\"\n     ViewingFrom=\"Now viewing from\"\n     OwnCamera=\"own camera\"\n     FailedView=\"Failed to change view.\"\n     TurnRateAdjuster=1.000000\n     bIsPlayer=True\n     bCanJump=True\n     bViewTarget=True\n     DesiredSpeed=0.300000\n     SightRadius=4100.000000\n     bTravel=True\n     bStasis=False\n     NetPriority=3.000000\n}\n",
            "name": "PlayerPawn.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Password=\"momsblend\"",
                    "DodgeClickTime=0.100000",
                    "FlashScale=(X=1.000000,Y=1.000000,Z=1.000000)",
                    "DesiredFOV=90.000000",
                    "DefaultFOV=90.000000",
                    "CdTrack=255",
                    "MyAutoAim=1.000000",
                    "Handedness=-1.000000",
                    "bAlwaysMouseLook=True",
                    "bKeyboardLook=True",
                    "bNoFlash=True",
                    "bMessageBeep=True",
                    "MouseSensitivity=3.000000",
                    "WeaponPriority(0)=WeaponEMPGrenade",
                    "WeaponPriority(1)=WeaponGasGrenade",
                    "WeaponPriority(2)=WeaponLAM",
                    "WeaponPriority(3)=CBPWeaponRifle",
                    "WeaponPriority(4)=NailGun",
                    "WeaponPriority(5)=WeaponDesertEagle",
                    "MouseSmoothThreshold=0.160000",
                    "MaxTimeMargin=1.000000",
                    "QuickSaveString=\"Quick Saving\"",
                    "NoPauseMessage=\"Game is not pauseable\"",
                    "ViewingFrom=\"Now viewing from\"",
                    "OwnCamera=\"own camera\"",
                    "FailedView=\"Failed to change view.\"",
                    "TurnRateAdjuster=1.000000",
                    "bIsPlayer=True",
                    "bCanJump=True",
                    "bViewTarget=True",
                    "DesiredSpeed=0.300000",
                    "SightRadius=4100.000000",
                    "bTravel=True",
                    "bStasis=False",
                    "NetPriority=3.000000"
                ],
                "exec": [],
                "extends": "Pawn",
                "functions": {
                    "ActivateHint": {
                        "body": "{\n\tif ( bShowMenu || Level.Pauser!=\"\" )\n\t\treturn;\n\tIf (Inventory!=None) Inventory.ActivateTranslator(True);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ActivateHint",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ActivateItem": {
                        "body": "{\n\tif( bShowMenu || Level.Pauser!=\"\" )\n\t\treturn;\n\tif (SelectedItem!=None) \n\t\tSelectedItem.Activate();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ActivateItem",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ActivateTranslator": {
                        "body": "{\n\tif ( bShowMenu || Level.Pauser!=\"\" )\n\t\treturn;\n\tIf (Inventory!=None) Inventory.ActivateTranslator(False);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ActivateTranslator",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AddBots": {
                        "body": "{\n\tServerAddBots(N);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AddBots",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "N"
                            ]
                        ],
                        "return": ""
                    },
                    "AdjustAim": {
                        "body": "{\n\t\n\tFireDir = vector(ViewRotation);\n\tHitActor = Trace(HitLocation, HitNormal, projStart + 4000 * FireDir, projStart, true);\n\tif ( (HitActor != None) && HitActor.bProjTarget )\n\t{\n\t\tif ( bWarnTarget && HitActor.IsA('Pawn') )\n\t\t\tPawn(HitActor).WarnTarget(self, projSpeed, FireDir);\n\t\treturn ViewRotation;\n\t}\n\n\tbestAim = FMin(0.93, MyAutoAim);\n\tBestTarget = PickTarget(bestAim, bestDist, FireDir, projStart);\n\n\tif ( bWarnTarget && (Pawn(BestTarget) != None) )\n\t\tPawn(BestTarget).WarnTarget(self, projSpeed, FireDir);\t\n\n\tif ( (Level.NetMode != NM_Standalone) || (Level.Game.Difficulty > 2) \n\t\t|| bAlwaysMouseLook || ((BestTarget != None) && (bestAim < MyAutoAim)) || (MyAutoAim >= 1) )\n\t\treturn ViewRotation;\n\t\n\tif ( BestTarget == None )\n\t{\n\t\tbestAim = MyAutoAim;\n\t\tBestTarget = PickAnyTarget(bestAim, bestDist, FireDir, projStart);\n\t\tif ( BestTarget == None )\n\t\t\treturn ViewRotation;\n\t}\n\n\tAimSpot = projStart + FireDir * bestDist;\n\tAimSpot.Z = BestTarget.Location.Z + 0.3 * BestTarget.CollisionHeight;\n\n\treturn rotator(AimSpot - projStart);\n}",
                        "locals": [
                            "local vector FireDir, AimSpot, HitNormal, HitLocation;",
                            "local actor BestTarget;",
                            "local float bestAim, bestDist;",
                            "local actor HitActor;"
                        ],
                        "modifiers": [],
                        "name": "AdjustAim",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "projSpeed"
                            ],
                            [
                                "vector",
                                "projStart"
                            ],
                            [
                                "int",
                                "aimerror"
                            ],
                            [
                                "bool",
                                "bLeadTarget"
                            ],
                            [
                                "bool",
                                "bWarnTarget"
                            ]
                        ],
                        "return": "rotator"
                    },
                    "AdjustHitLocation": {
                        "body": "{\n\n\tif ( Level.NetMode != NM_Standalone )\n\t{\n\t\tTraceDir = Normal(TraceDir);\n\t\tAdjTraceDir = TraceDir;\n\t\tAdjTraceDir.Z = 0.0;\n\t\tAdjTraceDir = Normal(AdjTraceDir);\n\t\tscale = TraceDir dot AdjTraceDir;\n\t\tHitLocation = HitLocation + ( CollisionRadius * 0.60 * TraceDir ) / scale;\n\t\tif ( BaseEyeHeight == Default.BaseEyeHeight )\n\t\t\treturn true;\n\n\t\tmaxZ = Location.Z + EyeHeight + 0.25 * CollisionHeight;\n\t\tif ( HitLocation.Z > maxZ )\n\t\t{\n\t\t\tif ( TraceDir.Z >= 0 )\n\t\t\t\treturn false;\n\t\t\tadjZ = (maxZ - HitLocation.Z)/TraceDir.Z;\n\t\t\tHitLocation.Z = maxZ;\n\t\t\tHitLocation.X = HitLocation.X + TraceDir.X * adjZ;\n\t\t\tHitLocation.Y = HitLocation.Y + TraceDir.Y * adjZ;\n\t\t\tif ( VSize(HitLocation - Location) > CollisionRadius )\t\n\t\t\t\treturn false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tTraceDir = Normal(TraceDir);\n\t\tHitLocation = HitLocation + 0.5 * CollisionRadius * TraceDir;\n\t\tif ( BaseEyeHeight == Default.BaseEyeHeight )\n\t\t\treturn true;\n\t\tmaxZ = Location.Z + EyeHeight + 0.25 * CollisionHeight;\n\t\tif ( HitLocation.Z > maxZ )\n\t\t{\n\t\t\tif ( TraceDir.Z >= 0 )\n\t\t\t\treturn false;\n\t\t\tadjZ = (maxZ - HitLocation.Z)/TraceDir.Z;\n\t\t\tHitLocation.Z = maxZ;\n\t\t\tHitLocation.X = HitLocation.X + TraceDir.X * adjZ;\n\t\t\tHitLocation.Y = HitLocation.Y + TraceDir.Y * adjZ;\n\t\t\tif ( VSize(HitLocation - Location) > CollisionRadius )\t\n\t\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}",
                        "locals": [
                            "local float adjZ, maxZ, scale;",
                            "local Vector adjTraceDir;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "AdjustHitLocation",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "vector",
                                "HitLocation"
                            ],
                            [
                                "vector",
                                "TraceDir"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Admin": {
                        "body": "{\n\tif( bAdmin )\n\t\tResult = ConsoleCommand( CommandLine );\n\tif( Result!=\"\" )\n\t\tClientMessage( Result );\n}",
                        "locals": [
                            "local string Result;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Admin",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "CommandLine"
                            ]
                        ],
                        "return": ""
                    },
                    "AdminLogin": {
                        "body": "{\n\tLevel.Game.AdminLogin( Self, Password );\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AdminLogin",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Password"
                            ]
                        ],
                        "return": ""
                    },
                    "AdminLogout": {
                        "body": "{\n\tLevel.Game.AdminLogout( Self );\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AdminLogout",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AllAmmo": {
                        "body": "{\n\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\n\t// DEUS_EX CNN - make this be limited by the MaxAmmo per ammo instead of 999\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory ) \n\t\tif (Ammo(Inv)!=None) \n\t\t\tAmmo(Inv).AmmoAmount  = Ammo(Inv).MaxAmmo;\n}",
                        "locals": [
                            "local Inventory Inv;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AllAmmo",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AltFire": {
                        "body": "{\n\t\tFire(F);\n\t}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AltFire",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "AlwaysMouseLook": {
                        "body": "{\n\tChangeAlwaysMouseLook(B);\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AlwaysMouseLook",
                        "native": false,
                        "param": [
                            [
                                "Bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "Amphibious": {
                        "body": "{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tUnderwaterTime = +999999.0;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Amphibious",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AnimEnd": {
                        "body": "{\n\t\tPlaySwimming();\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AnimEnd",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "AttitudeTo": {
                        "body": "{\n\tif (Other.bIsPlayer)\n\t\treturn AttitudeToPlayer;\n\telse \n\t\treturn Other.AttitudeToPlayer;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AttitudeTo",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": "eAttitude"
                    },
                    "BeginState": {
                        "body": "{\n\t\tEndZoom();\n\t\tAnimRate = 0.0;\n\t\tSimAnim.Y = 0;\n\t\tbFire = 0;\n\t\tbAltFire = 0;\n\t\tSetCollision(false,false,false);\n\t\tbShowScores = true;\n\t\tbFrozen = true;\n\t\tif ( !bFixedCamera )\n\t\t{\n\t\t\tFindGoodView();\n\t\t\tbBehindView = true;\n\t\t}\n\t\tSetTimer(1.5, false);\n\t\tSetPhysics(PHYS_None);\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BehindView": {
                        "body": "{\n\t// DEUS_EX CNN - This needs to be here!\n\tif (!bCheatsEnabled)\n\t\treturn;\n\n\tbBehindView = B;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "BehindView",
                        "native": false,
                        "param": [
                            [
                                "Bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "CalcBehindView": {
                        "body": "{\n\n\tCameraRotation = ViewRotation;\n\tView = vect(1,0,0) >> CameraRotation;\n\tif( Trace( HitLocation, HitNormal, CameraLocation - (Dist + 30) * vector(CameraRotation), CameraLocation ) != None )\n\t\tViewDist = FMin( (CameraLocation - HitLocation) Dot View, Dist );\n\telse\n\t\tViewDist = Dist;\n\tCameraLocation -= (ViewDist - 30) * View; \n}",
                        "locals": [
                            "local vector View,HitLocation,HitNormal;",
                            "local float ViewDist;"
                        ],
                        "modifiers": [],
                        "name": "CalcBehindView",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "vector",
                                "CameraLocation"
                            ],
                            [
                                "out",
                                "rotator",
                                "CameraRotation"
                            ],
                            [
                                "float",
                                "Dist"
                            ]
                        ],
                        "return": ""
                    },
                    "CallForHelp": {
                        "body": "{\n\n\tif ( !Level.Game.bTeamGame || (Enemy == None) || (Enemy.Health <= 0) )\n\t\treturn;\n\n\tfor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t\tif ( P.bIsPlayer && (P.PlayerReplicationInfo.Team == PlayerReplicationInfo.Team) )\n\t\t\tP.HandleHelpMessageFrom(self);\n}",
                        "locals": [
                            "local Pawn P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "CallForHelp",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CauseEvent": {
                        "body": "{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\tif( (bAdmin || (Level.Netmode == NM_Standalone)) && (N != '') )\n\t\tforeach AllActors( class 'Actor', A, N )\n\t\t\tA.Trigger( Self, Self );\n}",
                        "locals": [
                            "local actor A;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "CauseEvent",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "N"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangeAlwaysMouseLook": {
                        "body": "{\n\tbAlwaysMouseLook = B;\n\tif ( bAlwaysMouseLook )\n\t\tbLookUpStairs = false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangeAlwaysMouseLook",
                        "native": false,
                        "param": [
                            [
                                "Bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangeAutoAim": {
                        "body": "{\n\tMyAutoAim = FMax(Level.Game.AutoAim, F);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangeAutoAim",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangeCrosshair": {
                        "body": "{\n\tif ( myHud != None ) \n\t\tmyHUD.ChangeCrosshair(1);\n\tmyHUD.SaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ChangeCrosshair",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ChangeDodgeClickTime": {
                        "body": "{\n\tDodgeClickTime = FMin(0.3, F);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangeDodgeClickTime",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangeHud": {
                        "body": "{\n\tif ( myHud != None )\n\t\tmyHUD.ChangeHud(1);\n\tmyHUD.SaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ChangeHud",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ChangeName": {
                        "body": "{\n\tLevel.Game.ChangeName( self, S, false );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangeName",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangeSetHand": {
                        "body": "{\n\tif ( S ~= \"Left\" )\n\t\tHandedness = 1;\n\telse if ( S~= \"Right\" )\n\t\tHandedness = -1;\n\telse if ( S ~= \"Center\" )\n\t\tHandedness = 0;\n\telse if ( S ~= \"Hidden\" )\n\t\tHandedness = 2;\n\tServerSetHandedness(Handedness);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangeSetHand",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangeSnapView": {
                        "body": "{\n\tbSnapToLevel = B;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangeSnapView",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangeStairLook": {
                        "body": "{\n\tbLookUpStairs = B;\n\tif ( bLookUpStairs )\n\t\tbAlwaysMouseLook = false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangeStairLook",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangeTeam": {
                        "body": "{\n\t\tLevel.Game.ChangeTeam(self, N);\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangeTeam",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "N"
                            ]
                        ],
                        "return": ""
                    },
                    "ChangedWeapon": {
                        "body": "{\n\t\tWeapon = None;\n\t\tInventory.ChangedWeapon();\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangedWeapon",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CheckBob": {
                        "body": "{\n\n\tOldBobTime = BobTime;\n\tif ( Speed2D < 10 )\n\t\tBobTime += 0.2 * DeltaTime;\n\telse\n\t\tBobTime += DeltaTime * (0.3 + 0.7 * Speed2D/GroundSpeed);\n\tWalkBob = Y * 0.65 * Bob * Speed2D * sin(6 * BobTime);\n\tAppliedBob = AppliedBob * (1 - FMin(1, 16 * deltatime));\n\tif ( LandBob > 0.01 )\n\t{\n\t\tAppliedBob += FMin(1, 16 * deltatime) * LandBob;\n\t\tLandBob *= (1 - 8*Deltatime);\n\t}\n\tif ( Speed2D < 10 )\n\t\tWalkBob.Z = 0; // AppliedBob + Bob * 30 * sin(12 * BobTime);   // take out the \"breathe\" effect - DEUS_EX CNN\n\telse\n\t\tWalkBob.Z = AppliedBob + Bob * Speed2D * sin(12 * BobTime);\n}",
                        "locals": [
                            "local float OldBobTime;"
                        ],
                        "modifiers": [],
                        "name": "CheckBob",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ],
                            [
                                "float",
                                "Speed2D"
                            ],
                            [
                                "vector",
                                "Y"
                            ]
                        ],
                        "return": ""
                    },
                    "ClearProgressMessages": {
                        "body": "{\n\n\tfor (i=0; i<8; i++)\n\t{\n\t\tProgressMessage[i] = \"\";\n\t\tProgressColor[i].R = 255;\n\t\tProgressColor[i].G = 255;\n\t\tProgressColor[i].B = 255;\n\t}\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ClearProgressMessages",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ClientAdjustGlow": {
                        "body": "{\n\tConstantGlowScale += scale;\n\tConstantGlowFog += 0.001 * fog;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientAdjustGlow",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "scale"
                            ],
                            [
                                "vector",
                                "fog"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientChangeTeam": {
                        "body": "{\n\t\t\n\tif ( PlayerReplicationInfo != None )\n\t\tPlayerReplicationInfo.Team = N;\n\n\t// if listen server, this may be called for non-local players that are logging in\n\t// if so, don't update URL\n\tif ( (Level.NetMode == NM_ListenServer) && (Player == None) )\n\t{\n\t\t// check if any other players exist\n\t\tfor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t\t\tif ( P.IsA('PlayerPawn') && (ViewPort(PlayerPawn(P).Player) != None) )\n\t\t\t\treturn;\n\t}\n\t\t\n\tUpdateURL(\"Team\",string(N), true);\t\n}",
                        "locals": [
                            "local Pawn P;"
                        ],
                        "modifiers": [],
                        "name": "ClientChangeTeam",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "N"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientFlash": {
                        "body": "{\n\tDesiredFlashScale = scale;\n\tDesiredFlashFog = 0.001 * fog;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientFlash",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "scale"
                            ],
                            [
                                "vector",
                                "fog"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientInstantFlash": {
                        "body": "{\n\tInstantFlash = scale;\n\tInstantFog = 0.001 * fog;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientInstantFlash",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "scale"
                            ],
                            [
                                "vector",
                                "fog"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientMessage": {
                        "body": "{\n\tif (Player == None)\n\t\treturn;\n\n\tif (Type == '')\n\t\tType = 'Event';\n\n\tif (Player.Console != None)\n\t\tPlayer.Console.Message( PlayerReplicationInfo, S, Type );\n\n\tif (bBeep && bMessageBeep)\n\t\tPlayBeepSound();\n\tif ( myHUD != None )\n\t\tmyHUD.Message( PlayerReplicationInfo, S, Type );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientMessage",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "S"
                            ],
                            [
                                "optional",
                                "Name",
                                "Type"
                            ],
                            [
                                "optional",
                                "bool",
                                "bBeep"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientPlaySound": {
                        "body": "{\t\n\n\tLastPlaySound = Level.TimeSeconds;\t// so voice messages won't overlap\n\tif ( ViewTarget != None )\n\t\tSoundPlayer = ViewTarget;\n\telse\n\t\tSoundPlayer = self;\n\n\tSoundPlayer.PlaySound(ASound, SLOT_None, 16.0, bInterrupt);\n\tSoundPlayer.PlaySound(ASound, SLOT_Interface, 16.0, bInterrupt);\n\tSoundPlayer.PlaySound(ASound, SLOT_Misc, 16.0, bInterrupt);\n\tSoundPlayer.PlaySound(ASound, SLOT_Talk, 16.0, bInterrupt);\n}",
                        "locals": [
                            "local actor SoundPlayer;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientPlaySound",
                        "native": false,
                        "param": [
                            [
                                "sound",
                                "ASound"
                            ],
                            [
                                "optional",
                                "bool",
                                "bInterrupt"
                            ],
                            [
                                "optional",
                                "bool",
                                "bVolumeControl"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientReliablePlaySound": {
                        "body": "{\n\tClientPlaySound(ASound, bInterrupt, bVolumeControl);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientReliablePlaySound",
                        "native": false,
                        "param": [
                            [
                                "sound",
                                "ASound"
                            ],
                            [
                                "optional",
                                "bool",
                                "bInterrupt"
                            ],
                            [
                                "optional",
                                "bool",
                                "bVolumeControl"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientReplicateSkins": {
                        "body": "{\n\t// do nothing (just loading other player skins onto client)\n\tlog(\"Getting \"$Skin1$\", \"$Skin2$\", \"$Skin3$\", \"$Skin4);\n\treturn;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientReplicateSkins",
                        "native": false,
                        "param": [
                            [
                                "texture",
                                "Skin1"
                            ],
                            [
                                "optional",
                                "texture",
                                "Skin2"
                            ],
                            [
                                "optional",
                                "texture",
                                "Skin3"
                            ],
                            [
                                "optional",
                                "texture",
                                "Skin4"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientSetMusic": {
                        "body": "{\n\tSong        = NewSong;\n\tSongSection = NewSection;\n\tCdTrack     = NewCdTrack;\n\tTransition  = NewTransition;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientSetMusic",
                        "native": false,
                        "param": [
                            [
                                "music",
                                "NewSong"
                            ],
                            [
                                "byte",
                                "NewSection"
                            ],
                            [
                                "byte",
                                "NewCdTrack"
                            ],
                            [
                                "EMusicTransition",
                                "NewTransition"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientShake": {
                        "body": "{\n\tif ( (shakemag < shake.X) || (shaketimer <= 0.01 * shake.Y) )\n\t{\n\t\tshakemag = shake.X;\n\t\tshaketimer = 0.01 * shake.Y;\t\n\t\tmaxshake = 0.01 * shake.Z;\n\t\tverttimer = 0;\n\t\tShakeVert = -1.1 * maxshake;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientShake",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "shake"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientTravel": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientTravel",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "URL"
                            ],
                            [
                                "ETravelType",
                                "TravelType"
                            ],
                            [
                                "bool",
                                "bItems"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientUpdatePosition": {
                        "body": "{\n\n\n\tbUpdatePosition = false;\n\trealbRun= bRun;\n\trealbDuck = bDuck;\n\tbRealJump = bPressedJump;\n\tCurrentMove = SavedMoves;\n\tbUpdating = true;\n\twhile ( CurrentMove != None )\n\t{\n\t\tif ( CurrentMove.TimeStamp <= CurrentTimeStamp )\n\t\t{\n\t\t\tSavedMoves = CurrentMove.NextMove;\n\t\t\tCurrentMove.NextMove = FreeMoves;\n\t\t\tFreeMoves = CurrentMove;\n\t\t\tFreeMoves.Clear();\n\t\t\tCurrentMove = SavedMoves;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// adjust radius of nearby players with uncertain location\n\t\t\tif ( TotalTime > 0 )\n               // XXXDEUS_EX AMSD Slow Pawn Iterator\n\t\t\t\t//ForEach AllActors(class'Pawn', P)\n            for (p = Level.PawnList; p != None; p = p.NextPawn)\n               if ( (P != self) && (P.Velocity != vect(0,0,0)) && P.bBlockPlayers )\n\t\t\t\t\t{\n\t\t\t\t\t\tDist = P.Location - Location;\n\t\t\t\t\t\tAdjPCol = 0.0004 * PlayerReplicationInfo.Ping * ((P.Velocity - Velocity) Dot Normal(Dist));\n\t\t\t\t\t\tif ( VSize(Dist) < AdjPCol + P.CollisionRadius + CollisionRadius + CurrentMove.Delta * GroundSpeed * (Normal(Velocity) Dot Normal(Dist)) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSavedPawn = P;\n\t\t\t\t\t\t\tSavedRadius = P.CollisionRadius;\n\t\t\t\t\t\t\tDist.Z = 0;\n\t\t\t\t\t\t\tP.SetCollisionSize(FClamp(AdjPCol + P.CollisionRadius, 0.5 * P.CollisionRadius, VSize(Dist) - CollisionRadius - P.CollisionRadius), P.CollisionHeight);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\tTotalTime += CurrentMove.Delta;\n\t\t\tMoveAutonomous(CurrentMove.Delta, CurrentMove.bRun, CurrentMove.bDuck, CurrentMove.bPressedJump, CurrentMove.DodgeMove, CurrentMove.Acceleration, rot(0,0,0));\n\t\t\tCurrentMove = CurrentMove.NextMove;\n\t\t\tif ( SavedPawn != None )\n\t\t\t{\n\t\t\t\tSavedPawn.SetCollisionSize(SavedRadius, P.CollisionHeight);\n\t\t\t\tSavedPawn = None;\n\t\t\t}\n\t\t}\n      // DEUS_EX AMSD Must also do the pending move that we've been building up.\n      if ((CurrentMove == None) && (PendingMove != None))\n      {\n         CurrentMove = PendingMove;\n         PendingMove = None;\n      }\n\t}\n\tbUpdating = false;\n\tbDuck = realbDuck;\n\tbRun = realbRun;\n\tbPressedJump = bRealJump;\n   //DEUS_EX AMSD Whenever we adjust our position, we need to reset pending moves as well.\n   PendingMove = None;\n\t//log(\"Client adjusted \"$self$\" stamp \"$CurrentTimeStamp$\" location \"$Location$\" dodge \"$DodgeDir);\n}",
                        "locals": [
                            "local SavedMove CurrentMove;",
                            "local int realbRun, realbDuck;",
                            "local bool bRealJump;",
                            "local float AdjPCol, SavedRadius, TotalTime;",
                            "local pawn SavedPawn, P;",
                            "local vector Dist;"
                        ],
                        "modifiers": [],
                        "name": "ClientUpdatePosition",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ClientVoiceMessage": {
                        "body": "{\n\n\tif ( (Sender.voicetype == None) || (Player.Console == None) )\n\t\treturn;\n\t\t\n\tV = Spawn(Sender.voicetype, self);\n\tif ( V != None )\n\t\tV.ClientInitialize(Sender, Recipient, messagetype, messageID);\n}",
                        "locals": [
                            "local VoicePack V;"
                        ],
                        "modifiers": [],
                        "name": "ClientVoiceMessage",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "Sender"
                            ],
                            [
                                "PlayerReplicationInfo",
                                "Recipient"
                            ],
                            [
                                "name",
                                "messagetype"
                            ],
                            [
                                "byte",
                                "messageID"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientWeaponEvent": {
                        "body": "{\n\tif ( Weapon != None )\n\t\tWeapon.ClientWeaponEvent(EventType);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientWeaponEvent",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "EventType"
                            ]
                        ],
                        "return": ""
                    },
                    "CompressAccel": {
                        "body": "{\n\tif ( C >= 0 )\n\t\tC = Min(C, 127);\n\telse\n\t\tC = Min(abs(C), 127) + 128;\n\treturn C;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CompressAccel",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "C"
                            ]
                        ],
                        "return": "int"
                    },
                    "ConsoleCommand": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ConsoleCommand",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "Command"
                            ]
                        ],
                        "return": "string"
                    },
                    "CopyToClipboard": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "CopyToClipboard",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "Text"
                            ]
                        ],
                        "return": ""
                    },
                    "Destroyed": {
                        "body": "{\n\tSuper.Destroyed();\n\tif ( myHud != None )\n\t\tmyHud.Destroy();\n\tif ( Scoring != None )\n\t\tScoring.Destroy();\n\n\tWhile ( FreeMoves != None )\n\t{\n\t\tFreeMoves.Destroy();\n\t\tFreeMoves = FreeMoves.NextMove;\n\t}\n\n\tWhile ( SavedMoves != None )\n\t{\n\t\tSavedMoves.Destroy();\n\t\tSavedMoves = SavedMoves.NextMove;\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Destroyed",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Died": {
                        "body": "{\n\tStopZoom();\n\n\tSuper.Died(Killer, damageType, HitLocation);\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Died",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Killer"
                            ],
                            [
                                "name",
                                "damageType"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ]
                        ],
                        "return": ""
                    },
                    "DoJump": {
                        "body": "{\n\tif ( CarriedDecoration != None )\n\t\treturn;\n\tif ( !bIsCrouching && (Physics == PHYS_Walking) )\n\t{\n\t\tif ( !bUpdating )\n\t\t\tPlayOwnedSound(JumpSound, SLOT_Talk, 1.5, true, 1200, 1.0 );\n\t\tif ( (Level.Game != None) && (Level.Game.Difficulty > 0) )\n\t\t\tMakeNoise(0.1 * Level.Game.Difficulty);\n\t\tPlayInAir();\n\t\tif ( bCountJumps && (Role == ROLE_Authority) && (Inventory != None) )\n\t\t\tInventory.OwnerJumped();\n\t\tVelocity.Z = JumpZ;\n\t\tif ( (Base != Level) && (Base != None) )\n\t\t\tVelocity.Z += Base.Velocity.Z; \n\t\tSetPhysics(PHYS_Falling);\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "DoJump",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "Dodge": {
                        "body": "{\n\n\t\tif ( bIsCrouching || (Physics != PHYS_Walking) )\n\t\t\treturn;\n\n\t\tGetAxes(Rotation,X,Y,Z);\n\t\tif (DodgeMove == DODGE_Forward)\n\t\t\tVelocity = 1.5*GroundSpeed*X + (Velocity Dot Y)*Y;\n\t\telse if (DodgeMove == DODGE_Back)\n\t\t\tVelocity = -1.5*GroundSpeed*X + (Velocity Dot Y)*Y; \n\t\telse if (DodgeMove == DODGE_Left)\n\t\t\tVelocity = 1.5*GroundSpeed*Y + (Velocity Dot X)*X; \n\t\telse if (DodgeMove == DODGE_Right)\n\t\t\tVelocity = -1.5*GroundSpeed*Y + (Velocity Dot X)*X; \n\n\t\tVelocity.Z = 160;\n\t\tPlayOwnedSound(JumpSound, SLOT_Talk, 1.0, true, 800, 1.0 );\n\t\tPlayDodge(DodgeMove);\n\t\tDodgeDir = DODGE_Active;\n\t\tSetPhysics(PHYS_Falling);\n\t}",
                        "locals": [
                            "local vector X,Y,Z;"
                        ],
                        "modifiers": [],
                        "name": "Dodge",
                        "native": false,
                        "param": [
                            [
                                "eDodgeDir",
                                "DodgeMove"
                            ]
                        ],
                        "return": ""
                    },
                    "EndState": {
                        "body": "{\n\t\t// clean out saved moves\n\t\twhile ( SavedMoves != None )\n\t\t{\n\t\t\tSavedMoves.Destroy();\n\t\t\tSavedMoves = SavedMoves.NextMove;\n\t\t}\n\t\tif ( PendingMove != None )\n\t\t{\n\t\t\tPendingMove.Destroy();\n\t\t\tPendingMove = None;\n\t\t}\n\t\tVelocity = vect(0,0,0);\n\t\tAcceleration = vect(0,0,0);\n\t\tbBehindView = false;\n\t\tbShowScores = false;\n\t\tbJustFired = false;\n\t\tbJustAltFired = false;\n\t\tbPressedJump = false;\n\t\tif ( Carcass(ViewTarget) != None )\n\t\t\tViewTarget = None;\n\t\t//Log(self$\" exiting dying with remote role \"$RemoteRole$\" and role \"$Role);\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "EndState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "EndZoom": {
                        "body": "{\n\tbZooming = false;\n\tDesiredFOV = DefaultFOV;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "EndZoom",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FOV": {
                        "body": "{\n\tSetDesiredFOV(F);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "FOV",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "Falling": {
                        "body": "{\n\t\t//SetPhysics(PHYS_Falling); //Note - physics changes type to PHYS_Falling by default\n\t\t//log(class$\" Falling\");\n\t\tPlayInAir();\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Falling",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FeignDeath": {
                        "body": "{\n\t\tif ( Physics == PHYS_Walking )\n\t\t{\n\t\t\tServerFeignDeath();\n\t\t\tAcceleration = vect(0,0,0);\n\t\t\tGotoState('FeigningDeath');\n\t\t}\n\t}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "FeignDeath",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FindGoodView": {
                        "body": "{\n\t\t\n\t\tViewRotation.Pitch = 56000;\n\t\ttries = 0;\n\t\tbesttry = 0;\n\t\tbestdist = 0.0;\n\t\tstartYaw = ViewRotation.Yaw;\n\t\t\n\t\tfor (tries=0; tries<16; tries++)\n\t\t{\n\t\t\tif ( ViewTarget != None )\n\t\t\t\tcameraLoc = ViewTarget.Location;\n\t\t\telse\n\t\t\t\tcameraLoc = Location;\n\t\t\tPlayerCalcView(ViewActor, cameraLoc, cameraRot);\n\t\t\tnewdist = VSize(cameraLoc - Location);\n\t\t\tif (newdist > bestdist)\n\t\t\t{\n\t\t\t\tbestdist = newdist;\t\n\t\t\t\tbesttry = tries;\n\t\t\t}\n\t\t\tViewRotation.Yaw += 4096;\n\t\t}\n\t\t\t\n\t\tViewRotation.Yaw = startYaw + besttry * 4096;\n\t}",
                        "locals": [
                            "local vector cameraLoc;",
                            "local rotator cameraRot;",
                            "local int tries, besttry;",
                            "local float bestdist, newdist;",
                            "local int startYaw;",
                            "local actor ViewActor;"
                        ],
                        "modifiers": [],
                        "name": "FindGoodView",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Fire": {
                        "body": "{\n\t\tif ( Role < ROLE_Authority)\n\t\t\treturn;\n\t\tif ( !bFrozen )\n\t\t\tServerReStartGame();\n\t\telse if ( TimerRate <= 0 )\n\t\t\tSetTimer(1.5, false);\n\t}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Fire",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "Fly": {
                        "body": "{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\t\t\n\tUnderWaterTime = Default.UnderWaterTime;\t\n\tClientMessage(\"You feel much lighter\");\n\tSetCollision(true, true , true);\n\tbCollideWorld = true;\n\tGotoState('CheatFlying');\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Fly",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FunctionKey": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "FunctionKey",
                        "native": false,
                        "param": [
                            [
                                "byte",
                                "Num"
                            ]
                        ],
                        "return": ""
                    },
                    "GetDefaultURL": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetDefaultURL",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "Option"
                            ]
                        ],
                        "return": "string"
                    },
                    "GetEntryLevel": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetEntryLevel",
                        "native": true,
                        "param": [],
                        "return": "LevelInfo"
                    },
                    "GetFreeMove": {
                        "body": "{\n\n\tif ( FreeMoves == None )\n\t\treturn Spawn(class'SavedMove');\n\telse\n\t{\n\t\ts = FreeMoves;\n\t\tFreeMoves = FreeMoves.NextMove;\n\t\ts.NextMove = None;\n\t\treturn s;\n\t}\t\n}",
                        "locals": [
                            "local SavedMove s;"
                        ],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetFreeMove",
                        "native": false,
                        "param": [],
                        "return": "SavedMove"
                    },
                    "GetPlayerNetworkAddress": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetPlayerNetworkAddress",
                        "native": true,
                        "param": [],
                        "return": "string"
                    },
                    "Ghost": {
                        "body": "{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\t\n\tUnderWaterTime = -1.0;\t\n\tClientMessage(\"You feel ethereal\");\n\tSetCollision(false, false, false);\n\tbCollideWorld = false;\n\tGotoState('CheatFlying');\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Ghost",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Gibbed": {
                        "body": "{\n\tif ( (damageType == 'decapitated') || (damageType == 'shot') )\n\t\treturn false; \t\n\tif ( (Health < -80) || ((Health < -40) && (FRand() < 0.6)) )\n\t\treturn true;\n\treturn false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Gibbed",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "damageType"
                            ]
                        ],
                        "return": "bool"
                    },
                    "God": {
                        "body": "{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\n\tif ( ReducedDamageType == 'All' )\n\t{\n\t\tReducedDamageType = '';\n\t\tClientMessage(\"God mode off\");\n\t\treturn;\n\t}\n\n\tReducedDamageType = 'All'; \n\tClientMessage(\"God Mode on\");\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "God",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Grab": {
                        "body": "{\n\tif (CarriedDecoration == None)\n\t\tGrabDecoration();\n\telse\n\t\tDropDecoration();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Grab",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "HandleWalking": {
                        "body": "{\n\n\t// this is changed from Unreal -- default is now walk - DEUS_EX CNN\n\tbIsWalking = ((bRun == 0) || (bDuck != 0)) && !Region.Zone.IsA('WarpZoneInfo'); \n\n\tif ( CarriedDecoration != None )\n\t{\n\t\tif ( (Role == ROLE_Authority) && (standingcount == 0) ) \n\t\t\tCarriedDecoration = None;\n\t\tif ( CarriedDecoration != None ) //verify its still in front\n\t\t{\n\t\t\tbIsWalking = true;\n\t\t\tif ( Role == ROLE_Authority )\n\t\t\t{\n\t\t\t\tcarried = Rotator(CarriedDecoration.Location - Location);\n\t\t\t\tcarried.Yaw = ((carried.Yaw & 65535) - (Rotation.Yaw & 65535)) & 65535;\n\t\t\t\tif ( (carried.Yaw > 3072) && (carried.Yaw < 62463) )\n\t\t\t\t\tDropDecoration();\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local rotator carried;"
                        ],
                        "modifiers": [],
                        "name": "HandleWalking",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "InitPlayerReplicationInfo": {
                        "body": "{\n\tSuper.InitPlayerReplicationInfo();\n\n\tPlayerReplicationInfo.bAdmin = bAdmin;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "InitPlayerReplicationInfo",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "InvertMouse": {
                        "body": "{\n\tbInvertMouse = B;\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "InvertMouse",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "Invisible": {
                        "body": "{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\n\tif (B)\n\t{\n\t\tbHidden = true;\n\t\tVisibility = 0;\n\t\t// DEUS_EX STM - added AI invisibility\n\t\tbDetectable = false;\n\t\t// DEUS_EX CNN - added message\n\t\tClientMessage(\"Player is now invisible\");\n\t}\n\telse\n\t{\n\t\tbHidden = false;\n\t\tVisibility = Default.Visibility;\n\t\t// DEUS_EX STM - added AI invisibility\n\t\tbDetectable = true;\n\t\t// DEUS_EX CNN - added message\n\t\tClientMessage(\"Player is now visible\");\n\t}\t\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Invisible",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "Jump": {
                        "body": "{\n\t}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Jump",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "JumpOffPawn": {
                        "body": "{\n\tVelocity += 60 * VRand();\n\tVelocity.Z = 120;\n\tSetPhysics(PHYS_Falling);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "JumpOffPawn",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Kick": {
                        "body": "{\n\tif( !bAdmin )\n\t\treturn;\n\n\tfor( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )\n\t\tif\n\t\t(\taPawn.bIsPlayer\n\t\t    &&  string(aPawn.PlayerReplicationInfo.PlayerID) ~= KickString\n\t\t\t&&\t(PlayerPawn(aPawn)==None || NetConnection(PlayerPawn(aPawn).Player)!=None ) )\n\t\t{\n\t\t\taPawn.Destroy();\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [
                            "local Pawn aPawn;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Kick",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "KickString"
                            ]
                        ],
                        "return": ""
                    },
                    "KickBan": {
                        "body": "{\n\tif( !bAdmin )\n\t\treturn;\n\tfor( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )\n\t\tif\n\t\t(\taPawn.bIsPlayer\n\t\t    &&  string(aPawn.PlayerReplicationInfo.PlayerID) ~= KickString\n\t\t\t&&\t(PlayerPawn(aPawn)==None || NetConnection(PlayerPawn(aPawn).Player)!=None ) )\n\t\t{\n\t\t\tIP = PlayerPawn(aPawn).GetPlayerNetworkAddress();\n\t\t\tif(Level.Game.CheckIPPolicy(IP))\n\t\t\t{\n\t\t\t\tIP = Left(IP, InStr(IP, \":\"));\n\t\t\t\tLog(\"Adding IP Ban for: \"$IP);\n\t\t\t\tfor(j=0;j<50;j++)\n\t\t\t\t\tif(Level.Game.IPPolicies[j] == \"\")\n\t\t\t\t\t\tbreak;\n\t\t\t\tif(j < 50)\n\t\t\t\t\tLevel.Game.IPPolicies[j] = \"DENY,\"$IP;\n\t\t\t\tLevel.Game.SaveConfig();\n\t\t\t}\n\t\t\taPawn.Destroy();\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [
                            "local Pawn aPawn;",
                            "local string IP;",
                            "local int j;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "KickBan",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "KickString"
                            ]
                        ],
                        "return": ""
                    },
                    "KillAll": {
                        "body": "{\n\n\tif( !bCheatsEnabled )\n\t\treturn;\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tForEach AllActors(class 'Actor', A)\n\t\tif ( ClassIsChildOf(A.class, aClass) )\n\t\t\tA.Destroy();\n}",
                        "locals": [
                            "local Actor A;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "KillAll",
                        "native": false,
                        "param": [
                            [
                                "class<actor>",
                                "aClass"
                            ]
                        ],
                        "return": ""
                    },
                    "KillMessage": {
                        "body": "{\n\treturn ( Level.Game.PlayerKillMessage(damageType, Other.PlayerReplicationInfo)$PlayerReplicationInfo.PlayerName );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "KillMessage",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "damageType"
                            ],
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": "string"
                    },
                    "KillPawns": {
                        "body": "{\n\t\n\tif( !bCheatsEnabled )\n\t\treturn;\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tForEach AllActors(class 'Pawn', P)\n\t\tif (PlayerPawn(P) == None)\n\t\t\tP.Destroy();\n}",
                        "locals": [
                            "local Pawn P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "KillPawns",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "KilledBy": {
                        "body": "{\n\tHealth = 0;\n\tDied( EventInstigator, 'Suicided', Location );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "KilledBy",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    },
                    "Landed": {
                        "body": "{\n\t\tif ( !bUpdating )\n\t\t{\n\t\t\t//log(class$\" Landed while swimming\");\n\t\t\tPlayLanded(Velocity.Z);\n\t\t\tTakeFallingDamage();\n\t\t\tbJustLanded = true;\n\t\t}\n\t\tif ( Region.Zone.bWaterZone )\n\t\t\tSetPhysics(PHYS_Swimming);\n\t\telse\n\t\t{\n\t\t\tGotoState('PlayerWalking');\n\t\t\tAnimEnd();\n\t\t}\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Landed",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "HitNormal"
                            ]
                        ],
                        "return": ""
                    },
                    "LocalTravel": {
                        "body": "{\n\tif( bAdmin || Level.Netmode==NM_Standalone )\n\t\tClientTravel( URL, TRAVEL_Relative, true );\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "LocalTravel",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "URL"
                            ]
                        ],
                        "return": ""
                    },
                    "MultiplayerTick": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "MultiplayerTick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "Mutate": {
                        "body": "{\n\tif( Level.NetMode == NM_Client )\n\t\treturn;\n\tLevel.Game.BaseMutator.Mutate(MutateString, Self);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Mutate",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "MutateString"
                            ]
                        ],
                        "return": ""
                    },
                    "Name": {
                        "body": "{\n\tSetName(S);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Name",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "NeverSwitchOnPickup": {
                        "body": "{\n\tbNeverAutoSwitch = B;\n\tbNeverSwitchOnPickup = B;\n\tServerNeverSwitchOnPickup(B);\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "NeverSwitchOnPickup",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "NextWeapon": {
                        "body": "{\n\n\tif( bShowMenu || Level.Pauser!=\"\" )\n\t\treturn;\n\tif ( Weapon == None )\n\t{\n\t\tSwitchToBestWeapon();\n\t\treturn;\n\t}\n\tnextGroup = 100;\n\trealWeapon = Weapon;\n\tif ( PendingWeapon != None )\n\t\tWeapon = PendingWeapon;\n\tPendingWeapon = None;\n\n\tfor (inv=Inventory; inv!=None; inv=inv.Inventory)\n\t{\n\t\tw = Weapon(inv);\n\t\tif ( w != None )\n\t\t{\n\t\t\tif ( w.InventoryGroup == Weapon.InventoryGroup )\n\t\t\t{\n\t\t\t\tif ( w == Weapon )\n\t\t\t\t\tbFoundWeapon = true;\n\t\t\t\telse if ( bFoundWeapon && ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) )\n\t\t\t\t{\n\t\t\t\t\tPendingWeapon = W;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( (w.InventoryGroup > Weapon.InventoryGroup) \n\t\t\t\t\t&& ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) \n\t\t\t\t\t&& (w.InventoryGroup < nextGroup) )\n\t\t\t{\n\t\t\t\tnextGroup = w.InventoryGroup;\n\t\t\t\tPendingWeapon = w;\n\t\t\t}\n\t\t}\n\t}\n\n\tbFoundWeapon = false;\n\tnextGroup = Weapon.InventoryGroup;\n\tif ( PendingWeapon == None )\n\t\tfor (inv=Inventory; inv!=None; inv=inv.Inventory)\n\t\t{\n\t\t\tw = Weapon(Inv);\n\t\t\tif ( w != None )\n\t\t\t{\n\t\t\t\tif ( w.InventoryGroup == Weapon.InventoryGroup )\n\t\t\t\t{\n\t\t\t\t\tif ( w == Weapon )\n\t\t\t\t\t{\n\t\t\t\t\t\tbFoundWeapon = true;\n\t\t\t\t\t\tif ( Prev != None )\n\t\t\t\t\t\t\tPendingWeapon = Prev;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( !bFoundWeapon && (PendingWeapon == None) && ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) )\n\t\t\t\t\t\tPrev = W;\n\t\t\t\t}\n\t\t\t\telse if ( (w.InventoryGroup < nextGroup) \n\t\t\t\t\t&& ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) ) \n\t\t\t\t{\n\t\t\t\t\tnextGroup = w.InventoryGroup;\n\t\t\t\t\tPendingWeapon = w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tWeapon = realWeapon;\n\tif ( PendingWeapon == None )\n\t\treturn;\n\n\tWeapon.PutDown();\n}",
                        "locals": [
                            "local int nextGroup;",
                            "local Inventory inv;",
                            "local Weapon realWeapon, w, Prev;",
                            "local bool bFoundWeapon;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "NextWeapon",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PasteFromClipboard": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PasteFromClipboard",
                        "native": true,
                        "param": [],
                        "return": "string"
                    },
                    "Pause": {
                        "body": "{\n\t// Don't pause in multiplayer\n\tif ( Level.NetMode == NM_Standalone )\n\t{\n\t\tif ( bShowMenu )\n\t\t\treturn;\n\t\tif( !SetPause(Level.Pauser==\"\") )\n\t\t\tClientMessage(NoPauseMessage);\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Pause",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Ping": {
                        "body": "{\n\tClientMessage(\"Current ping is\"@PlayerReplicationInfo.Ping);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Ping",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayBeepSound": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PlayBeepSound",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayChatting": {
                        "body": "{\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayChatting",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayDodge": {
                        "body": "{\n\tPlayDuck();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayDodge",
                        "native": false,
                        "param": [
                            [
                                "eDodgeDir",
                                "DodgeMove"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayDying": {
                        "body": "{\n\t\tBaseEyeHeight = Default.BaseEyeHeight;\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayDying",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "DamageType"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayFeignDeath": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayFeignDeath",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayHit": {
                        "body": "{\n\tLevel.Game.SpecialDamageString = \"\";\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayHit",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Damage"
                            ],
                            [
                                "vector",
                                "HitLocation"
                            ],
                            [
                                "name",
                                "damageType"
                            ],
                            [
                                "vector",
                                "Momentum"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayRising": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayRising",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlaySwimming": {
                        "body": "{\n\tPlayRunning();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlaySwimming",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayTakeHit": {
                        "body": "{\n\t\tif ( IsAnimating() )\n\t\t{\n\t\t\tEnable('AnimEnd');\n\t\t\tGlobal.PlayTakeHit(tweentime, HitLoc, Damage);\n\t\t}\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayTakeHit",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "tweentime"
                            ],
                            [
                                "vector",
                                "HitLoc"
                            ],
                            [
                                "int",
                                "Damage"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayTurning": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayTurning",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayerCalcView": {
                        "body": "{\n\n\t\tif ( ViewTarget != None )\n\t\t{\n\t\t\tViewActor = ViewTarget;\n\t\t\tCameraLocation = ViewTarget.Location;\n\t\t\tCameraRotation = ViewTarget.Rotation;\n\t\t\tPTarget = Pawn(ViewTarget);\n\t\t\tif ( PTarget != None )\n\t\t\t{\n\t\t\t\tif ( Level.NetMode == NM_Client )\n\t\t\t\t{\n\t\t\t\t\tif ( PTarget.bIsPlayer )\n\t\t\t\t\t\tPTarget.ViewRotation = TargetViewRotation;\n\t\t\t\t\tPTarget.EyeHeight = TargetEyeHeight;\n\t\t\t\t\tif ( PTarget.Weapon != None )\n\t\t\t\t\t\tPTarget.Weapon.PlayerViewOffset = TargetWeaponViewOffset;\n\t\t\t\t}\n\t\t\t\tif ( PTarget.bIsPlayer )\n\t\t\t\t\tCameraRotation = PTarget.ViewRotation;\n\t\t\t\tCameraLocation.Z += PTarget.EyeHeight;\n\t\t\t}\n\n\t\t\tif ( Carcass(ViewTarget) != None )\n\t\t\t{\n\t\t\t\tif ( bBehindView || (ViewTarget.Physics == PHYS_None) )\n\t\t\t\t\tCameraRotation = ViewRotation;\n\t\t\t\telse \n\t\t\t\t\tViewRotation = CameraRotation;\n\t\t\t\tif ( bBehindView )\n\t\t\t\t\tCalcBehindView(CameraLocation, CameraRotation, 190);\n\t\t\t}\n\t\t\telse if ( bBehindView )\n\t\t\t\tCalcBehindView(CameraLocation, CameraRotation, 180);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// View rotation.\n\t\tCameraRotation = ViewRotation;\n\t\tDesiredFOV = DefaultFOV;\t\t\n\t\tViewActor = self;\n\t\tif( bBehindView ) //up and behind (for death scene)\n\t\t\tCalcBehindView(CameraLocation, CameraRotation, 180);\n\t\telse\n\t\t{\n\t\t\t// First-person view.\n\t\t\tCameraLocation = Location;\n\t\t\tCameraLocation.Z += Default.BaseEyeHeight;\n\t\t}\n\t}",
                        "locals": [
                            "local vector View,HitLocation,HitNormal, FirstHit, spot;",
                            "local float DesiredDist, ViewDist, WallOutDist;",
                            "local actor HitActor;",
                            "local Pawn PTarget;"
                        ],
                        "modifiers": [],
                        "name": "PlayerCalcView",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "actor",
                                "ViewActor"
                            ],
                            [
                                "out",
                                "vector",
                                "CameraLocation"
                            ],
                            [
                                "out",
                                "rotator",
                                "CameraRotation"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayerInput": {
                        "body": "{\n\n\tif ( bShowMenu && (myHud != None) ) \n\t{\n\t\tif ( myHud.MainMenu != None )\n\t\t\tmyHud.MainMenu.MenuTick( DeltaTime );\n\t\t// clear inputs\n\t\tbEdgeForward = false;\n\t\tbEdgeBack = false;\n\t\tbEdgeLeft = false;\n\t\tbEdgeRight = false;\n\t\tbWasForward = false;\n\t\tbWasBack = false;\n\t\tbWasLeft = false;\n\t\tbWasRight = false;\n\t\taStrafe = 0;\n\t\taTurn = 0;\n\t\taForward = 0;\n\t\taLookUp = 0;\n\t\treturn;\n\t}\n\telse if ( bDelayedCommand )\n\t{\n\t\tbDelayedCommand = false;\n\t\tConsoleCommand(DelayedCommand);\n\t}\n\t\t\t\t\n\t// Check for Dodge move\n\t// flag transitions\n\tbEdgeForward = (bWasForward ^^ (aBaseY > 0));\n\tbEdgeBack = (bWasBack ^^ (aBaseY < 0));\n\tbEdgeLeft = (bWasLeft ^^ (aStrafe > 0));\n\tbEdgeRight = (bWasRight ^^ (aStrafe < 0));\n\tbWasForward = (aBaseY > 0);\n\tbWasBack = (aBaseY < 0);\n\tbWasLeft = (aStrafe > 0);\n\tbWasRight = (aStrafe < 0);\n\t\n\t// Smooth and amplify mouse movement\n\tSmoothTime = FMin(0.2, 3 * DeltaTime * Level.TimeDilation);\n\tFOVScale = DesiredFOV * 0.01111; \n\tMouseScale = MouseSensitivity * FOVScale;\n\n\taMouseX *= MouseScale;\n\taMouseY *= MouseScale;\n\n//************************************************************************\n\n\t//log(\"X \"$aMouseX$\" Smooth \"$SmoothMouseX$\" Borrowed \"$BorrowedMouseX$\" zero time \"$(Level.TimeSeconds - MouseZeroTime)$\" vs \"$MouseSmoothThreshold);\n\tAbsSmoothX = SmoothMouseX;\n\tAbsSmoothY = SmoothMouseY;\n\tMouseTime = (Level.TimeSeconds - MouseZeroTime)/Level.TimeDilation;\n\tif ( bMaxMouseSmoothing && (aMouseX == 0) && (MouseTime < MouseSmoothThreshold) )\n\t{\n\t\tSmoothMouseX = 0.5 * (MouseSmoothThreshold - MouseTime) * AbsSmoothX/MouseSmoothThreshold;\n\t\tBorrowedMouseX += SmoothMouseX;\n\t}\n\telse\n\t{\n\t\tif ( (SmoothMouseX == 0) || (aMouseX == 0) \n\t\t\t\t|| ((SmoothMouseX > 0) != (aMouseX > 0)) )\n\t\t{\n\t\t\tSmoothMouseX = aMouseX;\n\t\t\tBorrowedMouseX = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSmoothMouseX = 0.5 * (SmoothMouseX + aMouseX - BorrowedMouseX);\n\t\t\tif ( (SmoothMouseX > 0) != (aMouseX > 0) )\n\t\t\t{\n\t\t\t\tif ( AMouseX > 0 )\n\t\t\t\t\tSmoothMouseX = 1;\n\t\t\t\telse\n\t\t\t\t\tSmoothMouseX = -1;\n\t\t\t} \n\t\t\tBorrowedMouseX = SmoothMouseX - aMouseX;\n\t\t}\n\t\tAbsSmoothX = SmoothMouseX;\n\t}\n\tif ( bMaxMouseSmoothing && (aMouseY == 0) && (MouseTime < MouseSmoothThreshold) )\n\t{\n\t\tSmoothMouseY = 0.5 * (MouseSmoothThreshold - MouseTime) * AbsSmoothY/MouseSmoothThreshold;\n\t\tBorrowedMouseY += SmoothMouseY;\n\t}\n\telse\n\t{\n\t\tif ( (SmoothMouseY == 0) || (aMouseY == 0) \n\t\t\t\t|| ((SmoothMouseY > 0) != (aMouseY > 0)) )\n\t\t{\n\t\t\tSmoothMouseY = aMouseY;\n\t\t\tBorrowedMouseY = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSmoothMouseY = 0.5 * (SmoothMouseY + aMouseY - BorrowedMouseY);\n\t\t\tif ( (SmoothMouseY > 0) != (aMouseY > 0) )\n\t\t\t{\n\t\t\t\tif ( AMouseY > 0 )\n\t\t\t\t\tSmoothMouseY = 1;\n\t\t\t\telse\n\t\t\t\t\tSmoothMouseY = -1;\n\t\t\t} \n\t\t\tBorrowedMouseY = SmoothMouseY - aMouseY;\n\t\t}\n\t\tAbsSmoothY = SmoothMouseY;\n\t}\n\tif ( (aMouseX != 0) || (aMouseY != 0) )\n\t\tMouseZeroTime = Level.TimeSeconds;\n\n\t// adjust keyboard and joystick movements\n\taLookUp *= FOVScale;\n\taTurn   *= FOVScale;\n\n\t// Remap raw x-axis movement.\n\tif( bStrafe!=0 )\n\t{\n\t\t// Strafe.\n\t\taStrafe += aBaseX + SmoothMouseX;\n\t\taBaseX   = 0;\n\t}\n\telse\n\t{\n\t\t// Forward.\n\t\taTurn  += aBaseX * FOVScale + SmoothMouseX;\n\t\tif ( Level.NetMode != NM_Standalone )\n\t\t\taTurn *= TurnRateAdjuster;\n\t\taBaseX  = 0;\n\t}\n\n\t// Remap mouse y-axis movement.\n\tif( (bStrafe == 0) && (bAlwaysMouseLook || (bLook!=0)) )\n\t{\n\t\t// Look up/down.\n\t\tif ( bInvertMouse )\n\t\t\taLookUp -= SmoothMouseY;\n\t\telse\n\t\t\taLookUp += SmoothMouseY;\n\t\tif ( Level.NetMode != NM_Standalone )\n\t\t\taLookUp *= TurnRateAdjuster;\n\t}\n\telse\n\t{\n\t\t// Move forward/backward.\n\t\taForward += SmoothMouseY;\n\t}\n\tSmoothMouseX = AbsSmoothX;\n\tSmoothMouseY = AbsSmoothY;\n\n\tif ( bSnapLevel != 0 )\n\t{\n\t\tbCenterView = true;\n\t\tbKeyboardLook = false;\n\t}\n\telse if (aLookUp != 0)\n\t{\n\t\tbCenterView = false;\n\t\tbKeyboardLook = true;\n\t}\n\telse if ( bSnapToLevel && !bAlwaysMouseLook )\n\t{\n\t\tbCenterView = true;\n\t\tbKeyboardLook = false;\n\t}\n\n\t// Remap other y-axis movement.\n\tif ( bFreeLook != 0 )\n\t{\n\t\tbKeyboardLook = true;\n\t\taLookUp += 0.5 * aBaseY * FOVScale;\n\t}\n\telse\n\t\taForward += aBaseY;\n\n\taBaseY = 0;\n\n\t// Handle walking.\n\tHandleWalking();\n}",
                        "locals": [
                            "local float SmoothTime, FOVScale, MouseScale, AbsSmoothX, AbsSmoothY, MouseTime;"
                        ],
                        "modifiers": [],
                        "name": "PlayerInput",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayerList": {
                        "body": "{\n\n\tlog(\"Player List:\");\n\tForEach AllActors(class'PlayerReplicationInfo', PRI)\n\t\tClientMessage(PRI.PlayerName$\"(\"$PRI.PlayerID$\")\");\n}",
                        "locals": [
                            "local PlayerReplicationInfo PRI;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "PlayerList",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayerMove": {
                        "body": "{\n\t\t\n\t\tGetAxes(ViewRotation,X,Y,Z);\n\t\t// Update view rotation.\n\n\t\tif ( !bFixedCamera )\n\t\t{\n\t\t\taLookup  *= 0.24;\n\t\t\taTurn    *= 0.24;\n\t\t\tViewRotation.Yaw += 32.0 * DeltaTime * aTurn;\n\t\t\tViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;\n\t\t\tViewRotation.Pitch = ViewRotation.Pitch & 65535;\n\t\t\tIf ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))\n\t\t\t{\n\t\t\t\tIf (aLookUp > 0) \n\t\t\t\t\tViewRotation.Pitch = 18000;\n\t\t\t\telse\n\t\t\t\t\tViewRotation.Pitch = 49152;\n\t\t\t}\n\t\t}\n\t\telse if ( ViewTarget != None )\n\t\t\tViewRotation = ViewTarget.Rotation;\n\n\t\tViewShake(DeltaTime);\n\t\tViewFlash(DeltaTime);\n\n\t\tif ( Role < ROLE_Authority ) // then save this move and replicate it\n\t\t\tReplicateMove(DeltaTime, vect(0,0,0), DODGE_None, rot(0,0,0));\n\t\telse\n\t\t\tProcessMove(DeltaTime, vect(0,0,0), DODGE_None, rot(0,0,0));\n\t\tbPressedJump = false;\n\t}",
                        "locals": [
                            "local vector X,Y,Z;"
                        ],
                        "modifiers": [],
                        "name": "PlayerMove",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayerTick": {
                        "body": "{\n\t\tif ( bUpdatePosition )\n\t\t\tClientUpdatePosition();\n\n\t\tPlayerMove(DeltaTime);\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayerTick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayerTimeOut": {
                        "body": "{\n\tif (Health > 0)\n\t\tDied(None, 'Suicided', Location);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayerTimeOut",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayersOnly": {
                        "body": "{\n\t// DEUS_EX CNN - This needs to be here!\n\tif (!bCheatsEnabled)\n\t\treturn;\n\n\tif ( Level.Netmode != NM_Standalone )\n\t\treturn;\n\n\tLevel.bPlayersOnly = !Level.bPlayersOnly;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "PlayersOnly",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Possess": {
                        "body": "{\n\tif ( Level.Netmode == NM_Client )\n\t{\n\t\t// replicate client weapon preferences to server\n\t\tServerNeverSwitchOnPickup(bNeverAutoSwitch);\n\t\tServerSetHandedness(Handedness);\n\t\tUpdateWeaponPriorities();\n\t}\n\tServerUpdateWeapons();\n\tbIsPlayer = true;\n\tDodgeClickTime = FMin(0.3, DodgeClickTime);\n\tEyeHeight = BaseEyeHeight;\n\tNetPriority = 3;\n\tStartWalk();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Possess",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\tSuper.PostBeginPlay();\n\tif (Level.LevelEnterText != \"\" )\n\t\tClientMessage(Level.LevelEnterText);\n\tif ( Level.NetMode != NM_Client )\n\t{\n\t\tHUDType = Level.Game.HUDType;\n\t\tScoringType = Level.Game.ScoreboardType;\n\t\tMyAutoAim = FMax(MyAutoAim, Level.Game.AutoAim);\n\t}\n\tbIsPlayer = true;\n\tDodgeClickTime = FMin(0.3, DodgeClickTime);\n\tDesiredFOV = DefaultFOV;\n\tEyeHeight = BaseEyeHeight;\n\tif ( Level.Game.IsA('SinglePlayer') && (Level.NetMode == NM_Standalone) )\n\t\tFlashScale = vect(0,0,0);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostRender": {
                        "body": "{\n\tif ( myHud != None )\t\n\t\tmyHUD.PostRender(Canvas);\n\telse if ( (Viewport(Player) != None) && (HUDType != None) )\n\t\tmyHUD = spawn(HUDType, self);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostRender",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "PostRenderFlash": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostRenderFlash",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tbIsPlayer = true;\n\tSuper.PreBeginPlay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreClientTravel": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreClientTravel",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreRender": {
                        "body": "{\n\tif ( myHud != None )\t\n\t\tmyHUD.PreRender(Canvas);\n\telse if ( (Viewport(Player) != None) && (HUDType != None) )\n\t\tmyHUD = spawn(HUDType, self);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreRender",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "PrevItem": {
                        "body": "{\n\n\t// DEUS_EX CNN - this function is EVIL!\n\treturn;\n\n\tif ( bShowMenu || Level.Pauser!=\"\" )\n\t\treturn;\n\tif (SelectedItem==None) {\n\t\tSelectedItem = Inventory.SelectNext();\n\t\tReturn;\n\t}",
                        "locals": [
                            "local Inventory Inv, LastItem;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "PrevItem",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PrevWeapon": {
                        "body": "{\n\n\tif( bShowMenu || Level.Pauser!=\"\" )\n\t\treturn;\n\tif ( Weapon == None )\n\t{\n\t\tSwitchToBestWeapon();\n\t\treturn;\n\t}\n\tprevGroup = 0;\n\trealWeapon = Weapon;\n\tif ( PendingWeapon != None )\n\t\tWeapon = PendingWeapon;\n\tPendingWeapon = None;\n\t\n\tfor (inv=Inventory; inv!=None; inv=inv.Inventory)\n\t{\n\t\tw = Weapon(inv);\n\t\tif ( w != None )\n\t\t{\n\t\t\tif ( w.InventoryGroup == Weapon.InventoryGroup )\n\t\t\t{\n\t\t\t\tif ( w == Weapon )\n\t\t\t\t{\n\t\t\t\t\tbFoundWeapon = true;\n\t\t\t\t\tif ( Prev != None )\n\t\t\t\t\t{\n\t\t\t\t\t\tPendingWeapon = Prev;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( !bFoundWeapon && ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) )\n\t\t\t\t\tPrev = W;\n\t\t\t}\n\t\t\telse if ( (w.InventoryGroup < Weapon.InventoryGroup) \n\t\t\t\t\t&& ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) \n\t\t\t\t\t&& (w.InventoryGroup >= prevGroup) )\n\t\t\t{\n\t\t\t\tprevGroup = w.InventoryGroup;\n\t\t\t\tPendingWeapon = w;\n\t\t\t}\n\t\t}\n\t}\n\tbFoundWeapon = false;\n\tprevGroup = Weapon.InventoryGroup;\n\tif ( PendingWeapon == None )\n\t\tfor (inv=Inventory; inv!=None; inv=inv.Inventory)\n\t\t{\n\t\t\tw = Weapon(inv);\n\t\t\tif ( w != None )\n\t\t\t{\n\t\t\t\tif ( w.InventoryGroup == Weapon.InventoryGroup )\n\t\t\t\t{\n\t\t\t\t\tif ( w == Weapon )\n\t\t\t\t\t\tbFoundWeapon = true;\n\t\t\t\t\telse if ( bFoundWeapon && (PendingWeapon == None) && ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) )\n\t\t\t\t\t\tPendingWeapon = W;\n\t\t\t\t}\n\t\t\t\telse if ( (w.InventoryGroup > PrevGroup) \n\t\t\t\t\t\t&& ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) ) \n\t\t\t\t{\n\t\t\t\t\tprevGroup = w.InventoryGroup;\n\t\t\t\t\tPendingWeapon = w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\tWeapon = realWeapon;\n\tif ( PendingWeapon == None )\n\t\treturn;\n\n\tWeapon.PutDown();\n}",
                        "locals": [
                            "local int prevGroup;",
                            "local Inventory inv;",
                            "local Weapon realWeapon, w, Prev;",
                            "local bool bFoundWeapon;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "PrevWeapon",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ProcessMove": {
                        "body": "{\n\t\tAcceleration = NewAccel;\n\t\tMoveSmooth(Acceleration * DeltaTime);\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessMove",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ],
                            [
                                "vector",
                                "NewAccel"
                            ],
                            [
                                "eDodgeDir",
                                "DodgeMove"
                            ],
                            [
                                "rotator",
                                "DeltaRot"
                            ]
                        ],
                        "return": ""
                    },
                    "Profile": {
                        "body": "{\n\t//TEMP for performance measurement\n\n\tlog(\"Average AI Time\"@Level.AvgAITime);\n\tlog(\" < 5% \"$Level.AIProfile[0]);\n\tlog(\" < 10% \"$Level.AIProfile[1]);\n\tlog(\" < 15% \"$Level.AIProfile[2]);\n\tlog(\" < 20% \"$Level.AIProfile[3]);\n\tlog(\" < 25% \"$Level.AIProfile[4]);\n\tlog(\" < 30% \"$Level.AIProfile[5]);\n\tlog(\" < 35% \"$Level.AIProfile[6]);\n\tlog(\" > 35% \"$Level.AIProfile[7]);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Profile",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "QuickLoad": {
                        "body": "{\n\tif ( (Level.NetMode == NM_Standalone)\n\t\t&& !Level.Game.bDeathMatch )\n\t\tClientTravel( \"?load=9\", TRAVEL_Absolute, false);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "QuickLoad",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "QuickSave": {
                        "body": "{\n\tif ( (Health > 0) \n\t\t&& (Level.NetMode == NM_Standalone)\n\t\t&& !Level.Game.bDeathMatch )\n\t{\n\t\tClientMessage(QuickSaveString);\n\t\tConsoleCommand(\"SaveGame 9\");\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "QuickSave",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ReceiveLocalizedMessage": {
                        "body": "{\n\tMessage.Static.ClientReceive( Self, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ReceiveLocalizedMessage",
                        "native": false,
                        "param": [
                            [
                                "class<LocalMessage>",
                                "Message"
                            ],
                            [
                                "optional",
                                "int",
                                "Switch"
                            ],
                            [
                                "optional",
                                "PlayerReplicationInfo",
                                "RelatedPRI_1"
                            ],
                            [
                                "optional",
                                "PlayerReplicationInfo",
                                "RelatedPRI_2"
                            ],
                            [
                                "optional",
                                "Object",
                                "OptionalObject"
                            ]
                        ],
                        "return": ""
                    },
                    "RememberSpot": {
                        "body": "{\n\t//remember spot\n\tDestination = Location;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "RememberSpot",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "RenderOverlays": {
                        "body": "{\n\tif ( Weapon != None )\n\t\tWeapon.RenderOverlays(Canvas);\n\n\tif ( myHUD != None )\n\t\tmyHUD.RenderOverlays(Canvas);\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "RenderOverlays",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "ResetKeyboard": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ResetKeyboard",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "RestartLevel": {
                        "body": "{\n\tif( bAdmin || Level.Netmode==NM_Standalone )\n\t\tClientTravel( \"?restart\", TRAVEL_Relative, false );\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "RestartLevel",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Rise": {
                        "body": "{\n\t\tif ( !bRising )\n\t\t{\n\t\t\tEnable('AnimEnd');\n\t\t\tBaseEyeHeight = Default.BaseEyeHeight;\n\t\t\tbRising = true;\n\t\t\tPlayRising();\n\t\t}\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Rise",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SShot": {
                        "body": "{\n\tb = float(ConsoleCommand(\"get ini:Engine.Engine.ViewportManager Brightness\"));\n\tConsoleCommand(\"set ini:Engine.Engine.ViewportManager Brightness 1\");\n\tConsoleCommand(\"flush\");\n\tConsoleCommand(\"shot\");\n\tConsoleCommand(\"set ini:Engine.Engine.ViewportManager Brightness \"$string(B));\n\tConsoleCommand(\"flush\");\n}",
                        "locals": [
                            "local float b;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SShot",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Say": {
                        "body": "{\n\n\tstr = PlayerReplicationInfo.PlayerName $ \": \" $ Msg;\n\n\tif ( Role == ROLE_Authority )\n\t\tlog( \"Say>\" $ str );\n\n\tfor( P = Level.PawnList; P != None; P = P.nextPawn )\n\t{\n\t\tif( P.bIsPlayer )\n\t\t\tP.ClientMessage( str, 'Say', true );\n\t}\n\n\treturn;\n}",
                        "locals": [
                            "local Pawn P;",
                            "local String str;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Say",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Msg"
                            ]
                        ],
                        "return": ""
                    },
                    "SendVoiceMessage": {
                        "body": "{\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SendVoiceMessage",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "Sender"
                            ],
                            [
                                "PlayerReplicationInfo",
                                "Recipient"
                            ],
                            [
                                "name",
                                "messagetype"
                            ],
                            [
                                "byte",
                                "messageID"
                            ],
                            [
                                "name",
                                "broadcasttype"
                            ]
                        ],
                        "return": ""
                    },
                    "ServerAddBots": {
                        "body": "{\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\n\tif ( !Level.Game.bDeathMatch )\n\t\treturn;\n\n\tfor ( i=0; i<N; i++ )\n\t\tLevel.Game.ForceAddBot();\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "ServerAddBots",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "N"
                            ]
                        ],
                        "return": ""
                    },
                    "ServerChangeSkin": {
                        "body": "{\n\n\tMeshName = GetItemName(string(Mesh));\n\tif ( Level.Game.bCanChangeSkin )\n\t{\n\t\tSelf.static.SetMultiSkin(Self, SkinName, FaceName, TeamNum );\n\t}\n}",
                        "locals": [
                            "local string MeshName;"
                        ],
                        "modifiers": [],
                        "name": "ServerChangeSkin",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "SkinName"
                            ],
                            [
                                "coerce",
                                "string",
                                "FaceName"
                            ],
                            [
                                "byte",
                                "TeamNum"
                            ]
                        ],
                        "return": ""
                    },
                    "ServerFeignDeath": {
                        "body": "{\n\n\tW = Weapon;\n\tPendingWeapon = None;\n\tif ( Weapon != None )\n\t\tWeapon.PutDown();\n\tPendingWeapon = W;\n\tGotoState('FeigningDeath');\n}",
                        "locals": [
                            "local Weapon W;"
                        ],
                        "modifiers": [],
                        "name": "ServerFeignDeath",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ServerNeverSwitchOnPickup": {
                        "body": "{\n\tbNeverSwitchOnPickup = B;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ServerNeverSwitchOnPickup",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "ServerReStartGame": {
                        "body": "{\n\tLevel.Game.RestartGame();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ServerReStartGame",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ServerReStartPlayer": {
                        "body": "{\n\t\t//log(\"calling restartplayer in dying with netmode \"$Level.NetMode);\n\t\tif ( Level.NetMode == NM_Client )\n\t\t\treturn;\n\t\tif( Level.Game.RestartPlayer(self) )\n\t\t{\n\t\t\tServerTimeStamp = 0;\n\t\t\tTimeMargin = 0;\n\t\t\tEnemy = None;\n\t\t\tLevel.Game.StartPlayer(self);\n\t\t\tif ( Mesh != None )\n\t\t\t\tPlayWaiting();\n\t\t\tClientReStart();\n\t\t}\n\t\telse\n\t\t\tlog(\"Restartplayer failed\");\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ServerReStartPlayer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ServerSetHandedness": {
                        "body": "{\n\tHandedness = hand;\n\tif ( Weapon != None )\n\t{\n\t\tWeapon.SetHand(Handedness);\n\t\tif (( Level.NetMode != NM_Standalone ) && ( Role == ROLE_Authority ))\n\t\t\tWeapon.ClientSetHandedness(Handedness);\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ServerSetHandedness",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "hand"
                            ]
                        ],
                        "return": ""
                    },
                    "ServerSetSloMo": {
                        "body": "{\n\tif ( bAdmin || (Level.Netmode == NM_Standalone) )\n\t{\n\t\tLevel.Game.SetGameSpeed(T);\n\t\tLevel.Game.SaveConfig(); \n\t\tLevel.Game.GameReplicationInfo.SaveConfig();\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ServerSetSloMo",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "T"
                            ]
                        ],
                        "return": ""
                    },
                    "ServerSetWeaponPriority": {
                        "body": "{\n\n\tWeaponPriority[i] = WeaponName;\n\n\tfor ( inv=Inventory; inv!=None; inv=inv.inventory )\n\t\tif ( inv.class.name == WeaponName )\n\t\t\tWeapon(inv).SetSwitchPriority(self);\n}",
                        "locals": [
                            "local inventory inv;"
                        ],
                        "modifiers": [],
                        "name": "ServerSetWeaponPriority",
                        "native": false,
                        "param": [
                            [
                                "byte",
                                "i"
                            ],
                            [
                                "name",
                                "WeaponName"
                            ]
                        ],
                        "return": ""
                    },
                    "ServerTaunt": {
                        "body": "{\n\tPlayAnim(Sequence, 0.7, 0.2);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ServerTaunt",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "Sequence"
                            ]
                        ],
                        "return": ""
                    },
                    "ServerUpdateWeapons": {
                        "body": "{\n\n\tFor ( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )\n\t\tif ( Inv.IsA('Weapon') )\n\t\t\tWeapon(Inv).SetSwitchPriority(self); \n}",
                        "locals": [
                            "local inventory Inv;"
                        ],
                        "modifiers": [],
                        "name": "ServerUpdateWeapons",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SetAutoAim": {
                        "body": "{\n\tChangeAutoAim(F);\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetAutoAim",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "SetBob": {
                        "body": "{\n\tUpdateBob(F);\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetBob",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "SetDesiredFOV": {
                        "body": "{\n\tif( (F >= 80.0) || Level.bAllowFOV || bAdmin || (Level.Netmode==NM_Standalone) )\n\t{\n\t\tDefaultFOV = FClamp(F, 1, 170);\n\t\tDesiredFOV = DefaultFOV;\n\t\tSaveConfig();\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetDesiredFOV",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "SetDodgeClickTime": {
                        "body": "{\n\tChangeDodgeClickTime(F);\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetDodgeClickTime",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "SetFOVAngle": {
                        "body": "{\n\tFOVAngle = newFOV;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetFOVAngle",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "newFOV"
                            ]
                        ],
                        "return": ""
                    },
                    "SetFriction": {
                        "body": "{\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tForEach AllActors(class'ZoneInfo', Z)\n\t\tZ.ZoneGroundFriction = F;\n}",
                        "locals": [
                            "local ZoneInfo Z;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetFriction",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "SetHand": {
                        "body": "{\n\tChangeSetHand(S);\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetHand",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "SetJumpZ": {
                        "body": "{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tJumpZ = F;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetJumpZ",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "SetMaxMouseSmoothing": {
                        "body": "{\n\tbMaxMouseSmoothing = B;\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetMaxMouseSmoothing",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "SetMouseSmoothThreshold": {
                        "body": "{\n\tMouseSmoothThreshold = FClamp(F, 0, 0.1);\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetMouseSmoothThreshold",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "SetName": {
                        "body": "{\n\tChangeName(S);\n\tUpdateURL(\"Name\", S, true);\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetName",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "SetPause": {
                        "body": "{\n\treturn Level.Game.SetPause(bPause, self);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetPause",
                        "native": false,
                        "param": [
                            [
                                "BOOL",
                                "bPause"
                            ]
                        ],
                        "return": "bool"
                    },
                    "SetProgressColor": {
                        "body": "{\n\tif (Index < 8)\n\t\tProgressColor[Index] = C;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetProgressColor",
                        "native": false,
                        "param": [
                            [
                                "color",
                                "C"
                            ],
                            [
                                "int",
                                "Index"
                            ]
                        ],
                        "return": ""
                    },
                    "SetProgressMessage": {
                        "body": "{\n\tif (Index < 8)\n\t\tProgressMessage[Index] = S;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetProgressMessage",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "S"
                            ],
                            [
                                "int",
                                "Index"
                            ]
                        ],
                        "return": ""
                    },
                    "SetProgressTime": {
                        "body": "{\n\tProgressTimeOut = T + Level.TimeSeconds;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetProgressTime",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "T"
                            ]
                        ],
                        "return": ""
                    },
                    "SetSensitivity": {
                        "body": "{\n\tUpdateSensitivity(F);\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetSensitivity",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "SetSpeed": {
                        "body": "{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tGroundSpeed = Default.GroundSpeed * f;\n\tWaterSpeed = Default.WaterSpeed * f;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetSpeed",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "SetViewFlash": {
                        "body": "{\n\tbNoFlash = !B;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetViewFlash",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "SetWeaponStay": {
                        "body": "{\n\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\n\tLevel.Game.bCoopWeaponMode = B;\n\tForEach AllActors(class'Weapon', W)\n\t{\n\t\tW.bWeaponStay = false;\n\t\tW.SetWeaponStay();\n\t}\n}",
                        "locals": [
                            "local Weapon W;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SetWeaponStay",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "ShakeView": {
                        "body": "{\n\n\tshake.X = RollMag;\n\tshake.Y = 100 * shaketime;\n\tshake.Z = 100 * vertmag;\n\tClientShake(shake);\n}",
                        "locals": [
                            "local vector shake;"
                        ],
                        "modifiers": [],
                        "name": "ShakeView",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "shaketime"
                            ],
                            [
                                "float",
                                "RollMag"
                            ],
                            [
                                "float",
                                "vertmag"
                            ]
                        ],
                        "return": ""
                    },
                    "ShowInventory": {
                        "body": "{\n\t\n\tif( Weapon!=None )\n\t\tlog( \"   Weapon: \" $ Weapon.Class );\n\tfor( Inv=Inventory; Inv!=None; Inv=Inv.Inventory ) \n\t\tlog( \"Inv: \"$Inv $ \" state \"$Inv.GetStateName());\n\tif ( SelectedItem != None )\n\t\tlog( \"Selected Item\"@SelectedItem@\"Charge\"@SelectedItem.Charge );\n}",
                        "locals": [
                            "local Inventory Inv;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ShowInventory",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ShowLoadMenu": {
                        "body": "{\n\tShowMenu();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ShowLoadMenu",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ShowMenu": {
                        "body": "{\n\tWalkBob = vect(0,0,0);\n\tbShowMenu = true; // menu is responsible for turning this off\n\tPlayer.Console.GotoState('Menuing');\n\t\t\n\tif( Level.Netmode == NM_Standalone )\n\t\tSetPause(true);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ShowMenu",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ShowPath": {
                        "body": "{\n\t//find next path to remembered spot\n\tnode = FindPathTo(Destination);\n\tif (node != None)\n\t{\n\t\tlog(\"found path\");\n\t\tSpawn(class 'WayBeacon', self, '', node.location);\n\t}\n\telse\n\t\tlog(\"didn't find path\");\n}",
                        "locals": [
                            "local Actor node;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ShowPath",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ShowProgress": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ShowProgress",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ShowSpecialMenu": {
                        "body": "{\n\n\taMenuClass = class<menu>( DynamicLoadObject( ClassName, class'Class' ) );\n\tif( aMenuClass!=None )\n\t{\n\t\tbSpecialMenu = true;\n\t\tSpecialMenu = aMenuClass;\n\t\tShowMenu();\n\t}\n}",
                        "locals": [
                            "local class<menu> aMenuClass;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ShowSpecialMenu",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "ClassName"
                            ]
                        ],
                        "return": ""
                    },
                    "ShowUpgradeMenu": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ShowUpgradeMenu",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SloMo": {
                        "body": "{\n\t// DEUS_EX CNN - This needs to be here!\n\tif (!bCheatsEnabled)\n\t\treturn;\n\n\tServerSetSloMo(T);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SloMo",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "T"
                            ]
                        ],
                        "return": ""
                    },
                    "SnapView": {
                        "body": "{\n\tChangeSnapView(B);\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SnapView",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "SpawnCarcass": {
                        "body": "{\n\n\tcarc = Spawn(CarcassType);\n\tif ( carc == None )\n\t\treturn None;\n\tcarc.Initfor(self);\n\tif (Player != None)\n\t\tcarc.bPlayerCarcass = true;\n\tif ( !Level.Game.bGameEnded && (Carcass(ViewTarget) == None) )\n\t\tViewTarget = carc; //for Player 3rd person views\n\treturn carc;\n}",
                        "locals": [
                            "local carcass carc;"
                        ],
                        "modifiers": [],
                        "name": "SpawnCarcass",
                        "native": false,
                        "param": [],
                        "return": "Carcass"
                    },
                    "SpawnGibbedCarcass": {
                        "body": "{\n\n\tcarc = Spawn(CarcassType);\n\tif ( carc != None )\n\t{\n\t\tcarc.Initfor(self);\n\t\tcarc.ChunkUp(-1 * Health);\n\t}\n}",
                        "locals": [
                            "local carcass carc;"
                        ],
                        "modifiers": [],
                        "name": "SpawnGibbedCarcass",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Speech": {
                        "body": "{\n\n\tV = Spawn( PlayerReplicationInfo.VoiceType, Self );\n\tif (V != None)\n\t\tV.PlayerSpeech( Type, Index, Callsign );\n}",
                        "locals": [
                            "local VoicePack V;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Speech",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Type"
                            ],
                            [
                                "int",
                                "Index"
                            ],
                            [
                                "int",
                                "Callsign"
                            ]
                        ],
                        "return": ""
                    },
                    "StairLook": {
                        "body": "{\n\tChangeStairLook(B);\n\tSaveConfig();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "StairLook",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "StartWalk": {
                        "body": "{\n\tUnderWaterTime = Default.UnderWaterTime;\t\n\tSetCollision(true, true , true);\n\tSetPhysics(PHYS_Walking);\n\tbCollideWorld = true;\n\tClientReStart();\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StartWalk",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StartZoom": {
                        "body": "{\n\tZoomLevel = 0.0;\n\tbZooming = true;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StartZoom",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StopZoom": {
                        "body": "{\n\tbZooming = false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StopZoom",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Suicide": {
                        "body": "{\n\t}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Suicide",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Summon": {
                        "body": "{\n\tif( !bCheatsEnabled )\n\t\treturn;\n\tif( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\tlog( \"Fabricate \" $ ClassName );\n\tNewClass = class<actor>( DynamicLoadObject( ClassName, class'Class' ) );\n\tif( NewClass!=None )\n\t\t// DEUS_EX STM\n\t\t//Spawn( NewClass,,,Location + 72 * Vector(Rotation) + vect(0,0,1) * 15 );\n\t\tSpawn( NewClass,,,Location + (CollisionRadius+NewClass.Default.CollisionRadius+30) * Vector(Rotation) + vect(0,0,1) * 15 );\n}",
                        "locals": [
                            "local class<actor> NewClass;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Summon",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "ClassName"
                            ]
                        ],
                        "return": ""
                    },
                    "SwimAnimUpdate": {
                        "body": "{\n\tif ( !bAnimTransition && (GetAnimGroup(AnimSequence) != 'Gesture') )\n\t{\n\t\tif ( bNotForward )\n\t \t{\n\t\t \t if ( GetAnimGroup(AnimSequence) != 'Waiting' )\n\t\t\t\tTweenToWaiting(0.1);\n\t\t}\n\t\telse if ( GetAnimGroup(AnimSequence) == 'Waiting' )\n\t\t\tTweenToSwimming(0.1);\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SwimAnimUpdate",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "bNotForward"
                            ]
                        ],
                        "return": ""
                    },
                    "SwitchCoopLevel": {
                        "body": "{\n\tif( bAdmin || Level.NetMode==NM_Standalone || Level.netMode==NM_ListenServer )\n\t\tLevel.ServerTravel( URL, true );\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SwitchCoopLevel",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "URL"
                            ]
                        ],
                        "return": ""
                    },
                    "SwitchLevel": {
                        "body": "{\n\tif( bAdmin || Level.NetMode==NM_Standalone || Level.netMode==NM_ListenServer )\n\t\tLevel.ServerTravel( URL, false );\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SwitchLevel",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "URL"
                            ]
                        ],
                        "return": ""
                    },
                    "SwitchWeapon": {
                        "body": "{\n\n\tif ( bShowMenu || Level.Pauser!=\"\" )\n\t{\n\t\tif ( myHud != None )\n\t\t\tmyHud.InputNumber(F);\n\t\treturn;\n\t}\n\tif ( Inventory == None )\n\t\treturn;\n\tif ( (Weapon != None) && (Weapon.Inventory != None) )\n\t\tnewWeapon = Weapon.Inventory.WeaponChange(F);\n\telse\n\t\tnewWeapon = None;\t\n\tif ( newWeapon == None )\n\t\tnewWeapon = Inventory.WeaponChange(F);\n\tif ( newWeapon == None )\n\t\treturn;\n\n\tif ( Weapon == None )\n\t{\n\t\tPendingWeapon = newWeapon;\n\t\tChangedWeapon();\n\t}\n\telse if ( Weapon != newWeapon )\n\t{\n\t\tPendingWeapon = newWeapon;\n\t\tif ( !Weapon.PutDown() )\n\t\t\tPendingWeapon = None;\n\t}\n}",
                        "locals": [
                            "local weapon newWeapon;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SwitchWeapon",
                        "native": false,
                        "param": [
                            [
                                "byte",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "Taunt": {
                        "body": "{\n\t\tif ( Health > 0 )\n\t\t\tGlobal.Taunt(Sequence);\n\t}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Taunt",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "Sequence"
                            ]
                        ],
                        "return": ""
                    },
                    "TeamMessage": {
                        "body": "{\n\tif (Player.Console != None)\n\t\tPlayer.Console.Message ( PRI, S, Type );\n\tif (bBeep && bMessageBeep)\n\t\tPlayBeepSound();\n\tif ( myHUD != None )\n\t\tmyHUD.Message( PRI, S, Type );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TeamMessage",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "PRI"
                            ],
                            [
                                "coerce",
                                "string",
                                "S"
                            ],
                            [
                                "name",
                                "Type"
                            ],
                            [
                                "optional",
                                "bool",
                                "bBeep"
                            ]
                        ],
                        "return": ""
                    },
                    "ThrowWeapon": {
                        "body": "{\n\t}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ThrowWeapon",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\t\tbFrozen = false;\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ToggleZoom": {
                        "body": "{\n\tif ( DefaultFOV != DesiredFOV )\n\t\tEndZoom();\n\telse\n\t\tStartZoom();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ToggleZoom",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TravelPostAccept": {
                        "body": "{\n\tif ( Health <= 0 )\n\t\tHealth = Default.Health;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TravelPostAccept",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Type": {
                        "body": "{\n\tif (!bCheatsEnabled)\n\t\treturn;\n\n\tPlayer.Console.TypedStr=\"\";\n\tPlayer.Console.GotoState( 'Typing' );\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Type",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Typing": {
                        "body": "{\n\tbIsTyping = bTyping;\n\tif (bTyping)\n\t{\n\t\tif (Level.Game.WorldLog != None)\n\t\t\tLevel.Game.WorldLog.LogTypingEvent(True, Self);\n\t\tif (Level.Game.LocalLog != None)\n\t\t\tLevel.Game.LocalLog.LogTypingEvent(True, Self);\n\t\tPlayChatting();\n\t} \n\telse \n\t{\n\t\tif (Level.Game.WorldLog != None)\n\t\t\tLevel.Game.WorldLog.LogTypingEvent(False, Self);\n\t\tif (Level.Game.LocalLog != None)\n\t\t\tLevel.Game.LocalLog.LogTypingEvent(False, Self);\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Typing",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "bTyping"
                            ]
                        ],
                        "return": ""
                    },
                    "UnPossess": {
                        "body": "{\n\tlog(Self$\" being unpossessed\");\n\tif ( myHUD != None )\n\t\tmyHUD.Destroy();\n\tbIsPlayer = false;\n\tEyeHeight = 0.8 * CollisionHeight;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UnPossess",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "UpdateBob": {
                        "body": "{\n\tBob = FClamp(F,0,0.032);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateBob",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "UpdateEyeHeight": {
                        "body": "{\n\t\t\n\t\t// smooth up/down stairs\n\t\tif( !bJustLanded )\n\t\t{\n\t\t\tsmooth = FMin(1.0, 10.0 * DeltaTime/Level.TimeDilation);\n\t\t\tEyeHeight = (EyeHeight - Location.Z + OldLocation.Z) * (1 - smooth) + ( ShakeVert + BaseEyeHeight) * smooth;\n\t\t\tbound = -0.5 * CollisionHeight;\n\t\t\tif (EyeHeight < bound)\n\t\t\t\tEyeHeight = bound;\n\t\t\telse\n\t\t\t{\n\t\t\t\tbound = CollisionHeight + FClamp((OldLocation.Z - Location.Z), 0.0, MaxStepHeight); \n\t\t\t\t if ( EyeHeight > bound )\n\t\t\t\t\tEyeHeight = bound;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsmooth = FClamp(10.0 * DeltaTime/Level.TimeDilation, 0.35, 1.0);\n\t\t\tbJustLanded = false;\n\t\t\tEyeHeight = EyeHeight * ( 1 - smooth) + (BaseEyeHeight + ShakeVert) * smooth;\n\t\t}\n\n\t\t// teleporters affect your FOV, so adjust it back down\n\t\tif ( FOVAngle != DesiredFOV )\n\t\t{\n\t\t\tif ( FOVAngle > DesiredFOV )\n\t\t\t\tFOVAngle = FOVAngle - FMax(7, 0.9 * DeltaTime * (FOVAngle - DesiredFOV)); \n\t\t\telse \n\t\t\t\tFOVAngle = FOVAngle - FMin(-7, 0.9 * DeltaTime * (FOVAngle - DesiredFOV)); \n\t\t\tif ( Abs(FOVAngle - DesiredFOV) <= 10 )\n\t\t\t\tFOVAngle = DesiredFOV;\n\t\t}\n\n\t\t// adjust FOV for weapon zooming\n\t\tif ( bZooming )\n\t\t{\t\n\t\t\tZoomLevel += DeltaTime * 1.0;\n\t\t\tif (ZoomLevel > 0.9)\n\t\t\t\tZoomLevel = 0.9;\n\t\t\tDesiredFOV = FClamp(90.0 - (ZoomLevel * 88.0), 1, 170);\n\t\t} \n\t}",
                        "locals": [
                            "local float smooth, bound;"
                        ],
                        "modifiers": [],
                        "name": "UpdateEyeHeight",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "UpdateRotation": {
                        "body": "{\n\t\n\tDesiredRotation = ViewRotation; //save old rotation\n\tViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;\n\tViewRotation.Pitch = ViewRotation.Pitch & 65535;\n\tIf ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))\n\t{\n\t\tIf (aLookUp > 0) \n\t\t\tViewRotation.Pitch = 18000;\n\t\telse\n\t\t\tViewRotation.Pitch = 49152;\n\t}\n\tViewRotation.Yaw += 32.0 * DeltaTime * aTurn;\n\tViewShake(deltaTime);\n\tViewFlash(deltaTime);\n\t\t\n\tnewRotation = Rotation;\n\tnewRotation.Yaw = ViewRotation.Yaw;\n\tnewRotation.Pitch = ViewRotation.Pitch;\n\tIf ( (newRotation.Pitch > maxPitch * RotationRate.Pitch) && (newRotation.Pitch < 65536 - maxPitch * RotationRate.Pitch) )\n\t{\n\t\tIf (ViewRotation.Pitch < 32768) \n\t\t\tnewRotation.Pitch = maxPitch * RotationRate.Pitch;\n\t\telse\n\t\t\tnewRotation.Pitch = 65536 - maxPitch * RotationRate.Pitch;\n\t}\n    // added to keep the player's model from pitching or rolling - DEUS_EX CNN\n\tnewRotation.Pitch = 0;\n\tnewRotation.Roll = 0;\n\n\tsetRotation(newRotation);\n}",
                        "locals": [
                            "local rotator newRotation;"
                        ],
                        "modifiers": [],
                        "name": "UpdateRotation",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ],
                            [
                                "float",
                                "maxPitch"
                            ]
                        ],
                        "return": ""
                    },
                    "UpdateSensitivity": {
                        "body": "{\n\tMouseSensitivity = FMax(0,F);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateSensitivity",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "UpdateURL": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "UpdateURL",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "NewOption"
                            ],
                            [
                                "string",
                                "NewValue"
                            ],
                            [
                                "bool",
                                "bSaveDefault"
                            ]
                        ],
                        "return": ""
                    },
                    "UpdateWeaponPriorities": {
                        "body": "{\n\n\t// send new priorities to server\n\tif ( Level.Netmode == NM_Client )\n\t\tfor ( i=0; i<ArrayCount(WeaponPriority); i++ )\n\t\t\tServerSetWeaponPriority(i, WeaponPriority[i]);\n}",
                        "locals": [
                            "local byte i;"
                        ],
                        "modifiers": [],
                        "name": "UpdateWeaponPriorities",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "VelocityChanged": {
                        "body": "{\n\n   OldSize = VSize(OldVel);\n   NewSize = VSize(NewVel);\n\n   // If both are tiny, just return (also handles zero case where the normal is zero).\n   if ((OldSize < 1) && (NewSize < 1))\n   {\n      return false;\n   }\n\n   if (OldSize > 1.1 * NewSize)\n      return true;\n\n   if (NewSize > 1.1 * OldSize)\n      return true;\n\n   NormDot = Normal(OldVel) dot Normal(NewVel);\n\n   // if they are close to each other, don't bother with the update.\n   return (NormDot < 0.99);\n}",
                        "locals": [
                            "local float NormDot, OldSize, NewSize;"
                        ],
                        "modifiers": [],
                        "name": "VelocityChanged",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "OldVel"
                            ],
                            [
                                "vector",
                                "NewVel"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ViewClass": {
                        "body": "{\n\t}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ViewClass",
                        "native": false,
                        "param": [
                            [
                                "class<actor>",
                                "aClass"
                            ],
                            [
                                "optional",
                                "bool",
                                "bQuiet"
                            ]
                        ],
                        "return": ""
                    },
                    "ViewFlash": {
                        "body": "{\n\n\tif ( bNoFlash )\n\t{\n\t\tInstantFlash = 0;\n\t\tInstantFog = vect(0,0,0);\n\t}\n\n\tdelta = FMin(0.1, DeltaTime);\n\tgoalScale = 1 + DesiredFlashScale + ConstantGlowScale + HeadRegion.Zone.ViewFlash.X; \n\tgoalFog = DesiredFlashFog + ConstantGlowFog + HeadRegion.Zone.ViewFog;\n\tDesiredFlashScale -= DesiredFlashScale * 2 * delta;  \n\tDesiredFlashFog -= DesiredFlashFog * 2 * delta;\n\tFlashScale.X += (goalScale - FlashScale.X + InstantFlash) * 10 * delta;\n\tFlashFog += (goalFog - FlashFog + InstantFog) * 10 * delta;\n\tInstantFlash = 0;\n\tInstantFog = vect(0,0,0);\n\n\tif ( FlashScale.X > 0.981 )\n\t\tFlashScale.X = 1;\n\tFlashScale = FlashScale.X * vect(1,1,1);\n\n\tif ( FlashFog.X < 0.019 )\n\t\tFlashFog.X = 0;\n\tif ( FlashFog.Y < 0.019 )\n\t\tFlashFog.Y = 0;\n\tif ( FlashFog.Z < 0.019 )\n\t\tFlashFog.Z = 0;\n}",
                        "locals": [
                            "local vector goalFog;",
                            "local float goalscale, delta;"
                        ],
                        "modifiers": [],
                        "name": "ViewFlash",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "ViewPlayer": {
                        "body": "{\n\t}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ViewPlayer",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "ViewPlayerNum": {
                        "body": "{\n\n\tif ( !PlayerReplicationInfo.bIsSpectator && !Level.Game.bTeamGame )\n\t\treturn;\n\tif ( num >= 0 )\n\t{\n\t\tP = Pawn(ViewTarget);\n\t\tif ( (P != None) && P.bIsPlayer && (P.PlayerReplicationInfo.TeamID == num) )\n\t\t{\n\t\t\tViewTarget = None;\n\t\t\tbBehindView = false;\n\t\t\treturn;\n\t\t}\n\t\tfor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t\t\tif ( P.bIsPlayer && (P.PlayerReplicationInfo.Team == PlayerReplicationInfo.Team)\n\t\t\t\t&& !P.PlayerReplicationInfo.bIsSpectator\n\t\t\t\t&& (P.PlayerReplicationInfo.TeamID == num) )\n\t\t\t{\n\t\t\t\tif ( P != self )\n\t\t\t\t{\n\t\t\t\t\tViewTarget = P;\n\t\t\t\t\tbBehindView = true;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\treturn;\n\t}\n\tif ( Role == ROLE_Authority )\n\t{\n\t\tViewClass(class'Pawn', true);\n\t\tWhile ( (ViewTarget != None) \n\t\t\t\t&& (!Pawn(ViewTarget).bIsPlayer || Pawn(ViewTarget).PlayerReplicationInfo.bIsSpectator) )\n\t\t\tViewClass(class'Pawn', true);\n\n\t\tif ( ViewTarget != None )\n\t\t\tClientMessage(ViewingFrom@Pawn(ViewTarget).PlayerReplicationInfo.PlayerName, 'Event', true);\n\t\telse\n\t\t\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n\t}\n}",
                        "locals": [
                            "local Pawn P;"
                        ],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ViewPlayerNum",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "int",
                                "num"
                            ]
                        ],
                        "return": ""
                    },
                    "ViewSelf": {
                        "body": "{\n\tbBehindView = false;\n\tViewtarget = None;\n\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ViewSelf",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ViewShake": {
                        "body": "{\n\tif (shaketimer > 0.0) //shake view\n\t{\n\t\tshaketimer -= DeltaTime;\n\t\tif ( verttimer == 0 )\n\t\t{\n\t\t\tverttimer = 0.1;\n\t\t\tShakeVert = -1.1 * maxshake;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tverttimer -= DeltaTime;\n\t\t\tif ( verttimer < 0 )\n\t\t\t{\n\t\t\t\tverttimer = 0.2 * FRand();\n\t\t\t\tshakeVert = (2 * FRand() - 1) * maxshake;  \n\t\t\t}\n\t\t}\n\t\tViewRotation.Roll = ViewRotation.Roll & 65535;\n\t\tif (bShakeDir)\n\t\t{\n\t\t\tViewRotation.Roll += Int( 10 * shakemag * FMin(0.1, DeltaTime));\n\t\t\tbShakeDir = (ViewRotation.Roll > 32768) || (ViewRotation.Roll < (0.5 + FRand()) * shakemag);\n\t\t\tif ( (ViewRotation.Roll < 32768) && (ViewRotation.Roll > 1.3 * shakemag) )\n\t\t\t{\n\t\t\t\tViewRotation.Roll = 1.3 * shakemag;\n\t\t\t\tbShakeDir = false;\n\t\t\t}\n\t\t\telse if (FRand() < 3 * DeltaTime)\n\t\t\t\tbShakeDir = !bShakeDir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tViewRotation.Roll -= Int( 10 * shakemag * FMin(0.1, DeltaTime));\n\t\t\tbShakeDir = (ViewRotation.Roll > 32768) && (ViewRotation.Roll < 65535 - (0.5 + FRand()) * shakemag);\n\t\t\tif ( (ViewRotation.Roll > 32768) && (ViewRotation.Roll < 65535 - 1.3 * shakemag) )\n\t\t\t{\n\t\t\t\tViewRotation.Roll = 65535 - 1.3 * shakemag;\n\t\t\t\tbShakeDir = true;\n\t\t\t}\n\t\t\telse if (FRand() < 3 * DeltaTime)\n\t\t\t\tbShakeDir = !bShakeDir;\n\t\t}\n\t}\n\telse\n\t{\n\t\tShakeVert = 0;\n\t\tViewRotation.Roll = ViewRotation.Roll & 65535;\n\t\tif (ViewRotation.Roll < 32768)\n\t\t{\n\t\t\tif ( ViewRotation.Roll > 0 )\n\t\t\t\tViewRotation.Roll = Max(0, ViewRotation.Roll - (Max(ViewRotation.Roll,500) * 10 * FMin(0.1,DeltaTime)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tViewRotation.Roll += ((65536 - Max(500,ViewRotation.Roll)) * 10 * FMin(0.1,DeltaTime));\n\t\t\tif ( ViewRotation.Roll > 65534 )\n\t\t\t\tViewRotation.Roll = 0;\n\t\t}\n\t} \n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ViewShake",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "Walk": {
                        "body": "{\t\n\tif ( !bAdmin && (Level.Netmode != NM_Standalone) )\n\t\treturn;\n\n\tStartWalk();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Walk",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ZoneChange": {
                        "body": "{\n\n\t\tif (!NewZone.bWaterZone)\n\t\t{\n\t\t\tSetPhysics(PHYS_Falling);\n\t\t\tif (bUpAndOut && CheckWaterJump(HitNormal)) //check for waterjump\n\t\t\t{\n\t\t\t\tvelocity.Z = 330 + 2 * CollisionRadius; //set here so physics uses this for remainder of tick\n\t\t\t\tPlayDuck();\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t}\t\t\t\t\n\t\t\telse if (!FootRegion.Zone.bWaterZone || (Velocity.Z > 160) )\n\t\t\t{\n\t\t\t\tGotoState('PlayerWalking');\n\t\t\t\tAnimEnd();\n\t\t\t}\n\t\t\telse //check if in deep water\n\t\t\t{\n\t\t\t\tcheckpoint = Location;\n\t\t\t\tcheckpoint.Z -= (CollisionHeight + 6.0);\n\t\t\t\tHitActor = Trace(HitLocation, HitNormal, checkpoint, Location, false);\n\t\t\t\tif (HitActor != None)\n\t\t\t\t{\n\t\t\t\t\tGotoState('PlayerWalking');\n\t\t\t\t\tAnimEnd();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tEnable('Timer');\n\t\t\t\t\tSetTimer(0.7,false);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//log(\"Out of water\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDisable('Timer');\n\t\t\tSetPhysics(PHYS_Swimming);\n\t\t}\n\t}",
                        "locals": [
                            "local actor HitActor;",
                            "local vector HitLocation, HitNormal, checkpoint;"
                        ],
                        "modifiers": [],
                        "name": "ZoneChange",
                        "native": false,
                        "param": [
                            [
                                "ZoneInfo",
                                "NewZone"
                            ]
                        ],
                        "return": ""
                    },
                    "damageAttitudeTo": {
                        "body": "{\n\tif ( Other != Self )\n\t\tEnemy = Other;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "damageAttitudeTo",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 4974,
                "replication": "",
                "states": [],
                "variables": [
                    "var const player Player;",
                    "var(Movement) globalconfig float\tDodgeClickTime;",
                    "var(Movement) globalconfig float Bob;",
                    "var float bobtime;",
                    "var int ShowFlags;",
                    "var int RendMap;",
                    "var int Misc1;",
                    "var int Misc2;",
                    "var actor ViewTarget;",
                    "var vector FlashScale, FlashFog;",
                    "var HUD\tmyHUD;",
                    "var ScoreBoard Scoring;",
                    "var class<hud> HUDType;",
                    "var class<scoreboard> ScoringType;",
                    "var float DesiredFlashScale, ConstantGlowScale, InstantFlash;",
                    "var vector DesiredFlashFog, ConstantGlowFog, InstantFog;",
                    "var globalconfig float DesiredFOV;",
                    "var globalconfig float DefaultFOV;",
                    "var music Song;",
                    "var byte  SongSection;",
                    "var byte  CdTrack;",
                    "var EMusicTransition Transition;",
                    "var float shaketimer; // player uses this for shaking view",
                    "var int shakemag;\t// max magnitude in degrees of shaking",
                    "var float shakevert; // max vertical shake magnitude",
                    "var float maxshake;",
                    "var float verttimer;",
                    "var(Pawn) class<carcass> CarcassType;",
                    "var travel float MyAutoAim;",
                    "var travel globalconfig float Handedness;",
                    "var(Sounds) sound JumpSound;",
                    "var bool\t\tbAdmin;",
                    "var() globalconfig bool \t\tbLookUpStairs;\t// look up/down stairs (player)",
                    "var() globalconfig bool\t\tbSnapToLevel;\t// Snap to level eyeheight when not mouselooking",
                    "var() globalconfig bool\t\tbAlwaysMouseLook;",
                    "var globalconfig bool \t\tbKeyboardLook;\t// no snapping when true",
                    "var bool\t\tbWasForward;\t// used for dodge move",
                    "var bool\t\tbWasBack;",
                    "var bool\t\tbWasLeft;",
                    "var bool\t\tbWasRight;",
                    "var bool\t\tbEdgeForward;",
                    "var bool\t\tbEdgeBack;",
                    "var bool\t\tbEdgeLeft;",
                    "var bool \t\tbEdgeRight;",
                    "var bool\t\tbIsCrouching;",
                    "var bool\t\tbAnimTransition;",
                    "var bool\t\tbIsTurning;",
                    "var bool\t\tbFrozen;",
                    "var bool        bBadConnectionAlert;",
                    "var globalconfig bool\tbInvertMouse;",
                    "var bool\t\tbShowScores;",
                    "var bool\t\tbShowMenu;",
                    "var bool\t\tbSpecialMenu;",
                    "var bool\t\tbWokeUp;",
                    "var bool\t\tbPressedJump;",
                    "var bool\t\tbUpdatePosition;",
                    "var bool\t\tbDelayedCommand;",
                    "var bool\t\tbRising;",
                    "var bool\t\tbReducedVis;",
                    "var bool\t\tbCenterView;",
                    "var() globalconfig bool bMaxMouseSmoothing;",
                    "var bool\t\tbMouseZeroed;",
                    "var bool\t\tbReadyToPlay;",
                    "var bool bNoFlash;",
                    "var globalconfig bool bNoVoices;",
                    "var globalconfig bool bMessageBeep;",
                    "var bool\t\tbZooming;",
                    "var() bool\t\tbSinglePlayer;\t\t// this class allowed in single player",
                    "var bool\t\tbJustFired;",
                    "var bool\t\tbJustAltFired;",
                    "var bool\t\tbIsTyping;",
                    "var bool\t\tbFixedCamera;",
                    "var globalconfig bool\tbNeverAutoSwitch;\t// if true, don't automatically switch to picked up weapon",
                    "var bool\t\tbJumpStatus;\t// used in net games",
                    "var bool\t\tbCheatsEnabled;  // DEUS_EX STM - added globalconfig (CNN - removed for command line cheats)",
                    "var float\t\tZoomLevel;",
                    "var const Actor   AdditionalViews[3]; // If the pawn can see from the point of view of any additional actors.",
                    "var class<menu> SpecialMenu;",
                    "var string DelayedCommand;",
                    "var globalconfig float\tMouseSensitivity;",
                    "var globalconfig name\tWeaponPriority[20]; //weapon class priorities (9 is highest)",
                    "var float SmoothMouseX, SmoothMouseY, BorrowedMouseX, BorrowedMouseY;",
                    "var() globalconfig float MouseSmoothThreshold;",
                    "var float MouseZeroTime;",
                    "var input float",
                    "var SavedMove SavedMoves;",
                    "var SavedMove FreeMoves;",
                    "var SavedMove PendingMove;",
                    "var float CurrentTimeStamp,LastUpdateTime,ServerTimeStamp,TimeMargin, ClientUpdateTime;",
                    "var globalconfig float MaxTimeMargin;",
                    "var string ProgressMessage[8];",
                    "var color ProgressColor[8];",
                    "var float ProgressTimeOut;",
                    "var localized string QuickSaveString;",
                    "var localized string NoPauseMessage;",
                    "var localized string ViewingFrom;",
                    "var localized string OwnCamera;",
                    "var localized string FailedView;",
                    "var GameReplicationInfo GameReplicationInfo;",
                    "var() globalconfig string ngWorldSecret;",
                    "var() globalconfig bool ngSecretSet;",
                    "var rotator TargetViewRotation;",
                    "var float TargetEyeHeight;",
                    "var vector TargetWeaponViewOffset;",
                    "var int DemoViewPitch;",
                    "var int DemoViewYaw;",
                    "var float LastPlaySound;",
                    "var float TurnRateAdjuster;"
                ]
            }
        },
        "PlayerReplicationInfo.uc": {
            "body": "//=============================================================================\n// PlayerReplicationInfo.\n//=============================================================================\nclass PlayerReplicationInfo expands ReplicationInfo\n\tnative nativereplication;\n\nvar string\t\t\t\tPlayerName;\t\t// Player name, or blank if none.\nvar string\t\t\t\tOldName;\t\t// Temporary value.\nvar int\t\t\t\t\tPlayerID;\t\t// Unique id number.\nvar string\t\t\t\tTeamName;\t\t// Team name, or blank if none.\nvar byte\t\t\t\tTeam;\t\t\t// Player Team, 255 = None for player.\nvar int\t\t\t\t\tTeamID;\t\t\t// Player position in team.\nvar float\t\t\t\tScore;\t\t\t// Player's current score.\nvar float\t\t\t\tDeaths;\t\t\t// Number of player's deaths.\nvar class<VoicePack>\tVoiceType;\nvar Decoration\t\t\tHasFlag;\nvar int\t\t\t\t\tPing;\nvar byte\t\t\t\tPacketLoss;\nvar bool\t\t\t\tbIsFemale;\nvar\tbool\t\t\t\tbIsABot;\nvar bool\t\t\t\tbFeigningDeath;\nvar bool\t\t\t\tbIsSpectator;\nvar bool\t\t\t\tbWaitingPlayer;\nvar bool\t\t\t\tbAdmin;\nvar Texture\t\t\t\tTalkTexture;\nvar ZoneInfo\t\t\tPlayerZone;\nvar LocationID\t\t\tPlayerLocation;\n\n// Time elapsed.\nvar int\t\t\t\t\tStartTime;\nvar int\t\t\t\t\tTimeAcc;\n\n// DXMP MBCODE : Keep track of streak as well\nvar float\t\t\t\tStreak;\n\nreplication\n{\n\t// Things the server should send to the client.\n\treliable if ( Role == ROLE_Authority )\n\t\tPlayerName, OldName, PlayerID, TeamName, Team, TeamID, Score, Deaths, VoiceType, Streak,\n\t\tHasFlag, Ping, PacketLoss, bIsFemale, bIsABot, bFeigningDeath, bIsSpectator, bWaitingPlayer,\n\t\tbAdmin, TalkTexture, PlayerZone, PlayerLocation, StartTime;\n}\n\nfunction PostBeginPlay()\n{\n\tStartTime = Level.TimeSeconds;\n\tTimer();\n\tSetTimer(2.0, true);\n\tbIsFemale = Pawn(Owner).bIsFemale;\n}\n \t\t\t\t\t\nfunction Timer()\n{\n\tlocal float MinDist, Dist;\n\tlocal LocationID L;\n\n\tMinDist = 1000000;\n\tPlayerLocation = None;\n\tif ( PlayerZone != None )\n\t\tfor ( L=PlayerZone.LocationID; L!=None; L=L.NextLocation )\n\t\t{\n\t\t\tDist = VSize(Owner.Location - L.Location);\n\t\t\tif ( (Dist < L.Radius) && (Dist < MinDist) )\n\t\t\t{\n\t\t\t\tPlayerLocation = L;\n\t\t\t\tMinDist = Dist;\n\t\t\t}\n\t\t}\n\tif ( FRand() < 0.65 )\n\t\treturn;\n\n\tif (PlayerPawn(Owner) != None)\n\t\tPing = int(PlayerPawn(Owner).ConsoleCommand(\"GETPING\"));\n\n\tif (PlayerPawn(Owner) != None)\n\t\tPacketLoss = int(PlayerPawn(Owner).ConsoleCommand(\"GETLOSS\"));\n}\n\ndefaultproperties\n{\n     Team=255\n     NetUpdateFrequency=5.000000\n}\n",
            "name": "PlayerReplicationInfo.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Team=255",
                    "NetUpdateFrequency=5.000000"
                ],
                "exec": [],
                "extends": "ReplicationInfo",
                "functions": {
                    "PostBeginPlay": {
                        "body": "{\n\tStartTime = Level.TimeSeconds;\n\tTimer();\n\tSetTimer(2.0, true);\n\tbIsFemale = Pawn(Owner).bIsFemale;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\n\tMinDist = 1000000;\n\tPlayerLocation = None;\n\tif ( PlayerZone != None )\n\t\tfor ( L=PlayerZone.LocationID; L!=None; L=L.NextLocation )\n\t\t{\n\t\t\tDist = VSize(Owner.Location - L.Location);\n\t\t\tif ( (Dist < L.Radius) && (Dist < MinDist) )\n\t\t\t{\n\t\t\t\tPlayerLocation = L;\n\t\t\t\tMinDist = Dist;\n\t\t\t}\n\t\t}\n\tif ( FRand() < 0.65 )\n\t\treturn;\n\n\tif (PlayerPawn(Owner) != None)\n\t\tPing = int(PlayerPawn(Owner).ConsoleCommand(\"GETPING\"));\n\n\tif (PlayerPawn(Owner) != None)\n\t\tPacketLoss = int(PlayerPawn(Owner).ConsoleCommand(\"GETLOSS\"));\n}",
                        "locals": [
                            "local float MinDist, Dist;",
                            "local LocationID L;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 85,
                "replication": "",
                "states": [],
                "variables": [
                    "var string\t\t\t\tPlayerName;\t\t// Player name, or blank if none.",
                    "var string\t\t\t\tOldName;\t\t// Temporary value.",
                    "var int\t\t\t\t\tPlayerID;\t\t// Unique id number.",
                    "var string\t\t\t\tTeamName;\t\t// Team name, or blank if none.",
                    "var byte\t\t\t\tTeam;\t\t\t// Player Team, 255 = None for player.",
                    "var int\t\t\t\t\tTeamID;\t\t\t// Player position in team.",
                    "var float\t\t\t\tScore;\t\t\t// Player's current score.",
                    "var float\t\t\t\tDeaths;\t\t\t// Number of player's deaths.",
                    "var class<VoicePack>\tVoiceType;",
                    "var Decoration\t\t\tHasFlag;",
                    "var int\t\t\t\t\tPing;",
                    "var byte\t\t\t\tPacketLoss;",
                    "var bool\t\t\t\tbIsFemale;",
                    "var bool\t\t\t\tbFeigningDeath;",
                    "var bool\t\t\t\tbIsSpectator;",
                    "var bool\t\t\t\tbWaitingPlayer;",
                    "var bool\t\t\t\tbAdmin;",
                    "var Texture\t\t\t\tTalkTexture;",
                    "var ZoneInfo\t\t\tPlayerZone;",
                    "var LocationID\t\t\tPlayerLocation;",
                    "var int\t\t\t\t\tStartTime;",
                    "var int\t\t\t\t\tTimeAcc;",
                    "var float\t\t\t\tStreak;"
                ]
            }
        },
        "PlayerStart.uc": {
            "body": "//=============================================================================\n// Player start location.\n//=============================================================================\nclass PlayerStart extends NavigationPoint \n\tnative;\n\n#exec Texture Import File=Textures\\S_Player.pcx Name=S_Player Mips=Off Flags=2\n\n// Players on different teams are not spawned in areas with the\n// same TeamNumber unless there are more teams in the level than\n// team numbers.\nvar() byte TeamNumber;\nvar() bool bSinglePlayerStart;\nvar() bool bTeamOnlyStart;\nvar() bool bNonTeamOnlyStart;\nvar() bool bCoopStart;\t\t\nvar() bool bEnabled; \n\nfunction Trigger( actor Other, pawn EventInstigator )\n{\n\tbEnabled = !bEnabled;\n}\n\nfunction PlayTeleportEffect(actor Incoming, bool bOut)\n{\n\tif ( Level.Game.bDeathMatch && Incoming.IsA('PlayerPawn') )\n\t\tPlayerPawn(Incoming).SetFOVAngle(135);\n\tLevel.Game.PlayTeleportEffect(Incoming, bOut, Level.Game.bDeathMatch );\n}\n\ndefaultproperties\n{\n     bSinglePlayerStart=True\n     bCoopStart=True\n     bEnabled=True\n     bDirectional=True\n     Texture=Texture'Engine.S_Player'\n     SoundVolume=128\n     CollisionRadius=18.000000\n     CollisionHeight=40.000000\n}\n",
            "name": "PlayerStart.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bSinglePlayerStart=True",
                    "bCoopStart=True",
                    "bEnabled=True",
                    "bDirectional=True",
                    "Texture=Texture'Engine.S_Player'",
                    "SoundVolume=128",
                    "CollisionRadius=18.000000",
                    "CollisionHeight=40.000000"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\S_Player.pcx Name=S_Player Mips=Off Flags=2"
                ],
                "extends": "NavigationPoint",
                "functions": {
                    "PlayTeleportEffect": {
                        "body": "{\n\tif ( Level.Game.bDeathMatch && Incoming.IsA('PlayerPawn') )\n\t\tPlayerPawn(Incoming).SetFOVAngle(135);\n\tLevel.Game.PlayTeleportEffect(Incoming, bOut, Level.Game.bDeathMatch );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayTeleportEffect",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Incoming"
                            ],
                            [
                                "bool",
                                "bOut"
                            ]
                        ],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "{\n\tbEnabled = !bEnabled;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 42,
                "replication": "",
                "states": [],
                "variables": [
                    "var() byte TeamNumber;",
                    "var() bool bSinglePlayerStart;",
                    "var() bool bTeamOnlyStart;",
                    "var() bool bNonTeamOnlyStart;",
                    "var() bool bCoopStart;",
                    "var() bool bEnabled;"
                ]
            }
        },
        "Projectile.uc": {
            "body": "//=============================================================================\n// Projectile.\n//\n// A delayed-hit projectile moves around for some time after it is created.\n// An instant-hit projectile acts immediately. \n//=============================================================================\nclass Projectile extends Actor\n\tabstract\n\tnative;\n\n#exec Texture Import File=Textures\\S_Camera.pcx Name=S_Camera Mips=Off Flags=2\n\n//-----------------------------------------------------------------------------\n// Projectile variables.\n\n// Motion information.\nvar() float    Speed;               // Initial speed of projectile.\nvar() float    MaxSpeed;            // Limit on speed of projectile (0 means no limit)\n\n// Damage attributes.\nvar() float    Damage;         \nvar() int\t   MomentumTransfer; // Momentum imparted by impacting projectile.\nvar() name\t   MyDamageType;\n\n// Projectile sound effects\nvar() sound    SpawnSound;\t\t// Sound made when projectile is spawned.\nvar() sound\t   ImpactSound;\t\t// Sound made when projectile hits something.\nvar() sound    MiscSound;\t\t// Miscellaneous Sound.\n\nvar() float\t\tExploWallOut;\t// distance to move explosions out from wall\n\n// explosion decal\nvar() class<Decal> ExplosionDecal;\n\n//==============\n// Encroachment\nfunction bool EncroachingOn( actor Other )\n{\n\tif ( (Other.Brush != None) || (Brush(Other) != None) )\n\t\treturn true;\n\t\t\n\treturn false;\n}\n\n//==============\n// Touching\nsimulated singular function Touch(Actor Other)\n{\n\tlocal actor HitActor;\n\tlocal vector HitLocation, HitNormal, TestLocation;\n\t\n\tif ( Other.IsA('BlockAll') )\n\t{\n\t\tHitWall( Normal(Location - Other.Location), Other);\n\t\treturn;\n\t}\n\tif ( Other.bProjTarget || (Other.bBlockActors && Other.bBlockPlayers) )\n\t{\n\t\t//get exact hitlocation\n\t \tHitActor = Trace(HitLocation, HitNormal, Location, OldLocation, true);\n\t\tif (HitActor == Other)\n\t\t{\n\t\t\tif ( Other.bIsPawn \n\t\t\t\t&& !Pawn(Other).AdjustHitLocation(HitLocation, Velocity) )\n\t\t\t\t\treturn;\n\t\t\tProcessTouch(Other, HitLocation); \n\t\t}\n\t\telse \n\t\t\tProcessTouch(Other, Other.Location + Other.CollisionRadius * Normal(Location - Other.Location));\n\t}\n}\n\nsimulated function ProcessTouch(Actor Other, Vector HitLocation)\n{\n\t//should be implemented in subclass\n}\n\nsimulated function HitWall (vector HitNormal, actor Wall)\n{\n\tif ( Role == ROLE_Authority )\n\t{\n\t\tif ( (Mover(Wall) != None) && Mover(Wall).bDamageTriggered )\n\t\t\tWall.TakeDamage( Damage, instigator, Location, MomentumTransfer * Normal(Velocity), '');\n\n\t\tMakeNoise(1.0);\n\t}\n\tExplode(Location + ExploWallOut * HitNormal, HitNormal);\n\tif ( ExplosionDecal != None )\n\t\tSpawn(ExplosionDecal,self,,Location, rotator(HitNormal));\n}\n\nsimulated function Explode(vector HitLocation, vector HitNormal)\n{\n\tDestroy();\n}\n\nsimulated final function RandSpin(float spinRate)\n{\n\tDesiredRotation = RotRand();\n\tRotationRate.Yaw = spinRate * 2 *FRand() - spinRate;\n\tRotationRate.Pitch = spinRate * 2 *FRand() - spinRate;\n\tRotationRate.Roll = spinRate * 2 *FRand() - spinRate;\t\n}\n\ndefaultproperties\n{\n     MaxSpeed=2000.000000\n     bReplicateInstigator=True\n     Physics=PHYS_Projectile\n     LifeSpan=140.000000\n     bDirectional=True\n     DrawType=DT_Mesh\n     Texture=Texture'Engine.S_Camera'\n     bGameRelevant=True\n     SoundVolume=0\n     CollisionRadius=0.000000\n     CollisionHeight=0.000000\n     bCollideActors=True\n     bCollideWorld=True\n     NetPriority=2.500000\n}\n",
            "name": "Projectile.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "MaxSpeed=2000.000000",
                    "bReplicateInstigator=True",
                    "Physics=PHYS_Projectile",
                    "LifeSpan=140.000000",
                    "bDirectional=True",
                    "DrawType=DT_Mesh",
                    "Texture=Texture'Engine.S_Camera'",
                    "bGameRelevant=True",
                    "SoundVolume=0",
                    "CollisionRadius=0.000000",
                    "CollisionHeight=0.000000",
                    "bCollideActors=True",
                    "bCollideWorld=True",
                    "NetPriority=2.500000"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\S_Camera.pcx Name=S_Camera Mips=Off Flags=2"
                ],
                "extends": "Actor",
                "functions": {
                    "EncroachingOn": {
                        "body": "{\n\tif ( (Other.Brush != None) || (Brush(Other) != None) )\n\t\treturn true;\n\t\t\n\treturn false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "EncroachingOn",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": "bool"
                    },
                    "Explode": {
                        "body": "{\n\tDestroy();\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Explode",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "HitLocation"
                            ],
                            [
                                "vector",
                                "HitNormal"
                            ]
                        ],
                        "return": ""
                    },
                    "HitWall": {
                        "body": "{\n\tif ( Role == ROLE_Authority )\n\t{\n\t\tif ( (Mover(Wall) != None) && Mover(Wall).bDamageTriggered )\n\t\t\tWall.TakeDamage( Damage, instigator, Location, MomentumTransfer * Normal(Velocity), '');\n\n\t\tMakeNoise(1.0);\n\t}\n\tExplode(Location + ExploWallOut * HitNormal, HitNormal);\n\tif ( ExplosionDecal != None )\n\t\tSpawn(ExplosionDecal,self,,Location, rotator(HitNormal));\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "HitWall",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "HitNormal"
                            ],
                            [
                                "actor",
                                "Wall"
                            ]
                        ],
                        "return": ""
                    },
                    "ProcessTouch": {
                        "body": "{\n\t//should be implemented in subclass\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ProcessTouch",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ],
                            [
                                "Vector",
                                "HitLocation"
                            ]
                        ],
                        "return": ""
                    },
                    "RandSpin": {
                        "body": "{\n\tDesiredRotation = RotRand();\n\tRotationRate.Yaw = spinRate * 2 *FRand() - spinRate;\n\tRotationRate.Pitch = spinRate * 2 *FRand() - spinRate;\n\tRotationRate.Roll = spinRate * 2 *FRand() - spinRate;\t\n}",
                        "locals": [],
                        "modifiers": [
                            "final",
                            "simulated"
                        ],
                        "name": "RandSpin",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "spinRate"
                            ]
                        ],
                        "return": ""
                    },
                    "Touch": {
                        "body": "{\n\t\n\tif ( Other.IsA('BlockAll') )\n\t{\n\t\tHitWall( Normal(Location - Other.Location), Other);\n\t\treturn;\n\t}\n\tif ( Other.bProjTarget || (Other.bBlockActors && Other.bBlockPlayers) )\n\t{\n\t\t//get exact hitlocation\n\t \tHitActor = Trace(HitLocation, HitNormal, Location, OldLocation, true);\n\t\tif (HitActor == Other)\n\t\t{\n\t\t\tif ( Other.bIsPawn \n\t\t\t\t&& !Pawn(Other).AdjustHitLocation(HitLocation, Velocity) )\n\t\t\t\t\treturn;\n\t\t\tProcessTouch(Other, HitLocation); \n\t\t}\n\t\telse \n\t\t\tProcessTouch(Other, Other.Location + Other.CollisionRadius * Normal(Location - Other.Location));\n\t}\n}",
                        "locals": [
                            "local actor HitActor;",
                            "local vector HitLocation, HitNormal, TestLocation;"
                        ],
                        "modifiers": [
                            "simulated",
                            "singular"
                        ],
                        "name": "Touch",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 122,
                "replication": "",
                "states": [],
                "variables": [
                    "var() float    Speed;               // Initial speed of projectile.",
                    "var() float    MaxSpeed;            // Limit on speed of projectile (0 means no limit)",
                    "var() float    Damage;",
                    "var() int\t   MomentumTransfer; // Momentum imparted by impacting projectile.",
                    "var() name\t   MyDamageType;",
                    "var() sound    SpawnSound;\t\t// Sound made when projectile is spawned.",
                    "var() sound\t   ImpactSound;\t\t// Sound made when projectile hits something.",
                    "var() sound    MiscSound;\t\t// Miscellaneous Sound.",
                    "var() float\t\tExploWallOut;\t// distance to move explosions out from wall",
                    "var() class<Decal> ExplosionDecal;"
                ]
            }
        },
        "RenderIterator.uc": {
            "body": "//=============================================================================\n// RenderIterator.\n//=============================================================================\nclass RenderIterator extends Object\n\tabstract\n\tnative\n\tnoexport;\n\nvar int\t\t\tMaxItems;\nvar int\t\t\tIndex;\nvar PlayerPawn\tObserver;\n\nfunction Init(PlayerPawn Camera)\n{\n}\n\nfunction bool IsDone()\n{\n}\n\nfunction Actor CurrentItem()\n{\n}\n\ndefaultproperties\n{\n}\n",
            "name": "RenderIterator.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Object",
                "functions": {
                    "CurrentItem": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "CurrentItem",
                        "native": false,
                        "param": [],
                        "return": "Actor"
                    },
                    "Init": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Init",
                        "native": false,
                        "param": [
                            [
                                "PlayerPawn",
                                "Camera"
                            ]
                        ],
                        "return": ""
                    },
                    "IsDone": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "IsDone",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 28,
                "replication": "",
                "states": [],
                "variables": [
                    "var int\t\t\tMaxItems;",
                    "var int\t\t\tIndex;",
                    "var PlayerPawn\tObserver;"
                ]
            }
        },
        "ReplicationInfo.uc": {
            "body": "//=============================================================================\n// ReplicationInfo.\n//=============================================================================\nclass ReplicationInfo extends Info\n\tabstract\n\tnative;\n\ndefaultproperties\n{\n     bAlwaysRelevant=True\n}\n",
            "name": "ReplicationInfo.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bAlwaysRelevant=True"
                ],
                "exec": [],
                "extends": "Info",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 12,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "RoundRobin.uc": {
            "body": "//=============================================================================\n// RoundRobin: Each time it's triggered, it advances through a list of\n// outgoing events.\n//=============================================================================\nclass RoundRobin extends Triggers;\n\nvar() name OutEvents[16]; // Events to generate.\nvar() bool bLoop;         // Whether to loop when get to end.\nvar int i;                // Internal counter.\n\n//\n// When RoundRobin is triggered...\n//\nfunction Trigger( actor Other, pawn EventInstigator )\n{\n\tlocal actor A;\n\tif( OutEvents[i] != '' )\n\t{\n\t\tforeach AllActors( class 'Actor', A, OutEvents[i] )\t\t\n\t\t{\n\t\t\tA.Trigger( Self, EventInstigator );\n\t\t}\n\t\tif( ++i>=ArrayCount(OutEvents) || OutEvents[i]=='' )\n\t\t{\n\t\t\tif( bLoop ) i=0;\n\t\t\telse\n\t\t\t\tSetCollision(false,false,false);\n\t\t}\n\t}\n}\n\ndefaultproperties\n{\n}\n",
            "name": "RoundRobin.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Triggers",
                "functions": {
                    "Trigger": {
                        "body": "{\n\tif( OutEvents[i] != '' )\n\t{\n\t\tforeach AllActors( class 'Actor', A, OutEvents[i] )\t\t\n\t\t{\n\t\t\tA.Trigger( Self, EventInstigator );\n\t\t}\n\t\tif( ++i>=ArrayCount(OutEvents) || OutEvents[i]=='' )\n\t\t{\n\t\t\tif( bLoop ) i=0;\n\t\t\telse\n\t\t\t\tSetCollision(false,false,false);\n\t\t}\n\t}\n}",
                        "locals": [
                            "local actor A;"
                        ],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 35,
                "replication": "",
                "states": [],
                "variables": [
                    "var() name OutEvents[16]; // Events to generate.",
                    "var() bool bLoop;         // Whether to loop when get to end.",
                    "var int i;                // Internal counter."
                ]
            }
        },
        "SavedMove.uc": {
            "body": "//=============================================================================\n// SavedMove is used during network play to buffer recent client moves,\n// for use when the server modifies the clients actual position, etc.\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass SavedMove extends Info;\n\n// also stores info in Acceleration attribute\nvar SavedMove NextMove;\t\t// Next move in linked list.\nvar float TimeStamp;\t\t// Time of this move.\nvar float Delta;\t\t\t// Distance moved.\nvar bool\tbRun;\nvar bool\tbDuck;\nvar bool\tbPressedJump;\nvar bool\tbFire;\nvar bool\tbAltFire;\nvar bool\tbForceFire;\nvar bool\tbForceAltFire;\nvar EDodgeDir DodgeMove;\t// Dodge info.\n\nfinal function Clear()\n{\n\tTimeStamp = 0;\n\tDelta = 0;\n\tDodgeMove = DODGE_None;\n\tAcceleration = vect(0,0,0);\n\tbFire = false;\n\tbRun = false;\n\tbDuck = false;\n\tbAltFire = false;\n\tbPressedJump = false;\n\tbForceFire = false;\n\tbForceAltFire = false;\n}\n\ndefaultproperties\n{\n}\n",
            "name": "SavedMove.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Info",
                "functions": {
                    "Clear": {
                        "body": "{\n\tTimeStamp = 0;\n\tDelta = 0;\n\tDodgeMove = DODGE_None;\n\tAcceleration = vect(0,0,0);\n\tbFire = false;\n\tbRun = false;\n\tbDuck = false;\n\tbAltFire = false;\n\tbPressedJump = false;\n\tbForceFire = false;\n\tbForceAltFire = false;\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "Clear",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 39,
                "replication": "",
                "states": [],
                "variables": [
                    "var SavedMove NextMove;\t\t// Next move in linked list.",
                    "var float TimeStamp;\t\t// Time of this move.",
                    "var float Delta;\t\t\t// Distance moved.",
                    "var bool\tbRun;",
                    "var bool\tbDuck;",
                    "var bool\tbPressedJump;",
                    "var bool\tbFire;",
                    "var bool\tbAltFire;",
                    "var bool\tbForceFire;",
                    "var bool\tbForceAltFire;",
                    "var EDodgeDir DodgeMove;\t// Dodge info."
                ]
            }
        },
        "ScaledSprite.uc": {
            "body": "//=============================================================================\n// ScaledSprite.\n//=============================================================================\nclass ScaledSprite extends Decoration;\n\ndefaultproperties\n{\n     Texture=Texture'Engine.S_Pickup'\n}\n",
            "name": "ScaledSprite.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Texture=Texture'Engine.S_Pickup'"
                ],
                "exec": [],
                "extends": "Decoration",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 10,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "ScoreBoard.uc": {
            "body": "//=============================================================================\n// ScoreBoard\n//=============================================================================\nclass ScoreBoard extends Info;\n\nvar font RegFont;\nvar HUD OwnerHUD;\n\nfunction ShowScores( canvas Canvas );\nfunction ShowMiniScores( Canvas Canvas );\n\nfunction PreBeginPlay()\n{\n}\n\ndefaultproperties\n{\n}\n",
            "name": "ScoreBoard.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Info",
                "functions": {
                    "PreBeginPlay": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ShowMiniScores": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ShowMiniScores",
                        "native": false,
                        "param": [
                            [
                                "Canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "ShowScores": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ShowScores",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 19,
                "replication": "",
                "states": [],
                "variables": [
                    "var font RegFont;",
                    "var HUD OwnerHUD;"
                ]
            }
        },
        "Scout.uc": {
            "body": "//=============================================================================\n// Scout used for path generation.\n//=============================================================================\nclass Scout extends Pawn\n\tnative;\n\nfunction PreBeginPlay()\n{\n\tDestroy(); //scouts shouldn't exist during play\n}\n\ndefaultproperties\n{\n     AccelRate=1.000000\n     SightRadius=4100.000000\n     CombatStyle=4363467783093056784302080.000000\n     CollisionRadius=52.000000\n     CollisionHeight=50.000000\n     bCollideActors=False\n     bCollideWorld=False\n     bBlockActors=False\n     bBlockPlayers=False\n     bProjTarget=False\n}\n",
            "name": "Scout.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "AccelRate=1.000000",
                    "SightRadius=4100.000000",
                    "CombatStyle=4363467783093056784302080.000000",
                    "CollisionRadius=52.000000",
                    "CollisionHeight=50.000000",
                    "bCollideActors=False",
                    "bCollideWorld=False",
                    "bBlockActors=False",
                    "bBlockPlayers=False",
                    "bProjTarget=False"
                ],
                "exec": [],
                "extends": "Pawn",
                "functions": {
                    "PreBeginPlay": {
                        "body": "{\n\tDestroy(); //scouts shouldn't exist during play\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 25,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "ScriptedTexture.uc": {
            "body": "//=============================================================================\n// ScriptedTexture: A scriptable Unreal texture\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass ScriptedTexture extends Texture \n\tsafereplace\n\tnative\n\tnoexport;\n\n// A SciptedTexture calls its Script's Render() method to draw to the texture at\n// runtime\nvar Actor NotifyActor;\nvar() Texture SourceTexture;\n\nvar transient const int Junk1;\t// C++ stuff\nvar transient const int Junk2;\t// C++ stuff\nvar transient const int Junk3;\t// C++ stuff\nvar transient const float LocalTime;\t// C++ stuff\n\n\nnative(473) final function DrawTile( float X, float Y, float XL, float YL, float U, float V, float UL, float VL, Texture Tex, bool bMasked );\nnative(472) final function DrawText( float X, float Y, string Text, Font Font );\nnative(474) final function DrawColoredText( float X, float Y, string Text, Font Font, color FontColor );\nnative(475) final function ReplaceTexture( Texture Tex );\nnative(476) final function TextSize( string Text, out float XL, out float YL, Font Font );\n\ndefaultproperties\n{\n}\n",
            "name": "ScriptedTexture.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Texture",
                "functions": {
                    "DrawColoredText": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawColoredText",
                        "native": true,
                        "param": [
                            [
                                "float",
                                "X"
                            ],
                            [
                                "float",
                                "Y"
                            ],
                            [
                                "string",
                                "Text"
                            ],
                            [
                                "Font",
                                "Font"
                            ],
                            [
                                "color",
                                "FontColor"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawText": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawText",
                        "native": true,
                        "param": [
                            [
                                "float",
                                "X"
                            ],
                            [
                                "float",
                                "Y"
                            ],
                            [
                                "string",
                                "Text"
                            ],
                            [
                                "Font",
                                "Font"
                            ]
                        ],
                        "return": ""
                    },
                    "DrawTile": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "DrawTile",
                        "native": true,
                        "param": [
                            [
                                "float",
                                "X"
                            ],
                            [
                                "float",
                                "Y"
                            ],
                            [
                                "float",
                                "XL"
                            ],
                            [
                                "float",
                                "YL"
                            ],
                            [
                                "float",
                                "U"
                            ],
                            [
                                "float",
                                "V"
                            ],
                            [
                                "float",
                                "UL"
                            ],
                            [
                                "float",
                                "VL"
                            ],
                            [
                                "Texture",
                                "Tex"
                            ],
                            [
                                "bool",
                                "bMasked"
                            ]
                        ],
                        "return": ""
                    },
                    "ReplaceTexture": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ReplaceTexture",
                        "native": true,
                        "param": [
                            [
                                "Texture",
                                "Tex"
                            ]
                        ],
                        "return": ""
                    },
                    "TextSize": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "TextSize",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "Text"
                            ],
                            [
                                "out",
                                "float",
                                "XL"
                            ],
                            [
                                "out",
                                "float",
                                "YL"
                            ],
                            [
                                "Font",
                                "Font"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 30,
                "replication": "",
                "states": [],
                "variables": [
                    "var Actor NotifyActor;",
                    "var() Texture SourceTexture;",
                    "var transient const int Junk1;\t// C++ stuff",
                    "var transient const int Junk2;\t// C++ stuff",
                    "var transient const int Junk3;\t// C++ stuff",
                    "var transient const float LocalTime;\t// C++ stuff"
                ]
            }
        },
        "SkyZoneInfo.uc": {
            "body": "//=============================================================================\n// SkyZoneInfo.\n//=============================================================================\nclass SkyZoneInfo extends ZoneInfo\n\tnative;\n\ndefaultproperties\n{\n     RemoteRole=ROLE_SimulatedProxy\n}\n",
            "name": "SkyZoneInfo.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "RemoteRole=ROLE_SimulatedProxy"
                ],
                "exec": [],
                "extends": "ZoneInfo",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 11,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "SmellNode.uc": {
            "body": "//=============================================================================\n// SmellNode.\n//=============================================================================\n\n// DEUS_EX STM - new class for Engine\n\nclass SmellNode extends Actor\n\tabstract;\n\n// ----------------------------------------------------------------------\n// Variables\n\n// BOOGER MAR! For now...\nvar(Smell) byte MaxSmellRadius;\nvar(Smell) byte Strength;\nvar(Smell) bool Communicable;\n\nvar SmellNode   nextNode;\nvar SmellNode   prevNode;\nvar Actor       Owner;\n\ndefaultproperties\n{\n}\n",
            "name": "SmellNode.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Actor",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 25,
                "replication": "",
                "states": [],
                "variables": [
                    "var(Smell) byte MaxSmellRadius;",
                    "var(Smell) byte Strength;",
                    "var(Smell) bool Communicable;",
                    "var SmellNode   nextNode;",
                    "var SmellNode   prevNode;",
                    "var Actor       Owner;"
                ]
            }
        },
        "SpawnNotify.uc": {
            "body": "//=============================================================================\n// SpawnNotify - Actor spawn notification.  \n//   NB - This happens on the client AND server for replicated actors.\n//=============================================================================\nclass SpawnNotify expands Actor\n\tnative;\n\nvar class<Actor> ActorClass;\nvar SpawnNotify  Next;\n\nreplication\n{\n\treliable if( Role == ROLE_Authority )\n\t\tActorClass;\n}\n\nsimulated function PostBeginPlay()\n{\n\tlocal SpawnNotify N;\n\n\tfor(N = Level.SpawnNotify; N != None; N = N.Next)\n\t\tif(N == Self)\n\t\t\treturn;\n\n\tNext = Level.SpawnNotify;\n\tLevel.SpawnNotify = Self;\n}\n\nsimulated event Destroyed()\n{\n\tlocal SpawnNotify N;\n\t\n\tif(Level.SpawnNotify == Self)\n\t{\n\t\tLevel.SpawnNotify = Next;\n\t\tNext = None;\t\t\n\t}\n\telse\n\t{\n\t\tfor(N = Level.SpawnNotify; N != None && N.Next != None; N = N.Next)\n\t\t{\n\t\t\tif(N.Next == Self)\n\t\t\t{\n\t\t\t\tN.Next = Next;\n\t\t\t\tNext = None;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nsimulated event Actor SpawnNotification(Actor A)\n{\n\treturn A;\n}\n\ndefaultproperties\n{\n     ActorClass=Class'Engine.Actor'\n     bHidden=True\n     bNetTemporary=True\n     bAlwaysRelevant=True\n}\n",
            "name": "SpawnNotify.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "ActorClass=Class'Engine.Actor'",
                    "bHidden=True",
                    "bNetTemporary=True",
                    "bAlwaysRelevant=True"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {
                    "Destroyed": {
                        "body": "{\n\t\n\tif(Level.SpawnNotify == Self)\n\t{\n\t\tLevel.SpawnNotify = Next;\n\t\tNext = None;\t\t\n\t}\n\telse\n\t{\n\t\tfor(N = Level.SpawnNotify; N != None && N.Next != None; N = N.Next)\n\t\t{\n\t\t\tif(N.Next == Self)\n\t\t\t{\n\t\t\t\tN.Next = Next;\n\t\t\t\tNext = None;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
                        "locals": [
                            "local SpawnNotify N;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Destroyed",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\n\tfor(N = Level.SpawnNotify; N != None; N = N.Next)\n\t\tif(N == Self)\n\t\t\treturn;\n\n\tNext = Level.SpawnNotify;\n\tLevel.SpawnNotify = Self;\n}",
                        "locals": [
                            "local SpawnNotify N;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpawnNotification": {
                        "body": "{\n\treturn A;\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "SpawnNotification",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "A"
                            ]
                        ],
                        "return": "Actor"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 64,
                "replication": "",
                "states": [],
                "variables": [
                    "var class<Actor> ActorClass;",
                    "var SpawnNotify  Next;"
                ]
            }
        },
        "SpecialEvent.uc": {
            "body": "//=============================================================================\n// SpecialEvent: Receives trigger messages and does some \"special event\"\n// depending on the state.\n//=============================================================================\nclass SpecialEvent extends Triggers;\n\n#exec Texture Import File=Textures\\TrigSpcl.pcx Name=S_SpecialEvent Mips=Off Flags=2\n\n//-----------------------------------------------------------------------------\n// Variables.\n\nvar() int        Damage;         // For DamagePlayer state.\nvar() name\t\t DamageType;\nvar() localized  string DamageString;\nvar() sound      Sound;          // For PlaySoundEffect state.\nvar() localized  string Message; // For all states.\nvar() bool       bBroadcast;     // To broadcast the message to all players.\nvar() bool       bPlayerViewRot; // Whether player can rotate the view while pathing.\n\n//-----------------------------------------------------------------------------\n// Functions.\n\nfunction Trigger( actor Other, pawn EventInstigator )\n{\n\tlocal pawn P;\n\tif( bBroadcast )\n\t\tBroadcastMessage(Message, true, 'CriticalEvent'); // Broadcast message to all players.\n\telse if( EventInstigator!=None && len(Message)!=0 )\n\t{\n\t\t// Send message to instigator only.\n\t\tEventInstigator.ClientMessage( Message );\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// States.\n\n// Just display the message.\nstate() DisplayMessage\n{\n}\n\n// Damage the instigator who caused this event.\nstate() DamageInstigator\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tGlobal.Trigger( Self, EventInstigator );\n\t\tif ( Other.IsA('PlayerPawn') )\n\t\t\tLevel.Game.SpecialDamageString = DamageString;\n\t\tOther.TakeDamage( Damage, EventInstigator, EventInstigator.Location, Vect(0,0,0), DamageType);\n\t}\n}\n\n// Kill the instigator who caused this event.\nstate() KillInstigator\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tGlobal.Trigger( Self, EventInstigator );\n\t\tif ( Other.IsA('PlayerPawn') )\n\t\t\tLevel.Game.SpecialDamageString = DamageString;\n\t\tif( EventInstigator != None )\n\t\t\tEventInstigator.Died( None, DamageType, EventInstigator.Location );\n\t}\n}\n\n// Play a sound.\nstate() PlaySoundEffect\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tGlobal.Trigger( Self, EventInstigator );\n\t\tPlaySound( Sound );\n\t}\n}\n\n// Play a sound.\nstate() PlayersPlaySoundEffect\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tlocal pawn P;\n\n\t\tGlobal.Trigger( Self, EventInstigator );\n\n\t\tfor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t\t\tif ( P.bIsPlayer && P.IsA('PlayerPawn') )\n\t\t\t\tPlayerPawn(P).ClientPlaySound(Sound);\n\t}\n}\n\n// Place Ambient sound effect on player\nstate() PlayAmbientSoundEffect\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tGlobal.Trigger( Self, EventInstigator );\n\t\tEventInstigator.AmbientSound = AmbientSound;\n\t}\n}\n\n\n// Send the player on a spline path through the level.\nstate() PlayerPath\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tlocal InterpolationPoint i;\n\t\tGlobal.Trigger( Self, EventInstigator );\n\t\tif( EventInstigator!=None && EventInstigator.bIsPlayer && (Level.NetMode == NM_Standalone) )\n\t\t{\n\t\t\tforeach AllActors( class 'InterpolationPoint', i, Event )\n\t\t\t{\n\t\t\t\tif( i.Position == 0 )\n\t\t\t\t{\n\t\t\t\t\tEventInstigator.GotoState('');\n\t\t\t\t\tEventInstigator.SetCollision(True,false,false);\n\t\t\t\t\tEventInstigator.bCollideWorld = False;\n\t\t\t\t\tEventInstigator.Target = i;\n\t\t\t\t\tEventInstigator.SetPhysics(PHYS_Interpolating);\n\t\t\t\t\tEventInstigator.PhysRate = 1.0;\n\t\t\t\t\tEventInstigator.PhysAlpha = 0.0;\n\t\t\t\t\tEventInstigator.bInterpolating = true;\n\t\t\t\t\tEventInstigator.AmbientSound = AmbientSound;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\ndefaultproperties\n{\n     Texture=Texture'Engine.S_SpecialEvent'\n}\n",
            "name": "SpecialEvent.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Texture=Texture'Engine.S_SpecialEvent'"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\TrigSpcl.pcx Name=S_SpecialEvent Mips=Off Flags=2"
                ],
                "extends": "Triggers",
                "functions": {
                    "Trigger": {
                        "body": "{\n\t\tGlobal.Trigger( Self, EventInstigator );\n\t\tif( EventInstigator!=None && EventInstigator.bIsPlayer && (Level.NetMode == NM_Standalone) )\n\t\t{\n\t\t\tforeach AllActors( class 'InterpolationPoint', i, Event )\n\t\t\t{\n\t\t\t\tif( i.Position == 0 )\n\t\t\t\t{\n\t\t\t\t\tEventInstigator.GotoState('');\n\t\t\t\t\tEventInstigator.SetCollision(True,false,false);\n\t\t\t\t\tEventInstigator.bCollideWorld = False;\n\t\t\t\t\tEventInstigator.Target = i;\n\t\t\t\t\tEventInstigator.SetPhysics(PHYS_Interpolating);\n\t\t\t\t\tEventInstigator.PhysRate = 1.0;\n\t\t\t\t\tEventInstigator.PhysAlpha = 0.0;\n\t\t\t\t\tEventInstigator.bInterpolating = true;\n\t\t\t\t\tEventInstigator.AmbientSound = AmbientSound;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
                        "locals": [
                            "local InterpolationPoint i;"
                        ],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 136,
                "replication": "",
                "states": [],
                "variables": [
                    "var() int        Damage;         // For DamagePlayer state.",
                    "var() name\t\t DamageType;",
                    "var() localized  string DamageString;",
                    "var() sound      Sound;          // For PlaySoundEffect state.",
                    "var() localized  string Message; // For all states.",
                    "var() bool       bBroadcast;     // To broadcast the message to all players.",
                    "var() bool       bPlayerViewRot; // Whether player can rotate the view while pathing."
                ]
            }
        },
        "Spectator.uc": {
            "body": "//=============================================================================\n// Spectator.\n//=============================================================================\nclass Spectator extends PlayerPawn;\n\nvar bool bChaseCam;\n\nfunction InitPlayerReplicationInfo()\n{\n\tSuper.InitPlayerReplicationInfo();\n\tPlayerReplicationInfo.bIsSpectator = true;\n}\n\nevent FootZoneChange(ZoneInfo newFootZone)\n{\n}\n\t\nevent HeadZoneChange(ZoneInfo newHeadZone)\n{\n}\n\nexec function Walk()\n{\t\n}\n\nexec function BehindView( Bool B )\n{\n\tbBehindView = B;\n\tbChaseCam = bBehindView;\n\tif ( ViewTarget == None )\n\t\tbBehindView = false;\n}\n\nfunction ChangeTeam( int N )\n{\n\tLevel.Game.ChangeTeam(self, N);\n}\n\nexec function Taunt( name Sequence )\n{\n}\n\nexec function CallForHelp()\n{\n}\n\nexec function ThrowWeapon()\n{\n}\n\nexec function Suicide()\n{\n}\n\nexec function Fly()\n{\n\tUnderWaterTime = -1;\t\n\tSetCollision(false, false, false);\n\tbCollideWorld = true;\n\tGotoState('CheatFlying');\n\n\tClientRestart();\n}\n\nfunction ServerChangeSkin( coerce string SkinName, coerce string FaceName, byte TeamNum )\n{\n}\n\nfunction ClientReStart()\n{\n\t//log(\"client restart\");\n\tVelocity = vect(0,0,0);\n\tAcceleration = vect(0,0,0);\n\tBaseEyeHeight = Default.BaseEyeHeight;\n\tEyeHeight = BaseEyeHeight;\n\t\n\tGotoState('CheatFlying');\n}\n\nfunction PlayerTimeOut()\n{\n\tif (Health > 0)\n\t\tDied(None, 'dropped', Location);\n}\n\nexec function Grab()\n{\n}\n\n// Send a message to all players.\nexec function Say( string S )\n{\n\tif ( Len(S) > 63 )\n\t\tS = Left(S,63);\n\tif ( !Level.Game.bMuteSpectators )\n\t\tBroadcastMessage( PlayerReplicationInfo.PlayerName$\":\"$S, true );\n}\n\n//=============================================================================\n// functions.\n\nexec function RestartLevel()\n{\n}\n\n// This pawn was possessed by a player.\nfunction Possess()\n{\n\tbIsPlayer = true;\n\tDodgeClickTime = FMin(0.3, DodgeClickTime);\n\tEyeHeight = BaseEyeHeight;\n\tNetPriority = 2;\n\tWeapon = None;\n\tInventory = None;\n\tFly();\n}\n\nfunction PostBeginPlay()\n{\n\tif (Level.LevelEnterText != \"\" )\n\t\tClientMessage(Level.LevelEnterText);\n\tbIsPlayer = true;\n\tFlashScale = vect(1,1,1);\n\tif ( Level.NetMode != NM_Client )\n\t\tScoringType = Level.Game.ScoreboardType;\n}\n\n//=============================================================================\n// Inventory-related input notifications.\n\n// The player wants to switch to weapon group numer I.\nexec function SwitchWeapon (byte F )\n{\n}\n\nexec function NextItem()\n{\n}\n\nexec function PrevItem()\n{\n}\n\nexec function Fire( optional float F )\n{\n\tViewPlayerNum(-1);\n\tbBehindView = bChaseCam;\n\tif ( ViewTarget == None )\n\t\tbBehindView = false;\n}\n\n// The player wants to alternate-fire.\nexec function AltFire( optional float F )\n{\n\tbBehindView = false;\n\tViewtarget = None;\n\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n}\n\n//=================================================================================\n\nfunction TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation, \n\t\t\t\t\t\tVector momentum, name damageType)\n{\n}\n\ndefaultproperties\n{\n     bChaseCam=True\n     AirSpeed=400.000000\n     Visibility=0\n     AttitudeToPlayer=ATTITUDE_Friendly\n     MenuName=\"Spectator\"\n     bHidden=True\n     bCollideActors=False\n     bCollideWorld=False\n     bBlockActors=False\n     bBlockPlayers=False\n     bProjTarget=False\n}\n",
            "name": "Spectator.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bChaseCam=True",
                    "AirSpeed=400.000000",
                    "Visibility=0",
                    "AttitudeToPlayer=ATTITUDE_Friendly",
                    "MenuName=\"Spectator\"",
                    "bHidden=True",
                    "bCollideActors=False",
                    "bCollideWorld=False",
                    "bBlockActors=False",
                    "bBlockPlayers=False",
                    "bProjTarget=False"
                ],
                "exec": [],
                "extends": "PlayerPawn",
                "functions": {
                    "AltFire": {
                        "body": "{\n\tbBehindView = false;\n\tViewtarget = None;\n\tClientMessage(ViewingFrom@OwnCamera, 'Event', true);\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "AltFire",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "BehindView": {
                        "body": "{\n\tbBehindView = B;\n\tbChaseCam = bBehindView;\n\tif ( ViewTarget == None )\n\t\tbBehindView = false;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "BehindView",
                        "native": false,
                        "param": [
                            [
                                "Bool",
                                "B"
                            ]
                        ],
                        "return": ""
                    },
                    "CallForHelp": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "CallForHelp",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ChangeTeam": {
                        "body": "{\n\tLevel.Game.ChangeTeam(self, N);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ChangeTeam",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "N"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientReStart": {
                        "body": "{\n\t//log(\"client restart\");\n\tVelocity = vect(0,0,0);\n\tAcceleration = vect(0,0,0);\n\tBaseEyeHeight = Default.BaseEyeHeight;\n\tEyeHeight = BaseEyeHeight;\n\t\n\tGotoState('CheatFlying');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientReStart",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Fire": {
                        "body": "{\n\tViewPlayerNum(-1);\n\tbBehindView = bChaseCam;\n\tif ( ViewTarget == None )\n\t\tbBehindView = false;\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Fire",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "Fly": {
                        "body": "{\n\tUnderWaterTime = -1;\t\n\tSetCollision(false, false, false);\n\tbCollideWorld = true;\n\tGotoState('CheatFlying');\n\n\tClientRestart();\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Fly",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FootZoneChange": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "FootZoneChange",
                        "native": false,
                        "param": [
                            [
                                "ZoneInfo",
                                "newFootZone"
                            ]
                        ],
                        "return": ""
                    },
                    "Grab": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Grab",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "HeadZoneChange": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "HeadZoneChange",
                        "native": false,
                        "param": [
                            [
                                "ZoneInfo",
                                "newHeadZone"
                            ]
                        ],
                        "return": ""
                    },
                    "InitPlayerReplicationInfo": {
                        "body": "{\n\tSuper.InitPlayerReplicationInfo();\n\tPlayerReplicationInfo.bIsSpectator = true;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "InitPlayerReplicationInfo",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "NextItem": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "NextItem",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayerTimeOut": {
                        "body": "{\n\tif (Health > 0)\n\t\tDied(None, 'dropped', Location);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayerTimeOut",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Possess": {
                        "body": "{\n\tbIsPlayer = true;\n\tDodgeClickTime = FMin(0.3, DodgeClickTime);\n\tEyeHeight = BaseEyeHeight;\n\tNetPriority = 2;\n\tWeapon = None;\n\tInventory = None;\n\tFly();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Possess",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\tif (Level.LevelEnterText != \"\" )\n\t\tClientMessage(Level.LevelEnterText);\n\tbIsPlayer = true;\n\tFlashScale = vect(1,1,1);\n\tif ( Level.NetMode != NM_Client )\n\t\tScoringType = Level.Game.ScoreboardType;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PrevItem": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "PrevItem",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "RestartLevel": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "RestartLevel",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Say": {
                        "body": "{\n\tif ( Len(S) > 63 )\n\t\tS = Left(S,63);\n\tif ( !Level.Game.bMuteSpectators )\n\t\tBroadcastMessage( PlayerReplicationInfo.PlayerName$\":\"$S, true );\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Say",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "S"
                            ]
                        ],
                        "return": ""
                    },
                    "ServerChangeSkin": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ServerChangeSkin",
                        "native": false,
                        "param": [
                            [
                                "coerce",
                                "string",
                                "SkinName"
                            ],
                            [
                                "coerce",
                                "string",
                                "FaceName"
                            ],
                            [
                                "byte",
                                "TeamNum"
                            ]
                        ],
                        "return": ""
                    },
                    "Suicide": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Suicide",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SwitchWeapon": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "SwitchWeapon",
                        "native": false,
                        "param": [
                            [
                                "byte",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "Taunt": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Taunt",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "Sequence"
                            ]
                        ],
                        "return": ""
                    },
                    "ThrowWeapon": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "ThrowWeapon",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Walk": {
                        "body": "{\t\n}",
                        "locals": [],
                        "modifiers": [
                            "exec"
                        ],
                        "name": "Walk",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 181,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool bChaseCam;"
                ]
            }
        },
        "Spotlight.uc": {
            "body": "//=============================================================================\n// A directional spotlight.\n//=============================================================================\nclass Spotlight extends Light;\n\ndefaultproperties\n{\n     bDirectional=True\n     LightEffect=LE_Spotlight\n}\n",
            "name": "Spotlight.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bDirectional=True",
                    "LightEffect=LE_Spotlight"
                ],
                "exec": [],
                "extends": "Light",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 11,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "StatLog.uc": {
            "body": "//=============================================================================\n// Logs game events for stat collection\n//\n// ngLog, ngStats, and ngWorldStats are registered trademarks of \n// NetGames USA, Inc. at http://www.netgamesusa.com All rights reserved. A\n// ny and all occurrences of code related to supporting their products and \n// services appears with their express permission.\n//=============================================================================\nclass StatLog extends Info\n\tnative;\n\n// Internal\nvar int\t\tContext;\n\n// State\nvar bool\tbWorld;\n\n// Time\nvar\tfloat\tTimeStamp;\n\n// Log Variables\nvar() string LocalStandard;\t\t// The standard this log is compliant to.\nvar() string WorldStandard;\t\t// The standard this log is compliant to.\nvar() string LogVersion;\t\t// Version of the log standard.\nvar() string LogInfoURL;\t\t// URL to info on logging standard.\nvar() string GameName;\t\t\t// Name of this game.\nvar() string GameCreator;\t\t// Name of game creator.\nvar() string GameCreatorURL;\t// URL to info on game creator.\nvar() string DecoderRingURL;\t// URL to log format decoder ring.\n\nvar() globalconfig string\t    LocalBatcherURL;\t\t// Batcher URL.\nvar() globalconfig string\t    LocalBatcherParams;\t\t// Batcher command line parameters.\nvar() globalconfig string\t    LocalStatsURL;\t\t\t// URL to local stats information.\nvar() globalconfig string\t    WorldBatcherURL;\t\t// Batcher URL.\nvar() globalconfig string\t    WorldBatcherParams;\t\t// Batcher command line parameters.\nvar() globalconfig string\t    WorldStatsURL;\t\t\t// URL to world stats information.\nvar() globalconfig string\t\tLocalLogDir;\nvar() globalconfig string\t\tWorldLogDir;\n\n// Object\nfunction BeginPlay()\n{\n\tSetTimer(30.0, True);\n}\n\nfunction Timer()\n{\n\tLogPings();\n}\n\n// Logging\nfunction StartLog()\n{\n\t// Implemented in subclass.\n}\n\nfunction StopLog()\n{\n\t// Implemented in subclass.\n}\n\nfunction FlushLog()\n{\n\t// Implemented in subclass.\n}\n\nfunction LogEventString( string EventString )\n{\n\tLog( EventString );\n}\n\n// Batching\nnative final function ExecuteLocalLogBatcher();\nnative final function ExecuteSilentLogBatcher();\nnative final static function BatchLocal();\nnative final function ExecuteWorldLogBatcher();\nnative static function BrowseRelativeLocalURL(string URL);\n\n// Special\nnative final function InitialCheck( GameInfo Game );\nnative final function LogMutator( Mutator M );\nnative static function GetPlayerChecksum( PlayerPawn P, out string Checksum );\n\n// Time\nnative final function string GetGMTRef();\n\n// Return absolute time.\nfunction string GetAbsoluteTime()\n{\n\tlocal string AbsoluteTime;\n\tlocal string GMTRef;\n\n\tAbsoluteTime = string(Level.Year);\n\n\tif (Level.Month < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Month;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Month;\n\n\tif (Level.Day < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Day;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Day;\n\n\tif (Level.Hour < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Hour;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Hour;\n\n\tif (Level.Minute < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Minute;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Minute;\n\n\tif (Level.Second < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Second;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Second;\n\n\tif (Level.Millisecond < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Millisecond;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Millisecond;\n\n\tGMTRef = GetGMTRef();\n\n\tAbsoluteTime = AbsoluteTime$\".\"$GMTRef;\n\n\tTimeStamp = 0;\n\n\treturn AbsoluteTime;\n}\n\n// A less verbose version...\nfunction string GetShortAbsoluteTime()\n{\n\tlocal string AbsoluteTime;\n\n\tAbsoluteTime = string(Level.Year);\n\n\tif (Level.Month < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Month;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Month;\n\n\tif (Level.Day < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Day;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Day;\n\n\tif (Level.Hour < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Hour;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Hour;\n\n\tif (Level.Minute < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Minute;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Minute;\n\n\tif (Level.Second < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Second;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Second;\n\n\tTimeStamp = 0;\n\n\treturn AbsoluteTime;\n}\n\n// Return a timestamp relative to last absolute time.\nfunction string GetTimeStamp()\n{\n\tlocal string Time;\n\tlocal int Pos;\n\n\tTime = string(TimeStamp);\n\tTime = Left(Time, InStr(Time, \".\") + 3);\n\treturn Time;\n}\n\n// Return a logfile name if relevant.\nfunction string GetLogFileName()\n{\n\treturn \"\";\n}\n\n// Track relative timestamps.\nfunction Tick(float Delta)\n{\n\tTimeStamp += Delta;\n}\n\n// Standard Log Entries\nfunction LogStandardInfo()\n{\n\tif (bWorld)\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Log_Standard\"$Chr(9)$WorldStandard);\n\telse\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Log_Standard\"$Chr(9)$LocalStandard);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Log_Version\"$Chr(9)$LogVersion);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Log_Info_URL\"$Chr(9)$LogInfoURL);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Game_Name\"$Chr(9)$GameName);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Game_Version\"$Chr(9)$Level.EngineVersion);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Game_Creator\"$Chr(9)$GameCreator);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Game_Creator_URL\"$Chr(9)$GameCreatorURL);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Game_Decoder_Ring_URL\"$Chr(9)$DecoderRingURL);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Absolute_Time\"$Chr(9)$GetAbsoluteTime());\t\n}\n\nfunction LogServerInfo()\n{\n\tlocal string NetworkNumber;\n\n\tNetworkNumber = Level.Game.GetNetworkNumber();\n\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_ServerName\"$Chr(9)$Level.Game.GameReplicationInfo.ServerName);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_AdminName\"$Chr(9)$Level.Game.GameReplicationInfo.AdminName);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_AdminEmail\"$Chr(9)$Level.Game.GameReplicationInfo.AdminEmail);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_Region\"$Chr(9)$Level.Game.GameReplicationInfo.Region);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_MOTDLine1\"$Chr(9)$Level.Game.GameReplicationInfo.MOTDLine1);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_MOTDLine2\"$Chr(9)$Level.Game.GameReplicationInfo.MOTDLine2);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_MOTDLine3\"$Chr(9)$Level.Game.GameReplicationInfo.MOTDLine3);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_MOTDLine4\"$Chr(9)$Level.Game.GameReplicationInfo.MOTDLine4);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_IP\"$Chr(9)$NetworkNumber);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_Port\"$Chr(9)$Level.Game.GetServerPort());\n}\n\nfinal event LogGameSpecial(String SpecialID, String SpecialParam)\n{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$SpecialID$Chr(9)$SpecialParam);\n}\n\nfinal event LogGameSpecial2(String SpecialID, String SpecialParam, String SpecialParam2)\n{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$SpecialID$Chr(9)$SpecialParam$Chr(9)$SpecialParam2);\n}\n\nnative final function string GetMapFileName();\n\nfunction LogMapParameters()\n{\n\tlocal string MapName;\n\n\tMapName = GetMapFileName();\n\n\tLogEventString(GetTimeStamp()$Chr(9)$\"map\"$Chr(9)$\"Name\"$Chr(9)$MapName);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"map\"$Chr(9)$\"Title\"$Chr(9)$Level.Title);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"map\"$Chr(9)$\"Author\"$Chr(9)$Level.Author);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"map\"$Chr(9)$\"IdealPlayerCount\"$Chr(9)$Level.IdealPlayerCount);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"map\"$Chr(9)$\"LevelEnterText\"$Chr(9)$Level.LevelEnterText);\n}\n\nfunction LogPlayerConnect(Pawn Player, optional string Checksum)\n{\n\tif (Player.IsA('PlayerPawn'))\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Connect\"$Chr(9)$Player.PlayerReplicationInfo.PlayerName$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$PlayerPawn(Player).bAdmin);\n\telse\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Connect\"$Chr(9)$Player.PlayerReplicationInfo.PlayerName$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$False);\n\tLogPlayerInfo(Player);\n}\n\nfunction LogPlayerInfo(Pawn Player)\n{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"TeamName\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.TeamName);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Team\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.Team);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"TeamID\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.TeamID);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Ping\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.Ping);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"IsABot\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.bIsABot);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Skill\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.Skill);\n}\n\nfunction LogPlayerDisconnect(Pawn Player)\n{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Disconnect\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID);\n}\n\nfunction LogKill( int KillerID, int VictimID, string KillerWeaponName, string VictimWeaponName, name DamageType )\n{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"kill\"$Chr(9)$KillerID$Chr(9)$KillerWeaponName$Chr(9)$VictimID$Chr(9)$VictimWeaponName$Chr(9)$DamageType);\n}\n\nfunction LogTeamKill( int KillerID, int VictimID, string KillerWeaponName, string VictimWeaponName, name DamageType )\n{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"teamkill\"$Chr(9)$KillerID$Chr(9)$KillerWeaponName$Chr(9)$VictimID$Chr(9)$VictimWeaponName$Chr(9)$DamageType);\n}\n\nfunction LogSuicide(Pawn Killed, name DamageType, Pawn Instigator)\n{\n\tlocal int KilledID;\n\tlocal string InstigatorString;\n\n\tif (Killed == None)\n\t\treturn;\n\n\tKilledID = Killed.PlayerReplicationInfo.PlayerID;\n\tif (Instigator == None)\n\t\tInstigatorString = \"None\";\n\telse\n\t\tInstigatorString = \"Self\";\n\n\tif (Killed.Weapon != None)\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"suicide\"$Chr(9)$KilledID$Chr(9)$Killed.Weapon.ItemName$Chr(9)$DamageType$Chr(9)$InstigatorString);\n\telse\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"suicide\"$Chr(9)$KilledID$Chr(9)$\"None\"$Chr(9)$DamageType$Chr(9)$InstigatorString);\n}\n\nfunction LogNameChange(Pawn Other)\n{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Rename\"$Chr(9)$Other.PlayerReplicationInfo.PlayerName$Chr(9)$Other.PlayerReplicationInfo.PlayerID);\n}\n\nfunction LogTeamChange(Pawn Other)\n{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Teamchange\"$Chr(9)$Other.PlayerReplicationInfo.PlayerID$Chr(9)$Other.PlayerReplicationInfo.Team);\n}\n\nfunction LogTypingEvent(bool bTyping, Pawn Other)\n{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"typing\"$Chr(9)$bTyping$Chr(9)$Other.PlayerReplicationInfo.PlayerID);\n}\n\nfunction LogPickup(Inventory Item, Pawn Other)\n{\n\tif (Item.ItemName != \"\")\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"item_get\"$Chr(9)$Item.ItemName$Chr(9)$Other.PlayerReplicationInfo.PlayerID);\n\telse\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"item_get\"$Chr(9)$Item.Class$Chr(9)$Other.PlayerReplicationInfo.PlayerID);\n}\n\nfunction LogItemActivate(Inventory Item, Pawn Other)\n{\n\tif ( (Other == None) || (Other.PlayerReplicationInfo == None) || (Item == None) )\n\t\treturn;\n\tLogEventString(GetTimeStamp()$Chr(9)$\"item_activate\"$Chr(9)$Item.ItemName$Chr(9)$Other.PlayerReplicationInfo.PlayerID);\n}\n\nfunction LogItemDeactivate(Inventory Item, Pawn Other)\n{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"item_deactivate\"$Chr(9)$Item.ItemName$Chr(9)$Other.PlayerReplicationInfo.PlayerID);\n}\n\nfunction LogSpecialEvent(string EventType, optional coerce string Arg1, optional coerce string Arg2, optional coerce string Arg3, optional coerce string Arg4)\n{\n\tlocal string Event;\n\n\tEvent = EventType;\n\tif (Arg1 != \"\")\n\t\tEvent = Event$Chr(9)$Arg1;\n\tif (Arg2 != \"\")\n\t\tEvent = Event$Chr(9)$Arg2;\n\tif (Arg3 != \"\")\n\t\tEvent = Event$Chr(9)$Arg3;\n\tif (Arg4 != \"\")\n\t\tEvent = Event$Chr(9)$Arg4;\n\n\tLogEventString(GetTimeStamp()$Chr(9)$Event);\n}\n\nfunction LogPings()\n{\n\tlocal PlayerReplicationInfo PRI;\n\n\tforeach AllActors(class'PlayerReplicationInfo', PRI)\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Ping\"$Chr(9)$PRI.PlayerID$Chr(9)$PRI.Ping);\n}\n\nfunction LogGameStart()\n{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"game_start\");\n}\n\nfunction LogGameEnd( string Reason )\n{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"game_end\"$Chr(9)$Reason);\n}\n\ndefaultproperties\n{\n     LocalStandard=\"ngLog\"\n     WorldStandard=\"ngLog\"\n     LogVersion=\"1.2\"\n     LogInfoURL=\"http://www.netgamesusa.com/ngLog/\"\n     GameName=\"Unreal\"\n     GameCreator=\"Epic MegaGames, Inc.\"\n     GameCreatorURL=\"http://www.epicgames.com/\"\n     DecoderRingURL=\"http://unreal.epicgames.com/Unreal_Log_Decoder_Ring.html\"\n     LocalBatcherURL=\"../NetGamesUSA.com/ngStats/ngStatsUT.exe\"\n     LocalStatsURL=\"../NetGamesUSA.com/ngStats/html/ngStats_Main.html\"\n     WorldBatcherURL=\"../NetGamesUSA.com/ngWorldStats/bin/ngWorldStats.exe\"\n     WorldBatcherParams=\"-d ../NetGamesUSA.com/ngWorldStats/logs -g UT\"\n     WorldStatsURL=\"http://www.netgamesusa.com\"\n     LocalLogDir=\"../Logs\"\n     WorldLogDir=\"../NetGamesUSA.com/ngWorldStats/logs\"\n}\n",
            "name": "StatLog.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "LocalStandard=\"ngLog\"",
                    "WorldStandard=\"ngLog\"",
                    "LogVersion=\"1.2\"",
                    "LogInfoURL=\"http://www.netgamesusa.com/ngLog/\"",
                    "GameName=\"Unreal\"",
                    "GameCreator=\"Epic MegaGames, Inc.\"",
                    "GameCreatorURL=\"http://www.epicgames.com/\"",
                    "DecoderRingURL=\"http://unreal.epicgames.com/Unreal_Log_Decoder_Ring.html\"",
                    "LocalBatcherURL=\"../NetGamesUSA.com/ngStats/ngStatsUT.exe\"",
                    "LocalStatsURL=\"../NetGamesUSA.com/ngStats/html/ngStats_Main.html\"",
                    "WorldBatcherURL=\"../NetGamesUSA.com/ngWorldStats/bin/ngWorldStats.exe\"",
                    "WorldBatcherParams=\"-d ../NetGamesUSA.com/ngWorldStats/logs -g UT\"",
                    "WorldStatsURL=\"http://www.netgamesusa.com\"",
                    "LocalLogDir=\"../Logs\"",
                    "WorldLogDir=\"../NetGamesUSA.com/ngWorldStats/logs\""
                ],
                "exec": [],
                "extends": "Info",
                "functions": {
                    "BatchLocal": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final",
                            "static"
                        ],
                        "name": "BatchLocal",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "BeginPlay": {
                        "body": "{\n\tSetTimer(30.0, True);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BrowseRelativeLocalURL": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "BrowseRelativeLocalURL",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "URL"
                            ]
                        ],
                        "return": ""
                    },
                    "ExecuteLocalLogBatcher": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "ExecuteLocalLogBatcher",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "ExecuteSilentLogBatcher": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "ExecuteSilentLogBatcher",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "ExecuteWorldLogBatcher": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "ExecuteWorldLogBatcher",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "FlushLog": {
                        "body": "{\n\t// Implemented in subclass.\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "FlushLog",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GetAbsoluteTime": {
                        "body": "{\n\n\tAbsoluteTime = string(Level.Year);\n\n\tif (Level.Month < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Month;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Month;\n\n\tif (Level.Day < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Day;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Day;\n\n\tif (Level.Hour < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Hour;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Hour;\n\n\tif (Level.Minute < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Minute;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Minute;\n\n\tif (Level.Second < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Second;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Second;\n\n\tif (Level.Millisecond < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Millisecond;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Millisecond;\n\n\tGMTRef = GetGMTRef();\n\n\tAbsoluteTime = AbsoluteTime$\".\"$GMTRef;\n\n\tTimeStamp = 0;\n\n\treturn AbsoluteTime;\n}",
                        "locals": [
                            "local string AbsoluteTime;",
                            "local string GMTRef;"
                        ],
                        "modifiers": [],
                        "name": "GetAbsoluteTime",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "GetGMTRef": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetGMTRef",
                        "native": true,
                        "param": [],
                        "return": "string"
                    },
                    "GetLogFileName": {
                        "body": "{\n\treturn \"\";\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetLogFileName",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "GetMapFileName": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetMapFileName",
                        "native": true,
                        "param": [],
                        "return": "string"
                    },
                    "GetPlayerChecksum": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "GetPlayerChecksum",
                        "native": true,
                        "param": [
                            [
                                "PlayerPawn",
                                "P"
                            ],
                            [
                                "out",
                                "string",
                                "Checksum"
                            ]
                        ],
                        "return": ""
                    },
                    "GetShortAbsoluteTime": {
                        "body": "{\n\n\tAbsoluteTime = string(Level.Year);\n\n\tif (Level.Month < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Month;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Month;\n\n\tif (Level.Day < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Day;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Day;\n\n\tif (Level.Hour < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Hour;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Hour;\n\n\tif (Level.Minute < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Minute;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Minute;\n\n\tif (Level.Second < 10)\n\t\tAbsoluteTime = AbsoluteTime$\".0\"$Level.Second;\n\telse\n\t\tAbsoluteTime = AbsoluteTime$\".\"$Level.Second;\n\n\tTimeStamp = 0;\n\n\treturn AbsoluteTime;\n}",
                        "locals": [
                            "local string AbsoluteTime;"
                        ],
                        "modifiers": [],
                        "name": "GetShortAbsoluteTime",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "GetTimeStamp": {
                        "body": "{\n\n\tTime = string(TimeStamp);\n\tTime = Left(Time, InStr(Time, \".\") + 3);\n\treturn Time;\n}",
                        "locals": [
                            "local string Time;",
                            "local int Pos;"
                        ],
                        "modifiers": [],
                        "name": "GetTimeStamp",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "InitialCheck": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "InitialCheck",
                        "native": true,
                        "param": [
                            [
                                "GameInfo",
                                "Game"
                            ]
                        ],
                        "return": ""
                    },
                    "LogEventString": {
                        "body": "{\n\tLog( EventString );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogEventString",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "EventString"
                            ]
                        ],
                        "return": ""
                    },
                    "LogGameEnd": {
                        "body": "{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"game_end\"$Chr(9)$Reason);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogGameEnd",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Reason"
                            ]
                        ],
                        "return": ""
                    },
                    "LogGameSpecial": {
                        "body": "{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$SpecialID$Chr(9)$SpecialParam);\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "LogGameSpecial",
                        "native": false,
                        "param": [
                            [
                                "String",
                                "SpecialID"
                            ],
                            [
                                "String",
                                "SpecialParam"
                            ]
                        ],
                        "return": ""
                    },
                    "LogGameSpecial2": {
                        "body": "{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"game\"$Chr(9)$SpecialID$Chr(9)$SpecialParam$Chr(9)$SpecialParam2);\n}",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "LogGameSpecial2",
                        "native": false,
                        "param": [
                            [
                                "String",
                                "SpecialID"
                            ],
                            [
                                "String",
                                "SpecialParam"
                            ],
                            [
                                "String",
                                "SpecialParam2"
                            ]
                        ],
                        "return": ""
                    },
                    "LogGameStart": {
                        "body": "{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"game_start\");\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogGameStart",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "LogItemActivate": {
                        "body": "{\n\tif ( (Other == None) || (Other.PlayerReplicationInfo == None) || (Item == None) )\n\t\treturn;\n\tLogEventString(GetTimeStamp()$Chr(9)$\"item_activate\"$Chr(9)$Item.ItemName$Chr(9)$Other.PlayerReplicationInfo.PlayerID);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogItemActivate",
                        "native": false,
                        "param": [
                            [
                                "Inventory",
                                "Item"
                            ],
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "LogItemDeactivate": {
                        "body": "{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"item_deactivate\"$Chr(9)$Item.ItemName$Chr(9)$Other.PlayerReplicationInfo.PlayerID);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogItemDeactivate",
                        "native": false,
                        "param": [
                            [
                                "Inventory",
                                "Item"
                            ],
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "LogKill": {
                        "body": "{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"kill\"$Chr(9)$KillerID$Chr(9)$KillerWeaponName$Chr(9)$VictimID$Chr(9)$VictimWeaponName$Chr(9)$DamageType);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogKill",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "KillerID"
                            ],
                            [
                                "int",
                                "VictimID"
                            ],
                            [
                                "string",
                                "KillerWeaponName"
                            ],
                            [
                                "string",
                                "VictimWeaponName"
                            ],
                            [
                                "name",
                                "DamageType"
                            ]
                        ],
                        "return": ""
                    },
                    "LogMapParameters": {
                        "body": "{\n\n\tMapName = GetMapFileName();\n\n\tLogEventString(GetTimeStamp()$Chr(9)$\"map\"$Chr(9)$\"Name\"$Chr(9)$MapName);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"map\"$Chr(9)$\"Title\"$Chr(9)$Level.Title);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"map\"$Chr(9)$\"Author\"$Chr(9)$Level.Author);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"map\"$Chr(9)$\"IdealPlayerCount\"$Chr(9)$Level.IdealPlayerCount);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"map\"$Chr(9)$\"LevelEnterText\"$Chr(9)$Level.LevelEnterText);\n}",
                        "locals": [
                            "local string MapName;"
                        ],
                        "modifiers": [],
                        "name": "LogMapParameters",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "LogMutator": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "LogMutator",
                        "native": true,
                        "param": [
                            [
                                "Mutator",
                                "M"
                            ]
                        ],
                        "return": ""
                    },
                    "LogNameChange": {
                        "body": "{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Rename\"$Chr(9)$Other.PlayerReplicationInfo.PlayerName$Chr(9)$Other.PlayerReplicationInfo.PlayerID);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogNameChange",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "LogPickup": {
                        "body": "{\n\tif (Item.ItemName != \"\")\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"item_get\"$Chr(9)$Item.ItemName$Chr(9)$Other.PlayerReplicationInfo.PlayerID);\n\telse\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"item_get\"$Chr(9)$Item.Class$Chr(9)$Other.PlayerReplicationInfo.PlayerID);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogPickup",
                        "native": false,
                        "param": [
                            [
                                "Inventory",
                                "Item"
                            ],
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "LogPings": {
                        "body": "{\n\n\tforeach AllActors(class'PlayerReplicationInfo', PRI)\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Ping\"$Chr(9)$PRI.PlayerID$Chr(9)$PRI.Ping);\n}",
                        "locals": [
                            "local PlayerReplicationInfo PRI;"
                        ],
                        "modifiers": [],
                        "name": "LogPings",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "LogPlayerConnect": {
                        "body": "{\n\tif (Player.IsA('PlayerPawn'))\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Connect\"$Chr(9)$Player.PlayerReplicationInfo.PlayerName$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$PlayerPawn(Player).bAdmin);\n\telse\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Connect\"$Chr(9)$Player.PlayerReplicationInfo.PlayerName$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$False);\n\tLogPlayerInfo(Player);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogPlayerConnect",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Player"
                            ],
                            [
                                "optional",
                                "string",
                                "Checksum"
                            ]
                        ],
                        "return": ""
                    },
                    "LogPlayerDisconnect": {
                        "body": "{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Disconnect\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogPlayerDisconnect",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Player"
                            ]
                        ],
                        "return": ""
                    },
                    "LogPlayerInfo": {
                        "body": "{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"TeamName\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.TeamName);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Team\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.Team);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"TeamID\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.TeamID);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Ping\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.Ping);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"IsABot\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.bIsABot);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Skill\"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.Skill);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogPlayerInfo",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Player"
                            ]
                        ],
                        "return": ""
                    },
                    "LogServerInfo": {
                        "body": "{\n\n\tNetworkNumber = Level.Game.GetNetworkNumber();\n\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_ServerName\"$Chr(9)$Level.Game.GameReplicationInfo.ServerName);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_AdminName\"$Chr(9)$Level.Game.GameReplicationInfo.AdminName);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_AdminEmail\"$Chr(9)$Level.Game.GameReplicationInfo.AdminEmail);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_Region\"$Chr(9)$Level.Game.GameReplicationInfo.Region);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_MOTDLine1\"$Chr(9)$Level.Game.GameReplicationInfo.MOTDLine1);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_MOTDLine2\"$Chr(9)$Level.Game.GameReplicationInfo.MOTDLine2);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_MOTDLine3\"$Chr(9)$Level.Game.GameReplicationInfo.MOTDLine3);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_MOTDLine4\"$Chr(9)$Level.Game.GameReplicationInfo.MOTDLine4);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_IP\"$Chr(9)$NetworkNumber);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Server_Port\"$Chr(9)$Level.Game.GetServerPort());\n}",
                        "locals": [
                            "local string NetworkNumber;"
                        ],
                        "modifiers": [],
                        "name": "LogServerInfo",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "LogSpecialEvent": {
                        "body": "{\n\n\tEvent = EventType;\n\tif (Arg1 != \"\")\n\t\tEvent = Event$Chr(9)$Arg1;\n\tif (Arg2 != \"\")\n\t\tEvent = Event$Chr(9)$Arg2;\n\tif (Arg3 != \"\")\n\t\tEvent = Event$Chr(9)$Arg3;\n\tif (Arg4 != \"\")\n\t\tEvent = Event$Chr(9)$Arg4;\n\n\tLogEventString(GetTimeStamp()$Chr(9)$Event);\n}",
                        "locals": [
                            "local string Event;"
                        ],
                        "modifiers": [],
                        "name": "LogSpecialEvent",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "EventType"
                            ],
                            [
                                "optional",
                                "coerce",
                                "string",
                                "Arg1"
                            ],
                            [
                                "optional",
                                "coerce",
                                "string",
                                "Arg2"
                            ],
                            [
                                "optional",
                                "coerce",
                                "string",
                                "Arg3"
                            ],
                            [
                                "optional",
                                "coerce",
                                "string",
                                "Arg4"
                            ]
                        ],
                        "return": ""
                    },
                    "LogStandardInfo": {
                        "body": "{\n\tif (bWorld)\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Log_Standard\"$Chr(9)$WorldStandard);\n\telse\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Log_Standard\"$Chr(9)$LocalStandard);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Log_Version\"$Chr(9)$LogVersion);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Log_Info_URL\"$Chr(9)$LogInfoURL);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Game_Name\"$Chr(9)$GameName);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Game_Version\"$Chr(9)$Level.EngineVersion);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Game_Creator\"$Chr(9)$GameCreator);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Game_Creator_URL\"$Chr(9)$GameCreatorURL);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Game_Decoder_Ring_URL\"$Chr(9)$DecoderRingURL);\n\tLogEventString(GetTimeStamp()$Chr(9)$\"info\"$Chr(9)$\"Absolute_Time\"$Chr(9)$GetAbsoluteTime());\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogStandardInfo",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "LogSuicide": {
                        "body": "{\n\n\tif (Killed == None)\n\t\treturn;\n\n\tKilledID = Killed.PlayerReplicationInfo.PlayerID;\n\tif (Instigator == None)\n\t\tInstigatorString = \"None\";\n\telse\n\t\tInstigatorString = \"Self\";\n\n\tif (Killed.Weapon != None)\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"suicide\"$Chr(9)$KilledID$Chr(9)$Killed.Weapon.ItemName$Chr(9)$DamageType$Chr(9)$InstigatorString);\n\telse\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"suicide\"$Chr(9)$KilledID$Chr(9)$\"None\"$Chr(9)$DamageType$Chr(9)$InstigatorString);\n}",
                        "locals": [
                            "local int KilledID;",
                            "local string InstigatorString;"
                        ],
                        "modifiers": [],
                        "name": "LogSuicide",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Killed"
                            ],
                            [
                                "name",
                                "DamageType"
                            ],
                            [
                                "Pawn",
                                "Instigator"
                            ]
                        ],
                        "return": ""
                    },
                    "LogTeamChange": {
                        "body": "{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Teamchange\"$Chr(9)$Other.PlayerReplicationInfo.PlayerID$Chr(9)$Other.PlayerReplicationInfo.Team);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogTeamChange",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "LogTeamKill": {
                        "body": "{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"teamkill\"$Chr(9)$KillerID$Chr(9)$KillerWeaponName$Chr(9)$VictimID$Chr(9)$VictimWeaponName$Chr(9)$DamageType);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogTeamKill",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "KillerID"
                            ],
                            [
                                "int",
                                "VictimID"
                            ],
                            [
                                "string",
                                "KillerWeaponName"
                            ],
                            [
                                "string",
                                "VictimWeaponName"
                            ],
                            [
                                "name",
                                "DamageType"
                            ]
                        ],
                        "return": ""
                    },
                    "LogTypingEvent": {
                        "body": "{\n\tLogEventString(GetTimeStamp()$Chr(9)$\"typing\"$Chr(9)$bTyping$Chr(9)$Other.PlayerReplicationInfo.PlayerID);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogTypingEvent",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "bTyping"
                            ],
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "StartLog": {
                        "body": "{\n\t// Implemented in subclass.\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StartLog",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StopLog": {
                        "body": "{\n\t// Implemented in subclass.\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StopLog",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n\tTimeStamp += Delta;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Delta"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "{\n\tLogPings();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 396,
                "replication": "",
                "states": [],
                "variables": [
                    "var int\t\tContext;",
                    "var bool\tbWorld;",
                    "var() string LocalStandard;\t\t// The standard this log is compliant to.",
                    "var() string WorldStandard;\t\t// The standard this log is compliant to.",
                    "var() string LogVersion;\t\t// Version of the log standard.",
                    "var() string LogInfoURL;\t\t// URL to info on logging standard.",
                    "var() string GameName;\t\t\t// Name of this game.",
                    "var() string GameCreator;\t\t// Name of game creator.",
                    "var() string GameCreatorURL;\t// URL to info on game creator.",
                    "var() string DecoderRingURL;\t// URL to log format decoder ring.",
                    "var() globalconfig string\t    LocalBatcherURL;\t\t// Batcher URL.",
                    "var() globalconfig string\t    LocalBatcherParams;\t\t// Batcher command line parameters.",
                    "var() globalconfig string\t    LocalStatsURL;\t\t\t// URL to local stats information.",
                    "var() globalconfig string\t    WorldBatcherURL;\t\t// Batcher URL.",
                    "var() globalconfig string\t    WorldBatcherParams;\t\t// Batcher command line parameters.",
                    "var() globalconfig string\t    WorldStatsURL;\t\t\t// URL to world stats information.",
                    "var() globalconfig string\t\tLocalLogDir;",
                    "var() globalconfig string\t\tWorldLogDir;"
                ]
            }
        },
        "StatLogFile.uc": {
            "body": "//=============================================================================\n// Logs game events for stat collection\n//\n// Logs to a file.\n//=============================================================================\nclass StatLogFile extends StatLog\n\tnative;\n\nvar bool bWatermark;\n\n// Internal\nvar int LogAr; // C++ FArchive*.\n\n// Configs\nvar string StatLogFile;\nvar string StatLogFinal;\n\n// File Manipulation\nnative final function OpenLog();\nnative final function CloseLog();\nnative final function Watermark( string EventString );\nnative final function GetChecksum( out string Checksum );\nnative final function FileFlush();\nnative final function FileLog( string EventString );\n\n// Logging.\nfunction StartLog()\n{\n\tlocal string FileName;\n\tlocal string AbsoluteTime;\n\n\tSaveConfig();\n\n\tAbsoluteTime = GetShortAbsoluteTime();\n\tif (!bWorld)\n\t{\n\t\tFileName = LocalLogDir$\"/\"$GameName$\".\"$LocalStandard$\".\"$AbsoluteTime$\".\"$Level.Game.GetServerPort();\n\t\tStatLogFile = FileName$\".tmp\";\n\t\tStatLogFinal = FileName$\".log\";\n\t} else {\n\t\tFileName = WorldLogDir$\"/\"$GameName$\".\"$WorldStandard$\".\"$AbsoluteTime$\".\"$Level.Game.GetServerPort();\n\t\tStatLogFile = FileName$\".tmp\";\n\t\tStatLogFinal = FileName$\".log\";\n\t\tbWatermark = True;\n\t}\n\n\tOpenLog();\n}\n\nfunction StopLog()\n{\n\tFlushLog();\n\tCloseLog();\n}\n\nfunction FlushLog()\n{\n\tFileFlush();\n}\n\nfunction LogEventString( string EventString )\n{\n\tif( bWatermark )\n\t\tWatermark( EventString );\n\tFileLog( EventString );\n\tFlushLog();\n}\n\n// Return a logfile name if relevant.\nfunction string GetLogFileName()\n{\n\treturn StatLogFinal;\n}\n\nfunction LogPlayerConnect(Pawn Player, optional string Checksum)\n{\n\tif( bWorld )\n\t{\n\t\tif( Player.PlayerReplicationInfo.bIsABot )\n\t\t\tChecksum = \"IsABot\";\n\t\tif (Player.IsA('PlayerPawn'))\n\t\t\tLogEventString( GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Connect\"$Chr(9)$Player.PlayerReplicationInfo.PlayerName$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$PlayerPawn(Player).bAdmin$Chr(9)$Checksum );\n\t\telse\n\t\t\tLogEventString( GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Connect\"$Chr(9)$Player.PlayerReplicationInfo.PlayerName$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$False$Chr(9)$Checksum );\n\t\tLogPlayerInfo( Player );\n\t}\n\telse Super.LogPlayerConnect( Player, Checksum );\n}\n\nfunction LogGameEnd( string Reason )\n{\n\tlocal string Checksum;\n\n\tif( bWorld )\n\t{\n\t\tbWatermark = False;\n\t\tGetChecksum( Checksum );\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"game_end\"$Chr(9)$Reason$Chr(9)$Checksum$\"\");\n\t}\n\telse Super.LogGameEnd(Reason);\n}\n\ndefaultproperties\n{\n     StatLogFile=\"../Logs/unreal.ngStats.Unknown.log\"\n}\n",
            "name": "StatLogFile.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "StatLogFile=\"../Logs/unreal.ngStats.Unknown.log\""
                ],
                "exec": [],
                "extends": "StatLog",
                "functions": {
                    "CloseLog": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "CloseLog",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "FileFlush": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "FileFlush",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "FileLog": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "FileLog",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "EventString"
                            ]
                        ],
                        "return": ""
                    },
                    "FlushLog": {
                        "body": "{\n\tFileFlush();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "FlushLog",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GetChecksum": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "GetChecksum",
                        "native": true,
                        "param": [
                            [
                                "out",
                                "string",
                                "Checksum"
                            ]
                        ],
                        "return": ""
                    },
                    "GetLogFileName": {
                        "body": "{\n\treturn StatLogFinal;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GetLogFileName",
                        "native": false,
                        "param": [],
                        "return": "string"
                    },
                    "LogEventString": {
                        "body": "{\n\tif( bWatermark )\n\t\tWatermark( EventString );\n\tFileLog( EventString );\n\tFlushLog();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogEventString",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "EventString"
                            ]
                        ],
                        "return": ""
                    },
                    "LogGameEnd": {
                        "body": "{\n\n\tif( bWorld )\n\t{\n\t\tbWatermark = False;\n\t\tGetChecksum( Checksum );\n\t\tLogEventString(GetTimeStamp()$Chr(9)$\"game_end\"$Chr(9)$Reason$Chr(9)$Checksum$\"\");\n\t}\n\telse Super.LogGameEnd(Reason);\n}",
                        "locals": [
                            "local string Checksum;"
                        ],
                        "modifiers": [],
                        "name": "LogGameEnd",
                        "native": false,
                        "param": [
                            [
                                "string",
                                "Reason"
                            ]
                        ],
                        "return": ""
                    },
                    "LogPlayerConnect": {
                        "body": "{\n\tif( bWorld )\n\t{\n\t\tif( Player.PlayerReplicationInfo.bIsABot )\n\t\t\tChecksum = \"IsABot\";\n\t\tif (Player.IsA('PlayerPawn'))\n\t\t\tLogEventString( GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Connect\"$Chr(9)$Player.PlayerReplicationInfo.PlayerName$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$PlayerPawn(Player).bAdmin$Chr(9)$Checksum );\n\t\telse\n\t\t\tLogEventString( GetTimeStamp()$Chr(9)$\"player\"$Chr(9)$\"Connect\"$Chr(9)$Player.PlayerReplicationInfo.PlayerName$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$False$Chr(9)$Checksum );\n\t\tLogPlayerInfo( Player );\n\t}\n\telse Super.LogPlayerConnect( Player, Checksum );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "LogPlayerConnect",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Player"
                            ],
                            [
                                "optional",
                                "string",
                                "Checksum"
                            ]
                        ],
                        "return": ""
                    },
                    "OpenLog": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "OpenLog",
                        "native": true,
                        "param": [],
                        "return": ""
                    },
                    "StartLog": {
                        "body": "{\n\n\tSaveConfig();\n\n\tAbsoluteTime = GetShortAbsoluteTime();\n\tif (!bWorld)\n\t{\n\t\tFileName = LocalLogDir$\"/\"$GameName$\".\"$LocalStandard$\".\"$AbsoluteTime$\".\"$Level.Game.GetServerPort();\n\t\tStatLogFile = FileName$\".tmp\";\n\t\tStatLogFinal = FileName$\".log\";\n\t} else {\n\t\tFileName = WorldLogDir$\"/\"$GameName$\".\"$WorldStandard$\".\"$AbsoluteTime$\".\"$Level.Game.GetServerPort();\n\t\tStatLogFile = FileName$\".tmp\";\n\t\tStatLogFinal = FileName$\".log\";\n\t\tbWatermark = True;\n\t}",
                        "locals": [
                            "local string FileName;",
                            "local string AbsoluteTime;"
                        ],
                        "modifiers": [],
                        "name": "StartLog",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "StopLog": {
                        "body": "{\n\tFlushLog();\n\tCloseLog();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "StopLog",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Watermark": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "final"
                        ],
                        "name": "Watermark",
                        "native": true,
                        "param": [
                            [
                                "string",
                                "EventString"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 107,
                "replication": "",
                "states": [],
                "variables": [
                    "var bool bWatermark;",
                    "var int LogAr; // C++ FArchive*.",
                    "var string StatLogFile;",
                    "var string StatLogFinal;"
                ]
            }
        },
        "Teleporter.uc": {
            "body": "///=============================================================================\n// Teleports actors either between different teleporters within a level\n// or to matching teleporters on other levels, or to general Internet URLs.\n//=============================================================================\nclass Teleporter extends NavigationPoint\n\tnative;\n\n#exec Texture Import File=Textures\\Teleport.pcx Name=S_Teleport Mips=Off Flags=2\n\n//-----------------------------------------------------------------------------\n// Teleporter URL can be one of the following forms:\n//\n// TeleporterName\n//\t\tTeleports to a named teleporter in this level.\n//\t\tif none, acts only as a teleporter destination\n//\n// LevelName/TeleporterName\n//     Teleports to a different level on this server.\n//\n// Unreal://Server.domain.com/LevelName/TeleporterName\n//     Teleports to a different server on the net.\n//\nvar() string URL;\n\n//-----------------------------------------------------------------------------\n// Product the user must have installed in order to enter the teleporter.\nvar() name ProductRequired;\n\n//-----------------------------------------------------------------------------\n// Teleporter destination flags.\nvar() bool    bChangesVelocity; // Set velocity to TargetVelocity.\nvar() bool    bChangesYaw;      // Sets yaw to teleporter's Rotation.Yaw\nvar() bool    bReversesX;       // Reverses X-component of velocity.\nvar() bool    bReversesY;       // Reverses Y-component of velocity.\nvar() bool    bReversesZ;       // Reverses Z-component of velocity.\n\n// Teleporter flags\nvar() bool\t  bEnabled;\t\t\t// Teleporter is turned on;\n\n//-----------------------------------------------------------------------------\n// Teleporter destination directions.\nvar() vector  TargetVelocity;   // If bChangesVelocity, set target's velocity to this.\n\n// AI related\nvar Actor TriggerActor;\t\t//used to tell AI how to trigger me\nvar Actor TriggerActor2;\n\nvar float LastFired;\n\n//-----------------------------------------------------------------------------\n// Teleporter destination functions.\n\nreplication\n{\n\treliable if( Role==ROLE_Authority )\n\t\tbEnabled, URL;\n\treliable if ( bNetInitial && (Role == ROLE_Authority) )\n\t\tbChangesVelocity, bChangesYaw, bReversesX, bReversesY, bReversesZ, TargetVelocity; \n}\n\nfunction PostBeginPlay()\n{\n\tif (URL ~= \"\")\n\t\tSetCollision(false, false, false); //destination only\n\t\t\n\tif ( !bEnabled )\n\t\tFindTriggerActor();\n\tSuper.PostBeginPlay();\n}\n\nfunction FindTriggerActor()\n{\n\tlocal Actor A;\n\n\tTriggerActor = None;\n\tTriggerActor2 = None;\n\tForEach AllActors(class 'Actor', A)\n\t\tif ( A.Event == Tag)\n\t\t{\n\t\t\tif ( Counter(A) != None )\n\t\t\t\treturn; //FIXME - handle counters\n\t\t\tif (TriggerActor == None)\n\t\t\t\tTriggerActor = A;\n\t\t\telse\n\t\t\t{\n\t\t\t\tTriggerActor2 = A;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n}\n\n// Accept an actor that has teleported in.\nsimulated function bool Accept( actor Incoming, Actor Source )\n{\n\tlocal rotator newRot, oldRot;\n\tlocal int oldYaw;\n\tlocal float mag;\n\tlocal vector oldDir;\n\tlocal pawn P;\n\n\t// Move the actor here.\n\tDisable('Touch');\n\t//log(\"Move Actor here \"$tag);\n\tnewRot = Incoming.Rotation;\n\tif (bChangesYaw)\n\t{\n\t\toldRot = Incoming.Rotation;\n\t\tnewRot.Yaw = Rotation.Yaw;\n\t\tif ( Source != None )\n\t\t\tnewRot.Yaw += (32768 + Incoming.Rotation.Yaw - Source.Rotation.Yaw);\n\t}\n\n\tif ( Pawn(Incoming) != None )\n\t{\n\t\t//tell enemies about teleport\n\t\tif ( Role == ROLE_Authority )\n\t\t{\n\t\t\tP = Level.PawnList;\n\t\t\tWhile ( P != None )\n\t\t\t{\n\t\t\t\tif (P.Enemy == Incoming)\n\t\t\t\t\tP.LastSeenPos = Incoming.Location; \n\t\t\t\tP = P.nextPawn;\n\t\t\t}\n\t\t}\n\t\tPawn(Incoming).SetLocation(Location);\n\t\tif ( (Role == ROLE_Authority) \n\t\t\t|| (Level.TimeSeconds - LastFired > 0.5) )\n\t\t{\n\t\t\tPawn(Incoming).SetRotation(newRot);\n\t\t\tPawn(Incoming).ViewRotation = newRot;\n\t\t\tLastFired = Level.TimeSeconds;\n\t\t}\n\t\tPawn(Incoming).MoveTimer = -1.0;\n\t\tPawn(Incoming).MoveTarget = self;\n\t\tPlayTeleportEffect( Incoming, false);\n\t}\n\telse\n\t{\n\t\tif ( !Incoming.SetLocation(Location) )\n\t\t{\n\t\t\tEnable('Touch');\n\t\t\treturn false;\n\t\t}\n\t\tif ( bChangesYaw )\n\t\t\tIncoming.SetRotation(newRot);\n\t}\n\n\tEnable('Touch');\n\n\t\n\tif (bChangesVelocity)\n\t\tIncoming.Velocity = TargetVelocity;\n\telse\n\t{\n\t\tif ( bChangesYaw )\n\t\t{\n\t\t\tif ( Incoming.Physics == PHYS_Walking )\n\t\t\t\tOldRot.Pitch = 0;\n\t\t\toldDir = vector(OldRot);\n\t\t\tmag = Incoming.Velocity Dot oldDir;\t\t\n\t\t\tIncoming.Velocity = Incoming.Velocity - mag * oldDir + mag * vector(Incoming.Rotation);\n\t\t} \n\t\tif ( bReversesX )\n\t\t\tIncoming.Velocity.X *= -1.0;\n\t\tif ( bReversesY )\n\t\t\tIncoming.Velocity.Y *= -1.0;\n\t\tif ( bReversesZ )\n\t\t\tIncoming.Velocity.Z *= -1.0;\n\t}\t\n\n\t// Play teleport-in effect.\n\n\treturn true;\n}\n\t\nfunction PlayTeleportEffect(actor Incoming, bool bOut)\n{\n\tif ( Incoming.IsA('Pawn') )\n\t{\n\t\tIncoming.MakeNoise(1.0);\n\t\tLevel.Game.PlayTeleportEffect(Incoming, bOut, true);\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// Teleporter functions.\n\nfunction Trigger( actor Other, pawn EventInstigator )\n{\n\tlocal int i;\n\n\tbEnabled = !bEnabled;\n\tif ( bEnabled ) //teleport any pawns already in my radius\n\t\tfor (i=0;i<4;i++)\n\t\t\tif ( Touching[i] != None )\n\t\t\t\tTouch(Touching[i]);\n}\n\n// Teleporter was touched by an actor.\nsimulated function Touch( actor Other )\n{\n\tlocal Teleporter Dest;\n\tlocal int i;\n\tlocal Actor A;\n\t\n\tif ( !bEnabled )\n\t\treturn;\n\n\tif( Other.bCanTeleport && Other.PreTeleport(Self)==false )\n\t{\n\t\tif( (InStr( URL, \"/\" ) >= 0) || (InStr( URL, \"#\" ) >= 0) )\n\t\t{\n\t\t\t// Teleport to a level on the net.\n\t\t\tif( (Role == ROLE_Authority) && (PlayerPawn(Other) != None) )\n\t\t\t\tLevel.Game.SendPlayer(PlayerPawn(Other), URL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Teleport to a random teleporter in this local level, if more than one pick random.\n\n\t\t\tforeach AllActors( class 'Teleporter', Dest )\n\t\t\t\tif( string(Dest.tag)~=URL && Dest!=Self )\n\t\t\t\t\ti++;\n\t\t\ti = rand(i);\n\t\t\tforeach AllActors( class 'Teleporter', Dest )\n\t\t\t\tif( string(Dest.tag)~=URL && Dest!=Self && i-- == 0 )\n\t\t\t\t\tbreak;\n\t\t\tif( Dest != None )\n\t\t\t{\n\t\t\t\t// Teleport the actor into the other teleporter.\n\t\t\t\tif ( Other.IsA('Pawn') )\n\t\t\t\t\tPlayTeleportEffect( Pawn(Other), false);\n\t\t\t\tDest.Accept( Other, self );\n\t\t\t\tif( (Event != '') && (Other.IsA('Pawn')) )\n\t\t\t\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\t\t\t\tA.Trigger( Other, Other.Instigator );\n\t\t\t}\n\t\t\telse if ( Role == ROLE_Authority )\n\t\t\t\tPawn(Other).ClientMessage( \"Teleport destination for \"$self$\" not found!\" );\n\t\t}\n\t}\n}\n\n/* SpecialHandling is called by the navigation code when the next path has been found.  \nIt gives that path an opportunity to modify the result based on any special considerations\n*/\n\nfunction Actor SpecialHandling(Pawn Other)\n{\n\tlocal int i;\n\tlocal vector Dist2D;\n\tif ( bEnabled && (Other.RouteCache[1] != None)\n\t\t&& Other.RouteCache[1].IsA('Teleporter') && (string(Other.RouteCache[1].tag)~=URL) )\n\t{\n\t\tif ( Abs(Location.Z - Other.Location.Z) < CollisionHeight + Other.CollisionHeight )\n\t\t{\n\t\t\tDist2D = Location - Other.Location;\n\t\t\tDist2D.Z = 0;\n\t\t\tif ( VSize(Dist2D) < CollisionRadius + Other.CollisionRadius )\n\t\t\t\tTouch(Other);\n\t\t}\t\n\t\treturn self;\n\t}\n\n\tif (TriggerActor == None)\n\t{\n\t\tFindTriggerActor();\n\t\tif (TriggerActor == None)\n\t\t\treturn None;\n\t}\n\n\tif ( (TriggerActor2 != None) \n\t\t&& (VSize(TriggerActor2.Location - Other.Location) < VSize(TriggerActor.Location - Other.Location)) )\n\t\treturn TriggerActor2;\n\t\t\t\t\t\n\treturn TriggerActor;\t\t\t\n}\t\n\t\n\ndefaultproperties\n{\n     bChangesYaw=True\n     bEnabled=True\n     RemoteRole=ROLE_SimulatedProxy\n     bDirectional=True\n     Texture=Texture'Engine.S_Teleport'\n     SoundVolume=128\n     CollisionRadius=18.000000\n     CollisionHeight=40.000000\n     bCollideActors=True\n}\n",
            "name": "Teleporter.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bChangesYaw=True",
                    "bEnabled=True",
                    "RemoteRole=ROLE_SimulatedProxy",
                    "bDirectional=True",
                    "Texture=Texture'Engine.S_Teleport'",
                    "SoundVolume=128",
                    "CollisionRadius=18.000000",
                    "CollisionHeight=40.000000",
                    "bCollideActors=True"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Teleport.pcx Name=S_Teleport Mips=Off Flags=2"
                ],
                "extends": "NavigationPoint",
                "functions": {
                    "Accept": {
                        "body": "{\n\n\t// Move the actor here.\n\tDisable('Touch');\n\t//log(\"Move Actor here \"$tag);\n\tnewRot = Incoming.Rotation;\n\tif (bChangesYaw)\n\t{\n\t\toldRot = Incoming.Rotation;\n\t\tnewRot.Yaw = Rotation.Yaw;\n\t\tif ( Source != None )\n\t\t\tnewRot.Yaw += (32768 + Incoming.Rotation.Yaw - Source.Rotation.Yaw);\n\t}\n\n\tif ( Pawn(Incoming) != None )\n\t{\n\t\t//tell enemies about teleport\n\t\tif ( Role == ROLE_Authority )\n\t\t{\n\t\t\tP = Level.PawnList;\n\t\t\tWhile ( P != None )\n\t\t\t{\n\t\t\t\tif (P.Enemy == Incoming)\n\t\t\t\t\tP.LastSeenPos = Incoming.Location; \n\t\t\t\tP = P.nextPawn;\n\t\t\t}\n\t\t}\n\t\tPawn(Incoming).SetLocation(Location);\n\t\tif ( (Role == ROLE_Authority) \n\t\t\t|| (Level.TimeSeconds - LastFired > 0.5) )\n\t\t{\n\t\t\tPawn(Incoming).SetRotation(newRot);\n\t\t\tPawn(Incoming).ViewRotation = newRot;\n\t\t\tLastFired = Level.TimeSeconds;\n\t\t}\n\t\tPawn(Incoming).MoveTimer = -1.0;\n\t\tPawn(Incoming).MoveTarget = self;\n\t\tPlayTeleportEffect( Incoming, false);\n\t}\n\telse\n\t{\n\t\tif ( !Incoming.SetLocation(Location) )\n\t\t{\n\t\t\tEnable('Touch');\n\t\t\treturn false;\n\t\t}\n\t\tif ( bChangesYaw )\n\t\t\tIncoming.SetRotation(newRot);\n\t}\n\n\tEnable('Touch');\n\n\t\n\tif (bChangesVelocity)\n\t\tIncoming.Velocity = TargetVelocity;\n\telse\n\t{\n\t\tif ( bChangesYaw )\n\t\t{\n\t\t\tif ( Incoming.Physics == PHYS_Walking )\n\t\t\t\tOldRot.Pitch = 0;\n\t\t\toldDir = vector(OldRot);\n\t\t\tmag = Incoming.Velocity Dot oldDir;\t\t\n\t\t\tIncoming.Velocity = Incoming.Velocity - mag * oldDir + mag * vector(Incoming.Rotation);\n\t\t} \n\t\tif ( bReversesX )\n\t\t\tIncoming.Velocity.X *= -1.0;\n\t\tif ( bReversesY )\n\t\t\tIncoming.Velocity.Y *= -1.0;\n\t\tif ( bReversesZ )\n\t\t\tIncoming.Velocity.Z *= -1.0;\n\t}\t\n\n\t// Play teleport-in effect.\n\n\treturn true;\n}",
                        "locals": [
                            "local rotator newRot, oldRot;",
                            "local int oldYaw;",
                            "local float mag;",
                            "local vector oldDir;",
                            "local pawn P;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Accept",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Incoming"
                            ],
                            [
                                "Actor",
                                "Source"
                            ]
                        ],
                        "return": "bool"
                    },
                    "FindTriggerActor": {
                        "body": "{\n\n\tTriggerActor = None;\n\tTriggerActor2 = None;\n\tForEach AllActors(class 'Actor', A)\n\t\tif ( A.Event == Tag)\n\t\t{\n\t\t\tif ( Counter(A) != None )\n\t\t\t\treturn; //FIXME - handle counters\n\t\t\tif (TriggerActor == None)\n\t\t\t\tTriggerActor = A;\n\t\t\telse\n\t\t\t{\n\t\t\t\tTriggerActor2 = A;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n}",
                        "locals": [
                            "local Actor A;"
                        ],
                        "modifiers": [],
                        "name": "FindTriggerActor",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayTeleportEffect": {
                        "body": "{\n\tif ( Incoming.IsA('Pawn') )\n\t{\n\t\tIncoming.MakeNoise(1.0);\n\t\tLevel.Game.PlayTeleportEffect(Incoming, bOut, true);\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayTeleportEffect",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Incoming"
                            ],
                            [
                                "bool",
                                "bOut"
                            ]
                        ],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\tif (URL ~= \"\")\n\t\tSetCollision(false, false, false); //destination only\n\t\t\n\tif ( !bEnabled )\n\t\tFindTriggerActor();\n\tSuper.PostBeginPlay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpecialHandling": {
                        "body": "{\n\tif ( bEnabled && (Other.RouteCache[1] != None)\n\t\t&& Other.RouteCache[1].IsA('Teleporter') && (string(Other.RouteCache[1].tag)~=URL) )\n\t{\n\t\tif ( Abs(Location.Z - Other.Location.Z) < CollisionHeight + Other.CollisionHeight )\n\t\t{\n\t\t\tDist2D = Location - Other.Location;\n\t\t\tDist2D.Z = 0;\n\t\t\tif ( VSize(Dist2D) < CollisionRadius + Other.CollisionRadius )\n\t\t\t\tTouch(Other);\n\t\t}\t\n\t\treturn self;\n\t}\n\n\tif (TriggerActor == None)\n\t{\n\t\tFindTriggerActor();\n\t\tif (TriggerActor == None)\n\t\t\treturn None;\n\t}\n\n\tif ( (TriggerActor2 != None) \n\t\t&& (VSize(TriggerActor2.Location - Other.Location) < VSize(TriggerActor.Location - Other.Location)) )\n\t\treturn TriggerActor2;\n\t\t\t\t\t\n\treturn TriggerActor;\t\t\t\n}",
                        "locals": [
                            "local int i;",
                            "local vector Dist2D;"
                        ],
                        "modifiers": [],
                        "name": "SpecialHandling",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": "Actor"
                    },
                    "Touch": {
                        "body": "{\n\t\n\tif ( !bEnabled )\n\t\treturn;\n\n\tif( Other.bCanTeleport && Other.PreTeleport(Self)==false )\n\t{\n\t\tif( (InStr( URL, \"/\" ) >= 0) || (InStr( URL, \"#\" ) >= 0) )\n\t\t{\n\t\t\t// Teleport to a level on the net.\n\t\t\tif( (Role == ROLE_Authority) && (PlayerPawn(Other) != None) )\n\t\t\t\tLevel.Game.SendPlayer(PlayerPawn(Other), URL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Teleport to a random teleporter in this local level, if more than one pick random.\n\n\t\t\tforeach AllActors( class 'Teleporter', Dest )\n\t\t\t\tif( string(Dest.tag)~=URL && Dest!=Self )\n\t\t\t\t\ti++;\n\t\t\ti = rand(i);\n\t\t\tforeach AllActors( class 'Teleporter', Dest )\n\t\t\t\tif( string(Dest.tag)~=URL && Dest!=Self && i-- == 0 )\n\t\t\t\t\tbreak;\n\t\t\tif( Dest != None )\n\t\t\t{\n\t\t\t\t// Teleport the actor into the other teleporter.\n\t\t\t\tif ( Other.IsA('Pawn') )\n\t\t\t\t\tPlayTeleportEffect( Pawn(Other), false);\n\t\t\t\tDest.Accept( Other, self );\n\t\t\t\tif( (Event != '') && (Other.IsA('Pawn')) )\n\t\t\t\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\t\t\t\tA.Trigger( Other, Other.Instigator );\n\t\t\t}\n\t\t\telse if ( Role == ROLE_Authority )\n\t\t\t\tPawn(Other).ClientMessage( \"Teleport destination for \"$self$\" not found!\" );\n\t\t}\n\t}\n}",
                        "locals": [
                            "local Teleporter Dest;",
                            "local int i;",
                            "local Actor A;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Touch",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "{\n\n\tbEnabled = !bEnabled;\n\tif ( bEnabled ) //teleport any pawns already in my radius\n\t\tfor (i=0;i<4;i++)\n\t\t\tif ( Touching[i] != None )\n\t\t\t\tTouch(Touching[i]);\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 293,
                "replication": "",
                "states": [],
                "variables": [
                    "var() string URL;",
                    "var() name ProductRequired;",
                    "var() bool    bChangesVelocity; // Set velocity to TargetVelocity.",
                    "var() bool    bChangesYaw;      // Sets yaw to teleporter's Rotation.Yaw",
                    "var() bool    bReversesX;       // Reverses X-component of velocity.",
                    "var() bool    bReversesY;       // Reverses Y-component of velocity.",
                    "var() bool    bReversesZ;       // Reverses Z-component of velocity.",
                    "var() bool\t  bEnabled;\t\t\t// Teleporter is turned on;",
                    "var() vector  TargetVelocity;   // If bChangesVelocity, set target's velocity to this.",
                    "var Actor TriggerActor;\t\t//used to tell AI how to trigger me",
                    "var Actor TriggerActor2;",
                    "var float LastFired;"
                ]
            }
        },
        "TestInfo.uc": {
            "body": "//=============================================================================\n// For internal testing.\n//=============================================================================\nclass TestInfo extends Info;\n\nvar() bool bTrue1;\nvar() bool bFalse1;\nvar() bool bTrue2;\nvar() bool bFalse2;\nvar bool bBool1;\nvar bool bBool2;\nvar() int xnum;\nvar float ppp;\nvar string sxx;\nvar int MyArray[2];\nvar vector v1,v2;\nvar string TestRepStr;\n//var string[32] teststring;\n\nconst Pie=3.14;\nconst Str=\"Tim\";\nconst Lotus=vect(1,2,3);\n\nvar struct STest\n{\n\tvar bool b1;\n\tvar int i;\n\tvar bool b2;\n\tvar bool b3;\n} ST;\n\nfunction TestQ()\n{\n\tlocal vector v;\n\tv.x = 2;\n\tv.y = 3;\n\tv.z = 4;\n\tassert(v==vect(2,3,4));\n\tassert(v.z==4);\n\tassert(v.y==3);\n\tassert(v.x==2);\n}\n\nstatic function test()\n{\n\tclass'testinfo'.default.v1 = vect(1,2,3);\n}\n\nfunction PostBeginPlay()\n{\n\tlocal object o;\n\tlocal actor TempActor;\n\tlog(\"!!BEGIN\");\n\n\tdefault.v1=vect(5,4,3);\n\tassert(default.v1==vect(5,4,3));\n\ttest();\n\tassert(default.v1==vect(1,2,3));\n\n\tBroadcastMessage(Tag);\n\tBroadcastMessage(string(Tag));\n\tBroadcastMessage(\"test \"$string(Tag));\n\tassert(IsA('Actor'));\n\tassert(IsA('TestInfo'));\n\tassert(IsA('Info'));\n\tassert(!IsA('LevelInfo'));\n\tassert(!IsA('Texture'));\n\t//o=dynamicloadobject( \"UnrealShare.AutoMag.Reload\", class'object' );\n\t//assert(o!=None);\n\t//assert(o==None);\n\tlog(\"!!END\");\n}\n\nfunction TestStructBools()\n{\n\tassert(ST.b1==false);\n\tassert(ST.b2==false);\n\tassert(ST.b3==false);\n\n\tST.b1=true;\n\tassert(ST.b1==true);\n\tassert(ST.b2==false);\n\tassert(ST.b3==false);\n\n\tST.b2=true;\n\tassert(ST.b1==true);\n\tassert(ST.b2==true);\n\tassert(ST.b3==false);\n\n\tST.b3=true;\n\tassert(ST.b1==true);\n\tassert(ST.b2==true);\n\tassert(ST.b3==true);\n\n\tST.b1=false;\n\tST.b2=false;\n\tST.b3=false;\n}\n\nfunction BeginPlay()\n{\n\tlocal testobj to;\n\tlocal object oo;\n\tto = new class'TestObj';\n\tto = new()class'TestObj';\n\tto = new(self)class'TestObj';\n\tto = new(self,'')class'TestObj';\n\tto = new(self,'',0)class'TestObj';\n\tto.Test();\n\tTestStructBools();\n}\n\nfunction TestX( bool bResource )\n{\n\tlocal int n;\n\tn = int(bResource);\n\tMyArray[ int(bResource) ] = 0;\n\tMyArray[ int(bResource) ]++;\n}\n\nfunction bool RecurseTest()\n{\n\tbBool1=true;\n\treturn false;\n}\n\nfunction TestLimitor( class c )\n{\n\tlocal class<actor> NewClass;\n\tNewClass = class<actor>( c );\n}\n\nstatic function int OtherStatic( int i )\n{\n\tassert(i==246);\n\tassert(default.xnum==777);\n\treturn 555;\n}\n\nstatic function int TestStatic( int i )\n{\n\tassert(i==123);\n\tassert(default.xnum==777);\n\tassert(OtherStatic(i*2)==555);\n}\n\nfunction TestContinueFor()\n{\n\tlocal int i;\n\tlog(\"TestContinue\");\n\tfor( i=0; i<20; i++ )\n\t{\n\t\tlog(\"iteration \"$i);\n\t\tif(i==7||i==9||i==19)\n\t\t\tcontinue;\n\t\tlog(\"...\");\n\t}\n\tlog(\"DoneContinue\");\n}\n\nfunction TestContinueWhile()\n{\n\tlocal int i;\n\tlog(\"TestContinue\");\n\twhile( ++i <= 20 )\n\t{\n\t\tlog(\"iteration \"$i);\n\t\tif(i==7||i==9)\n\t\t\tcontinue;\n\t\tlog(\"...\");\n\t}\n\tlog(\"DoneContinue\");\n}\n\nfunction TestContinueDoUntil()\n{\n\tlocal int i;\n\tlog(\"TestContinue\");\n\tdo\n\t{\n\t\ti++;\n\t\tlog(\"iteration \"$i);\n\t\tif(i==7||i==9||i>18)\n\t\t\tcontinue;\n\t\tlog(\"...\");\n\t} until( i>20 );\n\tlog(\"DoneContinue\");\n}\n\nfunction TestContinueForEach()\n{\n\tlocal actor a;\n\tlog(\"TestContinue\");\n\tforeach AllActors( class'Actor', a )\n\t{\n\t\tlog(\"actor \"$a);\n\t\tif(light(a)==none)\n\t\t\tcontinue;\n\t\tlog(\"...\");\n\t}\n\tlog(\"DoneContinue\");\n}\n\n\nfunction SubTestOptionalOut( optional out int a, optional out int b, optional out int c )\n{\n\ta *= 2;\n\tb = b*2;\n\tc += c;\n}\nfunction TestOptionalOut()\n{\n\tlocal int a,b,c;\n\ta=1; b=2; c=3;\n\n\tSubTestOptionalOut(a,b,c);\n\tassert(a==2); assert(b==4); assert(c==6);\n\n\tSubTestOptionalOut(a,b);\n\tassert(a==4); assert(b==8); assert(c==6);\n\n\tSubTestOptionalOut(,b,c);\n\tassert(a==4); assert(b==16); assert(c==12);\n\n\tSubTestOptionalOut();\n\tassert(a==4); assert(b==16); assert(c==12);\n\n\tSubTestOptionalOut(a,b,c);\n\tassert(a==8); assert(b==32); assert(c==24);\n\n\tlog(\"TestOptionalOut ok!\");\n}\n\nfunction TestNullContext( actor a )\n{\n\tbHidden = a.bHidden;\n\ta.bHidden = bHidden;\n}\n\nfunction TestSwitch()\n{\n\tlocal string s;\n\tlocal int i;\n\tlocal bool b;\n\ts=\"Tim\";\n\ti=2;\n\tswitch( i )\n\t{\n\t\tcase 0:\n\t\t\tassert(false);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tb=true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t\tbreak;\n\t}\n\tassert(b);\n\tswitch( s )\n\t{\n\t\tcase \"\":\n\t\t\tassert(false);\n\t\t\tbreak;\n\t\tcase \"xyzzy\":\n\t\t\tassert(false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tb=false;\n\t\t\tbreak;\n\t}\n\tassert(!b);\n\tlog(\"testswitch succeeded\");\n}\n\nfunction Tick( float DeltaTime )\n{\n\tlocal class C;\n\tlocal class<testinfo> TC;\n\tlocal actor a;\n\n\tlog(\"time=\"$Level.TimeSeconds);\n\n\tTestOptionalOut();\n\tTestNullContext( self );\n\tTestNullContext( None );\n\tTestSwitch();\n\n\tv1=vect(1,2,3);\n\tv2=vect(2,4,6);\n\tassert(v1!=v2);\n\tassert(!(v1==v2));\n\tassert(v1==vect(1,2,3));\n\tassert(v2==vect(2,4,6));\n\tassert(vect(1,2,5)!=v1);\n\tassert(v1*2==v2);\n\tassert(v1==v2/2);\n\n\tassert(Pie==3.14);\n\tassert(Pie!=2);\n\tassert(Str==\"Tim\");\n\tassert(Str!=\"Bob\");\n\tassert(Lotus==vect(1,2,3));\n\n\tassert(GetPropertyText(\"sxx\")==\"Tim\");\n\tassert(GetPropertyText(\"ppp\")!=\"123\");\n\tassert(GetPropertyText(\"bogus\")==\"\");\n\txnum=345;\n\tassert(GetPropertyText(\"xnum\")==\"345\");\n\tSetPropertyText(\"xnum\",\"999\");\n\tassert(xnum==999);\n\tassert(xnum!=666);\n\n\tassert(bTrue1==true);\n\tassert(bFalse1==false);\n\tassert(bTrue2==true);\n\tassert(bFalse2==false);\n\n\tassert(default.bTrue1==true);\n\tassert(default.bFalse1==false);\n\tassert(default.bTrue2==true);\n\tassert(default.bFalse2==false);\n\n\tassert(class'TestInfo'.default.bTrue1==true);\n\tassert(class'TestInfo'.default.bFalse1==false);\n\tassert(class'TestInfo'.default.bTrue2==true);\n\tassert(class'TestInfo'.default.bFalse2==false);\n\n\tTC=Class;\n\tassert(TC.default.bTrue1==true);\n\tassert(TC.default.bFalse1==false);\n\tassert(TC.default.bTrue2==true);\n\tassert(TC.default.bFalse2==false);\n\n\tC=Class;\n\tassert(class<testinfo>(C).default.bTrue1==true);\n\tassert(class<testinfo>(C).default.bFalse1==false);\n\tassert(class<testinfo>(C).default.bTrue2==true);\n\tassert(class<testinfo>(C).default.bFalse2==false);\n\n\tassert(default.xnum==777);\n\tTestStatic(123);\n\tTC.static.TestStatic(123);\n\tclass<testinfo>(C).static.TestStatic(123);\n\n\tbBool2=RecurseTest();\n\tassert(bBool2==false);\n\n\tTestStructBools();\n\tTestQ();\n\n\tlog( \"All tests passed\" );\n}\n\nfunction f();\n\nfunction temp()\n{\n\tlocal int i;\n\tlocal playerpawn PlayerOwner;\n\tlocal name LeftList[20];\n\tfor( i=0; i<20; i++ )\n\t\tPlayerOwner.WeaponPriority[i] = LeftList[i+1];\n\ttemp();\n}\n\nstate AA\n{\n\tfunction f();\n}\nstate BB\n{\n\tfunction f();\n}\nstate CCAA extends AA\n{\n\tfunction f();\n}\nstate DDAA extends AA\n{\n\tfunction f();\n}\nstate EEDDAA extends DDAA\n{\n\tfunction f();\n}\n\ndefaultproperties\n{\n     bTrue1=True\n     bTrue2=True\n     xnum=777\n     ppp=3.140000\n     sxx=\"Tim\"\n     bHidden=False\n     RemoteRole=ROLE_SimulatedProxy\n     bAlwaysRelevant=True\n}\n",
            "name": "TestInfo.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bTrue1=True",
                    "bTrue2=True",
                    "xnum=777",
                    "ppp=3.140000",
                    "sxx=\"Tim\"",
                    "bHidden=False",
                    "RemoteRole=ROLE_SimulatedProxy",
                    "bAlwaysRelevant=True"
                ],
                "exec": [],
                "extends": "Info",
                "functions": {
                    "BeginPlay": {
                        "body": "{\n\tto = new class'TestObj';\n\tto = new()class'TestObj';\n\tto = new(self)class'TestObj';\n\tto = new(self,'')class'TestObj';\n\tto = new(self,'',0)class'TestObj';\n\tto.Test();\n\tTestStructBools();\n}",
                        "locals": [
                            "local testobj to;",
                            "local object oo;"
                        ],
                        "modifiers": [],
                        "name": "BeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "OtherStatic": {
                        "body": "{\n\tassert(i==246);\n\tassert(default.xnum==777);\n\treturn 555;\n}",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "OtherStatic",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "i"
                            ]
                        ],
                        "return": "int"
                    },
                    "PostBeginPlay": {
                        "body": "{\n\tlog(\"!!BEGIN\");\n\n\tdefault.v1=vect(5,4,3);\n\tassert(default.v1==vect(5,4,3));\n\ttest();\n\tassert(default.v1==vect(1,2,3));\n\n\tBroadcastMessage(Tag);\n\tBroadcastMessage(string(Tag));\n\tBroadcastMessage(\"test \"$string(Tag));\n\tassert(IsA('Actor'));\n\tassert(IsA('TestInfo'));\n\tassert(IsA('Info'));\n\tassert(!IsA('LevelInfo'));\n\tassert(!IsA('Texture'));\n\t//o=dynamicloadobject( \"UnrealShare.AutoMag.Reload\", class'object' );\n\t//assert(o!=None);\n\t//assert(o==None);\n\tlog(\"!!END\");\n}",
                        "locals": [
                            "local object o;",
                            "local actor TempActor;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "RecurseTest": {
                        "body": "{\n\tbBool1=true;\n\treturn false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "RecurseTest",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "SubTestOptionalOut": {
                        "body": "{\n\ta *= 2;\n\tb = b*2;\n\tc += c;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SubTestOptionalOut",
                        "native": false,
                        "param": [
                            [
                                "optional",
                                "out",
                                "int",
                                "a"
                            ],
                            [
                                "optional",
                                "out",
                                "int",
                                "b"
                            ],
                            [
                                "optional",
                                "out",
                                "int",
                                "c"
                            ]
                        ],
                        "return": ""
                    },
                    "TestContinueDoUntil": {
                        "body": "{\n\tlog(\"TestContinue\");\n\tdo\n\t{\n\t\ti++;\n\t\tlog(\"iteration \"$i);\n\t\tif(i==7||i==9||i>18)\n\t\t\tcontinue;\n\t\tlog(\"...\");\n\t} until( i>20 );\n\tlog(\"DoneContinue\");\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "TestContinueDoUntil",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TestContinueFor": {
                        "body": "{\n\tlog(\"TestContinue\");\n\tfor( i=0; i<20; i++ )\n\t{\n\t\tlog(\"iteration \"$i);\n\t\tif(i==7||i==9||i==19)\n\t\t\tcontinue;\n\t\tlog(\"...\");\n\t}\n\tlog(\"DoneContinue\");\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "TestContinueFor",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TestContinueForEach": {
                        "body": "{\n\tlog(\"TestContinue\");\n\tforeach AllActors( class'Actor', a )\n\t{\n\t\tlog(\"actor \"$a);\n\t\tif(light(a)==none)\n\t\t\tcontinue;\n\t\tlog(\"...\");\n\t}\n\tlog(\"DoneContinue\");\n}",
                        "locals": [
                            "local actor a;"
                        ],
                        "modifiers": [],
                        "name": "TestContinueForEach",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TestContinueWhile": {
                        "body": "{\n\tlog(\"TestContinue\");\n\twhile( ++i <= 20 )\n\t{\n\t\tlog(\"iteration \"$i);\n\t\tif(i==7||i==9)\n\t\t\tcontinue;\n\t\tlog(\"...\");\n\t}\n\tlog(\"DoneContinue\");\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "TestContinueWhile",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TestNullContext": {
                        "body": "{\n\tbHidden = a.bHidden;\n\ta.bHidden = bHidden;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TestNullContext",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "a"
                            ]
                        ],
                        "return": ""
                    },
                    "TestOptionalOut": {
                        "body": "{\n\ta=1; b=2; c=3;\n\n\tSubTestOptionalOut(a,b,c);\n\tassert(a==2); assert(b==4); assert(c==6);\n\n\tSubTestOptionalOut(a,b);\n\tassert(a==4); assert(b==8); assert(c==6);\n\n\tSubTestOptionalOut(,b,c);\n\tassert(a==4); assert(b==16); assert(c==12);\n\n\tSubTestOptionalOut();\n\tassert(a==4); assert(b==16); assert(c==12);\n\n\tSubTestOptionalOut(a,b,c);\n\tassert(a==8); assert(b==32); assert(c==24);\n\n\tlog(\"TestOptionalOut ok!\");\n}",
                        "locals": [
                            "local int a,b,c;"
                        ],
                        "modifiers": [],
                        "name": "TestOptionalOut",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TestQ": {
                        "body": "{\n\tv.x = 2;\n\tv.y = 3;\n\tv.z = 4;\n\tassert(v==vect(2,3,4));\n\tassert(v.z==4);\n\tassert(v.y==3);\n\tassert(v.x==2);\n}",
                        "locals": [
                            "local vector v;"
                        ],
                        "modifiers": [],
                        "name": "TestQ",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TestStatic": {
                        "body": "{\n\tassert(i==123);\n\tassert(default.xnum==777);\n\tassert(OtherStatic(i*2)==555);\n}",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "TestStatic",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "i"
                            ]
                        ],
                        "return": "int"
                    },
                    "TestStructBools": {
                        "body": "{\n\tassert(ST.b1==false);\n\tassert(ST.b2==false);\n\tassert(ST.b3==false);\n\n\tST.b1=true;\n\tassert(ST.b1==true);\n\tassert(ST.b2==false);\n\tassert(ST.b3==false);\n\n\tST.b2=true;\n\tassert(ST.b1==true);\n\tassert(ST.b2==true);\n\tassert(ST.b3==false);\n\n\tST.b3=true;\n\tassert(ST.b1==true);\n\tassert(ST.b2==true);\n\tassert(ST.b3==true);\n\n\tST.b1=false;\n\tST.b2=false;\n\tST.b3=false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TestStructBools",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TestSwitch": {
                        "body": "{\n\ts=\"Tim\";\n\ti=2;\n\tswitch( i )\n\t{\n\t\tcase 0:\n\t\t\tassert(false);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tb=true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(false);\n\t\t\tbreak;\n\t}\n\tassert(b);\n\tswitch( s )\n\t{\n\t\tcase \"\":\n\t\t\tassert(false);\n\t\t\tbreak;\n\t\tcase \"xyzzy\":\n\t\t\tassert(false);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tb=false;\n\t\t\tbreak;\n\t}\n\tassert(!b);\n\tlog(\"testswitch succeeded\");\n}",
                        "locals": [
                            "local string s;",
                            "local int i;",
                            "local bool b;"
                        ],
                        "modifiers": [],
                        "name": "TestSwitch",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TestX": {
                        "body": "{\n\tn = int(bResource);\n\tMyArray[ int(bResource) ] = 0;\n\tMyArray[ int(bResource) ]++;\n}",
                        "locals": [
                            "local int n;"
                        ],
                        "modifiers": [],
                        "name": "TestX",
                        "native": false,
                        "param": [
                            [
                                "bool",
                                "bResource"
                            ]
                        ],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n\n\tlog(\"time=\"$Level.TimeSeconds);\n\n\tTestOptionalOut();\n\tTestNullContext( self );\n\tTestNullContext( None );\n\tTestSwitch();\n\n\tv1=vect(1,2,3);\n\tv2=vect(2,4,6);\n\tassert(v1!=v2);\n\tassert(!(v1==v2));\n\tassert(v1==vect(1,2,3));\n\tassert(v2==vect(2,4,6));\n\tassert(vect(1,2,5)!=v1);\n\tassert(v1*2==v2);\n\tassert(v1==v2/2);\n\n\tassert(Pie==3.14);\n\tassert(Pie!=2);\n\tassert(Str==\"Tim\");\n\tassert(Str!=\"Bob\");\n\tassert(Lotus==vect(1,2,3));\n\n\tassert(GetPropertyText(\"sxx\")==\"Tim\");\n\tassert(GetPropertyText(\"ppp\")!=\"123\");\n\tassert(GetPropertyText(\"bogus\")==\"\");\n\txnum=345;\n\tassert(GetPropertyText(\"xnum\")==\"345\");\n\tSetPropertyText(\"xnum\",\"999\");\n\tassert(xnum==999);\n\tassert(xnum!=666);\n\n\tassert(bTrue1==true);\n\tassert(bFalse1==false);\n\tassert(bTrue2==true);\n\tassert(bFalse2==false);\n\n\tassert(default.bTrue1==true);\n\tassert(default.bFalse1==false);\n\tassert(default.bTrue2==true);\n\tassert(default.bFalse2==false);\n\n\tassert(class'TestInfo'.default.bTrue1==true);\n\tassert(class'TestInfo'.default.bFalse1==false);\n\tassert(class'TestInfo'.default.bTrue2==true);\n\tassert(class'TestInfo'.default.bFalse2==false);\n\n\tTC=Class;\n\tassert(TC.default.bTrue1==true);\n\tassert(TC.default.bFalse1==false);\n\tassert(TC.default.bTrue2==true);\n\tassert(TC.default.bFalse2==false);\n\n\tC=Class;\n\tassert(class<testinfo>(C).default.bTrue1==true);\n\tassert(class<testinfo>(C).default.bFalse1==false);\n\tassert(class<testinfo>(C).default.bTrue2==true);\n\tassert(class<testinfo>(C).default.bFalse2==false);\n\n\tassert(default.xnum==777);\n\tTestStatic(123);\n\tTC.static.TestStatic(123);\n\tclass<testinfo>(C).static.TestStatic(123);\n\n\tbBool2=RecurseTest();\n\tassert(bBool2==false);\n\n\tTestStructBools();\n\tTestQ();\n\n\tlog( \"All tests passed\" );\n}",
                        "locals": [
                            "local class C;",
                            "local class<testinfo> TC;",
                            "local actor a;"
                        ],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "f": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "f",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "temp": {
                        "body": "{\n\tfor( i=0; i<20; i++ )\n\t\tPlayerOwner.WeaponPriority[i] = LeftList[i+1];\n\ttemp();\n}",
                        "locals": [
                            "local int i;",
                            "local playerpawn PlayerOwner;",
                            "local name LeftList[20];"
                        ],
                        "modifiers": [],
                        "name": "temp",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "test": {
                        "body": "{\n\tclass'testinfo'.default.v1 = vect(1,2,3);\n}",
                        "locals": [],
                        "modifiers": [
                            "static"
                        ],
                        "name": "test",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 399,
                "replication": "",
                "states": [],
                "variables": [
                    "var() bool bTrue1;",
                    "var() bool bFalse1;",
                    "var() bool bTrue2;",
                    "var() bool bFalse2;",
                    "var bool bBool1;",
                    "var bool bBool2;",
                    "var() int xnum;",
                    "var float ppp;",
                    "var string sxx;",
                    "var int MyArray[2];",
                    "var vector v1,v2;",
                    "var string TestRepStr;",
                    "var struct STest",
                    "var bool b1;",
                    "var int i;",
                    "var bool b2;",
                    "var bool b3;"
                ]
            }
        },
        "TestObj.uc": {
            "body": "//=============================================================================\n// TestObj: A purely scripted object for internal testing.\n//=============================================================================\nclass TestObj extends Object;\n\nfunction Test()\n{\n\tlog( \"TestObj.Test\" );\n}\n\ndefaultproperties\n{\n}\n",
            "name": "TestObj.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Object",
                "functions": {
                    "Test": {
                        "body": "{\n\tlog( \"TestObj.Test\" );\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Test",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 14,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "Texture.uc": {
            "body": "//=============================================================================\n// Texture: An Unreal texture map.\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass Texture extends Bitmap\n\tsafereplace\n\tnative\n\tnoexport;\n\n// Subtextures.\nvar(Texture) texture BumpMap;\t\t// Bump map to illuminate this texture with.\nvar(Texture) texture DetailTexture;\t// Detail texture to apply.\nvar(Texture) texture MacroTexture;\t// Macrotexture to apply, not currently used.\n\n// Surface properties.\nvar(Texture) float Diffuse;\t\t\t// Diffuse lighting coefficient.\nvar(Texture) float Specular;\t\t// Specular lighting coefficient.\nvar(Texture) float Alpha;\t\t\t// Alpha.\nvar(Texture) float DrawScale;       // Scaling relative to parent.\nvar(Texture) float Friction;\t\t// Surface friction coefficient, 1.0=none, 0.95=some.\nvar(Texture) float MipMult;         // Mipmap multiplier.\n\n// Sounds.\nvar() sound FootstepSound;\t\t\t// Footstep sound.\nvar() sound HitSound;\t\t\t\t// Sound when the texture is hit with a projectile.\n\n// Surface flags. !!out of date\nvar          bool bInvisible;\nvar(Surface) editconst bool bMasked;\nvar(Surface) bool bTransparent;\nvar          bool bNotSolid;\nvar(Surface) bool bEnvironment;\nvar          bool bSemisolid;\nvar(Surface) bool bModulate;\nvar(Surface) bool bFakeBackdrop;\nvar(Surface) bool bTwoSided;\nvar(Surface) bool bAutoUPan;\nvar(Surface) bool bAutoVPan;\nvar(Surface) bool bNoSmooth;\nvar(Surface) bool bBigWavy;\nvar(Surface) bool bSmallWavy;\nvar(Surface) bool bWaterWavy;\nvar          bool bLowShadowDetail;\nvar          bool bNoMerge;\nvar(Surface) bool bCloudWavy;\nvar          bool bDirtyShadows;\nvar          bool bHighLedge;\nvar          bool bSpecialLit;\nvar          bool bGouraud;\nvar(Surface) bool bUnlit;\nvar          bool bHighShadowDetail;\nvar          bool bPortal;\nvar          const bool bMirrored, bX2, bX3;\nvar          const bool bX4, bX5, bX6, bX7;\n\n// Texture flags.\nvar(Quality) private  bool bHighColorQuality;   // High color quality hint.\nvar(Quality) private  bool bHighTextureQuality; // High color quality hint.\nvar private           bool bRealtime;           // Texture changes in realtime.\nvar private           bool bParametric;         // Texture data need not be stored.\nvar private transient bool bRealtimeChanged;    // Changed since last render.\nvar private           bool bHasComp;\t\t\t// Whether a compressed version exists.\n\n// Level of detail set.\nvar(Quality) enum ELODSet\n{\n\tLODSET_None,   // No level of detail mipmap tossing.\n\tLODSET_World,  // World level-of-detail set.\n\tLODSET_Skin,   // Skin level-of-detail set.\n} LODSet;\n\n// Animation.\nvar(Animation) texture AnimNext;\nvar transient  texture AnimCurrent;\nvar(Animation) byte    PrimeCount;\nvar transient  byte    PrimeCurrent;\nvar(Animation) float   MinFrameRate, MaxFrameRate;\nvar transient  float   Accumulator;\n\n// Mipmaps.\nvar private native const array<int> Mips, CompMips;\nvar const ETextureFormat CompFormat;\n\ndefaultproperties\n{\n     Diffuse=1.000000\n     Specular=1.000000\n     DrawScale=1.000000\n     Friction=1.000000\n     MipMult=1.000000\n     LODSet=LODSET_World\n}\n",
            "name": "Texture.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "Diffuse=1.000000",
                    "Specular=1.000000",
                    "DrawScale=1.000000",
                    "Friction=1.000000",
                    "MipMult=1.000000",
                    "LODSet=LODSET_World"
                ],
                "exec": [],
                "extends": "Bitmap",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 93,
                "replication": "",
                "states": [],
                "variables": [
                    "var(Texture) texture BumpMap;\t\t// Bump map to illuminate this texture with.",
                    "var(Texture) texture DetailTexture;\t// Detail texture to apply.",
                    "var(Texture) texture MacroTexture;\t// Macrotexture to apply, not currently used.",
                    "var(Texture) float Diffuse;\t\t\t// Diffuse lighting coefficient.",
                    "var(Texture) float Specular;\t\t// Specular lighting coefficient.",
                    "var(Texture) float Alpha;\t\t\t// Alpha.",
                    "var(Texture) float DrawScale;       // Scaling relative to parent.",
                    "var(Texture) float Friction;\t\t// Surface friction coefficient, 1.0=none, 0.95=some.",
                    "var(Texture) float MipMult;         // Mipmap multiplier.",
                    "var() sound FootstepSound;\t\t\t// Footstep sound.",
                    "var() sound HitSound;\t\t\t\t// Sound when the texture is hit with a projectile.",
                    "var          bool bInvisible;",
                    "var(Surface) editconst bool bMasked;",
                    "var(Surface) bool bTransparent;",
                    "var          bool bNotSolid;",
                    "var(Surface) bool bEnvironment;",
                    "var          bool bSemisolid;",
                    "var(Surface) bool bModulate;",
                    "var(Surface) bool bFakeBackdrop;",
                    "var(Surface) bool bTwoSided;",
                    "var(Surface) bool bAutoUPan;",
                    "var(Surface) bool bAutoVPan;",
                    "var(Surface) bool bNoSmooth;",
                    "var(Surface) bool bBigWavy;",
                    "var(Surface) bool bSmallWavy;",
                    "var(Surface) bool bWaterWavy;",
                    "var          bool bLowShadowDetail;",
                    "var          bool bNoMerge;",
                    "var(Surface) bool bCloudWavy;",
                    "var          bool bDirtyShadows;",
                    "var          bool bHighLedge;",
                    "var          bool bSpecialLit;",
                    "var          bool bGouraud;",
                    "var(Surface) bool bUnlit;",
                    "var          bool bHighShadowDetail;",
                    "var          bool bPortal;",
                    "var          const bool bMirrored, bX2, bX3;",
                    "var          const bool bX4, bX5, bX6, bX7;",
                    "var(Quality) private  bool bHighColorQuality;   // High color quality hint.",
                    "var(Quality) private  bool bHighTextureQuality; // High color quality hint.",
                    "var private           bool bRealtime;           // Texture changes in realtime.",
                    "var private           bool bParametric;         // Texture data need not be stored.",
                    "var private transient bool bRealtimeChanged;    // Changed since last render.",
                    "var private           bool bHasComp;\t\t\t// Whether a compressed version exists.",
                    "var(Quality) enum ELODSet",
                    "var(Animation) texture AnimNext;",
                    "var transient  texture AnimCurrent;",
                    "var(Animation) byte    PrimeCount;",
                    "var transient  byte    PrimeCurrent;",
                    "var(Animation) float   MinFrameRate, MaxFrameRate;",
                    "var transient  float   Accumulator;",
                    "var private native const array<int> Mips, CompMips;",
                    "var const ETextureFormat CompFormat;"
                ]
            }
        },
        "Trigger.uc": {
            "body": "//=============================================================================\n// Trigger: senses things happening in its proximity and generates \n// sends Trigger/UnTrigger to actors whose names match 'EventName'.\n//=============================================================================\nclass Trigger extends Triggers\n\tnative;\n\n#exec Texture Import File=Textures\\Trigger.pcx Name=S_Trigger Mips=Off Flags=2\n\n//-----------------------------------------------------------------------------\n// Trigger variables.\n\n// Trigger type.\nvar() enum ETriggerType\n{\n\tTT_PlayerProximity,\t// Trigger is activated by player proximity.\n\tTT_PawnProximity,\t// Trigger is activated by any pawn's proximity\n\tTT_ClassProximity,\t// Trigger is activated by actor of that class only\n\tTT_AnyProximity,    // Trigger is activated by any actor in proximity.\n\tTT_Shoot,\t\t    // Trigger is activated by player shooting it.\n} TriggerType;\n\n// Human readable triggering message.\nvar() localized string Message;\n\n// Only trigger once and then go dormant.\nvar() bool bTriggerOnceOnly;\n\n// For triggers that are activated/deactivated by other triggers.\nvar() bool bInitiallyActive;\n\nvar() class<actor> ClassProximityType;\n\nvar() float\tRepeatTriggerTime; //if > 0, repeat trigger message at this interval is still touching other\nvar() float ReTriggerDelay; //minimum time before trigger can be triggered again\nvar\t  float TriggerTime;\nvar() float DamageThreshold; //minimum damage to trigger if TT_Shoot\n\n// AI vars\nvar\tactor TriggerActor;\t// actor that triggers this trigger\nvar actor TriggerActor2;\n\n//=============================================================================\n// AI related functions\n\nfunction PostBeginPlay()\n{\n\tif ( !bInitiallyActive )\n\t\tFindTriggerActor();\n\tif ( TriggerType == TT_Shoot )\n\t{\n\t\tbHidden = false;\n\t\tbProjTarget = true;\n\t\tDrawType = DT_None;\n\t}\n\t\t\n\tSuper.PostBeginPlay();\n}\n\nfunction FindTriggerActor()\n{\n\tlocal Actor A;\n\n\tTriggerActor = None;\n\tTriggerActor2 = None;\n\tForEach AllActors(class 'Actor', A)\n\t\tif ( A.Event == Tag)\n\t\t{\n\t\t\tif ( Counter(A) != None )\n\t\t\t\treturn; //FIXME - handle counters\n\t\t\tif (TriggerActor == None)\n\t\t\t\tTriggerActor = A;\n\t\t\telse\n\t\t\t{\n\t\t\t\tTriggerActor2 = A;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n}\n\nfunction Actor SpecialHandling(Pawn Other)\n{\n\tlocal int i;\n\n\tif ( bTriggerOnceOnly && !bCollideActors )\n\t\treturn None;\n\n\tif ( (TriggerType == TT_PlayerProximity) && !Other.bIsPlayer )\n\t\treturn None;\n\n\tif ( !bInitiallyActive )\n\t{\n\t\tif ( TriggerActor == None )\n\t\t\tFindTriggerActor();\n\t\tif ( TriggerActor == None )\n\t\t\treturn None;\n\t\tif ( (TriggerActor2 != None) \n\t\t\t&& (VSize(TriggerActor2.Location - Other.Location) < VSize(TriggerActor.Location - Other.Location)) )\n\t\t\treturn TriggerActor2;\n\t\telse\n\t\t\treturn TriggerActor;\n\t}\n\n\t// is this a shootable trigger?\n\tif ( TriggerType == TT_Shoot )\n\t{\n\t\tif ( !Other.bCanDoSpecial || (Other.Weapon == None) )\n\t\t\treturn None;\n\n\t\tOther.Target = self;\n\t\tOther.bShootSpecial = true;\n\t\tOther.FireWeapon();\n\t\tOther.bFire = 0;\n\t\tOther.bAltFire = 0;\n\t\treturn Other;\n\t}\n\n\t// can other trigger it right away?\n\tif ( IsRelevant(Other) )\n\t{\n\t\tfor (i=0;i<4;i++)\n\t\t\tif (Touching[i] == Other)\n\t\t\t\tTouch(Other);\n\t\treturn self;\n\t}\n\n\treturn self;\n}\n\n// when trigger gets turned on, check its touch list\n\nfunction CheckTouchList()\n{\n\tlocal int i;\n\n\tfor (i=0;i<4;i++)\n\t\tif ( Touching[i] != None )\n\t\t\tTouch(Touching[i]);\n}\n\n//=============================================================================\n// Trigger states.\n\n// Trigger is always active.\nstate() NormalTrigger\n{\n}\n\n// Other trigger toggles this trigger's activity.\nstate() OtherTriggerToggles\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tbInitiallyActive = !bInitiallyActive;\n\t\tif ( bInitiallyActive )\n\t\t\tCheckTouchList();\n\t}\n}\n\n// Other trigger turns this on.\nstate() OtherTriggerTurnsOn\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tlocal bool bWasActive;\n\n\t\tbWasActive = bInitiallyActive;\n\t\tbInitiallyActive = true;\n\t\tif ( !bWasActive )\n\t\t\tCheckTouchList();\n\t}\n}\n\n// Other trigger turns this off.\nstate() OtherTriggerTurnsOff\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tbInitiallyActive = false;\n\t}\n}\n\n//=============================================================================\n// Trigger logic.\n\n//\n// See whether the other actor is relevant to this trigger.\n//\nfunction bool IsRelevant( actor Other )\n{\n\tif( !bInitiallyActive )\n\t\treturn false;\n\n\t// DEUS_EX STM -- added cheat\n\tif( (Other != None) && (!Other.bDetectable) )\n\t\treturn false;\n\n\tswitch( TriggerType )\n\t{\n\t\tcase TT_PlayerProximity:\n\t\t\treturn Pawn(Other)!=None && Pawn(Other).bIsPlayer;\n\t\tcase TT_PawnProximity:\n\t\t\treturn Pawn(Other)!=None && ( Pawn(Other).Intelligence > BRAINS_None );\n\t\tcase TT_ClassProximity:\n\t\t\treturn ClassIsChildOf(Other.Class, ClassProximityType);\n\t\tcase TT_AnyProximity:\n\t\t\treturn true;\n\t\tcase TT_Shoot:\n\t\t\treturn ( (Projectile(Other) != None) && (Projectile(Other).Damage >= DamageThreshold) );\n\t}\n}\n//\n// Called when something touches the trigger.\n//\nfunction Touch( actor Other )\n{\n\tlocal actor A;\n\tlocal bool  restoreGroup;  // DEUS_EX CNN\n\n\tif( IsRelevant( Other ) )\n\t{\n\t\tif ( ReTriggerDelay > 0 )\n\t\t{\n\t\t\tif ( Level.TimeSeconds - TriggerTime < ReTriggerDelay )\n\t\t\t\treturn;\n\t\t\tTriggerTime = Level.TimeSeconds;\n\t\t}\n\t\t// Broadcast the Trigger message to all matching actors.\n\t\tif( Event != '' )\n\t\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\t{\n\t\t\t\t// DEUS_EX CNN\n\t\t\t\t// If the triggering actor doesn't have a group, then\n\t\t\t\t// we copy the trigger's group into the group of the triggerer\n\t\t\t\t// This will make LogicTriggers work correctly and won't\n\t\t\t\t// affect anything else\n\t\t\t\tif (Other.Group == '')\n\t\t\t\t{\n\t\t\t\t\tOther.Group = Group;\n\t\t\t\t\trestoreGroup = True;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\trestoreGroup = False;\n\n\t\t\t\tA.Trigger( Other, Other.Instigator );\n\n\t\t\t\t// DEUS_EX CNN\n\t\t\t\tif (restoreGroup)\n\t\t\t\t\tOther.Group = '';\n\t\t\t}\n\n\t\tif ( Other.IsA('Pawn') && (Pawn(Other).SpecialGoal == self) )\n\t\t\tPawn(Other).SpecialGoal = None;\n\t\t\t\t\n\t\tif( Message != \"\" )\n\t\t\t// Send a string message to the toucher.\n\t\t\tOther.Instigator.ClientMessage( Message );\n\n\t\tif( bTriggerOnceOnly )\n\t\t\t// Ignore future touches.\n\t\t\tSetCollision(False);\n\t\telse if ( RepeatTriggerTime > 0 )\n\t\t\tSetTimer(RepeatTriggerTime, false);\n\t}\n}\n\nfunction Timer()\n{\n\tlocal bool bKeepTiming;\n\tlocal int i;\n\n\tbKeepTiming = false;\n\n\tfor (i=0;i<4;i++)\n\t\tif ( (Touching[i] != None) && IsRelevant(Touching[i]) )\n\t\t{\n\t\t\tbKeepTiming = true;\n\t\t\tTouch(Touching[i]);\n\t\t}\n\n\tif ( bKeepTiming )\n\t\tSetTimer(RepeatTriggerTime, false);\n}\n\nfunction TakeDamage( int Damage, Pawn instigatedBy, Vector hitlocation, \n\t\t\t\t\t\tVector momentum, name damageType)\n{\n\tlocal actor A;\n\n\tif ( bInitiallyActive && (TriggerType == TT_Shoot) && (Damage >= DamageThreshold) && (instigatedBy != None) )\n\t{\n\t\tif ( ReTriggerDelay > 0 )\n\t\t{\n\t\t\tif ( Level.TimeSeconds - TriggerTime < ReTriggerDelay )\n\t\t\t\treturn;\n\t\t\tTriggerTime = Level.TimeSeconds;\n\t\t}\n\t\t// Broadcast the Trigger message to all matching actors.\n\t\tif( Event != '' )\n\t\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\t\tA.Trigger( instigatedBy, instigatedBy );\n\n\t\tif( Message != \"\" )\n\t\t\t// Send a string message to the toucher.\n\t\t\tinstigatedBy.Instigator.ClientMessage( Message );\n\n\t\tif( bTriggerOnceOnly )\n\t\t\t// Ignore future touches.\n\t\t\tSetCollision(False);\n\t}\n}\n\n//\n// When something untouches the trigger.\n//\nfunction UnTouch( actor Other )\n{\n\tlocal actor A;\n\tif( IsRelevant( Other ) )\n\t{\n\t\t// Untrigger all matching actors.\n\t\tif( Event != '' )\n\t\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\t\tA.UnTrigger( Other, Other.Instigator );\n\t}\n}\n\ndefaultproperties\n{\n     bInitiallyActive=True\n     InitialState=NormalTrigger\n     Texture=Texture'Engine.S_Trigger'\n}\n",
            "name": "Trigger.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bInitiallyActive=True",
                    "InitialState=NormalTrigger",
                    "Texture=Texture'Engine.S_Trigger'"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Trigger.pcx Name=S_Trigger Mips=Off Flags=2"
                ],
                "extends": "Triggers",
                "functions": {
                    "CheckTouchList": {
                        "body": "{\n\n\tfor (i=0;i<4;i++)\n\t\tif ( Touching[i] != None )\n\t\t\tTouch(Touching[i]);\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "CheckTouchList",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "FindTriggerActor": {
                        "body": "{\n\n\tTriggerActor = None;\n\tTriggerActor2 = None;\n\tForEach AllActors(class 'Actor', A)\n\t\tif ( A.Event == Tag)\n\t\t{\n\t\t\tif ( Counter(A) != None )\n\t\t\t\treturn; //FIXME - handle counters\n\t\t\tif (TriggerActor == None)\n\t\t\t\tTriggerActor = A;\n\t\t\telse\n\t\t\t{\n\t\t\t\tTriggerActor2 = A;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n}",
                        "locals": [
                            "local Actor A;"
                        ],
                        "modifiers": [],
                        "name": "FindTriggerActor",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "IsRelevant": {
                        "body": "{\n\tif( !bInitiallyActive )\n\t\treturn false;\n\n\t// DEUS_EX STM -- added cheat\n\tif( (Other != None) && (!Other.bDetectable) )\n\t\treturn false;\n\n\tswitch( TriggerType )\n\t{\n\t\tcase TT_PlayerProximity:\n\t\t\treturn Pawn(Other)!=None && Pawn(Other).bIsPlayer;\n\t\tcase TT_PawnProximity:\n\t\t\treturn Pawn(Other)!=None && ( Pawn(Other).Intelligence > BRAINS_None );\n\t\tcase TT_ClassProximity:\n\t\t\treturn ClassIsChildOf(Other.Class, ClassProximityType);\n\t\tcase TT_AnyProximity:\n\t\t\treturn true;\n\t\tcase TT_Shoot:\n\t\t\treturn ( (Projectile(Other) != None) && (Projectile(Other).Damage >= DamageThreshold) );\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "IsRelevant",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": "bool"
                    },
                    "PostBeginPlay": {
                        "body": "{\n\tif ( !bInitiallyActive )\n\t\tFindTriggerActor();\n\tif ( TriggerType == TT_Shoot )\n\t{\n\t\tbHidden = false;\n\t\tbProjTarget = true;\n\t\tDrawType = DT_None;\n\t}\n\t\t\n\tSuper.PostBeginPlay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpecialHandling": {
                        "body": "{\n\n\tif ( bTriggerOnceOnly && !bCollideActors )\n\t\treturn None;\n\n\tif ( (TriggerType == TT_PlayerProximity) && !Other.bIsPlayer )\n\t\treturn None;\n\n\tif ( !bInitiallyActive )\n\t{\n\t\tif ( TriggerActor == None )\n\t\t\tFindTriggerActor();\n\t\tif ( TriggerActor == None )\n\t\t\treturn None;\n\t\tif ( (TriggerActor2 != None) \n\t\t\t&& (VSize(TriggerActor2.Location - Other.Location) < VSize(TriggerActor.Location - Other.Location)) )\n\t\t\treturn TriggerActor2;\n\t\telse\n\t\t\treturn TriggerActor;\n\t}\n\n\t// is this a shootable trigger?\n\tif ( TriggerType == TT_Shoot )\n\t{\n\t\tif ( !Other.bCanDoSpecial || (Other.Weapon == None) )\n\t\t\treturn None;\n\n\t\tOther.Target = self;\n\t\tOther.bShootSpecial = true;\n\t\tOther.FireWeapon();\n\t\tOther.bFire = 0;\n\t\tOther.bAltFire = 0;\n\t\treturn Other;\n\t}\n\n\t// can other trigger it right away?\n\tif ( IsRelevant(Other) )\n\t{\n\t\tfor (i=0;i<4;i++)\n\t\t\tif (Touching[i] == Other)\n\t\t\t\tTouch(Other);\n\t\treturn self;\n\t}\n\n\treturn self;\n}",
                        "locals": [
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "SpecialHandling",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": "Actor"
                    },
                    "Timer": {
                        "body": "{\n\n\tbKeepTiming = false;\n\n\tfor (i=0;i<4;i++)\n\t\tif ( (Touching[i] != None) && IsRelevant(Touching[i]) )\n\t\t{\n\t\t\tbKeepTiming = true;\n\t\t\tTouch(Touching[i]);\n\t\t}\n\n\tif ( bKeepTiming )\n\t\tSetTimer(RepeatTriggerTime, false);\n}",
                        "locals": [
                            "local bool bKeepTiming;",
                            "local int i;"
                        ],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Touch": {
                        "body": "{\n\n\tif( IsRelevant( Other ) )\n\t{\n\t\tif ( ReTriggerDelay > 0 )\n\t\t{\n\t\t\tif ( Level.TimeSeconds - TriggerTime < ReTriggerDelay )\n\t\t\t\treturn;\n\t\t\tTriggerTime = Level.TimeSeconds;\n\t\t}\n\t\t// Broadcast the Trigger message to all matching actors.\n\t\tif( Event != '' )\n\t\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\t{\n\t\t\t\t// DEUS_EX CNN\n\t\t\t\t// If the triggering actor doesn't have a group, then\n\t\t\t\t// we copy the trigger's group into the group of the triggerer\n\t\t\t\t// This will make LogicTriggers work correctly and won't\n\t\t\t\t// affect anything else\n\t\t\t\tif (Other.Group == '')\n\t\t\t\t{\n\t\t\t\t\tOther.Group = Group;\n\t\t\t\t\trestoreGroup = True;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\trestoreGroup = False;\n\n\t\t\t\tA.Trigger( Other, Other.Instigator );\n\n\t\t\t\t// DEUS_EX CNN\n\t\t\t\tif (restoreGroup)\n\t\t\t\t\tOther.Group = '';\n\t\t\t}\n\n\t\tif ( Other.IsA('Pawn') && (Pawn(Other).SpecialGoal == self) )\n\t\t\tPawn(Other).SpecialGoal = None;\n\t\t\t\t\n\t\tif( Message != \"\" )\n\t\t\t// Send a string message to the toucher.\n\t\t\tOther.Instigator.ClientMessage( Message );\n\n\t\tif( bTriggerOnceOnly )\n\t\t\t// Ignore future touches.\n\t\t\tSetCollision(False);\n\t\telse if ( RepeatTriggerTime > 0 )\n\t\t\tSetTimer(RepeatTriggerTime, false);\n\t}\n}",
                        "locals": [
                            "local actor A;",
                            "local bool  restoreGroup;  // DEUS_EX CNN"
                        ],
                        "modifiers": [],
                        "name": "Touch",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "{\n\t\tbInitiallyActive = false;\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    },
                    "UnTouch": {
                        "body": "{\n\tif( IsRelevant( Other ) )\n\t{\n\t\t// Untrigger all matching actors.\n\t\tif( Event != '' )\n\t\t\tforeach AllActors( class 'Actor', A, Event )\n\t\t\t\tA.UnTrigger( Other, Other.Instigator );\n\t}\n}",
                        "locals": [
                            "local actor A;"
                        ],
                        "modifiers": [],
                        "name": "UnTouch",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 334,
                "replication": "",
                "states": [],
                "variables": [
                    "var() enum ETriggerType",
                    "var() localized string Message;",
                    "var() bool bTriggerOnceOnly;",
                    "var() bool bInitiallyActive;",
                    "var() class<actor> ClassProximityType;",
                    "var() float\tRepeatTriggerTime; //if > 0, repeat trigger message at this interval is still touching other",
                    "var() float ReTriggerDelay; //minimum time before trigger can be triggered again",
                    "var() float DamageThreshold; //minimum damage to trigger if TT_Shoot",
                    "var actor TriggerActor2;"
                ]
            }
        },
        "TriggerLight.uc": {
            "body": "//=============================================================================\n// TriggerLight.\n// A lightsource which can be triggered on or off.\n//=============================================================================\nclass TriggerLight extends Light;\n\n//-----------------------------------------------------------------------------\n// Variables.\n\nvar() float ChangeTime;        // Time light takes to change from on to off.\nvar() bool  bInitiallyOn;      // Whether it's initially on.\nvar() bool  bDelayFullOn;      // Delay then go full-on.\nvar() float RemainOnTime;      // How long the TriggerPound effect lasts\n\nvar   float InitialBrightness; // Initial brightness.\nvar   float Alpha, Direction;\nvar   actor SavedTrigger;\nvar   float poundTime;\n\n//-----------------------------------------------------------------------------\n// Engine functions.\n\n// Called at start of gameplay.\nsimulated function BeginPlay()\n{\n\t// Remember initial light type and set new one.\n\tDisable( 'Tick' );\n\tInitialBrightness = LightBrightness;\n\tif( bInitiallyOn )\n\t{\n\t\tAlpha     = 1.0;\n\t\tDirection = 1.0;\n\t}\n\telse\n\t{\n\t\tAlpha     = 0.0;\n\t\tDirection = -1.0;\n\t}\n\tDrawType = DT_None;\n}\n\n// Called whenever time passes.\nfunction Tick( float DeltaTime )\n{\n\tAlpha += Direction * DeltaTime / ChangeTime;\n\tif( Alpha > 1.0 )\n\t{\n\t\tAlpha = 1.0;\n\t\tDisable( 'Tick' );\n\t\tif( SavedTrigger != None )\n\t\t\tSavedTrigger.EndEvent();\n\t}\n\telse if( Alpha < 0.0 )\n\t{\n\t\tAlpha = 0.0;\n\t\tDisable( 'Tick' );\n\t\tif( SavedTrigger != None )\n\t\t\tSavedTrigger.EndEvent();\n\t}\n\tif( !bDelayFullOn )\n\t\tLightBrightness = Alpha * InitialBrightness;\n\telse if( (Direction>0 && Alpha!=1) || Alpha==0 )\n\t\tLightBrightness = 0;\n\telse\n\t\tLightBrightness = InitialBrightness;\n\n\t// DEUS_EX CNN - Hide the corona when turned off\n\tif (LightBrightness == 0)\n\t{\n\t\tMultiSkins[1] = Skin;\n\t\tSkin = None;\n\t}\n\telse\n\t{\n\t\tSkin = MultiSkins[1];\n\t\tMultiSkins[1] = None;\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// Public states.\n\n// Trigger turns the light on.\nstate() TriggerTurnsOn\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tif( SavedTrigger!=None )\n\t\t\tSavedTrigger.EndEvent();\n\t\tSavedTrigger = Other;\n\t\tSavedTrigger.BeginEvent();\n\t\tDirection = 1.0;\n\t\tEnable( 'Tick' );\n\t}\n}\n\n// Trigger turns the light off.\nstate() TriggerTurnsOff\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tif( SavedTrigger!=None )\n\t\t\tSavedTrigger.EndEvent();\n\t\tSavedTrigger = Other;\n\t\tSavedTrigger.BeginEvent();\n\t\tDirection = -1.0;\n\t\tEnable( 'Tick' );\n\t}\n}\n\n// Trigger toggles the light.\nstate() TriggerToggle\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tif( SavedTrigger!=None )\n\t\t\tSavedTrigger.EndEvent();\n\t\tSavedTrigger = Other;\n\t\tSavedTrigger.BeginEvent();\n\t\tDirection *= -1;\n\t\tEnable( 'Tick' );\n\t}\n}\n\n// Trigger controls the light.\nstate() TriggerControl\n{\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\t\tif( SavedTrigger!=None )\n\t\t\tSavedTrigger.EndEvent();\n\t\tSavedTrigger = Other;\n\t\tSavedTrigger.BeginEvent();\n\t\tif( bInitiallyOn ) Direction = -1.0;\n\t\telse               Direction = 1.0;\n\t\tEnable( 'Tick' );\n\t}\n\tfunction UnTrigger( actor Other, pawn EventInstigator )\n\t{\n\t\tif( SavedTrigger!=None )\n\t\t\tSavedTrigger.EndEvent();\n\t\tSavedTrigger = Other;\n\t\tSavedTrigger.BeginEvent();\n\t\tif( bInitiallyOn ) Direction = 1.0;\n\t\telse               Direction = -1.0;\n\t\tEnable( 'Tick' );\n\t}\n}\n\nstate() TriggerPound {\n\n\tfunction Timer () {\n\t\n\t\tif (poundTime >= RemainOnTime) {\n\t\t\n\t\t\tDisable ('Timer');\n\t\t}\n\t\tpoundTime += ChangeTime;\n\t\tDirection *= -1;\n\t\tSetTimer (ChangeTime, false);\n\t}\n\n\tfunction Trigger( actor Other, pawn EventInstigator )\n\t{\n\n\t\tif( SavedTrigger!=None )\n\t\t\tSavedTrigger.EndEvent();\n\t\tSavedTrigger = Other;\n\t\tSavedTrigger.BeginEvent();\n\t\tDirection = 1;\n\t\tpoundTime = ChangeTime;\t\t\t// how much time will pass till reversal\n\t\tSetTimer (ChangeTime, false);\t\t// wake up when it's time to reverse\n\t\tEnable   ('Timer');\n\t\tEnable   ('Tick');\n\t}\n}\n\ndefaultproperties\n{\n     bStatic=False\n     bHidden=False\n     bMovable=True\n     RemoteRole=ROLE_SimulatedProxy\n}\n",
            "name": "TriggerLight.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bStatic=False",
                    "bHidden=False",
                    "bMovable=True",
                    "RemoteRole=ROLE_SimulatedProxy"
                ],
                "exec": [],
                "extends": "Light",
                "functions": {
                    "BeginPlay": {
                        "body": "{\n\t// Remember initial light type and set new one.\n\tDisable( 'Tick' );\n\tInitialBrightness = LightBrightness;\n\tif( bInitiallyOn )\n\t{\n\t\tAlpha     = 1.0;\n\t\tDirection = 1.0;\n\t}\n\telse\n\t{\n\t\tAlpha     = 0.0;\n\t\tDirection = -1.0;\n\t}\n\tDrawType = DT_None;\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "BeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n\tAlpha += Direction * DeltaTime / ChangeTime;\n\tif( Alpha > 1.0 )\n\t{\n\t\tAlpha = 1.0;\n\t\tDisable( 'Tick' );\n\t\tif( SavedTrigger != None )\n\t\t\tSavedTrigger.EndEvent();\n\t}\n\telse if( Alpha < 0.0 )\n\t{\n\t\tAlpha = 0.0;\n\t\tDisable( 'Tick' );\n\t\tif( SavedTrigger != None )\n\t\t\tSavedTrigger.EndEvent();\n\t}\n\tif( !bDelayFullOn )\n\t\tLightBrightness = Alpha * InitialBrightness;\n\telse if( (Direction>0 && Alpha!=1) || Alpha==0 )\n\t\tLightBrightness = 0;\n\telse\n\t\tLightBrightness = InitialBrightness;\n\n\t// DEUS_EX CNN - Hide the corona when turned off\n\tif (LightBrightness == 0)\n\t{\n\t\tMultiSkins[1] = Skin;\n\t\tSkin = None;\n\t}\n\telse\n\t{\n\t\tSkin = MultiSkins[1];\n\t\tMultiSkins[1] = None;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "Timer": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Timer",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "{\n\n\t\tif( SavedTrigger!=None )\n\t\t\tSavedTrigger.EndEvent();\n\t\tSavedTrigger = Other;\n\t\tSavedTrigger.BeginEvent();\n\t\tDirection = 1;\n\t\tpoundTime = ChangeTime;\t\t\t// how much time will pass till reversal\n\t\tSetTimer (ChangeTime, false);\t\t// wake up when it's time to reverse\n\t\tEnable   ('Timer');\n\t\tEnable   ('Tick');\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    },
                    "UnTrigger": {
                        "body": "{\n\t\tif( SavedTrigger!=None )\n\t\t\tSavedTrigger.EndEvent();\n\t\tSavedTrigger = Other;\n\t\tSavedTrigger.BeginEvent();\n\t\tif( bInitiallyOn ) Direction = 1.0;\n\t\telse               Direction = -1.0;\n\t\tEnable( 'Tick' );\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "UnTrigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 185,
                "replication": "",
                "states": [],
                "variables": [
                    "var() float ChangeTime;        // Time light takes to change from on to off.",
                    "var() bool  bInitiallyOn;      // Whether it's initially on.",
                    "var() bool  bDelayFullOn;      // Delay then go full-on.",
                    "var() float RemainOnTime;      // How long the TriggerPound effect lasts",
                    "var   float InitialBrightness; // Initial brightness.",
                    "var   float Alpha, Direction;",
                    "var   actor SavedTrigger;",
                    "var   float poundTime;"
                ]
            }
        },
        "TriggerMarker.uc": {
            "body": "//=============================================================================\n// TriggerMarker.\n//=============================================================================\nclass TriggerMarker extends NavigationPoint\n\tnative;\n\n// OBSOLETE - to be removed\n\ndefaultproperties\n{\n}\n",
            "name": "TriggerMarker.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "NavigationPoint",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 12,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "Triggers.uc": {
            "body": "//=============================================================================\n// Event.\n//=============================================================================\nclass Triggers extends Actor\n\tnative;\n\ndefaultproperties\n{\n     bHidden=True\n     CollisionRadius=40.000000\n     CollisionHeight=40.000000\n     bCollideActors=True\n}\n",
            "name": "Triggers.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bHidden=True",
                    "CollisionRadius=40.000000",
                    "CollisionHeight=40.000000",
                    "bCollideActors=True"
                ],
                "exec": [],
                "extends": "Actor",
                "functions": {},
                "header": [],
                "instructions": [],
                "loc": 14,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "VoicePack.uc": {
            "body": "//=============================================================================\n// VoicePack.\n//=============================================================================\nclass VoicePack extends Info\n\tabstract;\n\t\n/*\n(exec function to do ServerVoiceMessage, and use in OrdersMenu)\n(voicepack configuration for players and bots)\n*/\n\n/* \nClientInitialize() sets up playing the appropriate voice segment, and returns a string\n representation of the message\n*/\nfunction ClientInitialize(PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageIndex);\nfunction PlayerSpeech(int Type, int Index, int Callsign);\n\t\n\ndefaultproperties\n{\n     RemoteRole=ROLE_None\n     LifeSpan=10.000000\n}\n",
            "name": "VoicePack.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "RemoteRole=ROLE_None",
                    "LifeSpan=10.000000"
                ],
                "exec": [],
                "extends": "Info",
                "functions": {
                    "": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "",
                        "native": false,
                        "param": [
                            [
                                "exec",
                                "function",
                                "to",
                                "do",
                                "ServerVoiceMessage"
                            ],
                            [
                                "and",
                                "use",
                                "in",
                                "OrdersMenu"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientInitialize": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientInitialize",
                        "native": false,
                        "param": [
                            [
                                "PlayerReplicationInfo",
                                "Sender"
                            ],
                            [
                                "PlayerReplicationInfo",
                                "Recipient"
                            ],
                            [
                                "name",
                                "messagetype"
                            ],
                            [
                                "byte",
                                "messageIndex"
                            ]
                        ],
                        "return": ""
                    },
                    "PlayerSpeech": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayerSpeech",
                        "native": false,
                        "param": [
                            [
                                "int",
                                "Type"
                            ],
                            [
                                "int",
                                "Index"
                            ],
                            [
                                "int",
                                "Callsign"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 25,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "WarpZoneInfo.uc": {
            "body": "//=============================================================================\n// WarpZoneInfo. For making disjoint spaces appear as if they were connected;\n// supports both in-level warp zones and cross-level warp zones.\n//=============================================================================\nclass WarpZoneInfo extends ZoneInfo\n\tnative;\n\n//-----------------------------------------------------------------------------\n// Information set by the level designer.\n\nvar() string     OtherSideURL;\nvar() name       ThisTag;\nvar() bool\t\t bNoTeleFrag;\n\n//-----------------------------------------------------------------------------\n// Internal.\n\nvar const int              iWarpZone;\nvar const coords           WarpCoords;\nvar transient WarpZoneInfo OtherSideActor;\nvar transient object       OtherSideLevel;\nvar() string\t\t       Destinations[8];\nvar int\t\t\t\t\t   numDestinations;\n\n//-----------------------------------------------------------------------------\n// Network replication.\n\nreplication\n{\n\treliable if( Role==ROLE_Authority )\n\t\tOtherSideURL, ThisTag, OtherSideActor;\n}\n\n//-----------------------------------------------------------------------------\n// Functions.\n\n// Warp coordinate system transformations.\nnative(314) final function Warp  ( out vector Loc, out vector Vel, out rotator R );\nnative(315) final function UnWarp( out vector Loc, out vector Vel, out rotator R );\n\nfunction PreBeginPlay()\n{\n\tSuper.PreBeginPlay();\n\n\t// Generate the local connection.\n\tGenerate();\n\n\t// Setup destination list.\n\tnumDestinations = 0;\n\tWhile( numDestinations < 8 )\n\t\tif (Destinations[numDestinations] != \"\")\n\t\t\tnumDestinations++;\n\t\telse\n\t\t\tnumDestinations = 8;\n\n\t// Generate URL if necessary.\n\tif( numDestinations>0 && (OtherSideURL == \"\") )\n\t\tOtherSideURL = Destinations[0];\n}\n\nfunction Trigger( actor Other, pawn EventInstigator )\n{\n\tlocal int nextPick;\n\tif (numDestinations == 0)\n\t\treturn;\n\t\n\tnextPick = 0;\n\tWhile( (nextPick < 8) && (Destinations[nextPick] != OtherSideURL )  )\n\t\tnextPick++;\n\n\tnextPick++;\n\tif ( (nextPick > 7) || (Destinations[nextPick] == \"\") )\n\t\tnextPick = 0;\n\t\n\tOtherSideURL = Destinations[nextPick];\n\tForceGenerate();\n}\n\n// Set up this warp zone's destination.\nsimulated event Generate()\n{\n\tif( OtherSideLevel != None )\n\t\treturn;\n\tForceGenerate();\n}\n\n// Set up this warp zone's destination.\nsimulated event ForceGenerate()\n{\n\tif( InStr(OtherSideURL,\"/\") >= 0 )\n\t{\n\t\t// Remote level.\n\t\t//log( \"Warpzone \" $ Self $ \" remote\" );\n\t\tOtherSideLevel = None;\n\t\tOtherSideActor = None;\n\t}\n\telse\n\t{\n\t\t// Local level.\n\t\tOtherSideLevel = XLevel;\n\t\tforeach AllActors( class 'WarpZoneInfo', OtherSideActor )\n\t\t\tif( string(OtherSideActor.ThisTag)~=OtherSideURL && OtherSideActor!=Self )\n\t\t\t\tbreak;\n\t\t//log( \"Warpzone \" $ Self $ \" local, connected to \" $ OtherSideActor );\n\t}\n}\n\n// When an actor enters this warp zone.\nsimulated function ActorEntered( actor Other )\n{\n\tlocal vector L;\n\tlocal rotator R;\n\tlocal Pawn P;\n\n\t//if ( Other.Role == ROLE_AutonomousProxy )\n\t//\treturn; // don't simulate for client players\n\tSuper.ActorEntered( Other );\n\tif( !Other.bJustTeleported )\n\t{\n\t\tGenerate();\n\t\tif( OtherSideActor != None )\n\t\t{\n\t\t\t// This needs to also perform a coordinate system transformation,\n\t\t\t// in case the portals aren't directionally aligned. This is easy to\n\t\t\t// do but UnrealScript doesn't provide coordinate system operators yet.\n\t\t\tOther.Disable('Touch');\n\t\t\tOther.Disable('UnTouch');\n\n\t\t\tL = Other.Location;\n\t\t\tif( Other.IsA('PlayerPawn') )\n\t\t\t\tR = PlayerPawn(Other).ViewRotation;\n\t\t\telse\n\t\t\t\tR = Other.Rotation;\n\n\t\t\tUnWarp( L, Other.Velocity, R );\n\t\t\tOtherSideActor.Warp( L, Other.Velocity, R );\n\n\t\t\tif( Other.IsA('Pawn') )\n\t\t\t{\n\t\t\t\tPawn(Other).bWarping = bNoTelefrag;\n\t\t\t\tif ( Other.SetLocation(L) )\n\t\t\t\t{\n\t\t\t\t\t//tell enemies about teleport\n\t\t\t\t\tif ( Role == ROLE_Authority )\n\t\t\t\t\t{\n\t\t\t\t\t\tP = Level.PawnList;\n\t\t\t\t\t\tWhile ( P != None )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (P.Enemy == Other)\n\t\t\t\t\t\t\t\tP.LastSeenPos = Other.Location; \n\t\t\t\t\t\t\tP = P.nextPawn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tR.Roll = 0;\n\t\t\t\t\tPawn(Other).ViewRotation = R;\n\t\t\t\t\tPawn(Other).ClientSetLocation(L, R );\n\t\t\t\t\tPawn(Other).MoveTimer = -1.0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// set up to keep trying to teleport\n\t\t\t\t\tGotoState('DelayedWarp');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOther.SetLocation(L);\n\t\t\t\tOther.SetRotation( R );\n\t\t\t}\n\t\t\tOther.Enable('Touch');\n\t\t\tOther.Enable('UnTouch');\n\t\t\t// Change rotation according to portal's rotational change.\n\t\t}\n\t}\n}\n\nevent ActorLeaving( actor Other )\n{\n\tSuper.ActorLeaving(Other);\n\tIf ( Other.IsA('Pawn') )\n\t\tPawn(Other).bWarping = false;\n}\n\nState DelayedWarp\n{\n\tfunction Tick(float DeltaTime)\n\t{\n\t\tlocal Pawn P;\n\t\tlocal bool bFound;\n\n\t\tFor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t\t\tif ( P.bWarping && (P.Region.Zone == Self) )\n\t\t\t{\n\t\t\t\tbFound = true;\n\t\t\t\tActorEntered(P);\n\t\t\t}\n\n\t\tIf ( !bFound )\n\t\t\tGotoState('');\n\t}\n}\n\ndefaultproperties\n{\n     MaxCarcasses=0\n}\n",
            "name": "WarpZoneInfo.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "MaxCarcasses=0"
                ],
                "exec": [],
                "extends": "ZoneInfo",
                "functions": {
                    "ActorEntered": {
                        "body": "{\n\n\t//if ( Other.Role == ROLE_AutonomousProxy )\n\t//\treturn; // don't simulate for client players\n\tSuper.ActorEntered( Other );\n\tif( !Other.bJustTeleported )\n\t{\n\t\tGenerate();\n\t\tif( OtherSideActor != None )\n\t\t{\n\t\t\t// This needs to also perform a coordinate system transformation,\n\t\t\t// in case the portals aren't directionally aligned. This is easy to\n\t\t\t// do but UnrealScript doesn't provide coordinate system operators yet.\n\t\t\tOther.Disable('Touch');\n\t\t\tOther.Disable('UnTouch');\n\n\t\t\tL = Other.Location;\n\t\t\tif( Other.IsA('PlayerPawn') )\n\t\t\t\tR = PlayerPawn(Other).ViewRotation;\n\t\t\telse\n\t\t\t\tR = Other.Rotation;\n\n\t\t\tUnWarp( L, Other.Velocity, R );\n\t\t\tOtherSideActor.Warp( L, Other.Velocity, R );\n\n\t\t\tif( Other.IsA('Pawn') )\n\t\t\t{\n\t\t\t\tPawn(Other).bWarping = bNoTelefrag;\n\t\t\t\tif ( Other.SetLocation(L) )\n\t\t\t\t{\n\t\t\t\t\t//tell enemies about teleport\n\t\t\t\t\tif ( Role == ROLE_Authority )\n\t\t\t\t\t{\n\t\t\t\t\t\tP = Level.PawnList;\n\t\t\t\t\t\tWhile ( P != None )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (P.Enemy == Other)\n\t\t\t\t\t\t\t\tP.LastSeenPos = Other.Location; \n\t\t\t\t\t\t\tP = P.nextPawn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tR.Roll = 0;\n\t\t\t\t\tPawn(Other).ViewRotation = R;\n\t\t\t\t\tPawn(Other).ClientSetLocation(L, R );\n\t\t\t\t\tPawn(Other).MoveTimer = -1.0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// set up to keep trying to teleport\n\t\t\t\t\tGotoState('DelayedWarp');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tOther.SetLocation(L);\n\t\t\t\tOther.SetRotation( R );\n\t\t\t}\n\t\t\tOther.Enable('Touch');\n\t\t\tOther.Enable('UnTouch');\n\t\t\t// Change rotation according to portal's rotational change.\n\t\t}\n\t}\n}",
                        "locals": [
                            "local vector L;",
                            "local rotator R;",
                            "local Pawn P;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ActorEntered",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "ActorLeaving": {
                        "body": "{\n\tSuper.ActorLeaving(Other);\n\tIf ( Other.IsA('Pawn') )\n\t\tPawn(Other).bWarping = false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ActorLeaving",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "ForceGenerate": {
                        "body": "{\n\tif( InStr(OtherSideURL,\"/\") >= 0 )\n\t{\n\t\t// Remote level.\n\t\t//log( \"Warpzone \" $ Self $ \" remote\" );\n\t\tOtherSideLevel = None;\n\t\tOtherSideActor = None;\n\t}\n\telse\n\t{\n\t\t// Local level.\n\t\tOtherSideLevel = XLevel;\n\t\tforeach AllActors( class 'WarpZoneInfo', OtherSideActor )\n\t\t\tif( string(OtherSideActor.ThisTag)~=OtherSideURL && OtherSideActor!=Self )\n\t\t\t\tbreak;\n\t\t//log( \"Warpzone \" $ Self $ \" local, connected to \" $ OtherSideActor );\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ForceGenerate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Generate": {
                        "body": "{\n\tif( OtherSideLevel != None )\n\t\treturn;\n\tForceGenerate();\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "Generate",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tSuper.PreBeginPlay();\n\n\t// Generate the local connection.\n\tGenerate();\n\n\t// Setup destination list.\n\tnumDestinations = 0;\n\tWhile( numDestinations < 8 )\n\t\tif (Destinations[numDestinations] != \"\")\n\t\t\tnumDestinations++;\n\t\telse\n\t\t\tnumDestinations = 8;\n\n\t// Generate URL if necessary.\n\tif( numDestinations>0 && (OtherSideURL == \"\") )\n\t\tOtherSideURL = Destinations[0];\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Tick": {
                        "body": "{\n\n\t\tFor ( P=Level.PawnList; P!=None; P=P.NextPawn )\n\t\t\tif ( P.bWarping && (P.Region.Zone == Self) )\n\t\t\t{\n\t\t\t\tbFound = true;\n\t\t\t\tActorEntered(P);\n\t\t\t}\n\n\t\tIf ( !bFound )\n\t\t\tGotoState('');\n\t}",
                        "locals": [
                            "local Pawn P;",
                            "local bool bFound;"
                        ],
                        "modifiers": [],
                        "name": "Tick",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "DeltaTime"
                            ]
                        ],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "{\n\tif (numDestinations == 0)\n\t\treturn;\n\t\n\tnextPick = 0;\n\tWhile( (nextPick < 8) && (Destinations[nextPick] != OtherSideURL )  )\n\t\tnextPick++;\n\n\tnextPick++;\n\tif ( (nextPick > 7) || (Destinations[nextPick] == \"\") )\n\t\tnextPick = 0;\n\t\n\tOtherSideURL = Destinations[nextPick];\n\tForceGenerate();\n}",
                        "locals": [
                            "local int nextPick;"
                        ],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    },
                    "UnWarp": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "UnWarp",
                        "native": true,
                        "param": [
                            [
                                "out",
                                "vector",
                                "Loc"
                            ],
                            [
                                "out",
                                "vector",
                                "Vel"
                            ],
                            [
                                "out",
                                "rotator",
                                "R"
                            ]
                        ],
                        "return": ""
                    },
                    "Warp": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "Warp",
                        "native": true,
                        "param": [
                            [
                                "out",
                                "vector",
                                "Loc"
                            ],
                            [
                                "out",
                                "vector",
                                "Vel"
                            ],
                            [
                                "out",
                                "rotator",
                                "R"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 207,
                "replication": "",
                "states": [],
                "variables": [
                    "var() string     OtherSideURL;",
                    "var() name       ThisTag;",
                    "var() bool\t\t bNoTeleFrag;",
                    "var const int              iWarpZone;",
                    "var const coords           WarpCoords;",
                    "var transient WarpZoneInfo OtherSideActor;",
                    "var transient object       OtherSideLevel;",
                    "var() string\t\t       Destinations[8];",
                    "var int\t\t\t\t\t   numDestinations;"
                ]
            }
        },
        "WarpZoneMarker.uc": {
            "body": "//=============================================================================\n// WarpZoneMarker.\n//=============================================================================\nclass WarpZoneMarker extends NavigationPoint\n\tnative;\n\nvar WarpZoneInfo markedWarpZone;\n\n// AI related\nvar Actor TriggerActor;\t\t//used to tell AI how to trigger me\nvar Actor TriggerActor2;\n\nfunction PostBeginPlay()\n{\n\tif ( markedWarpZone.numDestinations > 1 )\n\t\tFindTriggerActor();\n\tSuper.PostBeginPlay();\n}\n\nfunction FindTriggerActor()\n{\n\tlocal ZoneTrigger Z;\n\tForEach AllActors(class 'ZoneTrigger', Z)\n\t\tif ( Z.Event == markedWarpZone.ZoneTag)\n\t\t{\n\t\t\tTriggerActor = Z;\n\t\t\treturn;\n\t\t} \n}\n\n/* SpecialHandling is called by the navigation code when the next path has been found.  \nIt gives that path an opportunity to modify the result based on any special considerations\n*/\n\n/* FIXME - how to figure out if other side actor is OK and use intelligently for all dests? \n*/\nfunction Actor SpecialHandling(Pawn Other)\n{\n\tif (Other.Region.Zone == markedWarpZone)\n\t\tmarkedWarpZone.ActorEntered(Other);\n\treturn self;\n}\n/*\tif ( markedWarpZone.numDestinations <= 1 )\n\t\treturn self;\n\t\n\tif ( markedWarpZone.OtherSideActor is OK )\n\t\treturn self;\n\t\t\t\n\tif (TriggerActor == None)\n\t{\n\t\tFindTriggerActor();\n\t\tif (TriggerActor == None)\n\t\t\treturn None;\n\t}\n\t\n\treturn TriggerActor;\t\t\t\n}\t \n*/\n\ndefaultproperties\n{\n     bCollideWhenPlacing=False\n     bHiddenEd=True\n     CollisionRadius=20.000000\n     CollisionHeight=40.000000\n}\n",
            "name": "WarpZoneMarker.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bCollideWhenPlacing=False",
                    "bHiddenEd=True",
                    "CollisionRadius=20.000000",
                    "CollisionHeight=40.000000"
                ],
                "exec": [],
                "extends": "NavigationPoint",
                "functions": {
                    "FindTriggerActor": {
                        "body": "{\n\tForEach AllActors(class 'ZoneTrigger', Z)\n\t\tif ( Z.Event == markedWarpZone.ZoneTag)\n\t\t{\n\t\t\tTriggerActor = Z;\n\t\t\treturn;\n\t\t} \n}",
                        "locals": [
                            "local ZoneTrigger Z;"
                        ],
                        "modifiers": [],
                        "name": "FindTriggerActor",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\tif ( markedWarpZone.numDestinations > 1 )\n\t\tFindTriggerActor();\n\tSuper.PostBeginPlay();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpecialHandling": {
                        "body": "{\n\tif (Other.Region.Zone == markedWarpZone)\n\t\tmarkedWarpZone.ActorEntered(Other);\n\treturn self;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SpecialHandling",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": "Actor"
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 67,
                "replication": "",
                "states": [],
                "variables": [
                    "var WarpZoneInfo markedWarpZone;",
                    "var Actor TriggerActor;\t\t//used to tell AI how to trigger me",
                    "var Actor TriggerActor2;"
                ]
            }
        },
        "WayBeacon.uc": {
            "body": "//=============================================================================\n// WayBeacon.\n//=============================================================================\nclass WayBeacon extends Keypoint;\n\n//temporary beacon for serverfind navigation\n\nfunction PostBeginPlay()\n{\n\tlocal class<actor> NewClass;\n\n\tSuper.PostBeginPlay();\n\tNewClass = class<actor>( DynamicLoadObject( \"Unreali.Lamp4\", class'Class' ) );\n\tif( NewClass!=None )\n\t\tMesh = NewClass.Default.Mesh;\n}\n\nfunction touch(actor other)\n{\n\tif (other == owner)\n\t{\n\t\tif ( Owner.IsA('PlayerPawn') )\n\t\t\tPlayerPawn(owner).ShowPath();\n\t\tDestroy();\n\t}\n}\n\ndefaultproperties\n{\n     bStatic=False\n     bHidden=False\n     RemoteRole=ROLE_None\n     LifeSpan=6.000000\n     DrawType=DT_Mesh\n     DrawScale=0.500000\n     AmbientGlow=40\n     bOnlyOwnerSee=True\n     bCollideActors=True\n     LightType=LT_Steady\n     LightBrightness=125\n     LightSaturation=125\n}\n",
            "name": "WayBeacon.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "bStatic=False",
                    "bHidden=False",
                    "RemoteRole=ROLE_None",
                    "LifeSpan=6.000000",
                    "DrawType=DT_Mesh",
                    "DrawScale=0.500000",
                    "AmbientGlow=40",
                    "bOnlyOwnerSee=True",
                    "bCollideActors=True",
                    "LightType=LT_Steady",
                    "LightBrightness=125",
                    "LightSaturation=125"
                ],
                "exec": [],
                "extends": "Keypoint",
                "functions": {
                    "PostBeginPlay": {
                        "body": "{\n\n\tSuper.PostBeginPlay();\n\tNewClass = class<actor>( DynamicLoadObject( \"Unreali.Lamp4\", class'Class' ) );\n\tif( NewClass!=None )\n\t\tMesh = NewClass.Default.Mesh;\n}",
                        "locals": [
                            "local class<actor> NewClass;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "touch": {
                        "body": "{\n\tif (other == owner)\n\t{\n\t\tif ( Owner.IsA('PlayerPawn') )\n\t\t\tPlayerPawn(owner).ShowPath();\n\t\tDestroy();\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "touch",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "other"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 43,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "Weapon.uc": {
            "body": "//=============================================================================\n// Parent class of all weapons.\n//=============================================================================\nclass Weapon extends Inventory\n\tabstract\n\tnative;\n\n#exec Texture Import File=Textures\\Weapon.pcx Name=S_Weapon Mips=Off Flags=2\n\n//-----------------------------------------------------------------------------\n// Weapon ammo/firing information:\n// Two-element arrays here are defined for normal fire (0) and alt fire (1).\nvar() float   MaxTargetRange;    // Maximum distance to target.\nvar() class<ammo> AmmoName;          // Type of ammo used.\n//var() byte    ReloadCount;       // Amount of ammo depletion before reloading. 0 if no reloading is done.\n// DEUS_EX CNN - travel added\nvar() travel byte    ReloadCount;       // Amount of ammo depletion before reloading. 0 if no reloading is done.\nvar() int     PickupAmmoCount;   // Amount of ammo initially in pick-up item.\nvar travel ammo\tAmmoType;\t\t // Inventory Ammo being used.\nvar\t  bool\t  bPointing;\t\t // Indicates weapon is being pointed\n//var() bool\t  bInstantHit;\t\t // If true, instant hit rather than projectile firing weapon\n// DEUS_EX CNN - travel added\nvar() travel bool\t  bInstantHit;\t\t // If true, instant hit rather than projectile firing weapon\nvar() bool\t  bAltInstantHit;\t // If true, instant hit rather than projectile firing weapon for AltFire\nvar(WeaponAI) bool\t  bWarnTarget;\t\t // When firing projectile, warn the target\nvar(WeaponAI) bool\t  bAltWarnTarget;\t // When firing alternate projectile, warn the target\nvar   bool\t  bWeaponUp;\t\t // Used in Active State\nvar   bool\t  bChangeWeapon;\t // Used in Active State\nvar   bool \t  bLockedOn;\nvar(WeaponAI) bool\t  bSplashDamage;\t // used by bot AI\nvar()\t\t  bool\t  bCanThrow;\t//if true, player can toss this weapon out\nvar(WeaponAI) bool\t  bRecommendSplashDamage; //if true, bot preferentially tries to use splash damage\n\t\t\t\t\t\t\t\t\t\t\t  // rather than direct hits\nvar(WeaponAI) bool\t  bRecommendAltSplashDamage; //if true, bot preferentially tries to use splash damage\n\t\t\t\t\t\t\t\t\t\t\t  // rather than direct hits\nvar() bool\t  bWeaponStay;\nvar() bool\t  bOwnsCrosshair;\t// this weapon is responsible for drawing its own crosshair (in its postrender function)\nvar\t  bool\t  bHideWeapon;\t\t// if true, weapon is not rendered\nvar(WeaponAI) bool\t  bMeleeWeapon; //Weapon is only a melee weapon\nvar() bool\t  bRapidFire;\t\t// used by human animations in determining firing animation (for still firing)\nvar\t  bool\t  bSpecialIcon;\n\nvar() float\t  FiringSpeed;\t\t// used by human animations in determining firing speed\n\nvar()   vector\tFireOffset;\t\t // Offset from drawing location for projectile/trace start\nvar()   class<projectile> ProjectileClass;\nvar()   class<projectile> AltProjectileClass;\nvar()\tname MyDamageType;\nvar()\tname AltDamageType;\n//var\t\tfloat\tProjectileSpeed;\n// DEUS_EX CNN - travel added\nvar\ttravel float\tProjectileSpeed;\nvar\t\tfloat\tAltProjectileSpeed;\nvar\t\tfloat\tAimError;\t\t// Aim Error for bots (note this value doubled if instant hit weapon)\nvar()\tfloat\tShakeMag;\nvar()\tfloat\tShakeTime;\nvar()\tfloat   ShakeVert;\nvar(WeaponAI)\tfloat\tAIRating;\nvar(WeaponAI)\tfloat\tRefireRate;\nvar(WeaponAI)\tfloat\tAltRefireRate;\n\n//-----------------------------------------------------------------------------\n// Sound Assignments\nvar() sound \tFireSound;\nvar() sound \tAltFireSound;\nvar() sound \tCockingSound;\nvar() sound \tSelectSound;\nvar() sound \tMisc1Sound;\nvar() sound \tMisc2Sound;\nvar() sound \tMisc3Sound;\n\nvar() Localized string MessageNoAmmo;\nvar() Localized string DeathMessage;\nvar() Color NameColor;\t// used when drawing name on HUD\n\nvar Rotator AdjustedAim;\n\n//-----------------------------------------------------------------------------\n// Muzzle Flash\n// weapon is responsible for setting and clearing bMuzzleFlash whenever it wants the\n// MFTexture drawn on the canvas (see RenderOverlays() )\nvar bool bSetFlashTime;\nvar(MuzzleFlash) bool bDrawMuzzleFlash;\nvar byte bMuzzleFlash;\nvar float FlashTime;\nvar(MuzzleFlash) float MuzzleScale, FlashY, FlashO, FlashC, FlashLength;\nvar(MuzzleFlash) int FlashS;\t// size of (square) texture/2\nvar(MuzzleFlash) texture MFTexture;\nvar(MuzzleFlash) texture MuzzleFlare;\nvar(MuzzleFlash) float FlareOffset; \n\n// Network replication\n//\nreplication\n{\n\t// Things the server should send to the client.\n\treliable if( Role==ROLE_Authority && bNetOwner )\n\t\tAmmoType, bLockedOn, bHideWeapon, bChangeWeapon;\n\treliable if ( Role == ROLE_Authority )\n\t\tClientSetHandedness;\n}\n\n//=============================================================================\n// Inventory travelling across servers.\n\nevent TravelPostAccept()\n{\n\tSuper.TravelPostAccept();\n\tif ( Pawn(Owner) == None )\n\t\treturn;\n\tif ( AmmoName != None )\n\t{\n\t\t// DEUS_EX CNN - if AmmoType isn't already set (through a travel),\n\t\t// find the default in the inventory list\n\t\tif ( AmmoType == None )\n\t\t{\t\t\n\t\t\tAmmoType = Ammo(Pawn(Owner).FindInventoryType(AmmoName));\n\t\t\tif (AmmoType == None)\n\t\t\t{\n\t\t\t\tAmmoType = Spawn(AmmoName);\t// Create ammo type required\t\t\n\t\t\t\tPawn(Owner).AddInventory(AmmoType);\t\t// and add to player's inventory\n\t\t\t\tAmmoType.BecomeItem();\n\t\t\t\tAmmoType.AmmoAmount = PickUpAmmoCount; \n\t\t\t\tAmmoType.GotoState('Idle2');\n\t\t\t}\n\t\t}\n\t}\n\tif ( self == Pawn(Owner).Weapon )\n\t\tBringUp();\n\telse GoToState('Idle2');\n}\n\nfunction Destroyed()\n{\n\tSuper.Destroyed();\n\tif( (Pawn(Owner)!=None) && (Pawn(Owner).Weapon == self) )\n\t\tPawn(Owner).Weapon = None;\n}\n\n//=============================================================================\n// Weapon rendering\n// Draw first person view of inventory\nsimulated event RenderOverlays( canvas Canvas )\n{\n\tlocal rotator NewRot;\n\tlocal bool bPlayerOwner;\n\tlocal int Hand;\n\tlocal PlayerPawn PlayerOwner;\n\n\tif ( bHideWeapon || (Owner == None) )\n\t\treturn;\n\n\tPlayerOwner = PlayerPawn(Owner);\n\n\tif ( PlayerOwner != None )\n\t{\n\t\tif ( PlayerOwner.DesiredFOV != PlayerOwner.DefaultFOV )\n\t\t\treturn;\n\t\tbPlayerOwner = true;\n\t\tHand = PlayerOwner.Handedness;\n\n\t\tif (  (Level.NetMode == NM_Client) && (Hand == 2) )\n\t\t{\n\t\t\tbHideWeapon = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( !bPlayerOwner || (PlayerOwner.Player == None) )\n\t\tPawn(Owner).WalkBob = vect(0,0,0);\n\n\tif ( (bMuzzleFlash > 0) && bDrawMuzzleFlash && Level.bHighDetailMode && (MFTexture != None) )\n\t{\n\t\tMuzzleScale = Default.MuzzleScale * Canvas.ClipX/640.0;\n\t\tif ( !bSetFlashTime )\n\t\t{\n\t\t\tbSetFlashTime = true;\n\t\t\tFlashTime = Level.TimeSeconds + FlashLength;\n\t\t}\n\t\telse if ( FlashTime < Level.TimeSeconds )\n\t\t\tbMuzzleFlash = 0;\n\t\tif ( bMuzzleFlash > 0 )\n\t\t{\n\t\t\tif ( Hand == 0 )\n\t\t\t\tCanvas.SetPos(Canvas.ClipX/2 - 0.5 * MuzzleScale * FlashS + Canvas.ClipX * (-0.2 * Default.FireOffset.Y * FlashO), Canvas.ClipY/2 - 0.5 * MuzzleScale * FlashS + Canvas.ClipY * (FlashY + FlashC));\n\t\t\telse\n\t\t\t\tCanvas.SetPos(Canvas.ClipX/2 - 0.5 * MuzzleScale * FlashS + Canvas.ClipX * (Hand * Default.FireOffset.Y * FlashO), Canvas.ClipY/2 - 0.5 * MuzzleScale * FlashS + Canvas.ClipY * FlashY);\n\n\t\t\tCanvas.Style = 3;\n\t\t\tCanvas.DrawIcon(MFTexture, MuzzleScale);\n\t\t\tCanvas.Style = 1;\n\t\t}\n\t}\n\telse\n\t\tbSetFlashTime = false;\n\n\tSetLocation( Owner.Location + CalcDrawOffset() );\n\tNewRot = Pawn(Owner).ViewRotation;\n\n\tif ( Hand == 0 )\n\t\tnewRot.Roll = -2 * Default.Rotation.Roll;\n\telse\n\t\tnewRot.Roll = Default.Rotation.Roll * Hand;\n\n\tsetRotation(newRot);\n\tCanvas.DrawActor(self, false);\n}\n\n//-------------------------------------------------------\n// AI related functions\n\nfunction PostBeginPlay()\n{\n\tSuper.PostBeginPlay();\n\tSetWeaponStay();\n\tMaxDesireability = 1.2 * AIRating;\n\tif ( ProjectileClass != None )\n\t{\n\t\tProjectileSpeed = ProjectileClass.Default.Speed;\n\t\tMyDamageType = ProjectileClass.Default.MyDamageType;\n\t}\n\tif ( AltProjectileClass != None )\n\t{\n\t\tAltProjectileSpeed = AltProjectileClass.Default.Speed;\n\t\tAltDamageType = AltProjectileClass.Default.MyDamageType;\n\t}\n}\n\nfunction bool SplashJump()\n{\n\treturn false;\n}\n\nfunction SetWeaponStay()\n{\n\tbWeaponStay = bWeaponStay || Level.Game.bCoopWeaponMode;\n}\n\nevent float BotDesireability(Pawn Bot)\n{\n\tlocal Weapon AlreadyHas;\n\tlocal float desire;\n\n\tdesire = MaxDesireability + Bot.AdjustDesireFor(self);\n\tAlreadyHas = Weapon(Bot.FindInventoryType(class)); \n\tif ( AlreadyHas != None )\n\t{\n\t\tif ( (RespawnTime < 10) \n\t\t\t&& ( bHidden || (AlreadyHas.AmmoType == None) \n\t\t\t\t|| (AlreadyHas.AmmoType.AmmoAmount < AlreadyHas.AmmoType.MaxAmmo)) )\n\t\t\treturn 0;\n\t\tif ( (!bHeldItem || bTossedOut) && bWeaponStay )\n\t\t\treturn 0;\n\t\tif ( AlreadyHas.AmmoType == None )\n\t\t\treturn 0.25 * desire;\n\n\t\tif ( AlreadyHas.AmmoType.AmmoAmount > 0 )\n\t\t\treturn FMax( 0.25 * desire, \n\t\t\t\t\tAlreadyHas.AmmoType.MaxDesireability\n\t\t\t\t\t * FMin(1, 0.15 * AlreadyHas.AmmoType.MaxAmmo/AlreadyHas.AmmoType.AmmoAmount) ); \n\t\telse\n\t\t\treturn 0.05;\n\t}\n\tif ( (Bot.Weapon == None) || (Bot.Weapon.AIRating <= 0.4) )\n\t\treturn 2*desire;\n\n\treturn desire;\n}\n\nfunction float RateSelf( out int bUseAltMode )\n{\n\tif ( (AmmoType != None) && (AmmoType.AmmoAmount <=0) )\n\t\treturn -2;\n\tbUseAltMode = int(FRand() < 0.4);\n\treturn (AIRating + FRand() * 0.05);\n}\n\n// return delta to combat style\nfunction float SuggestAttackStyle()\n{\n\treturn 0.0;\n}\n\nfunction float SuggestDefenseStyle()\n{\n\treturn 0.0;\n}\n\n//-------------------------------------------------------\n\nsimulated function PreRender( canvas Canvas );\nsimulated function PostRender( canvas Canvas );\n\nfunction ClientWeaponEvent(name EventType);\n\nfunction bool HandlePickupQuery( inventory Item )\n{\n\tlocal int OldAmmo;\n\tlocal Pawn P;\n\n\tif (Item.Class == Class)\n\t{\n\t\tif ( Weapon(item).bWeaponStay && (!Weapon(item).bHeldItem || Weapon(item).bTossedOut) )\n\t\t\treturn true;\n\t\tP = Pawn(Owner);\n//\t\tif ( AmmoType != None )\n//\t\t{\n//\t\t\tOldAmmo = AmmoType.AmmoAmount;\n//\n//\t\t\t// DEUS_EX CNN - never switch weapons automatically, but do add the ammo\n//\t\t\tAmmoType.AddAmmo(Weapon(Item).PickupAmmoCount);\n//\t\t\tif ( AmmoType.AddAmmo(Weapon(Item).PickupAmmoCount) && (OldAmmo == 0) \n//\t\t\t\t&& (P.Weapon.class != item.class) && !P.bNeverSwitchOnPickup )\n//\t\t\t\t\tWeaponSet(P);\n//\t\t}\n\t\tif (Level.Game.LocalLog != None)\n\t\t\tLevel.Game.LocalLog.LogPickup(Item, Pawn(Owner));\n\t\tif (Level.Game.WorldLog != None)\n\t\t\tLevel.Game.WorldLog.LogPickup(Item, Pawn(Owner));\n\t\tif (Item.PickupMessageClass == None)\n\t\t\t// DEUS_EX CNN - use the itemArticle and itemName\n//\t\t\tP.ClientMessage(Item.PickupMessage, 'Pickup');\n\t\t\tP.ClientMessage(Item.PickupMessage @ Item.itemArticle @ Item.itemName, 'Pickup');\n\t\telse\n\t\t\tP.ReceiveLocalizedMessage( Item.PickupMessageClass, 0, None, None, item.Class );\n\t\tItem.PlaySound(Item.PickupSound);\n\t\tItem.SetRespawn();   \n\t\treturn true;\n\t}\n\tif ( Inventory == None )\n\t\treturn false;\n\n\treturn Inventory.HandlePickupQuery(Item);\n}\n\n// set which hand is holding weapon\nsimulated function setHand( float Hand )\n{\n\tif ( Hand == 2 )\n\t{\n\t\tPlayerViewOffset.Y = 0;\n\t\tFireOffset.Y = 0;\n\t\tbHideWeapon = true;\n\t\treturn;\n\t}\n\telse\n\t\tbHideWeapon = false;\n\n\tif ( Hand == 0 )\n\t{\n\t\tPlayerViewOffset.X = Default.PlayerViewOffset.X * 0.88;\n\t\tPlayerViewOffset.Y = -0.2 * Default.PlayerViewOffset.Y;\n\t\tPlayerViewOffset.Z = Default.PlayerViewOffset.Z * 1.12;\n\t}\n\telse\n\t{\n\t\tPlayerViewOffset.X = Default.PlayerViewOffset.X;\n\t\tPlayerViewOffset.Y = Default.PlayerViewOffset.Y * Hand;\n\t\tPlayerViewOffset.Z = Default.PlayerViewOffset.Z;\n\t}\n\tPlayerViewOffset *= 100; //scale since network passes vector components as ints\n\tFireOffset.Y = Default.FireOffset.Y * Hand;\n}\n\n// Update the client numbers in multiplayer\nsimulated function ClientSetHandedness( float Hand )\n{\n\tsetHand( Hand );\n}\n\n//\n// Change weapon to that specificed by F matching inventory weapon's Inventory Group.\nfunction Weapon WeaponChange( byte F )\n{\t\n\tlocal Weapon newWeapon;\n\t \n\tif ( InventoryGroup == F )\n\t{\n\t\t/* we want you to change weapons even if you're out of ammo - DEUS_EX CNN\n\t\tif ( (AmmoType != None) && (AmmoType.AmmoAmount <= 0) )\n\t\t{\n\t\t\tif ( Inventory == None )\n\t\t\t\tnewWeapon = None;\n\t\t\telse\n\t\t\t\tnewWeapon = Inventory.WeaponChange(F);\n\t\t\tif ( newWeapon == None )\n\t\t\t\tPawn(Owner).ClientMessage( ItemName$MessageNoAmmo );\t\t\n\t\t\treturn newWeapon;\n\t\t}\t\t\n\t\telse \n\t\t*/\n\t\t\treturn self;\n\t}\n\telse if ( Inventory == None )\n\t\treturn None;\n\telse\n\t\treturn Inventory.WeaponChange(F);\n}\n\n// Either give this inventory to player Other, or spawn a copy\n// and give it to the player Other, setting up original to be respawned.\n// Also add Ammo to Other's inventory if it doesn't already exist\n//\nfunction inventory SpawnCopy( pawn Other )\n{\n\tlocal inventory Copy;\n\tlocal Weapon newWeapon;\n\n\tif( Level.Game.ShouldRespawn(self) )\n\t{\n\t\tCopy = spawn(Class,Other,,,rot(0,0,0));\n\t\tCopy.Tag           = Tag;\n\t\tCopy.Event         = Event;\n\t\tif ( !bWeaponStay )\n\t\t\tGotoState('Sleeping');\n\t}\n\telse\n\t\tCopy = self;\n\n\tCopy.RespawnTime = 0.0;\n\tCopy.bHeldItem = true;\n\tCopy.bTossedOut = false;\n\n\t// DEUS_EX AJY\n\t// Give weapon ammo before giving to player\t\n\tWeapon(Copy).GiveAmmo(Other);\n\tCopy.GiveTo( Other );\n\t\n\tnewWeapon = Weapon(Copy);\n\tnewWeapon.Instigator = Other;\n\tnewWeapon.SetSwitchPriority(Other);\n\t// DEUS_EX CNN - Don't autoswitch weapons\n//\tif ( !Other.bNeverSwitchOnPickup )\n//\t\tnewWeapon.WeaponSet(Other);\n\tnewWeapon.AmbientGlow = 0;\n\treturn newWeapon;\n}\n\nfunction SetSwitchPriority(pawn Other)\n{\n\tlocal int i;\n\tlocal name temp, carried;\n\n\tif ( PlayerPawn(Other) != None )\n\t{\n\t\tfor ( i=0; i<20; i++)\n\t\t\tif ( PlayerPawn(Other).WeaponPriority[i] == class.name )\n\t\t\t{\n\t\t\t\tAutoSwitchPriority = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t// else, register this weapon\n\t\tcarried = class.name;\n\t\tfor ( i=AutoSwitchPriority; i<20; i++ )\n\t\t{\n\t\t\tif ( PlayerPawn(Other).WeaponPriority[i] == '' )\n\t\t\t{\n\t\t\t\tPlayerPawn(Other).WeaponPriority[i] = carried;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if ( i<19 )\n\t\t\t{\n\t\t\t\ttemp = PlayerPawn(Other).WeaponPriority[i];\n\t\t\t\tPlayerPawn(Other).WeaponPriority[i] = carried;\n\t\t\t\tcarried = temp;\n\t\t\t}\n\t\t}\n\t}\t\t\n}\n\nfunction GiveAmmo( Pawn Other )\n{\n\tif ( AmmoName == None )\n\t\treturn;\n\tAmmoType = Ammo(Other.FindInventoryType(AmmoName));\n\tif ( AmmoType != None )\n\t\tAmmoType.AddAmmo(PickUpAmmoCount);\n\telse\n\t{\n\t\tAmmoType = Spawn(AmmoName);\t// Create ammo type required\t\t\n\t\tOther.AddInventory(AmmoType);\t\t// and add to player's inventory\n\t\tAmmoType.BecomeItem();\n\t\tAmmoType.AmmoAmount = PickUpAmmoCount; \n\t\tAmmoType.GotoState('Idle2');\n\t}\n}\t\n\n// Return the switch priority of the weapon (normally AutoSwitchPriority, but may be\n// modified by environment (or by other factors for bots)\nfunction float SwitchPriority() \n{\n\tlocal float temp;\n\tlocal int bTemp;\n\n\tif ( !Owner.IsA('PlayerPawn') )\n\t\treturn RateSelf(bTemp);\n\telse if ( (AmmoType != None) && (AmmoType.AmmoAmount<=0) )\n\t{\n\t\tif ( Pawn(Owner).Weapon == self )\n\t\t\treturn -0.5;\n\t\telse\n\t\t\treturn -1;\n\t}\n\telse \n\t\treturn AutoSwitchPriority;\n}\n\n// Compare self to current weapon.  If better than current weapon, then switch\nfunction bool WeaponSet(Pawn Other)\n{\n\tlocal bool bSwitch,bHaveAmmo;\n\tlocal Inventory Inv;\n\tlocal weapon W;\n\t\n\tif ( Other.Weapon == self)\n\t\treturn false;\n\n\tif ( Other.Weapon == None )\n\t{\n\t\tOther.PendingWeapon = self;\n\t\tOther.ChangedWeapon();\n\t\treturn true;\t\n\t}\n\telse if ( Other.Weapon.SwitchPriority() < SwitchPriority() ) \n\t{\n\t\tW = Other.PendingWeapon;\n\t\tOther.PendingWeapon = self;\n\t\tGotoState('');\n\n\t\tif ( Other.Weapon.PutDown() )\n\t\t\treturn true;\n\t\tOther.PendingWeapon = W;\n\t\treturn false;\n\t}\n\telse \n\t{\n\t\tGoToState('');\n\t\treturn false;\n\t}\n}\n\nfunction Weapon RecommendWeapon( out float rating, out int bUseAltMode )\n{\n\tlocal Weapon Recommended;\n\tlocal float oldRating, oldFiring;\n\tlocal int oldMode;\n\n\tif ( Owner.IsA('PlayerPawn') )\n\t\trating = SwitchPriority();\n\telse\n\t{\n\t\trating = RateSelf(bUseAltMode);\n\t\tif ( (self == Pawn(Owner).Weapon) && (Pawn(Owner).Enemy != None) \n\t\t\t&& ((AmmoType == None) || (AmmoType.AmmoAmount > 0)) )\n\t\t\trating += 0.21; // tend to stick with same weapon\n\t}\n\tif ( inventory != None )\n\t{\n\t\tRecommended = inventory.RecommendWeapon(oldRating, oldMode);\n\t\tif ( (Recommended != None) && (oldRating > rating) )\n\t\t{\n\t\t\trating = oldRating;\n\t\t\tbUseAltMode = oldMode;\n\t\t\treturn Recommended;\n\t\t}\n\t}\n\treturn self;\n}\n\n// Toss this weapon out\nfunction DropFrom(vector StartLocation)\n{\n\tif ( !SetLocation(StartLocation) )\n\t\treturn; \n\tAIRating = Default.AIRating;\n\tbMuzzleFlash = 0;\n\t//\n\t// DEUS_EX CNN - ALERT!  HUGE HACK ALERT!!!\n\t//\n\t// Basically, you don't want to drop all of your ammo unless you are dropping\n\t// a grenade of some sort.  The only way to check for a grenade is to check the\n\t// PickupViewMesh for the illegal mesh TestBox.  But since TestBox is in the DeusExItems\n\t// package, we can't directly access the mesh, so we have to cast the mesh to a string\n\t// and check it that way.\n\t//\n\t// Hate Hate Hate.\n\t//\n\tif (AmmoType != None)\n\t{\n\t\tif (String(AmmoType.PickupViewMesh) == \"DeusExItems.TestBox\")\n\t\t{\n\t\t\tPickupAmmoCount = AmmoType.AmmoAmount;\n\t\t\tAmmoType.AmmoAmount = 0;\n\t\t}\n\t\telse\n\t\t\tPickupAmmoCount = 0;\n\t}\n   if (Level.Netmode != NM_Standalone)\n      bTossedOut = true;\n\tSuper.DropFrom(StartLocation);\n}\n\n// Become a pickup\nfunction BecomePickup()\n{\n\tSuper.BecomePickup();\n\tSetDisplayProperties(Default.Style, Default.Texture, Default.bUnlit, Default.bMeshEnviromap );\n   if (Level.NetMode != NM_Standalone)\n      if (bTossedOut)\n         Lifespan = 5.0;\n}\n\n// Become an inventory item\nfunction BecomeItem()\n{\n   Super.BecomeItem();\n   Lifespan = 0;\n}\n\nsimulated function TweenToStill();\n\n//**************************************************************************************\n//\n// Firing functions and states\n//\n\nfunction CheckVisibility()\n{\n\tlocal Pawn PawnOwner;\n\n\tPawnOwner = Pawn(Owner);\n\tif( Owner.bHidden && (PawnOwner.Health > 0) && (PawnOwner.Visibility < PawnOwner.Default.Visibility) )\n\t{\n\t\tOwner.bHidden = false;\n\t\tPawnOwner.Visibility = PawnOwner.Default.Visibility;\n\t}\n}\n\nsimulated function bool ClientFire( float Value )\n{\n\treturn true;\n}\n\nfunction ForceFire();\nfunction ForceAltFire();\n\nfunction Fire( float Value )\n{\n\tif (AmmoType.UseAmmo(1))\n\t{\n\t\tGotoState('NormalFire');\n\t\tif ( PlayerPawn(Owner) != None )\n\t\t\tPlayerPawn(Owner).ShakeView(ShakeTime, ShakeMag, ShakeVert);\n\t\tbPointing=True;\n\t\tPlayFiring();\n\t\tif ( !bRapidFire && (FiringSpeed > 0) )\n\t\t\tPawn(Owner).PlayRecoil(FiringSpeed);\n\t\tif ( bInstantHit )\n\t\t\tTraceFire(0.0);\n\t\telse\n\t\t\tProjectileFire(ProjectileClass, ProjectileSpeed, bWarnTarget);\n\t\tif ( Owner.bHidden )\n\t\t\tCheckVisibility();\n\t}\n}\n\nsimulated function bool ClientAltFire( float Value )\n{\n\treturn true;\n}\n\nfunction AltFire( float Value )\n{\n\tif (AmmoType.UseAmmo(1))\n\t{\n\t\tGotoState('AltFiring');\n\t\tif ( PlayerPawn(Owner) != None )\n\t\t\tPlayerPawn(Owner).ShakeView(ShakeTime, ShakeMag, ShakeVert);\n\t\tbPointing=True;\n\t\tPlayAltFiring();\n\t\tif ( !bRapidFire && (FiringSpeed > 0) )\n\t\t\tPawn(Owner).PlayRecoil(FiringSpeed);\n\t\tif ( bAltInstantHit )\n\t\t\tTraceFire(0.0);\n\t\telse\n\t\t\tProjectileFire(AltProjectileClass, AltProjectileSpeed, bAltWarnTarget);\n\t\tif ( Owner.bHidden )\n\t\t\tCheckVisibility();\n\t}\n}\n\nsimulated function PlayFiring()\n{\n\t//Play firing animation and sound\n}\n\nsimulated function PlayAltFiring()\n{\n\t//Play alt firing animation and sound\n}\n\nfunction Projectile ProjectileFire(class<projectile> ProjClass, float ProjSpeed, bool bWarn)\n{\n\tlocal Vector Start, X,Y,Z;\n\tlocal Pawn PawnOwner;\n\n\tPawnOwner = Pawn(Owner);\n\tOwner.MakeNoise(PawnOwner.SoundDampening);\n\tGetAxes(PawnOwner.ViewRotation,X,Y,Z);\n\tStart = Owner.Location + CalcDrawOffset() + FireOffset.X * X + FireOffset.Y * Y + FireOffset.Z * Z; \n\tAdjustedAim = PawnOwner.AdjustAim(ProjSpeed, Start, AimError, True, bWarn);\t\n\treturn Spawn(ProjClass,,, Start,AdjustedAim);\t\n}\n\nfunction TraceFire( float Accuracy )\n{\n\tlocal vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z;\n\tlocal actor Other;\n\tlocal Pawn PawnOwner;\n\n\tPawnOwner = Pawn(Owner);\n\n\tOwner.MakeNoise(PawnOwner.SoundDampening);\n\tGetAxes(PawnOwner.ViewRotation,X,Y,Z);\n\tStartTrace = Owner.Location + CalcDrawOffset() + FireOffset.X * X + FireOffset.Y * Y + FireOffset.Z * Z; \n\tAdjustedAim = PawnOwner.AdjustAim(1000000, StartTrace, 2*AimError, False, False);\t\n\tEndTrace = StartTrace + Accuracy * (FRand() - 0.5 )* Y * 1000\n\t\t+ Accuracy * (FRand() - 0.5 ) * Z * 1000;\n\tX = vector(AdjustedAim);\n\tEndTrace += (10000 * X); \n\tOther = PawnOwner.TraceShot(HitLocation,HitNormal,EndTrace,StartTrace);\n\tProcessTraceHit(Other, HitLocation, HitNormal, X,Y,Z);\n}\n\nfunction ProcessTraceHit(Actor Other, Vector HitLocation, Vector HitNormal, Vector X, Vector Y, Vector Z)\n{\n\t//Spawn appropriate effects at hit location, any weapon lights, and damage hit actor\n}\n\n// Finish a firing sequence\nfunction Finish()\n{\n\tlocal Pawn PawnOwner;\n\n\tif ( bChangeWeapon )\n\t{\n\t\tGotoState('DownWeapon');\n\t\treturn;\n\t}\n\n\tPawnOwner = Pawn(Owner);\n\tif ( PlayerPawn(Owner) == None )\n\t{\n\t\tif ( (AmmoType != None) && (AmmoType.AmmoAmount<=0) )\n\t\t{\n\t\t\tPawnOwner.StopFiring();\n\t\t\tPawnOwner.SwitchToBestWeapon();\n\t\t\tif ( bChangeWeapon )\n\t\t\t\tGotoState('DownWeapon');\n\t\t}\n\t\telse if ( (PawnOwner.bFire != 0) && (FRand() < RefireRate) )\n\t\t\tGlobal.Fire(0);\n\t\telse if ( (PawnOwner.bAltFire != 0) && (FRand() < AltRefireRate) )\n\t\t\tGlobal.AltFire(0);\t\n\t\telse \n\t\t{\n\t\t\tPawnOwner.StopFiring();\n\t\t\tGotoState('Idle');\n\t\t}\n\t\treturn;\n\t}\n\tif ( ((AmmoType != None) && (AmmoType.AmmoAmount<=0)) || (PawnOwner.Weapon != self) )\n\t\tGotoState('Idle');\n\telse if ( PawnOwner.bFire!=0 )\n\t\tGlobal.Fire(0);\n\telse if ( PawnOwner.bAltFire!=0 )\n\t\tGlobal.AltFire(0);\n\telse \n\t\tGotoState('Idle');\n}\n\n///////////////////////////////////////////////////////\nstate NormalFire\n{\n\tfunction Fire(float F) \n\t{\n\t}\n\tfunction AltFire(float F) \n\t{\n\t}\n\nBegin:\n\tFinishAnim();\n\tFinish();\n}\n\n////////////////////////////////////////////////////////\nstate AltFiring\n{\n\tfunction Fire(float F) \n\t{\n\t}\n\n\tfunction AltFire(float F) \n\t{\n\t}\n\nBegin:\n\tFinishAnim();\n\tFinish();\n}\n\n//**********************************************************************************\n// Weapon is up, but not firing\nstate Idle\n{\n\tfunction AnimEnd()\n\t{\n\t\tPlayIdleAnim();\n\t}\n\n\tfunction bool PutDown()\n\t{\n\t\tGotoState('DownWeapon');\n\t\treturn True;\n\t}\n\nBegin:\n\tbPointing=False;\n\tif ( (AmmoType != None) && (AmmoType.AmmoAmount<=0) ) \n\t\tPawn(Owner).SwitchToBestWeapon();  //Goto Weapon that has Ammo\n\tif ( Pawn(Owner).bFire!=0 ) Fire(0.0);\n\tif ( Pawn(Owner).bAltFire!=0 ) AltFire(0.0);\t\n\tDisable('AnimEnd');\n\tPlayIdleAnim();\n}\n\n//\n// Bring newly active weapon up\n// Bring newly active weapon up\nstate Active\n{\n\tfunction Fire(float F) \n\t{\n\t}\n\n\tfunction AltFire(float F) \n\t{\n\t}\n\n\tfunction bool PutDown()\n\t{\n\t\tif ( bWeaponUp || (AnimFrame < 0.75) )\n\t\t\tGotoState('DownWeapon');\n\t\telse\n\t\t\tbChangeWeapon = true;\n\t\treturn True;\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tbChangeWeapon = false;\n\t}\n\nBegin:\n\tFinishAnim();\n\tif ( bChangeWeapon )\n\t\tGotoState('DownWeapon');\n\tbWeaponUp = True;\n\tPlayPostSelect();\n\tFinishAnim();\n\tFinish();\n}\n\n//\n// Putting down weapon in favor of a new one.\n//\nState DownWeapon\n{\nignores Fire, AltFire;\n\n\tfunction bool PutDown()\n\t{\n\t\tPawn(Owner).ClientPutDown(self, Pawn(Owner).PendingWeapon);\n\t\treturn true; //just keep putting it down\n\t}\n\n\tfunction BeginState()\n\t{\n\t\tbChangeWeapon = false;\n\t\tbMuzzleFlash = 0;\n\t\tPawn(Owner).ClientPutDown(self, Pawn(Owner).PendingWeapon);\n\t}\n\nBegin:\n\tTweenDown();\n\tFinishAnim();\n\tPawn(Owner).ChangedWeapon();\n}\n\nsimulated function ClientPutDown(Weapon NextWeapon);\n\nfunction BringUp()\n{\n\tif ( Owner.IsA('PlayerPawn') )\n\t{\n\t\tSetHand(PlayerPawn(Owner).Handedness);\n\t\tif (( Level.NetMode != NM_Standalone ) && (Role == ROLE_Authority))\n\t\t\tClientSetHandedness( PlayerPawn(Owner).Handedness );\n\t\tPlayerPawn(Owner).EndZoom();\n\t}\t\n\tbWeaponUp = false;\n\tPlaySelect();\n\tGotoState('Active');\n}\n\nfunction RaiseUp(Weapon OldWeapon)\n{\n\tBringUp();\n}\n\nfunction bool PutDown()\n{\n\tbChangeWeapon = true;\n\tGotoState('DownWeapon');\t\t// DEUS_EX CNN - added to force the weapon down\n\treturn true; \n}\n\nsimulated function TweenDown()\n{\n\tif ( (AnimSequence != '') && (GetAnimGroup(AnimSequence) == 'Select') )\n\t\tTweenAnim( AnimSequence, AnimFrame * 0.4 );\n\telse\n\t{\n\t\t// Have the put away animation play twice as fast in multiplayer\n\t\tif ( Level.NetMode != NM_Standalone )\n\t\t\tPlayAnim('Down', 2.0, 0.05);\n\t\telse\n\t\t\tPlayAnim('Down', 1.0, 0.05);\n\t}\n}\n\nfunction TweenSelect()\n{\n\tTweenAnim('Select',0.001);\n}\n\nfunction PlaySelect()\n{\n\tPlayAnim('Select',1.0,0.0);\n\tOwner.PlaySound(SelectSound, SLOT_Misc, Pawn(Owner).SoundDampening);\t\n}\n\nfunction PlayPostSelect()\n{\n}\n\nfunction PlayIdleAnim()\n{\n}\n\ndefaultproperties\n{\n     MaxTargetRange=4096.000000\n     bCanThrow=True\n     ProjectileSpeed=1000.000000\n     AltProjectileSpeed=1000.000000\n     aimerror=550.000000\n     shakemag=300.000000\n     shaketime=0.100000\n     shakevert=5.000000\n     AIRating=0.100000\n     RefireRate=0.500000\n     AltRefireRate=0.500000\n     MessageNoAmmo=\" has no ammo.\"\n     DeathMessage=\"%o was killed by %k's %w.\"\n     NameColor=(R=255,G=255,B=255)\n     MuzzleScale=4.000000\n     FlashLength=0.100000\n     AutoSwitchPriority=1\n     InventoryGroup=1\n     PickupMessage=\"You got a weapon\"\n     ItemName=\"Weapon\"\n     RespawnTime=30.000000\n     PlayerViewOffset=(X=30.000000,Z=-5.000000)\n     MaxDesireability=0.500000\n     Icon=Texture'Engine.S_Weapon'\n     Texture=Texture'Engine.S_Weapon'\n     bNoSmooth=True\n}\n",
            "name": "Weapon.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "MaxTargetRange=4096.000000",
                    "bCanThrow=True",
                    "ProjectileSpeed=1000.000000",
                    "AltProjectileSpeed=1000.000000",
                    "aimerror=550.000000",
                    "shakemag=300.000000",
                    "shaketime=0.100000",
                    "shakevert=5.000000",
                    "AIRating=0.100000",
                    "RefireRate=0.500000",
                    "AltRefireRate=0.500000",
                    "MessageNoAmmo=\" has no ammo.\"",
                    "DeathMessage=\"%o was killed by %k's %w.\"",
                    "NameColor=(R=255,G=255,B=255)",
                    "MuzzleScale=4.000000",
                    "FlashLength=0.100000",
                    "AutoSwitchPriority=1",
                    "InventoryGroup=1",
                    "PickupMessage=\"You got a weapon\"",
                    "ItemName=\"Weapon\"",
                    "RespawnTime=30.000000",
                    "PlayerViewOffset=(X=30.000000,Z=-5.000000)",
                    "MaxDesireability=0.500000",
                    "Icon=Texture'Engine.S_Weapon'",
                    "Texture=Texture'Engine.S_Weapon'",
                    "bNoSmooth=True"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\Weapon.pcx Name=S_Weapon Mips=Off Flags=2"
                ],
                "extends": "Inventory",
                "functions": {
                    "AltFire": {
                        "body": "{\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AltFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "AnimEnd": {
                        "body": "{\n\t\tPlayIdleAnim();\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "AnimEnd",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BecomeItem": {
                        "body": "{\n   Super.BecomeItem();\n   Lifespan = 0;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BecomeItem",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BecomePickup": {
                        "body": "{\n\tSuper.BecomePickup();\n\tSetDisplayProperties(Default.Style, Default.Texture, Default.bUnlit, Default.bMeshEnviromap );\n   if (Level.NetMode != NM_Standalone)\n      if (bTossedOut)\n         Lifespan = 5.0;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BecomePickup",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BeginState": {
                        "body": "{\n\t\tbChangeWeapon = false;\n\t\tbMuzzleFlash = 0;\n\t\tPawn(Owner).ClientPutDown(self, Pawn(Owner).PendingWeapon);\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BeginState",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "BotDesireability": {
                        "body": "{\n\n\tdesire = MaxDesireability + Bot.AdjustDesireFor(self);\n\tAlreadyHas = Weapon(Bot.FindInventoryType(class)); \n\tif ( AlreadyHas != None )\n\t{\n\t\tif ( (RespawnTime < 10) \n\t\t\t&& ( bHidden || (AlreadyHas.AmmoType == None) \n\t\t\t\t|| (AlreadyHas.AmmoType.AmmoAmount < AlreadyHas.AmmoType.MaxAmmo)) )\n\t\t\treturn 0;\n\t\tif ( (!bHeldItem || bTossedOut) && bWeaponStay )\n\t\t\treturn 0;\n\t\tif ( AlreadyHas.AmmoType == None )\n\t\t\treturn 0.25 * desire;\n\n\t\tif ( AlreadyHas.AmmoType.AmmoAmount > 0 )\n\t\t\treturn FMax( 0.25 * desire, \n\t\t\t\t\tAlreadyHas.AmmoType.MaxDesireability\n\t\t\t\t\t * FMin(1, 0.15 * AlreadyHas.AmmoType.MaxAmmo/AlreadyHas.AmmoType.AmmoAmount) ); \n\t\telse\n\t\t\treturn 0.05;\n\t}\n\tif ( (Bot.Weapon == None) || (Bot.Weapon.AIRating <= 0.4) )\n\t\treturn 2*desire;\n\n\treturn desire;\n}",
                        "locals": [
                            "local Weapon AlreadyHas;",
                            "local float desire;"
                        ],
                        "modifiers": [],
                        "name": "BotDesireability",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Bot"
                            ]
                        ],
                        "return": "float"
                    },
                    "BringUp": {
                        "body": "{\n\tif ( Owner.IsA('PlayerPawn') )\n\t{\n\t\tSetHand(PlayerPawn(Owner).Handedness);\n\t\tif (( Level.NetMode != NM_Standalone ) && (Role == ROLE_Authority))\n\t\t\tClientSetHandedness( PlayerPawn(Owner).Handedness );\n\t\tPlayerPawn(Owner).EndZoom();\n\t}\t\n\tbWeaponUp = false;\n\tPlaySelect();\n\tGotoState('Active');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "BringUp",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "CheckVisibility": {
                        "body": "{\n\n\tPawnOwner = Pawn(Owner);\n\tif( Owner.bHidden && (PawnOwner.Health > 0) && (PawnOwner.Visibility < PawnOwner.Default.Visibility) )\n\t{\n\t\tOwner.bHidden = false;\n\t\tPawnOwner.Visibility = PawnOwner.Default.Visibility;\n\t}\n}",
                        "locals": [
                            "local Pawn PawnOwner;"
                        ],
                        "modifiers": [],
                        "name": "CheckVisibility",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ClientAltFire": {
                        "body": "{\n\treturn true;\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientAltFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Value"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ClientFire": {
                        "body": "{\n\treturn true;\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Value"
                            ]
                        ],
                        "return": "bool"
                    },
                    "ClientPutDown": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientPutDown",
                        "native": false,
                        "param": [
                            [
                                "Weapon",
                                "NextWeapon"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientSetHandedness": {
                        "body": "{\n\tsetHand( Hand );\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "ClientSetHandedness",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Hand"
                            ]
                        ],
                        "return": ""
                    },
                    "ClientWeaponEvent": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ClientWeaponEvent",
                        "native": false,
                        "param": [
                            [
                                "name",
                                "EventType"
                            ]
                        ],
                        "return": ""
                    },
                    "Destroyed": {
                        "body": "{\n\tSuper.Destroyed();\n\tif( (Pawn(Owner)!=None) && (Pawn(Owner).Weapon == self) )\n\t\tPawn(Owner).Weapon = None;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Destroyed",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "DropFrom": {
                        "body": "{\n\tif ( !SetLocation(StartLocation) )\n\t\treturn; \n\tAIRating = Default.AIRating;\n\tbMuzzleFlash = 0;\n\t//\n\t// DEUS_EX CNN - ALERT!  HUGE HACK ALERT!!!\n\t//\n\t// Basically, you don't want to drop all of your ammo unless you are dropping\n\t// a grenade of some sort.  The only way to check for a grenade is to check the\n\t// PickupViewMesh for the illegal mesh TestBox.  But since TestBox is in the DeusExItems\n\t// package, we can't directly access the mesh, so we have to cast the mesh to a string\n\t// and check it that way.\n\t//\n\t// Hate Hate Hate.\n\t//\n\tif (AmmoType != None)\n\t{\n\t\tif (String(AmmoType.PickupViewMesh) == \"DeusExItems.TestBox\")\n\t\t{\n\t\t\tPickupAmmoCount = AmmoType.AmmoAmount;\n\t\t\tAmmoType.AmmoAmount = 0;\n\t\t}\n\t\telse\n\t\t\tPickupAmmoCount = 0;\n\t}\n   if (Level.Netmode != NM_Standalone)\n      bTossedOut = true;\n\tSuper.DropFrom(StartLocation);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "DropFrom",
                        "native": false,
                        "param": [
                            [
                                "vector",
                                "StartLocation"
                            ]
                        ],
                        "return": ""
                    },
                    "Finish": {
                        "body": "{\n\n\tif ( bChangeWeapon )\n\t{\n\t\tGotoState('DownWeapon');\n\t\treturn;\n\t}\n\n\tPawnOwner = Pawn(Owner);\n\tif ( PlayerPawn(Owner) == None )\n\t{\n\t\tif ( (AmmoType != None) && (AmmoType.AmmoAmount<=0) )\n\t\t{\n\t\t\tPawnOwner.StopFiring();\n\t\t\tPawnOwner.SwitchToBestWeapon();\n\t\t\tif ( bChangeWeapon )\n\t\t\t\tGotoState('DownWeapon');\n\t\t}\n\t\telse if ( (PawnOwner.bFire != 0) && (FRand() < RefireRate) )\n\t\t\tGlobal.Fire(0);\n\t\telse if ( (PawnOwner.bAltFire != 0) && (FRand() < AltRefireRate) )\n\t\t\tGlobal.AltFire(0);\t\n\t\telse \n\t\t{\n\t\t\tPawnOwner.StopFiring();\n\t\t\tGotoState('Idle');\n\t\t}\n\t\treturn;\n\t}\n\tif ( ((AmmoType != None) && (AmmoType.AmmoAmount<=0)) || (PawnOwner.Weapon != self) )\n\t\tGotoState('Idle');\n\telse if ( PawnOwner.bFire!=0 )\n\t\tGlobal.Fire(0);\n\telse if ( PawnOwner.bAltFire!=0 )\n\t\tGlobal.AltFire(0);\n\telse \n\t\tGotoState('Idle');\n}",
                        "locals": [
                            "local Pawn PawnOwner;"
                        ],
                        "modifiers": [],
                        "name": "Finish",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Fire": {
                        "body": "{\n\t}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Fire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "F"
                            ]
                        ],
                        "return": ""
                    },
                    "ForceAltFire": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ForceAltFire",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "ForceFire": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ForceFire",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "GiveAmmo": {
                        "body": "{\n\tif ( AmmoName == None )\n\t\treturn;\n\tAmmoType = Ammo(Other.FindInventoryType(AmmoName));\n\tif ( AmmoType != None )\n\t\tAmmoType.AddAmmo(PickUpAmmoCount);\n\telse\n\t{\n\t\tAmmoType = Spawn(AmmoName);\t// Create ammo type required\t\t\n\t\tOther.AddInventory(AmmoType);\t\t// and add to player's inventory\n\t\tAmmoType.BecomeItem();\n\t\tAmmoType.AmmoAmount = PickUpAmmoCount; \n\t\tAmmoType.GotoState('Idle2');\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "GiveAmmo",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "HandlePickupQuery": {
                        "body": "{\n\n\tif (Item.Class == Class)\n\t{\n\t\tif ( Weapon(item).bWeaponStay && (!Weapon(item).bHeldItem || Weapon(item).bTossedOut) )\n\t\t\treturn true;\n\t\tP = Pawn(Owner);\n//\t\tif ( AmmoType != None )\n//\t\t{\n//\t\t\tOldAmmo = AmmoType.AmmoAmount;\n//\n//\t\t\t// DEUS_EX CNN - never switch weapons automatically, but do add the ammo\n//\t\t\tAmmoType.AddAmmo(Weapon(Item).PickupAmmoCount);\n//\t\t\tif ( AmmoType.AddAmmo(Weapon(Item).PickupAmmoCount) && (OldAmmo == 0) \n//\t\t\t\t&& (P.Weapon.class != item.class) && !P.bNeverSwitchOnPickup )\n//\t\t\t\t\tWeaponSet(P);\n//\t\t}\n\t\tif (Level.Game.LocalLog != None)\n\t\t\tLevel.Game.LocalLog.LogPickup(Item, Pawn(Owner));\n\t\tif (Level.Game.WorldLog != None)\n\t\t\tLevel.Game.WorldLog.LogPickup(Item, Pawn(Owner));\n\t\tif (Item.PickupMessageClass == None)\n\t\t\t// DEUS_EX CNN - use the itemArticle and itemName\n//\t\t\tP.ClientMessage(Item.PickupMessage, 'Pickup');\n\t\t\tP.ClientMessage(Item.PickupMessage @ Item.itemArticle @ Item.itemName, 'Pickup');\n\t\telse\n\t\t\tP.ReceiveLocalizedMessage( Item.PickupMessageClass, 0, None, None, item.Class );\n\t\tItem.PlaySound(Item.PickupSound);\n\t\tItem.SetRespawn();   \n\t\treturn true;\n\t}",
                        "locals": [
                            "local int OldAmmo;",
                            "local Pawn P;"
                        ],
                        "modifiers": [],
                        "name": "HandlePickupQuery",
                        "native": false,
                        "param": [
                            [
                                "inventory",
                                "Item"
                            ]
                        ],
                        "return": "bool"
                    },
                    "PlayAltFiring": {
                        "body": "{\n\t//Play alt firing animation and sound\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PlayAltFiring",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayFiring": {
                        "body": "{\n\t//Play firing animation and sound\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PlayFiring",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayIdleAnim": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayIdleAnim",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlayPostSelect": {
                        "body": "{\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlayPostSelect",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PlaySelect": {
                        "body": "{\n\tPlayAnim('Select',1.0,0.0);\n\tOwner.PlaySound(SelectSound, SLOT_Misc, Pawn(Owner).SoundDampening);\t\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PlaySelect",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostBeginPlay": {
                        "body": "{\n\tSuper.PostBeginPlay();\n\tSetWeaponStay();\n\tMaxDesireability = 1.2 * AIRating;\n\tif ( ProjectileClass != None )\n\t{\n\t\tProjectileSpeed = ProjectileClass.Default.Speed;\n\t\tMyDamageType = ProjectileClass.Default.MyDamageType;\n\t}\n\tif ( AltProjectileClass != None )\n\t{\n\t\tAltProjectileSpeed = AltProjectileClass.Default.Speed;\n\t\tAltDamageType = AltProjectileClass.Default.MyDamageType;\n\t}\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PostRender": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PostRender",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "PreRender": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PreRender",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "ProcessTraceHit": {
                        "body": "{\n\t//Spawn appropriate effects at hit location, any weapon lights, and damage hit actor\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "ProcessTraceHit",
                        "native": false,
                        "param": [
                            [
                                "Actor",
                                "Other"
                            ],
                            [
                                "Vector",
                                "HitLocation"
                            ],
                            [
                                "Vector",
                                "HitNormal"
                            ],
                            [
                                "Vector",
                                "X"
                            ],
                            [
                                "Vector",
                                "Y"
                            ],
                            [
                                "Vector",
                                "Z"
                            ]
                        ],
                        "return": ""
                    },
                    "ProjectileFire": {
                        "body": "{\n\n\tPawnOwner = Pawn(Owner);\n\tOwner.MakeNoise(PawnOwner.SoundDampening);\n\tGetAxes(PawnOwner.ViewRotation,X,Y,Z);\n\tStart = Owner.Location + CalcDrawOffset() + FireOffset.X * X + FireOffset.Y * Y + FireOffset.Z * Z; \n\tAdjustedAim = PawnOwner.AdjustAim(ProjSpeed, Start, AimError, True, bWarn);\t\n\treturn Spawn(ProjClass,,, Start,AdjustedAim);\t\n}",
                        "locals": [
                            "local Vector Start, X,Y,Z;",
                            "local Pawn PawnOwner;"
                        ],
                        "modifiers": [],
                        "name": "ProjectileFire",
                        "native": false,
                        "param": [
                            [
                                "class<projectile>",
                                "ProjClass"
                            ],
                            [
                                "float",
                                "ProjSpeed"
                            ],
                            [
                                "bool",
                                "bWarn"
                            ]
                        ],
                        "return": "Projectile"
                    },
                    "PutDown": {
                        "body": "{\n\tbChangeWeapon = true;\n\tGotoState('DownWeapon');\t\t// DEUS_EX CNN - added to force the weapon down\n\treturn true; \n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "PutDown",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "RaiseUp": {
                        "body": "{\n\tBringUp();\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "RaiseUp",
                        "native": false,
                        "param": [
                            [
                                "Weapon",
                                "OldWeapon"
                            ]
                        ],
                        "return": ""
                    },
                    "RateSelf": {
                        "body": "{\n\tif ( (AmmoType != None) && (AmmoType.AmmoAmount <=0) )\n\t\treturn -2;\n\tbUseAltMode = int(FRand() < 0.4);\n\treturn (AIRating + FRand() * 0.05);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "RateSelf",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "int",
                                "bUseAltMode"
                            ]
                        ],
                        "return": "float"
                    },
                    "RecommendWeapon": {
                        "body": "{\n\n\tif ( Owner.IsA('PlayerPawn') )\n\t\trating = SwitchPriority();\n\telse\n\t{\n\t\trating = RateSelf(bUseAltMode);\n\t\tif ( (self == Pawn(Owner).Weapon) && (Pawn(Owner).Enemy != None) \n\t\t\t&& ((AmmoType == None) || (AmmoType.AmmoAmount > 0)) )\n\t\t\trating += 0.21; // tend to stick with same weapon\n\t}\n\tif ( inventory != None )\n\t{\n\t\tRecommended = inventory.RecommendWeapon(oldRating, oldMode);\n\t\tif ( (Recommended != None) && (oldRating > rating) )\n\t\t{\n\t\t\trating = oldRating;\n\t\t\tbUseAltMode = oldMode;\n\t\t\treturn Recommended;\n\t\t}\n\t}\n\treturn self;\n}",
                        "locals": [
                            "local Weapon Recommended;",
                            "local float oldRating, oldFiring;",
                            "local int oldMode;"
                        ],
                        "modifiers": [],
                        "name": "RecommendWeapon",
                        "native": false,
                        "param": [
                            [
                                "out",
                                "float",
                                "rating"
                            ],
                            [
                                "out",
                                "int",
                                "bUseAltMode"
                            ]
                        ],
                        "return": "Weapon"
                    },
                    "RenderOverlays": {
                        "body": "{\n\n\tif ( bHideWeapon || (Owner == None) )\n\t\treturn;\n\n\tPlayerOwner = PlayerPawn(Owner);\n\n\tif ( PlayerOwner != None )\n\t{\n\t\tif ( PlayerOwner.DesiredFOV != PlayerOwner.DefaultFOV )\n\t\t\treturn;\n\t\tbPlayerOwner = true;\n\t\tHand = PlayerOwner.Handedness;\n\n\t\tif (  (Level.NetMode == NM_Client) && (Hand == 2) )\n\t\t{\n\t\t\tbHideWeapon = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( !bPlayerOwner || (PlayerOwner.Player == None) )\n\t\tPawn(Owner).WalkBob = vect(0,0,0);\n\n\tif ( (bMuzzleFlash > 0) && bDrawMuzzleFlash && Level.bHighDetailMode && (MFTexture != None) )\n\t{\n\t\tMuzzleScale = Default.MuzzleScale * Canvas.ClipX/640.0;\n\t\tif ( !bSetFlashTime )\n\t\t{\n\t\t\tbSetFlashTime = true;\n\t\t\tFlashTime = Level.TimeSeconds + FlashLength;\n\t\t}\n\t\telse if ( FlashTime < Level.TimeSeconds )\n\t\t\tbMuzzleFlash = 0;\n\t\tif ( bMuzzleFlash > 0 )\n\t\t{\n\t\t\tif ( Hand == 0 )\n\t\t\t\tCanvas.SetPos(Canvas.ClipX/2 - 0.5 * MuzzleScale * FlashS + Canvas.ClipX * (-0.2 * Default.FireOffset.Y * FlashO), Canvas.ClipY/2 - 0.5 * MuzzleScale * FlashS + Canvas.ClipY * (FlashY + FlashC));\n\t\t\telse\n\t\t\t\tCanvas.SetPos(Canvas.ClipX/2 - 0.5 * MuzzleScale * FlashS + Canvas.ClipX * (Hand * Default.FireOffset.Y * FlashO), Canvas.ClipY/2 - 0.5 * MuzzleScale * FlashS + Canvas.ClipY * FlashY);\n\n\t\t\tCanvas.Style = 3;\n\t\t\tCanvas.DrawIcon(MFTexture, MuzzleScale);\n\t\t\tCanvas.Style = 1;\n\t\t}\n\t}\n\telse\n\t\tbSetFlashTime = false;\n\n\tSetLocation( Owner.Location + CalcDrawOffset() );\n\tNewRot = Pawn(Owner).ViewRotation;\n\n\tif ( Hand == 0 )\n\t\tnewRot.Roll = -2 * Default.Rotation.Roll;\n\telse\n\t\tnewRot.Roll = Default.Rotation.Roll * Hand;\n\n\tsetRotation(newRot);\n\tCanvas.DrawActor(self, false);\n}",
                        "locals": [
                            "local rotator NewRot;",
                            "local bool bPlayerOwner;",
                            "local int Hand;",
                            "local PlayerPawn PlayerOwner;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "RenderOverlays",
                        "native": false,
                        "param": [
                            [
                                "canvas",
                                "Canvas"
                            ]
                        ],
                        "return": ""
                    },
                    "SetSwitchPriority": {
                        "body": "{\n\n\tif ( PlayerPawn(Other) != None )\n\t{\n\t\tfor ( i=0; i<20; i++)\n\t\t\tif ( PlayerPawn(Other).WeaponPriority[i] == class.name )\n\t\t\t{\n\t\t\t\tAutoSwitchPriority = i;\n\t\t\t\treturn;\n\t\t\t}\n\t\t// else, register this weapon\n\t\tcarried = class.name;\n\t\tfor ( i=AutoSwitchPriority; i<20; i++ )\n\t\t{\n\t\t\tif ( PlayerPawn(Other).WeaponPriority[i] == '' )\n\t\t\t{\n\t\t\t\tPlayerPawn(Other).WeaponPriority[i] = carried;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if ( i<19 )\n\t\t\t{\n\t\t\t\ttemp = PlayerPawn(Other).WeaponPriority[i];\n\t\t\t\tPlayerPawn(Other).WeaponPriority[i] = carried;\n\t\t\t\tcarried = temp;\n\t\t\t}\n\t\t}\n\t}\t\t\n}",
                        "locals": [
                            "local int i;",
                            "local name temp, carried;"
                        ],
                        "modifiers": [],
                        "name": "SetSwitchPriority",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "SetWeaponStay": {
                        "body": "{\n\tbWeaponStay = bWeaponStay || Level.Game.bCoopWeaponMode;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SetWeaponStay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "SpawnCopy": {
                        "body": "{\n\n\tif( Level.Game.ShouldRespawn(self) )\n\t{\n\t\tCopy = spawn(Class,Other,,,rot(0,0,0));\n\t\tCopy.Tag           = Tag;\n\t\tCopy.Event         = Event;\n\t\tif ( !bWeaponStay )\n\t\t\tGotoState('Sleeping');\n\t}\n\telse\n\t\tCopy = self;\n\n\tCopy.RespawnTime = 0.0;\n\tCopy.bHeldItem = true;\n\tCopy.bTossedOut = false;\n\n\t// DEUS_EX AJY\n\t// Give weapon ammo before giving to player\t\n\tWeapon(Copy).GiveAmmo(Other);\n\tCopy.GiveTo( Other );\n\t\n\tnewWeapon = Weapon(Copy);\n\tnewWeapon.Instigator = Other;\n\tnewWeapon.SetSwitchPriority(Other);\n\t// DEUS_EX CNN - Don't autoswitch weapons\n//\tif ( !Other.bNeverSwitchOnPickup )\n//\t\tnewWeapon.WeaponSet(Other);\n\tnewWeapon.AmbientGlow = 0;\n\treturn newWeapon;\n}",
                        "locals": [
                            "local inventory Copy;",
                            "local Weapon newWeapon;"
                        ],
                        "modifiers": [],
                        "name": "SpawnCopy",
                        "native": false,
                        "param": [
                            [
                                "pawn",
                                "Other"
                            ]
                        ],
                        "return": "inventory"
                    },
                    "SplashJump": {
                        "body": "{\n\treturn false;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SplashJump",
                        "native": false,
                        "param": [],
                        "return": "bool"
                    },
                    "SuggestAttackStyle": {
                        "body": "{\n\treturn 0.0;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SuggestAttackStyle",
                        "native": false,
                        "param": [],
                        "return": "float"
                    },
                    "SuggestDefenseStyle": {
                        "body": "{\n\treturn 0.0;\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "SuggestDefenseStyle",
                        "native": false,
                        "param": [],
                        "return": "float"
                    },
                    "SwitchPriority": {
                        "body": "{\n\n\tif ( !Owner.IsA('PlayerPawn') )\n\t\treturn RateSelf(bTemp);\n\telse if ( (AmmoType != None) && (AmmoType.AmmoAmount<=0) )\n\t{\n\t\tif ( Pawn(Owner).Weapon == self )\n\t\t\treturn -0.5;\n\t\telse\n\t\t\treturn -1;\n\t}\n\telse \n\t\treturn AutoSwitchPriority;\n}",
                        "locals": [
                            "local float temp;",
                            "local int bTemp;"
                        ],
                        "modifiers": [],
                        "name": "SwitchPriority",
                        "native": false,
                        "param": [],
                        "return": "float"
                    },
                    "TraceFire": {
                        "body": "{\n\n\tPawnOwner = Pawn(Owner);\n\n\tOwner.MakeNoise(PawnOwner.SoundDampening);\n\tGetAxes(PawnOwner.ViewRotation,X,Y,Z);\n\tStartTrace = Owner.Location + CalcDrawOffset() + FireOffset.X * X + FireOffset.Y * Y + FireOffset.Z * Z; \n\tAdjustedAim = PawnOwner.AdjustAim(1000000, StartTrace, 2*AimError, False, False);\t\n\tEndTrace = StartTrace + Accuracy * (FRand() - 0.5 )* Y * 1000\n\t\t+ Accuracy * (FRand() - 0.5 ) * Z * 1000;\n\tX = vector(AdjustedAim);\n\tEndTrace += (10000 * X); \n\tOther = PawnOwner.TraceShot(HitLocation,HitNormal,EndTrace,StartTrace);\n\tProcessTraceHit(Other, HitLocation, HitNormal, X,Y,Z);\n}",
                        "locals": [
                            "local vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z;",
                            "local actor Other;",
                            "local Pawn PawnOwner;"
                        ],
                        "modifiers": [],
                        "name": "TraceFire",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Accuracy"
                            ]
                        ],
                        "return": ""
                    },
                    "TravelPostAccept": {
                        "body": "{\n\tSuper.TravelPostAccept();\n\tif ( Pawn(Owner) == None )\n\t\treturn;\n\tif ( AmmoName != None )\n\t{\n\t\t// DEUS_EX CNN - if AmmoType isn't already set (through a travel),\n\t\t// find the default in the inventory list\n\t\tif ( AmmoType == None )\n\t\t{\t\t\n\t\t\tAmmoType = Ammo(Pawn(Owner).FindInventoryType(AmmoName));\n\t\t\tif (AmmoType == None)\n\t\t\t{\n\t\t\t\tAmmoType = Spawn(AmmoName);\t// Create ammo type required\t\t\n\t\t\t\tPawn(Owner).AddInventory(AmmoType);\t\t// and add to player's inventory\n\t\t\t\tAmmoType.BecomeItem();\n\t\t\t\tAmmoType.AmmoAmount = PickUpAmmoCount; \n\t\t\t\tAmmoType.GotoState('Idle2');\n\t\t\t}\n\t\t}\n\t}\n\tif ( self == Pawn(Owner).Weapon )\n\t\tBringUp();\n\telse GoToState('Idle2');\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TravelPostAccept",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TweenDown": {
                        "body": "{\n\tif ( (AnimSequence != '') && (GetAnimGroup(AnimSequence) == 'Select') )\n\t\tTweenAnim( AnimSequence, AnimFrame * 0.4 );\n\telse\n\t{\n\t\t// Have the put away animation play twice as fast in multiplayer\n\t\tif ( Level.NetMode != NM_Standalone )\n\t\t\tPlayAnim('Down', 2.0, 0.05);\n\t\telse\n\t\t\tPlayAnim('Down', 1.0, 0.05);\n\t}\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "TweenDown",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TweenSelect": {
                        "body": "{\n\tTweenAnim('Select',0.001);\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "TweenSelect",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "TweenToStill": {
                        "body": "",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "TweenToStill",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "WeaponChange": {
                        "body": "{\t\n\t \n\tif ( InventoryGroup == F )\n\t{\n\t\t/* we want you to change weapons even if you're out of ammo - DEUS_EX CNN\n\t\tif ( (AmmoType != None) && (AmmoType.AmmoAmount <= 0) )\n\t\t{\n\t\t\tif ( Inventory == None )\n\t\t\t\tnewWeapon = None;\n\t\t\telse\n\t\t\t\tnewWeapon = Inventory.WeaponChange(F);\n\t\t\tif ( newWeapon == None )\n\t\t\t\tPawn(Owner).ClientMessage( ItemName$MessageNoAmmo );\t\t\n\t\t\treturn newWeapon;\n\t\t}\t\t\n\t\telse \n\t\t*/\n\t\t\treturn self;\n\t}\n\telse if ( Inventory == None )\n\t\treturn None;\n\telse\n\t\treturn Inventory.WeaponChange(F);\n}",
                        "locals": [
                            "local Weapon newWeapon;"
                        ],
                        "modifiers": [],
                        "name": "WeaponChange",
                        "native": false,
                        "param": [
                            [
                                "byte",
                                "F"
                            ]
                        ],
                        "return": "Weapon"
                    },
                    "WeaponSet": {
                        "body": "{\n\t\n\tif ( Other.Weapon == self)\n\t\treturn false;\n\n\tif ( Other.Weapon == None )\n\t{\n\t\tOther.PendingWeapon = self;\n\t\tOther.ChangedWeapon();\n\t\treturn true;\t\n\t}\n\telse if ( Other.Weapon.SwitchPriority() < SwitchPriority() ) \n\t{\n\t\tW = Other.PendingWeapon;\n\t\tOther.PendingWeapon = self;\n\t\tGotoState('');\n\n\t\tif ( Other.Weapon.PutDown() )\n\t\t\treturn true;\n\t\tOther.PendingWeapon = W;\n\t\treturn false;\n\t}\n\telse \n\t{\n\t\tGoToState('');\n\t\treturn false;\n\t}\n}",
                        "locals": [
                            "local bool bSwitch,bHaveAmmo;",
                            "local Inventory Inv;",
                            "local weapon W;"
                        ],
                        "modifiers": [],
                        "name": "WeaponSet",
                        "native": false,
                        "param": [
                            [
                                "Pawn",
                                "Other"
                            ]
                        ],
                        "return": "bool"
                    },
                    "setHand": {
                        "body": "{\n\tif ( Hand == 2 )\n\t{\n\t\tPlayerViewOffset.Y = 0;\n\t\tFireOffset.Y = 0;\n\t\tbHideWeapon = true;\n\t\treturn;\n\t}\n\telse\n\t\tbHideWeapon = false;\n\n\tif ( Hand == 0 )\n\t{\n\t\tPlayerViewOffset.X = Default.PlayerViewOffset.X * 0.88;\n\t\tPlayerViewOffset.Y = -0.2 * Default.PlayerViewOffset.Y;\n\t\tPlayerViewOffset.Z = Default.PlayerViewOffset.Z * 1.12;\n\t}\n\telse\n\t{\n\t\tPlayerViewOffset.X = Default.PlayerViewOffset.X;\n\t\tPlayerViewOffset.Y = Default.PlayerViewOffset.Y * Hand;\n\t\tPlayerViewOffset.Z = Default.PlayerViewOffset.Z;\n\t}\n\tPlayerViewOffset *= 100; //scale since network passes vector components as ints\n\tFireOffset.Y = Default.FireOffset.Y * Hand;\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "setHand",
                        "native": false,
                        "param": [
                            [
                                "float",
                                "Hand"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 991,
                "replication": "",
                "states": [],
                "variables": [
                    "var() float   MaxTargetRange;    // Maximum distance to target.",
                    "var() class<ammo> AmmoName;          // Type of ammo used.",
                    "var() travel byte    ReloadCount;       // Amount of ammo depletion before reloading. 0 if no reloading is done.",
                    "var() int     PickupAmmoCount;   // Amount of ammo initially in pick-up item.",
                    "var travel ammo\tAmmoType;\t\t // Inventory Ammo being used.",
                    "var() travel bool\t  bInstantHit;\t\t // If true, instant hit rather than projectile firing weapon",
                    "var() bool\t  bAltInstantHit;\t // If true, instant hit rather than projectile firing weapon for AltFire",
                    "var(WeaponAI) bool\t  bWarnTarget;\t\t // When firing projectile, warn the target",
                    "var(WeaponAI) bool\t  bAltWarnTarget;\t // When firing alternate projectile, warn the target",
                    "var   bool\t  bWeaponUp;\t\t // Used in Active State",
                    "var   bool\t  bChangeWeapon;\t // Used in Active State",
                    "var   bool \t  bLockedOn;",
                    "var(WeaponAI) bool\t  bSplashDamage;\t // used by bot AI",
                    "var()\t\t  bool\t  bCanThrow;\t//if true, player can toss this weapon out",
                    "var(WeaponAI) bool\t  bRecommendSplashDamage; //if true, bot preferentially tries to use splash damage",
                    "var(WeaponAI) bool\t  bRecommendAltSplashDamage; //if true, bot preferentially tries to use splash damage",
                    "var() bool\t  bWeaponStay;",
                    "var() bool\t  bOwnsCrosshair;\t// this weapon is responsible for drawing its own crosshair (in its postrender function)",
                    "var(WeaponAI) bool\t  bMeleeWeapon; //Weapon is only a melee weapon",
                    "var() bool\t  bRapidFire;\t\t// used by human animations in determining firing animation (for still firing)",
                    "var() float\t  FiringSpeed;\t\t// used by human animations in determining firing speed",
                    "var()   vector\tFireOffset;\t\t // Offset from drawing location for projectile/trace start",
                    "var()   class<projectile> ProjectileClass;",
                    "var()   class<projectile> AltProjectileClass;",
                    "var()\tname MyDamageType;",
                    "var()\tname AltDamageType;",
                    "var()\tfloat\tShakeMag;",
                    "var()\tfloat\tShakeTime;",
                    "var()\tfloat   ShakeVert;",
                    "var(WeaponAI)\tfloat\tAIRating;",
                    "var(WeaponAI)\tfloat\tRefireRate;",
                    "var(WeaponAI)\tfloat\tAltRefireRate;",
                    "var() sound \tFireSound;",
                    "var() sound \tAltFireSound;",
                    "var() sound \tCockingSound;",
                    "var() sound \tSelectSound;",
                    "var() sound \tMisc1Sound;",
                    "var() sound \tMisc2Sound;",
                    "var() sound \tMisc3Sound;",
                    "var() Localized string MessageNoAmmo;",
                    "var() Localized string DeathMessage;",
                    "var() Color NameColor;\t// used when drawing name on HUD",
                    "var Rotator AdjustedAim;",
                    "var bool bSetFlashTime;",
                    "var(MuzzleFlash) bool bDrawMuzzleFlash;",
                    "var byte bMuzzleFlash;",
                    "var float FlashTime;",
                    "var(MuzzleFlash) float MuzzleScale, FlashY, FlashO, FlashC, FlashLength;",
                    "var(MuzzleFlash) int FlashS;\t// size of (square) texture/2",
                    "var(MuzzleFlash) texture MFTexture;",
                    "var(MuzzleFlash) texture MuzzleFlare;",
                    "var(MuzzleFlash) float FlareOffset;"
                ]
            }
        },
        "ZoneInfo.uc": {
            "body": "//=============================================================================\n// ZoneInfo, the built-in Unreal class for defining properties\n// of zones.  If you place one ZoneInfo actor in a\n// zone you have partioned, the ZoneInfo defines the \n// properties of the zone.\n// This is a built-in Unreal class and it shouldn't be modified.\n//=============================================================================\nclass ZoneInfo extends Info\n\tnative\n\tnativereplication;\n\n#exec Texture Import File=Textures\\ZoneInfo.pcx Name=S_ZoneInfo Mips=Off Flags=2\n\n//-----------------------------------------------------------------------------\n// Zone properties.\n\nvar() name   ZoneTag;\nvar() vector ZoneGravity;\nvar() vector ZoneVelocity;\nvar() float  ZoneGroundFriction;\nvar() float  ZoneFluidFriction;\nvar() float\t ZoneTerminalVelocity;\nvar() name   ZonePlayerEvent;\nvar   int    ZonePlayerCount;\nvar   int\t NumCarcasses;\nvar() int\t DamagePerSec;\nvar() name\t DamageType;\nvar() localized string DamageString;\nvar(LocationStrings) localized string ZoneName;\nvar LocationID LocationID;\t\nvar() int\t MaxCarcasses;\nvar() sound  EntrySound;\t//only if waterzone\nvar() sound  ExitSound;\t\t// only if waterzone\nvar() class<actor> EntryActor;\t// e.g. a splash (only if water zone)\nvar() class<actor> ExitActor;\t// e.g. a splash (only if water zone)\nvar skyzoneinfo SkyZone; // Optional sky zone containing this zone's sky.\n\n//-----------------------------------------------------------------------------\n// Zone flags.\n\nvar()\t\tbool   bWaterZone;   // Zone is water-filled.\nvar() const bool   bFogZone;     // Zone is fog-filled.\nvar() const bool   bKillZone;    // Zone instantly kills those who enter.\nvar()\t\tbool   bNeutralZone; // Players can't take damage in this zone.\nvar()\t\tbool   bGravityZone; // Use ZoneGravity.\nvar()\t\tbool   bPainZone;\t // Zone causes pain.\nvar()\t\tbool   bDestructive; // Destroys carcasses.\nvar()\t\tbool   bNoInventory;\nvar()\t\tbool   bMoveProjectiles;\t// this velocity zone should impart velocity to projectiles and effects\nvar()\t\tbool   bBounceVelocity;\t\t// this velocity zone should bounce actors that land in it\n\n//-----------------------------------------------------------------------------\n// Zone light.\n\nvar(ZoneLight) byte AmbientBrightness, AmbientHue, AmbientSaturation;\nvar(ZoneLight) color FogColor;\nvar(ZoneLight) float FogDistance;\n\nvar(ZoneLight) const texture EnvironmentMap;\nvar(ZoneLight) float TexUPanSpeed, TexVPanSpeed;\nvar(ZoneLight) vector ViewFlash, ViewFog;\n\n//-----------------------------------------------------------------------------\n// Reverb.\n\n// Settings.\nvar(Reverb) bool bReverbZone;\nvar(Reverb) bool bRaytraceReverb;\nvar(Reverb) float SpeedOfSound;\nvar(Reverb) byte MasterGain;\nvar(Reverb) int  CutoffHz;\nvar(Reverb) byte Delay[6];\nvar(Reverb) byte Gain[6];\n\n//LEGEND:begin\n//-----------------------------------------------------------------------------\n// Lens flare.\n\nvar(LensFlare) texture LensFlare[12];\nvar(LensFlare) float LensFlareOffset[12];\nvar(LensFlare) float LensFlareScale[12];\n\n//-----------------------------------------------------------------------------\n// per-Zone mesh LOD lighting control\n \n// the number of lights applied to the actor mesh is interpolated between the following\n// properties, as a function of the MeshPolyCount for the previous frame.\nvar() byte MinLightCount; // minimum number of lights to use (when MaxLightingPolyCount is exceeded)\nvar() byte MaxLightCount; // maximum number of lights to use (when MeshPolyCount drops below MinLightingPolyCount)\nvar() int MinLightingPolyCount;\nvar() int MaxLightingPolyCount;\n// (NOTE: the default LOD properties (below) have no effect on the mesh lighting behavior)\n//LEGEND:end\n\n//=============================================================================\n// Network replication.\n\nreplication\n{\n\treliable if( Role==ROLE_Authority )\n\t\tZoneGravity, ZoneVelocity, \n\t\t// ZoneTerminalVelocity,\n\t\t// ZoneGroundFriction, ZoneFluidFriction,\n\t\tAmbientBrightness, AmbientHue, AmbientSaturation,\n\t\tTexUPanSpeed, TexVPanSpeed,\n\t\t// ViewFlash, ViewFog, // Not replicated because vectors replicated with elements rounded to integers\n\t\tbReverbZone,\n\t\tFogColor;\n}\n\n//=============================================================================\n// Iterator functions.\n\n// Iterate through all actors in this zone.\nnative(308) final iterator function ZoneActors( class<actor> BaseClass, out actor Actor );\n\n//LEGEND:begin -- moved out of PreBeginPlay() to allow overriding\n//=============================================================================\nsimulated function LinkToSkybox()\n{\n\tlocal skyzoneinfo TempSkyZone;\n\n\t// SkyZone.\n\tforeach AllActors( class 'SkyZoneInfo', TempSkyZone, '' )\n\t\tSkyZone = TempSkyZone;\n\tforeach AllActors( class 'SkyZoneInfo', TempSkyZone, '' )\n\t\tif( TempSkyZone.bHighDetail == Level.bHighDetailMode )\n\t\t\tSkyZone = TempSkyZone;\n}\n//LEGEND:end\n\n//=============================================================================\n// Engine notification functions.\n\nsimulated function PreBeginPlay()\n{\n\tSuper.PreBeginPlay();\n\n\t// DEUS_EX CNN - set the SoundRadius to ZERO to fix the zone AmbientSound problem\n\tSoundRadius = 0;\n\n\t// call overridable function to link this ZoneInfo actor to a skybox\n\tLinkToSkybox();\n}\n\nfunction Trigger( actor Other, pawn EventInstigator )\n{\n// modified to toggle instead of just set to true - DEUS_EX CNN\n// modified to start the pain timer if you are alread in the zone - DEUS_EX CNN\n\tif (DamagePerSec != 0)\n\t{\n//\t\tbPainZone = true;\n\t\tbPainZone = !bPainZone;\n\t\tif (bPainZone)\n\t\t\tEventInstigator.PainTimer();\n\t}\n\n}\n\n// When an actor enters this zone.\nevent ActorEntered( actor Other )\n{\n\tlocal actor A;\n\tlocal vector AddVelocity;\n\n\tif ( bNoInventory && Other.IsA('Inventory') && (Other.Owner == None) )\n\t{\n\t\tOther.LifeSpan = 1.5;\n\t\treturn;\n\t}\n\n\tif( Pawn(Other)!=None && Pawn(Other).bIsPlayer )\n\t\tif( ++ZonePlayerCount==1 && ZonePlayerEvent!='' )\n\t\t\tforeach AllActors( class 'Actor', A, ZonePlayerEvent )\n\t\t\t\tA.Trigger( Self, Pawn(Other) );\n\n\tif ( bMoveProjectiles && (ZoneVelocity != vect(0,0,0)) )\n\t{\n\t\tif ( Other.Physics == PHYS_Projectile )\n\t\t\tOther.Velocity += ZoneVelocity;\n\t\telse if ( Other.IsA('Effects') && (Other.Physics == PHYS_None) )\n\t\t{\n\t\t\tOther.SetPhysics(PHYS_Projectile);\n\t\t\tOther.Velocity += ZoneVelocity;\n\t\t}\n\t}\n}\n\n// When an actor leaves this zone.\nevent ActorLeaving( actor Other )\n{\n\tlocal actor A;\n\tif( Pawn(Other)!=None && Pawn(Other).bIsPlayer )\n\t\tif( --ZonePlayerCount==0 && ZonePlayerEvent!='' )\n\t\t\tforeach AllActors( class 'Actor', A, ZonePlayerEvent )\n\t\t\t\tA.UnTrigger( Self, Pawn(Other) );\n}\n\ndefaultproperties\n{\n     ZoneGravity=(Z=-950.000000)\n     ZoneGroundFriction=8.000000\n     ZoneFluidFriction=1.200000\n     ZoneTerminalVelocity=2500.000000\n     MaxCarcasses=3\n     bMoveProjectiles=True\n     AmbientSaturation=255\n     TexUPanSpeed=1.000000\n     TexVPanSpeed=1.000000\n     SpeedOfSound=8000.000000\n     MasterGain=100\n     CutoffHz=6000\n     Delay(0)=20\n     Delay(1)=34\n     Gain(0)=150\n     Gain(1)=70\n     MinLightCount=6\n     MaxLightCount=6\n     MinLightingPolyCount=1000\n     MaxLightingPolyCount=5000\n     bStatic=True\n     bNoDelete=True\n     Texture=Texture'Engine.S_ZoneInfo'\n     bAlwaysRelevant=True\n     NetUpdateFrequency=4.000000\n}\n",
            "name": "ZoneInfo.uc",
            "uc": {
                "comments": [],
                "default_properties": [
                    "ZoneGravity=(Z=-950.000000)",
                    "ZoneGroundFriction=8.000000",
                    "ZoneFluidFriction=1.200000",
                    "ZoneTerminalVelocity=2500.000000",
                    "MaxCarcasses=3",
                    "bMoveProjectiles=True",
                    "AmbientSaturation=255",
                    "TexUPanSpeed=1.000000",
                    "TexVPanSpeed=1.000000",
                    "SpeedOfSound=8000.000000",
                    "MasterGain=100",
                    "CutoffHz=6000",
                    "Delay(0)=20",
                    "Delay(1)=34",
                    "Gain(0)=150",
                    "Gain(1)=70",
                    "MinLightCount=6",
                    "MaxLightCount=6",
                    "MinLightingPolyCount=1000",
                    "MaxLightingPolyCount=5000",
                    "bStatic=True",
                    "bNoDelete=True",
                    "Texture=Texture'Engine.S_ZoneInfo'",
                    "bAlwaysRelevant=True",
                    "NetUpdateFrequency=4.000000"
                ],
                "exec": [
                    "#exec Texture Import File=Textures\\ZoneInfo.pcx Name=S_ZoneInfo Mips=Off Flags=2"
                ],
                "extends": "Info",
                "functions": {
                    "ActorEntered": {
                        "body": "{\n\n\tif ( bNoInventory && Other.IsA('Inventory') && (Other.Owner == None) )\n\t{\n\t\tOther.LifeSpan = 1.5;\n\t\treturn;\n\t}\n\n\tif( Pawn(Other)!=None && Pawn(Other).bIsPlayer )\n\t\tif( ++ZonePlayerCount==1 && ZonePlayerEvent!='' )\n\t\t\tforeach AllActors( class 'Actor', A, ZonePlayerEvent )\n\t\t\t\tA.Trigger( Self, Pawn(Other) );\n\n\tif ( bMoveProjectiles && (ZoneVelocity != vect(0,0,0)) )\n\t{\n\t\tif ( Other.Physics == PHYS_Projectile )\n\t\t\tOther.Velocity += ZoneVelocity;\n\t\telse if ( Other.IsA('Effects') && (Other.Physics == PHYS_None) )\n\t\t{\n\t\t\tOther.SetPhysics(PHYS_Projectile);\n\t\t\tOther.Velocity += ZoneVelocity;\n\t\t}\n\t}\n}",
                        "locals": [
                            "local actor A;",
                            "local vector AddVelocity;"
                        ],
                        "modifiers": [],
                        "name": "ActorEntered",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "ActorLeaving": {
                        "body": "{\n\tif( Pawn(Other)!=None && Pawn(Other).bIsPlayer )\n\t\tif( --ZonePlayerCount==0 && ZonePlayerEvent!='' )\n\t\t\tforeach AllActors( class 'Actor', A, ZonePlayerEvent )\n\t\t\t\tA.UnTrigger( Self, Pawn(Other) );\n}",
                        "locals": [
                            "local actor A;"
                        ],
                        "modifiers": [],
                        "name": "ActorLeaving",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "LinkToSkybox": {
                        "body": "{\n\n\t// SkyZone.\n\tforeach AllActors( class 'SkyZoneInfo', TempSkyZone, '' )\n\t\tSkyZone = TempSkyZone;\n\tforeach AllActors( class 'SkyZoneInfo', TempSkyZone, '' )\n\t\tif( TempSkyZone.bHighDetail == Level.bHighDetailMode )\n\t\t\tSkyZone = TempSkyZone;\n}",
                        "locals": [
                            "local skyzoneinfo TempSkyZone;"
                        ],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "LinkToSkybox",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "PreBeginPlay": {
                        "body": "{\n\tSuper.PreBeginPlay();\n\n\t// DEUS_EX CNN - set the SoundRadius to ZERO to fix the zone AmbientSound problem\n\tSoundRadius = 0;\n\n\t// call overridable function to link this ZoneInfo actor to a skybox\n\tLinkToSkybox();\n}",
                        "locals": [],
                        "modifiers": [
                            "simulated"
                        ],
                        "name": "PreBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    },
                    "Trigger": {
                        "body": "{\n// modified to toggle instead of just set to true - DEUS_EX CNN\n// modified to start the pain timer if you are alread in the zone - DEUS_EX CNN\n\tif (DamagePerSec != 0)\n\t{\n//\t\tbPainZone = true;\n\t\tbPainZone = !bPainZone;\n\t\tif (bPainZone)\n\t\t\tEventInstigator.PainTimer();\n\t}\n\n}",
                        "locals": [],
                        "modifiers": [],
                        "name": "Trigger",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ],
                            [
                                "pawn",
                                "EventInstigator"
                            ]
                        ],
                        "return": ""
                    },
                    "ZoneActors": {
                        "body": "",
                        "locals": [],
                        "modifiers": [],
                        "name": "ZoneActors",
                        "native": true,
                        "param": [
                            [
                                "class<actor>",
                                "BaseClass"
                            ],
                            [
                                "out",
                                "actor",
                                "Actor"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 227,
                "replication": "",
                "states": [],
                "variables": [
                    "var() name   ZoneTag;",
                    "var() vector ZoneGravity;",
                    "var() vector ZoneVelocity;",
                    "var() float  ZoneGroundFriction;",
                    "var() float  ZoneFluidFriction;",
                    "var() float\t ZoneTerminalVelocity;",
                    "var() name   ZonePlayerEvent;",
                    "var   int    ZonePlayerCount;",
                    "var   int\t NumCarcasses;",
                    "var() int\t DamagePerSec;",
                    "var() name\t DamageType;",
                    "var() localized string DamageString;",
                    "var(LocationStrings) localized string ZoneName;",
                    "var LocationID LocationID;",
                    "var() int\t MaxCarcasses;",
                    "var() sound  EntrySound;\t//only if waterzone",
                    "var() sound  ExitSound;\t\t// only if waterzone",
                    "var() class<actor> EntryActor;\t// e.g. a splash (only if water zone)",
                    "var() class<actor> ExitActor;\t// e.g. a splash (only if water zone)",
                    "var skyzoneinfo SkyZone; // Optional sky zone containing this zone's sky.",
                    "var()\t\tbool   bWaterZone;   // Zone is water-filled.",
                    "var() const bool   bFogZone;     // Zone is fog-filled.",
                    "var() const bool   bKillZone;    // Zone instantly kills those who enter.",
                    "var()\t\tbool   bNeutralZone; // Players can't take damage in this zone.",
                    "var()\t\tbool   bGravityZone; // Use ZoneGravity.",
                    "var()\t\tbool   bPainZone;\t // Zone causes pain.",
                    "var()\t\tbool   bDestructive; // Destroys carcasses.",
                    "var()\t\tbool   bNoInventory;",
                    "var()\t\tbool   bMoveProjectiles;\t// this velocity zone should impart velocity to projectiles and effects",
                    "var()\t\tbool   bBounceVelocity;\t\t// this velocity zone should bounce actors that land in it",
                    "var(ZoneLight) byte AmbientBrightness, AmbientHue, AmbientSaturation;",
                    "var(ZoneLight) color FogColor;",
                    "var(ZoneLight) float FogDistance;",
                    "var(ZoneLight) const texture EnvironmentMap;",
                    "var(ZoneLight) float TexUPanSpeed, TexVPanSpeed;",
                    "var(ZoneLight) vector ViewFlash, ViewFog;",
                    "var(Reverb) bool bReverbZone;",
                    "var(Reverb) bool bRaytraceReverb;",
                    "var(Reverb) float SpeedOfSound;",
                    "var(Reverb) byte MasterGain;",
                    "var(Reverb) int  CutoffHz;",
                    "var(Reverb) byte Delay[6];",
                    "var(Reverb) byte Gain[6];",
                    "var(LensFlare) texture LensFlare[12];",
                    "var(LensFlare) float LensFlareOffset[12];",
                    "var(LensFlare) float LensFlareScale[12];",
                    "var() byte MinLightCount; // minimum number of lights to use (when MaxLightingPolyCount is exceeded)",
                    "var() byte MaxLightCount; // maximum number of lights to use (when MeshPolyCount drops below MinLightingPolyCount)",
                    "var() int MinLightingPolyCount;",
                    "var() int MaxLightingPolyCount;"
                ]
            }
        },
        "ZoneTrigger.uc": {
            "body": "//=============================================================================\n// ZoneTrigger.\n//=============================================================================\nclass ZoneTrigger extends Trigger;\n\n//\n// Called when something touches the trigger.\n//\nfunction Touch( actor Other )\n{\n\tlocal ZoneInfo Z;\n\tif( IsRelevant( Other ) )\n\t{\n\t\t// Broadcast the Trigger message to all matching actors.\n\t\tif( Event != '' )\n\t\t\tforeach AllActors( class 'ZoneInfo', Z )\n\t\t\t\tif ( Z.ZoneTag == Event )\n\t\t\t\t\tZ.Trigger( Other, Other.Instigator );\n\n\t\tif( Message != \"\" )\n\t\t\t// Send a string message to the toucher.\n\t\t\tOther.Instigator.ClientMessage( Message );\n\n\t\tif( bTriggerOnceOnly )\n\t\t\t// Ignore future touches.\n\t\t\tSetCollision(False);\n\t}\n}\n\n//\n// When something untouches the trigger.\n//\nfunction UnTouch( actor Other )\n{\n\tlocal ZoneInfo Z;\n\tif( IsRelevant( Other ) )\n\t{\n\t\t// Untrigger all matching actors.\n\t\tif( Event != '' )\n\t\t\tforeach AllActors( class 'ZoneInfo', Z )\n\t\t\t\tif ( Z.ZoneTag == Event )\n\t\t\t\t\tZ.UnTrigger( Other, Other.Instigator );\n\t}\n}\n\ndefaultproperties\n{\n}\n",
            "name": "ZoneTrigger.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "Trigger",
                "functions": {
                    "Touch": {
                        "body": "{\n\tif( IsRelevant( Other ) )\n\t{\n\t\t// Broadcast the Trigger message to all matching actors.\n\t\tif( Event != '' )\n\t\t\tforeach AllActors( class 'ZoneInfo', Z )\n\t\t\t\tif ( Z.ZoneTag == Event )\n\t\t\t\t\tZ.Trigger( Other, Other.Instigator );\n\n\t\tif( Message != \"\" )\n\t\t\t// Send a string message to the toucher.\n\t\t\tOther.Instigator.ClientMessage( Message );\n\n\t\tif( bTriggerOnceOnly )\n\t\t\t// Ignore future touches.\n\t\t\tSetCollision(False);\n\t}\n}",
                        "locals": [
                            "local ZoneInfo Z;"
                        ],
                        "modifiers": [],
                        "name": "Touch",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    },
                    "UnTouch": {
                        "body": "{\n\tif( IsRelevant( Other ) )\n\t{\n\t\t// Untrigger all matching actors.\n\t\tif( Event != '' )\n\t\t\tforeach AllActors( class 'ZoneInfo', Z )\n\t\t\t\tif ( Z.ZoneTag == Event )\n\t\t\t\t\tZ.UnTrigger( Other, Other.Instigator );\n\t}\n}",
                        "locals": [
                            "local ZoneInfo Z;"
                        ],
                        "modifiers": [],
                        "name": "UnTouch",
                        "native": false,
                        "param": [
                            [
                                "actor",
                                "Other"
                            ]
                        ],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 49,
                "replication": "",
                "states": [],
                "variables": []
            }
        },
        "locationid.uc": {
            "body": "//=============================================================================\n// LocationID - marks and names an area in a zone\n//=============================================================================\nclass LocationID extends KeyPoint\n\tnative;\n\nvar() localized string LocationName;\nvar() float Radius;\nvar LocationID NextLocation;\n\nfunction PostBeginPlay()\n{\n\tlocal LocationID L;\n\tSuper.PostBeginPlay();\n\n\t// add self to zone list\n\tif ( Region.Zone.LocationID == None )\n\t{\n\t\tRegion.Zone.LocationID = self;\n\t\treturn;\n\t}\n\n\tfor ( L=Region.Zone.LocationID; L!=None; L=L.NextLocation )\n\t\tif ( L.NextLocation == None )\n\t\t{\n\t\t\tL.NextLocation = self;\n\t\t\treturn;\n\t\t}\n}\n\ndefaultproperties\n{\n}\n",
            "name": "locationid.uc",
            "uc": {
                "comments": [],
                "default_properties": [],
                "exec": [],
                "extends": "KeyPoint",
                "functions": {
                    "PostBeginPlay": {
                        "body": "{\n\tSuper.PostBeginPlay();\n\n\t// add self to zone list\n\tif ( Region.Zone.LocationID == None )\n\t{\n\t\tRegion.Zone.LocationID = self;\n\t\treturn;\n\t}\n\n\tfor ( L=Region.Zone.LocationID; L!=None; L=L.NextLocation )\n\t\tif ( L.NextLocation == None )\n\t\t{\n\t\t\tL.NextLocation = self;\n\t\t\treturn;\n\t\t}\n}",
                        "locals": [
                            "local LocationID L;"
                        ],
                        "modifiers": [],
                        "name": "PostBeginPlay",
                        "native": false,
                        "param": [],
                        "return": ""
                    }
                },
                "header": [],
                "instructions": [],
                "loc": 34,
                "replication": "",
                "states": [],
                "variables": [
                    "var() localized string LocationName;",
                    "var() float Radius;",
                    "var LocationID NextLocation;"
                ]
            }
        }
    },
    "models": {},
    "sounds": {},
    "textures": {}
}