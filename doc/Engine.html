
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>Deus Ex</title>
    <meta name="description" content="UC Class API documentation..">
    <meta name="author" content="Kaiser">
    <link rel="stylesheet" href="../styles.css">
    <script src="../kaiser.js"></script>
  </head>
  <body>
    <header><h2>Deus Ex Documentation::Engine</h2></header>
    <section>
	<nav>
	  <ul>
	    <li><a href="../index.html">Home</a></li>
	    <li><a href="../about.html">About</a></li>
	    <li><a href="https://twitter.com/_technomancer">Twitter</a></li>
	    <li><a href="https://gitlab.com/technomancer7/">Gitlab</a></li>
        <li><a href="https://discord.gg/jCFJ3A6">Discord</a></li>
        -
        <li><a href="RCON.html">RCON</a></li>
<li><a href="Core.html">Core</a></li>
<li><a href="OpenDX.html">OpenDX</a></li>
<li><a href="Extension.html">Extension</a></li>
<li><a href="PartyStuff.html">PartyStuff</a></li>
<li><a href="Engine.html">Engine</a></li>
<li><a href="DeusEx.html">DeusEx</a></li>
        -
        <li><a href="#Actor.uc">Actor.uc</a></li>
<li><a href="#AmbientSound.uc">AmbientSound.uc</a></li>
<li><a href="#Ambushpoint.uc">Ambushpoint.uc</a></li>
<li><a href="#Ammo.uc">Ammo.uc</a></li>
<li><a href="#Bitmap.uc">Bitmap.uc</a></li>
<li><a href="#BlockAll.uc">BlockAll.uc</a></li>
<li><a href="#BlockMonsters.uc">BlockMonsters.uc</a></li>
<li><a href="#BlockPlayer.uc">BlockPlayer.uc</a></li>
<li><a href="#Brush.uc">Brush.uc</a></li>
<li><a href="#ButtonMarker.uc">ButtonMarker.uc</a></li>
<li><a href="#Camera.uc">Camera.uc</a></li>
<li><a href="#CameraPoint.uc">CameraPoint.uc</a></li>
<li><a href="#Canvas.uc">Canvas.uc</a></li>
<li><a href="#Carcass.uc">Carcass.uc</a></li>
<li><a href="#Console.uc">Console.uc</a></li>
<li><a href="#Counter.uc">Counter.uc</a></li>
<li><a href="#DamageType.uc">DamageType.uc</a></li>
<li><a href="#Decal.uc">Decal.uc</a></li>
<li><a href="#Decoration.uc">Decoration.uc</a></li>
<li><a href="#DemoRecSpectator.uc">DemoRecSpectator.uc</a></li>
<li><a href="#Dispatcher.uc">Dispatcher.uc</a></li>
<li><a href="#Effects.uc">Effects.uc</a></li>
<li><a href="#Engine.uc">Engine.uc</a></li>
<li><a href="#Fragment.uc">Fragment.uc</a></li>
<li><a href="#GameInfo.uc">GameInfo.uc</a></li>
<li><a href="#GameReplicationInfo.uc">GameReplicationInfo.uc</a></li>
<li><a href="#HUD.uc">HUD.uc</a></li>
<li><a href="#HomeBase.uc">HomeBase.uc</a></li>
<li><a href="#Info.uc">Info.uc</a></li>
<li><a href="#InternetInfo.uc">InternetInfo.uc</a></li>
<li><a href="#InterpolationPoint.uc">InterpolationPoint.uc</a></li>
<li><a href="#Inventory.uc">Inventory.uc</a></li>
<li><a href="#InventorySpot.uc">InventorySpot.uc</a></li>
<li><a href="#Keypoint.uc">Keypoint.uc</a></li>
<li><a href="#LevelInfo.uc">LevelInfo.uc</a></li>
<li><a href="#LevelSummary.uc">LevelSummary.uc</a></li>
<li><a href="#LiftCenter.uc">LiftCenter.uc</a></li>
<li><a href="#LiftExit.uc">LiftExit.uc</a></li>
<li><a href="#Light.uc">Light.uc</a></li>
<li><a href="#LocalMessage.uc">LocalMessage.uc</a></li>
<li><a href="#MapList.uc">MapList.uc</a></li>
<li><a href="#Menu.uc">Menu.uc</a></li>
<li><a href="#MessagingSpectator.uc">MessagingSpectator.uc</a></li>
<li><a href="#Mover.uc">Mover.uc</a></li>
<li><a href="#MusicEvent.uc">MusicEvent.uc</a></li>
<li><a href="#Mutator.uc">Mutator.uc</a></li>
<li><a href="#NavigationPoint.uc">NavigationPoint.uc</a></li>
<li><a href="#Palette.uc">Palette.uc</a></li>
<li><a href="#PathNode.uc">PathNode.uc</a></li>
<li><a href="#PatrolPoint.uc">PatrolPoint.uc</a></li>
<li><a href="#Pawn.uc">Pawn.uc</a></li>
<li><a href="#Pickup.uc">Pickup.uc</a></li>
<li><a href="#Player.uc">Player.uc</a></li>
<li><a href="#PlayerPawn.uc">PlayerPawn.uc</a></li>
<li><a href="#PlayerReplicationInfo.uc">PlayerReplicationInfo.uc</a></li>
<li><a href="#PlayerStart.uc">PlayerStart.uc</a></li>
<li><a href="#Projectile.uc">Projectile.uc</a></li>
<li><a href="#RenderIterator.uc">RenderIterator.uc</a></li>
<li><a href="#ReplicationInfo.uc">ReplicationInfo.uc</a></li>
<li><a href="#RoundRobin.uc">RoundRobin.uc</a></li>
<li><a href="#SavedMove.uc">SavedMove.uc</a></li>
<li><a href="#ScaledSprite.uc">ScaledSprite.uc</a></li>
<li><a href="#ScoreBoard.uc">ScoreBoard.uc</a></li>
<li><a href="#Scout.uc">Scout.uc</a></li>
<li><a href="#ScriptedTexture.uc">ScriptedTexture.uc</a></li>
<li><a href="#SkyZoneInfo.uc">SkyZoneInfo.uc</a></li>
<li><a href="#SmellNode.uc">SmellNode.uc</a></li>
<li><a href="#SpawnNotify.uc">SpawnNotify.uc</a></li>
<li><a href="#SpecialEvent.uc">SpecialEvent.uc</a></li>
<li><a href="#Spectator.uc">Spectator.uc</a></li>
<li><a href="#Spotlight.uc">Spotlight.uc</a></li>
<li><a href="#StatLog.uc">StatLog.uc</a></li>
<li><a href="#StatLogFile.uc">StatLogFile.uc</a></li>
<li><a href="#Teleporter.uc">Teleporter.uc</a></li>
<li><a href="#TestInfo.uc">TestInfo.uc</a></li>
<li><a href="#TestObj.uc">TestObj.uc</a></li>
<li><a href="#Texture.uc">Texture.uc</a></li>
<li><a href="#Trigger.uc">Trigger.uc</a></li>
<li><a href="#TriggerLight.uc">TriggerLight.uc</a></li>
<li><a href="#TriggerMarker.uc">TriggerMarker.uc</a></li>
<li><a href="#Triggers.uc">Triggers.uc</a></li>
<li><a href="#VoicePack.uc">VoicePack.uc</a></li>
<li><a href="#WarpZoneInfo.uc">WarpZoneInfo.uc</a></li>
<li><a href="#WarpZoneMarker.uc">WarpZoneMarker.uc</a></li>
<li><a href="#WayBeacon.uc">WayBeacon.uc</a></li>
<li><a href="#Weapon.uc">Weapon.uc</a></li>
<li><a href="#ZoneInfo.uc">ZoneInfo.uc</a></li>
<li><a href="#ZoneTrigger.uc">ZoneTrigger.uc</a></li>
<li><a href="#locationid.uc">locationid.uc</a></li>
	  </ul>
	</nav>
	<article>  
    <button onclick="topFunction()" id="btt" title="Go to top">Top</button>
    <a class="headerlink" href="#Actor.uc" title="Permanent link"><h2 id="Actor.uc">Actor.uc (extends Object)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var actor BestActor;<br>var float Score;<br>var float Visibility;<br>var float Volume;<br>var float Smell;<br>var(Advanced) const bool  bStatic;       // Does not move or change over time.<br>var(Advanced) bool        bHidden;       // Is hidden during gameplay.<br>var(Advanced) const bool  bNoDelete;     // Cannot be deleted during play.<br>var bool				  bAnimFinished; // Unlooped animation sequence has finished.<br>var bool				  bAnimLoop;     // Whether animation is looping.<br>var bool				  bAnimNotify;   // Whether a notify is applied to the current sequence.<br>var bool				  bAnimByOwner;	 // Animation dictated by owner.<br>var const bool            bDeleteMe;     // About to be deleted.<br>var transient const bool  bAssimilated;  // Actor dynamics are assimilated in world geometry.<br>var transient const bool  bTicked;       // Actor has been updated.<br>var transient bool        bLightChanged; // Recalculate this light's lighting now.<br>var bool                  bDynamicLight; // Temporarily treat this as a dynamic light.<br>var bool                  bTimerLoop;    // Timer loops (else is one-shot).<br>var(Advanced) bool        bCanTeleport;  // This actor can be teleported.<br>var(Advanced) bool        bIsSecretGoal; // This actor counts in the "secret" total.<br>var(Advanced) bool        bIsKillGoal;   // This actor counts in the "death" toll.<br>var(Advanced) bool        bIsItemGoal;   // This actor counts in the "item" count.<br>var(Advanced) bool		  bCollideWhenPlacing; // This actor collides with the world when placing.<br>var(Advanced) bool		  bTravel;       // Actor is capable of travelling among servers.<br>var(Advanced) bool		  bMovable;      // Actor is capable of travelling among servers.<br>var(Advanced) bool        bHighDetail;	 // Only show up on high-detail.<br>var(Advanced) bool		  bStasis;		 // In StandAlone games, turn off if not in a recently rendered zone turned off if  bCanStasis  and physics = PHYS_None or PHYS_Rotating.<br>var(Advanced) bool		  bForceStasis;	 // Force stasis when not recently rendered, even if physics not none or rotating.<br>var const	  bool		  bIsPawn;		 // True only for pawns.<br>var(Advanced) const bool  bNetTemporary; // Tear-off simulation in network play.<br>var(Advanced) const bool  bNetOptional;  // Actor should only be replicated if bandwidth available.<br>var(Advanced) bool        bBlockSight;   // True if pawns can't see through this actor.<br>var(Advanced) bool        bDetectable;   // True if this actor can be detected (by sight, sound, etc).<br>var(Advanced) bool        bTransient;    // True if this actor should be destroyed when it goes into stasis<br>var           bool        bIgnore;       // True if this actor should be generally ignored; compliance is voluntary<br>var(Movement) const enum EPhysics<br>var ENetRole Role;<br>var(Networking) ENetRole RemoteRole;<br>var float LastRenderTime;<br>var float DistanceFromPlayer;<br>var         const Actor   Owner;         // Owner actor.<br>var(Object) name InitialState;<br>var(Object) name Group;<br>var float                 TimerRate;     // Timer event, 0=no timer.<br>var const float           TimerCounter;	 // Counts up until it reaches TimerRate.<br>var(Advanced) float		  LifeSpan;      // How old the object lives before dying, 0=forever.<br>var(Display) name         AnimSequence;  // Animation sequence we're playing.<br>var(Display) float        AnimFrame;     // Current animation frame, 0.0 to 1.0.<br>var(Display) float        AnimRate;      // Animation rate in frames per second, 0=none, negative=velocity scaled.<br>var          float        TweenRate;     // Tween-into rate.<br>var(Display) float		  LODBias;<br>var name	BlendAnimSequence[4];<br>var float	BlendAnimFrame[4];<br>var float	BlendAnimRate[4];<br>var float	BlendTweenRate[4];<br>var zoneinfo Zone;       // Zone.<br>var int      iLeaf;      // Bsp leaf.<br>var byte     ZoneNumber; // Zone number.<br>var       const LevelInfo Level;         // Level this actor is on.<br>var transient const Level XLevel;        // Level object.<br>var(Events) name		  Tag;			 // Actor's tag name.<br>var(Events) name          Event;         // The event this actor causes.<br>var Actor                 Target;        // Actor we're aiming at (other uses as well).<br>var Pawn                  Instigator;    // Pawn responsible for damage.<br>var travel Inventory      Inventory;     // Inventory chain.  (DEUS_EX STM - added "travel")<br>var const Actor           Base;          // Moving brush actor we're standing on.<br>var const PointRegion     Region;        // Region this actor is in.<br>var(Movement)	name	  AttachTag;<br>var const byte            StandingCount; // Count of actors standing on this actor.<br>var const byte            MiscNumber;    // Internal use.<br>var const byte            LatentByte;    // Internal latent function use.<br>var const int             LatentInt;     // Internal latent function use.<br>var const float           LatentFloat;   // Internal latent function use.<br>var const actor           LatentActor;   // Internal latent function use.<br>var const actor           Touching[4];   // List of touching actors.<br>var const actor           Deleted;       // Next actor in just-deleted chain.<br>var const transient int CollisionTag, LightingTag, NetTag, OtherTag, ExtraTag, SpecialTag;<br>var(Movement) const vector Location;     // Actor's location; use Move to set.<br>var(Movement) const rotator Rotation;    // Rotation.<br>var       const vector    OldLocation;   // Actor's old location one tick ago.<br>var       const vector    ColLocation;   // Actor's old location one move ago.<br>var(Movement) vector      Velocity;      // Velocity.<br>var       vector          Acceleration;  // Acceleration.<br>var(Advanced) bool        bHiddenEd;     // Is hidden during editing.<br>var(Advanced) bool        bDirectional;  // Actor shows direction arrow during editing.<br>var const bool            bSelected;     // Selected in UnrealEd.<br>var const bool            bMemorized;    // Remembered in UnrealEd.<br>var const bool            bHighlighted;  // Highlighted in UnrealEd.<br>var bool                  bEdLocked;     // Locked in editor (no movement or rotation).<br>var(Advanced) bool        bEdShouldSnap; // Snap to grid in editor.<br>var transient bool        bEdSnap;       // Should snap to grid in UnrealEd.<br>var transient const bool  bTempEditor;   // Internal UnrealEd.<br>var(Filter) bool          bDifficulty0;  // Appear in difficulty 0.<br>var(Filter) bool          bDifficulty1;  // Appear in difficulty 1.<br>var(Filter) bool          bDifficulty2;  // Appear in difficulty 2.<br>var(Filter) bool          bDifficulty3;  // Appear in difficulty 3.<br>var(Filter) bool          bSinglePlayer; // Appear in single player.<br>var(Filter) bool          bNet;          // Appear in regular network play.<br>var(Filter) bool          bNetSpecial;   // Appear in special network play mode.<br>var(Filter) float		  OddsOfAppearing; // 0-1 - chance actor will appear in relevant game modes.<br>var(Display) enum EDrawType<br>var(Display) enum ERenderStyle<br>var(Display) texture    Sprite;			 // Sprite texture if DrawType=DT_Sprite.<br>var(Display) texture    Texture;		 // Misc texture.<br>var(Display) texture    Skin;            // Special skin or enviro map texture.<br>var(Display) mesh       Mesh;            // Mesh if DrawType=DT_Mesh.<br>var const export model  Brush;           // Brush if DrawType=DT_Brush.<br>var(Display) float      DrawScale;		 // Scaling factor, 1.0=normal size.<br>var(Display) float      ScaleGlow;		 // Multiplies lighting.<br>var(Display) byte       AmbientGlow;     // Ambient brightness, or 255=pulsing.<br>var(Display) byte       Fatness;         // Fatness (mesh distortion).<br>var(Display)  bool      bUnlit;          // Lights don't affect actor.<br>var(Display)  bool      bNoSmooth;       // Don't smooth actor's texture.<br>var(Display)  bool      bParticles;      // Mesh is a particle system.<br>var(Display)  bool      bRandomFrame;    // Particles use a random texture from among the default texture and the multiskins textures<br>var(Display)  bool      bMeshEnviroMap;  // Environment-map the mesh.<br>var(Display)  bool      bMeshCurvy;      // Curvy mesh.<br>var(Display)  float     VisibilityRadius;// Actor is drawn if viewer is within its visibility<br>var(Display)  float     VisibilityHeight;// cylinder.  Zero=infinite visibility.<br>var(Display) bool       bShadowCast;     // Casts shadows.<br>var(Advanced) bool		bOwnerNoSee;	 // Everything but the owner can see this actor.<br>var(Advanced) bool      bOnlyOwnerSee;   // Only owner can see this actor.<br>var Const     bool		bIsMover;		 // Is a mover.<br>var(Advanced) bool		bAlwaysRelevant; // Always relevant for network.<br>var Const	  bool		bAlwaysTick;     // Update even when players-only.<br>var(Advanced) bool		bGameRelevant;	 // Always relevant for game<br>var(Display) texture MultiSkins[8];<br>var(Sound) byte         SoundRadius;	 // Radius of ambient sound.<br>var(Sound) byte         SoundVolume;	 // Volume of amient sound.<br>var(Sound) byte         SoundPitch;	     // Sound pitch shift, 64.0=none.<br>var(Sound) sound        AmbientSound;    // Ambient sound effect.<br>var(Sound) float TransientSoundVolume;<br>var(Sound) float TransientSoundRadius;<br>var(Collision) const float CollisionRadius; // Radius of collision cyllinder.<br>var(Collision) const float CollisionHeight; // Half-height cyllinder.<br>var(Collision) const bool bCollideActors;   // Collides with other actors.<br>var(Collision) bool       bCollideWorld;    // Collides with the world.<br>var(Collision) bool       bBlockActors;	    // Blocks other nonplayer actors.<br>var(Collision) bool       bBlockPlayers;    // Blocks other player actors.<br>var(Collision) bool       bProjTarget;      // Projectiles should potentially target this actor.<br>var(Lighting) enum ELightType<br>var(Lighting) enum ELightEffect<br>var(LightColor) byte<br>var(Lighting) byte<br>var(Lighting) bool	     bSpecialLit;	 // Only affects special-lit surfaces.<br>var(Lighting) bool	     bActorShadows;  // Light casts actor shadows.<br>var(Lighting) bool	     bCorona;        // Light uses Skin as a corona.<br>var(Lighting) bool	     bLensFlare;     // Whether to use zone lens flare.<br>var(Movement) bool        bBounce;           // Bounces when hits ground fast.<br>var(Movement) bool		  bFixedRotationDir; // Fixed direction of rotation.<br>var(Movement) bool		  bRotateToDesired;  // Rotate to DesiredRotation.<br>var           bool        bInterpolating;    // Performing interpolating.<br>var enum EDodgeDir<br>var(Movement) float       Mass;            // Mass of this actor.<br>var(Movement) float       Buoyancy;        // Water buoyancy.<br>var(Movement) rotator	  RotationRate;    // Change in rotation per second.<br>var(Movement) rotator     DesiredRotation; // Physics will rotate pawn to this if bRotateToDesired.<br>var           float       PhysAlpha;       // Interpolating position, 0.0-1.0.<br>var           float       PhysRate;        // Interpolation rate per second.<br>var          float        AnimLast;        // Last frame.<br>var          float        AnimMinRate;     // Minimum rate for velocity-scaled animation.<br>var          float        BlendAnimLast[4];        // Last frame.<br>var          float        BlendAnimMinRate[4];     // Minimum rate for velocity-scaled animation.<br>var(Conversation) String BindName;					// Used to bind conversations<br>var(Conversation) String BarkBindName;				// Used to bind Barks!<br>var(Conversation) localized String FamiliarName;	// For display in Conversations<br>var(Conversation) localized String UnfamiliarName;	// For display in Conversations<br>var transient Object     ConListItems;				// List of ConListItems for this Actor<br>var(Conversation) float  ConStartInterval;			// Amount of time required between two convos.<br>var(Smell)   class<SmellNode> SmellClass;<br>var          SmellNode        LastSmellNode;<br>var(Advanced) bool            bOwned;<br>var bool bVisionImportant;<br>var(Networking) float NetPriority; // Higher priorities means update it more frequently.<br>var(Networking) float NetUpdateFrequency; // How many seconds between net updates.<br>var(Networking) float RelevantRadius; //Radius in which things are always relevant.<br>var const bool bNetInitial;       // Initial network update.<br>var const bool bNetOwner;         // Player owns this actor.<br>var const bool bNetRelevant;      // Actor is currently relevant. Only valid server side, only when replicating variables.<br>var const bool bNetSee;           // Player sees it in network play.<br>var const bool bNetHear;          // Player hears it in network play.<br>var const bool bNetFeel;          // Player collides with/feels it in network play.<br>var const bool bSimulatedPawn;	  // True if Pawn and simulated proxy.<br>var const bool bDemoRecording;	  // True we are currently demo recording<br>var const bool bClientDemoRecording;// True we are currently recording a client-side demo<br>var const bool bClientDemoNetFunc;// True if we're client-side demo recording and this call originated from the remote.<br>var(Display) class<RenderIterator> RenderIteratorClass;	// class to instantiate as the actor's RenderInterface<br>var transient RenderIterator RenderInterface;		// abstract iterator initialized in the Rendering engine</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bMovable=True<br>bDetectable=True<br>Role=ROLE_Authority<br>RemoteRole=ROLE_DumbProxy<br>LastRenderTime=-10.000000<br>LODBias=1.000000<br>bDifficulty0=True<br>bDifficulty1=True<br>bDifficulty2=True<br>bDifficulty3=True<br>bSinglePlayer=True<br>bNet=True<br>bNetSpecial=True<br>OddsOfAppearing=1.000000<br>DrawType=DT_Sprite<br>Style=STY_Normal<br>Texture=Texture'Engine.S_Actor'<br>DrawScale=1.000000<br>ScaleGlow=1.000000<br>Fatness=128<br>SoundRadius=32<br>SoundVolume=128<br>SoundPitch=64<br>TransientSoundVolume=1.000000<br>CollisionRadius=22.000000<br>CollisionHeight=22.000000<br>bJustTeleported=True<br>Mass=100.000000<br>ConStartInterval=5.000000<br>NetPriority=1.000000<br>NetUpdateFrequency=100.000000</div>
<h3 id="Actor.AIClearEvent"><a class="headerlink" href="#Actor.AIClearEvent" title="Permanent link">AIClearEvent</a> (name eventName) | native</h3>

<h3 id="Actor.AIClearEventCallback"><a class="headerlink" href="#Actor.AIClearEventCallback" title="Permanent link">AIClearEventCallback</a> (name eventName) | native</h3>

<h3 id="Actor.AIEndEvent"><a class="headerlink" href="#Actor.AIEndEvent" title="Permanent link">AIEndEvent</a> (name eventName, EAIEventType eventType) | native</h3>

<h3 id="Actor.AIGetLightLevel"><a class="headerlink" href="#Actor.AIGetLightLevel" title="Permanent link">AIGetLightLevel</a> (vector Location) | native</h3>

<h3 id="Actor.AIVisibility"><a class="headerlink" href="#Actor.AIVisibility" title="Permanent link">AIVisibility</a> (optional bool bIncludeVelocity) | native</h3>

<h3 id="Actor.AllActors"><a class="headerlink" href="#Actor.AllActors" title="Permanent link">AllActors</a> (class<actor> BaseClass, out actor Actor, optional name MatchTag) | native</h3>

<h3 id="Actor.AnimEnd"><a class="headerlink" href="#Actor.AnimEnd" title="Permanent link">AnimEnd</a></h3>

<h3 id="Actor.Attach"><a class="headerlink" href="#Actor.Attach" title="Permanent link">Attach</a> (Actor Other)</h3>

<h3 id="Actor.AutonomousPhysics"><a class="headerlink" href="#Actor.AutonomousPhysics" title="Permanent link">AutonomousPhysics</a> (float DeltaSeconds) | native</h3>

<h3 id="Actor.BaseChange"><a class="headerlink" href="#Actor.BaseChange" title="Permanent link">BaseChange</a></h3>

<h3 id="Actor.BasedActors"><a class="headerlink" href="#Actor.BasedActors" title="Permanent link">BasedActors</a> (class<actor> BaseClass, out actor Actor) | native</h3>

<h3 id="Actor.BecomeViewTarget"><a class="headerlink" href="#Actor.BecomeViewTarget" title="Permanent link">BecomeViewTarget</a></h3>

<h3 id="Actor.BeginEvent"><a class="headerlink" href="#Actor.BeginEvent" title="Permanent link">BeginEvent</a></h3>

<h3 id="Actor.BeginPlay"><a class="headerlink" href="#Actor.BeginPlay" title="Permanent link">BeginPlay</a></h3>

<h3 id="Actor.BroadcastLocalizedMessage"><a class="headerlink" href="#Actor.BroadcastLocalizedMessage" title="Permanent link">BroadcastLocalizedMessage</a> (class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br><br><br>&#9;for ( P=Level.PawnList; P != None; P=P.nextPawn )<br>&#9;&#9;if ( P.bIsPlayer || P.IsA('MessagingSpectator') )<br>&#9;&#9;&#9;P.ReceiveLocalizedMessage( Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );<br><br></div>
<h3 id="Actor.BroadcastMessage"><a class="headerlink" href="#Actor.BroadcastMessage" title="Permanent link">BroadcastMessage</a> (coerce string Msg, optional bool bBeep, optional name Type)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br><br><br>&#9;if (Type == '')<br>&#9;&#9;Type = 'Event';<br><br>//&#9;if ( Level.Game.AllowsBroadcast(self, Len(Msg)) )<br>&#9;&#9;for( P=Level.PawnList; P!=None; P=P.nextPawn )<br>&#9;&#9;&#9;if( P.bIsPlayer || P.IsA('MessagingSpectator') )<br>&#9;&#9;&#9;&#9;P.ClientMessage( Msg, Type, bBeep );<br><br></div>
<h3 id="Actor.Bump"><a class="headerlink" href="#Actor.Bump" title="Permanent link">Bump</a> (Actor Other)</h3>

<h3 id="Actor.BumpWall"><a class="headerlink" href="#Actor.BumpWall" title="Permanent link">BumpWall</a> (vector HitLocation, vector HitNormal)</h3>

<h3 id="Actor.ChildActors"><a class="headerlink" href="#Actor.ChildActors" title="Permanent link">ChildActors</a> (class<actor> BaseClass, out actor Actor) | native</h3>

<h3 id="Actor.ConsoleCommand"><a class="headerlink" href="#Actor.ConsoleCommand" title="Permanent link">ConsoleCommand</a> (string Command) -> string | native</h3>

<h3 id="Actor.CycleActors"><a class="headerlink" href="#Actor.CycleActors" title="Permanent link">CycleActors</a> (class<actor> BaseClass, out actor Actor, out int Index) | native</h3>

<h3 id="Actor.Destroy"><a class="headerlink" href="#Actor.Destroy" title="Permanent link">Destroy</a> | native</h3>

<h3 id="Actor.Destroyed"><a class="headerlink" href="#Actor.Destroyed" title="Permanent link">Destroyed</a></h3>

<h3 id="Actor.Detach"><a class="headerlink" href="#Actor.Detach" title="Permanent link">Detach</a> (Actor Other)</h3>

<h3 id="Actor.EncroachedBy"><a class="headerlink" href="#Actor.EncroachedBy" title="Permanent link">EncroachedBy</a> (actor Other)</h3>

<h3 id="Actor.EncroachingOn"><a class="headerlink" href="#Actor.EncroachingOn" title="Permanent link">EncroachingOn</a> (actor Other) -> bool</h3>

<h3 id="Actor.EndConversation"><a class="headerlink" href="#Actor.EndConversation" title="Permanent link">EndConversation</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LastConEndTime = Level.TimeSeconds;<br><br></div>
<h3 id="Actor.EndEvent"><a class="headerlink" href="#Actor.EndEvent" title="Permanent link">EndEvent</a></h3>

<h3 id="Actor.EndedRotation"><a class="headerlink" href="#Actor.EndedRotation" title="Permanent link">EndedRotation</a></h3>

<h3 id="Actor.Error"><a class="headerlink" href="#Actor.Error" title="Permanent link">Error</a> (coerce string S) | native</h3>

<h3 id="Actor.Expired"><a class="headerlink" href="#Actor.Expired" title="Permanent link">Expired</a></h3>

<h3 id="Actor.Falling"><a class="headerlink" href="#Actor.Falling" title="Permanent link">Falling</a></h3>

<h3 id="Actor.FellOutOfWorld"><a class="headerlink" href="#Actor.FellOutOfWorld" title="Permanent link">FellOutOfWorld</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;SetPhysics(PHYS_None);<br>&#9;Destroy();<br><br></div>
<h3 id="Actor.FinishAnim"><a class="headerlink" href="#Actor.FinishAnim" title="Permanent link">FinishAnim</a> | native</h3>

<h3 id="Actor.FinishInterpolation"><a class="headerlink" href="#Actor.FinishInterpolation" title="Permanent link">FinishInterpolation</a> | native</h3>

<h3 id="Actor.Frob"><a class="headerlink" href="#Actor.Frob" title="Permanent link">Frob</a> (Actor Frobber, Inventory frobWith)</h3>

<h3 id="Actor.GainedChild"><a class="headerlink" href="#Actor.GainedChild" title="Permanent link">GainedChild</a> (Actor Other)</h3>

<h3 id="Actor.GetAnimGroup"><a class="headerlink" href="#Actor.GetAnimGroup" title="Permanent link">GetAnimGroup</a> (name Sequence) | native</h3>

<h3 id="Actor.GetHumanName"><a class="headerlink" href="#Actor.GetHumanName" title="Permanent link">GetHumanName</a> -> String</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return GetItemName(string(class));<br><br></div>
<h3 id="Actor.GetItemName"><a class="headerlink" href="#Actor.GetItemName" title="Permanent link">GetItemName</a> (string FullName) -> String</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int pos;<br><br><br>&#9;pos = InStr(FullName, ".");<br>&#9;While ( pos != -1 )<br>&#9;{<br>&#9;&#9;FullName = Right(FullName, Len(FullName) - pos - 1);<br>&#9;&#9;pos = InStr(FullName, ".");<br>&#9;}<br><br>&#9;return FullName;<br><br></div>
<h3 id="Actor.GetMapName"><a class="headerlink" href="#Actor.GetMapName" title="Permanent link">GetMapName</a> (string NameEnding, string MapName, int Dir) | native</h3>

<h3 id="Actor.GetMeshTexture"><a class="headerlink" href="#Actor.GetMeshTexture" title="Permanent link">GetMeshTexture</a> (optional int texnum) | native</h3>

<h3 id="Actor.GetNextInt"><a class="headerlink" href="#Actor.GetNextInt" title="Permanent link">GetNextInt</a> (string ClassName, int Num) -> string | native</h3>

<h3 id="Actor.GetNextIntDesc"><a class="headerlink" href="#Actor.GetNextIntDesc" title="Permanent link">GetNextIntDesc</a> (string ClassName, int Num, out string Entry, out string Description) | native</h3>

<h3 id="Actor.GetNextSkin"><a class="headerlink" href="#Actor.GetNextSkin" title="Permanent link">GetNextSkin</a> (string Prefix, string CurrentSkin, int Dir, out string SkinName, out string SkinDesc) | native</h3>

<h3 id="Actor.GetPlayerPawn"><a class="headerlink" href="#Actor.GetPlayerPawn" title="Permanent link">GetPlayerPawn</a> | native</h3>

<h3 id="Actor.GetSoundDuration"><a class="headerlink" href="#Actor.GetSoundDuration" title="Permanent link">GetSoundDuration</a> (sound Sound) -> float | native</h3>

<h3 id="Actor.GetURLMap"><a class="headerlink" href="#Actor.GetURLMap" title="Permanent link">GetURLMap</a> | native</h3>

<h3 id="Actor.HasAnim"><a class="headerlink" href="#Actor.HasAnim" title="Permanent link">HasAnim</a> (name Sequence) | native</h3>

<h3 id="Actor.HitWall"><a class="headerlink" href="#Actor.HitWall" title="Permanent link">HitWall</a> (vector HitNormal, actor HitWall)</h3>

<h3 id="Actor.HurtRadius"><a class="headerlink" href="#Actor.HurtRadius" title="Permanent link">HurtRadius</a> (float DamageAmount, float DamageRadius, name DamageName, float Momentum, vector HitLocation, optional bool bIgnoreLOS)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor Victims;<br>&#9;local float damageScale, dist;<br>&#9;local vector dir;<br>&#9;local Mover M;<br><br><br>&#9;// DEUS_EX CNN<br>&#9;<br>&#9;if( bHurtEntry )<br>&#9;&#9;return;<br><br>&#9;bHurtEntry = true;<br>   if (!bIgnoreLOS)<br>   {<br>      foreach VisibleCollidingActors( class 'Actor', Victims, DamageRadius, HitLocation )<br>      {<br>         if( Victims != self )<br>         {<br>            dir = Victims.Location - HitLocation;<br>            dist = FMax(1,VSize(dir));<br>            dir = dir/dist; <br>            damageScale = 1 - FMax(0,(dist - Victims.CollisionRadius)/DamageRadius);<br>            Victims.TakeDamage<br>               (<br>               damageScale * DamageAmount,<br>               Instigator, <br>               Victims.Location - 0.5 * (Victims.CollisionHeight + Victims.CollisionRadius) * dir,<br>               (damageScale * Momentum * dir),<br>               DamageName<br>               );<br>         } <br>      }<br>   }<br>   else<br>   {<br>      foreach RadiusActors(class 'Actor', Victims, DamageRadius, HitLocation )<br>      {<br>         if( Victims != self )<br>         {<br>            dir = Victims.Location - HitLocation;<br>            dist = FMax(1,VSize(dir));<br>            dir = dir/dist; <br>            damageScale = 1 - FMax(0,(dist - Victims.CollisionRadius)/DamageRadius);<br>            Victims.TakeDamage<br>               (<br>               damageScale * DamageAmount,<br>               Instigator, <br>               Victims.Location - 0.5 * (Victims.CollisionHeight + Victims.CollisionRadius) * dir,<br>               (damageScale * Momentum * dir),<br>               DamageName<br>               );<br>         } <br>      }<br>   }<br><br>&#9;//<br>&#9;// DEUS_EX - CNN - damage the movers, also<br>&#9;//<br>&#9;foreach RadiusActors(class 'Mover', M, DamageRadius, HitLocation)<br>&#9;{<br>&#9;&#9;if( M != self )<br>&#9;&#9;{<br>&#9;&#9;&#9;dir = M.Location - HitLocation;<br>&#9;&#9;&#9;dist = FMax(1,VSize(dir));<br>&#9;&#9;&#9;dir = dir/dist; <br>&#9;&#9;&#9;damageScale = 1 - FMax(0,(dist - M.CollisionRadius)/DamageRadius);<br>&#9;&#9;&#9;M.TakeDamage<br>&#9;&#9;&#9;(<br>&#9;&#9;&#9;&#9;damageScale * DamageAmount,<br>&#9;&#9;&#9;&#9;Instigator, <br>&#9;&#9;&#9;&#9;M.Location - 0.5 * (M.CollisionHeight + M.CollisionRadius) * dir,<br>&#9;&#9;&#9;&#9;(damageScale * Momentum * dir),<br>&#9;&#9;&#9;&#9;DamageName<br>&#9;&#9;&#9;);<br>&#9;&#9;} <br>&#9;}<br><br>&#9;bHurtEntry = false;<br><br></div>
<h3 id="Actor.InStasis"><a class="headerlink" href="#Actor.InStasis" title="Permanent link">InStasis</a> | native</h3>

<h3 id="Actor.InterpolateEnd"><a class="headerlink" href="#Actor.InterpolateEnd" title="Permanent link">InterpolateEnd</a> (actor Other)</h3>

<h3 id="Actor.IsAnimating"><a class="headerlink" href="#Actor.IsAnimating" title="Permanent link">IsAnimating</a> | native</h3>

<h3 id="Actor.IsOverlapping"><a class="headerlink" href="#Actor.IsOverlapping" title="Permanent link">IsOverlapping</a> (actor checkActor) | native</h3>

<h3 id="Actor.KillCredit"><a class="headerlink" href="#Actor.KillCredit" title="Permanent link">KillCredit</a> (Actor Other)</h3>

<h3 id="Actor.KilledBy"><a class="headerlink" href="#Actor.KilledBy" title="Permanent link">KilledBy</a> (pawn EventInstigator)</h3>

<h3 id="Actor.Landed"><a class="headerlink" href="#Actor.Landed" title="Permanent link">Landed</a> (vector HitNormal)</h3>

<h3 id="Actor.LastRendered"><a class="headerlink" href="#Actor.LastRendered" title="Permanent link">LastRendered</a> | native</h3>

<h3 id="Actor.LoopAnim"><a class="headerlink" href="#Actor.LoopAnim" title="Permanent link">LoopAnim</a> (name Sequence, optional float Rate, optional float TweenTime, optional float MinRate) | native</h3>

<h3 id="Actor.LostChild"><a class="headerlink" href="#Actor.LostChild" title="Permanent link">LostChild</a> (Actor Other)</h3>

<h3 id="Actor.MakeNoise"><a class="headerlink" href="#Actor.MakeNoise" title="Permanent link">MakeNoise</a> (float Loudness) | native</h3>

<h3 id="Actor.Move"><a class="headerlink" href="#Actor.Move" title="Permanent link">Move</a> (vector Delta) | native</h3>

<h3 id="Actor.MoveSmooth"><a class="headerlink" href="#Actor.MoveSmooth" title="Permanent link">MoveSmooth</a> (vector Delta) | native</h3>

<h3 id="Actor.PlayAnim"><a class="headerlink" href="#Actor.PlayAnim" title="Permanent link">PlayAnim</a> (name Sequence, optional float Rate, optional float TweenTime) | native</h3>

<h3 id="Actor.PlayBlendAnim"><a class="headerlink" href="#Actor.PlayBlendAnim" title="Permanent link">PlayBlendAnim</a> (name Sequence, optional float Rate, optional float TweenTime, optional int BlendSlot) | native</h3>

<h3 id="Actor.PlayerCanSeeMe"><a class="headerlink" href="#Actor.PlayerCanSeeMe" title="Permanent link">PlayerCanSeeMe</a> | native</h3>

<h3 id="Actor.PostBeginPlay"><a class="headerlink" href="#Actor.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>

<h3 id="Actor.PostNetBeginPlay"><a class="headerlink" href="#Actor.PostNetBeginPlay" title="Permanent link">PostNetBeginPlay</a></h3>

<h3 id="Actor.PostPostBeginPlay"><a class="headerlink" href="#Actor.PostPostBeginPlay" title="Permanent link">PostPostBeginPlay</a></h3>

<h3 id="Actor.PostTeleport"><a class="headerlink" href="#Actor.PostTeleport" title="Permanent link">PostTeleport</a> (Teleporter OutTeleporter)</h3>

<h3 id="Actor.PreBeginPlay"><a class="headerlink" href="#Actor.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// fake shrink to fix faked collision with floor problems - DEUS_EX CNN<br>&#9;if ((IsA('Decoration') || IsA('Inventory')) && (CollisionHeight > 0.75))<br>&#9;&#9;SetCollisionSize(CollisionRadius, CollisionHeight - 0.75);<br>&#9;else if (IsA('Pawn'))<br>&#9;{<br>&#9;&#9;if (CollisionHeight > 9)<br>&#9;&#9;&#9;SetCollisionSize(CollisionRadius, CollisionHeight - 4.5);<br>&#9;&#9;else<br>&#9;&#9;&#9;SetCollisionSize(CollisionRadius, CollisionHeight*0.5);<br>&#9;}<br><br>&#9;// Handle autodestruction if desired.<br>&#9;if( !bGameRelevant && (Level.NetMode != NM_Client) && !Level.Game.IsRelevant(Self) )<br>&#9;&#9;Destroy();<br><br></div>
<h3 id="Actor.PreTeleport"><a class="headerlink" href="#Actor.PreTeleport" title="Permanent link">PreTeleport</a> (Teleporter InTeleporter) -> bool</h3>

<h3 id="Actor.RadiusActors"><a class="headerlink" href="#Actor.RadiusActors" title="Permanent link">RadiusActors</a> (class<actor> BaseClass, out actor Actor, float Radius, optional vector Loc) | native</h3>

<h3 id="Actor.RenderOverlays"><a class="headerlink" href="#Actor.RenderOverlays" title="Permanent link">RenderOverlays</a> (canvas Canvas)</h3>

<h3 id="Actor.RenderTexture"><a class="headerlink" href="#Actor.RenderTexture" title="Permanent link">RenderTexture</a> (ScriptedTexture Tex)</h3>

<h3 id="Actor.SetBase"><a class="headerlink" href="#Actor.SetBase" title="Permanent link">SetBase</a> (actor NewBase) | native</h3>

<h3 id="Actor.SetCollision"><a class="headerlink" href="#Actor.SetCollision" title="Permanent link">SetCollision</a> (optional bool NewColActors, optional bool NewBlockActors, optional bool NewBlockPlayers) | native</h3>

<h3 id="Actor.SetCollisionSize"><a class="headerlink" href="#Actor.SetCollisionSize" title="Permanent link">SetCollisionSize</a> (float NewRadius, float NewHeight) | native</h3>

<h3 id="Actor.SetDefaultDisplayProperties"><a class="headerlink" href="#Actor.SetDefaultDisplayProperties" title="Permanent link">SetDefaultDisplayProperties</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Style = Default.Style;<br>&#9;texture = Default.Texture;<br>&#9;bUnlit = Default.bUnlit;<br>&#9;bMeshEnviromap = Default.bMeshEnviromap;<br><br></div>
<h3 id="Actor.SetDisplayProperties"><a class="headerlink" href="#Actor.SetDisplayProperties" title="Permanent link">SetDisplayProperties</a> (ERenderStyle NewStyle, texture NewTexture, bool bLighting, bool bEnviroMap)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Style = NewStyle;<br>&#9;texture = NewTexture;<br>&#9;bUnlit = bLighting;<br>&#9;bMeshEnviromap = bEnviromap;<br><br></div>
<h3 id="Actor.SetInitialState"><a class="headerlink" href="#Actor.SetInitialState" title="Permanent link">SetInitialState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( InitialState!='' )<br>&#9;&#9;GotoState( InitialState );<br>&#9;else<br>&#9;&#9;GotoState( 'Auto' );<br><br></div>
<h3 id="Actor.SetInstantMusicVolume"><a class="headerlink" href="#Actor.SetInstantMusicVolume" title="Permanent link">SetInstantMusicVolume</a> (byte newMusicVolume) | native</h3>

<h3 id="Actor.SetInstantSoundVolume"><a class="headerlink" href="#Actor.SetInstantSoundVolume" title="Permanent link">SetInstantSoundVolume</a> (byte newSoundVolume) | native</h3>

<h3 id="Actor.SetInstantSpeechVolume"><a class="headerlink" href="#Actor.SetInstantSpeechVolume" title="Permanent link">SetInstantSpeechVolume</a> (byte newSpeechVolume) | native</h3>

<h3 id="Actor.SetLocation"><a class="headerlink" href="#Actor.SetLocation" title="Permanent link">SetLocation</a> (vector NewLocation) | native</h3>

<h3 id="Actor.SetOwner"><a class="headerlink" href="#Actor.SetOwner" title="Permanent link">SetOwner</a> (actor NewOwner) | native</h3>

<h3 id="Actor.SetPhysics"><a class="headerlink" href="#Actor.SetPhysics" title="Permanent link">SetPhysics</a> (EPhysics newPhysics, optional Actor newFloor) | native</h3>

<h3 id="Actor.SetRotation"><a class="headerlink" href="#Actor.SetRotation" title="Permanent link">SetRotation</a> (rotator NewRotation) | native</h3>

<h3 id="Actor.SetTimer"><a class="headerlink" href="#Actor.SetTimer" title="Permanent link">SetTimer</a> (float NewTimerRate, bool bLoop) | native</h3>

<h3 id="Actor.Sleep"><a class="headerlink" href="#Actor.Sleep" title="Permanent link">Sleep</a> (float Seconds) | native</h3>

<h3 id="Actor.Spawned"><a class="headerlink" href="#Actor.Spawned" title="Permanent link">Spawned</a></h3>

<h3 id="Actor.SpecialHandling"><a class="headerlink" href="#Actor.SpecialHandling" title="Permanent link">SpecialHandling</a> (Pawn Other) -> Actor</h3>

<h3 id="Actor.StopBlendAnims"><a class="headerlink" href="#Actor.StopBlendAnims" title="Permanent link">StopBlendAnims</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br><br><br>&#9;for (i=0; i<ArrayCount(BlendAnimSequence); i++)<br>&#9;&#9;BlendAnimSequence[i] = '';<br><br></div>
<h3 id="Actor.StopSound"><a class="headerlink" href="#Actor.StopSound" title="Permanent link">StopSound</a> (int Id) | native</h3>

<h3 id="Actor.SupportActor"><a class="headerlink" href="#Actor.SupportActor" title="Permanent link">SupportActor</a> (actor StandingActor)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;StandingActor.SetBase( self );<br><br></div>
<h3 id="Actor.TakeDamage"><a class="headerlink" href="#Actor.TakeDamage" title="Permanent link">TakeDamage</a> (int Damage, Pawn EventInstigator, vector HitLocation, vector Momentum, name DamageType)</h3>

<h3 id="Actor.Tick"><a class="headerlink" href="#Actor.Tick" title="Permanent link">Tick</a> (float DeltaTime)</h3>

<h3 id="Actor.Timer"><a class="headerlink" href="#Actor.Timer" title="Permanent link">Timer</a></h3>

<h3 id="Actor.Touch"><a class="headerlink" href="#Actor.Touch" title="Permanent link">Touch</a> (Actor Other)</h3>

<h3 id="Actor.TouchingActors"><a class="headerlink" href="#Actor.TouchingActors" title="Permanent link">TouchingActors</a> (class<actor> BaseClass, out actor Actor) | native</h3>

<h3 id="Actor.TraceActors"><a class="headerlink" href="#Actor.TraceActors" title="Permanent link">TraceActors</a> (class<actor> BaseClass, out actor Actor, out vector HitLoc, out vector HitNorm, vector End, optional vector Start, optional vector Extent) | native</h3>

<h3 id="Actor.TraceTexture"><a class="headerlink" href="#Actor.TraceTexture" title="Permanent link">TraceTexture</a> (class<actor> BaseClass, out actor Actor, out name texName, out name texGroup, out int flags, out vector HitLoc, out vector HitNorm, vector End, optional vector Start, optional vector Extent) | native</h3>

<h3 id="Actor.TraceVisibleActors"><a class="headerlink" href="#Actor.TraceVisibleActors" title="Permanent link">TraceVisibleActors</a> (class<actor> BaseClass, out actor Actor, out vector HitLoc, out vector HitNorm, vector End, optional vector Start, optional vector Extent) | native</h3>

<h3 id="Actor.TravelPostAccept"><a class="headerlink" href="#Actor.TravelPostAccept" title="Permanent link">TravelPostAccept</a></h3>

<h3 id="Actor.TravelPreAccept"><a class="headerlink" href="#Actor.TravelPreAccept" title="Permanent link">TravelPreAccept</a></h3>

<h3 id="Actor.Trigger"><a class="headerlink" href="#Actor.Trigger" title="Permanent link">Trigger</a> (Actor Other, Pawn EventInstigator)</h3>

<h3 id="Actor.TweenAnim"><a class="headerlink" href="#Actor.TweenAnim" title="Permanent link">TweenAnim</a> (name Sequence, float Time) | native</h3>

<h3 id="Actor.TweenBlendAnim"><a class="headerlink" href="#Actor.TweenBlendAnim" title="Permanent link">TweenBlendAnim</a> (name Sequence, float Time, optional int BlendSlot) | native</h3>

<h3 id="Actor.UnTouch"><a class="headerlink" href="#Actor.UnTouch" title="Permanent link">UnTouch</a> (Actor Other)</h3>

<h3 id="Actor.UnTrigger"><a class="headerlink" href="#Actor.UnTrigger" title="Permanent link">UnTrigger</a> (Actor Other, Pawn EventInstigator)</h3>

<h3 id="Actor.VisibleActors"><a class="headerlink" href="#Actor.VisibleActors" title="Permanent link">VisibleActors</a> (class<actor> BaseClass, out actor Actor, optional float Radius, optional vector Loc) | native</h3>

<h3 id="Actor.VisibleCollidingActors"><a class="headerlink" href="#Actor.VisibleCollidingActors" title="Permanent link">VisibleCollidingActors</a> (class<actor> BaseClass, out actor Actor, optional float Radius, optional vector Loc, optional bool bIgnoreHidden) | native</h3>

<h3 id="Actor.ZoneChange"><a class="headerlink" href="#Actor.ZoneChange" title="Permanent link">ZoneChange</a> (ZoneInfo NewZone)</h3>

<br><br><hr>
<a class="headerlink" href="#AmbientSound.uc" title="Permanent link"><h2 id="AmbientSound.uc">AmbientSound.uc (extends Keypoint)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Texture=Texture'Engine.S_Ambient'<br>SoundRadius=64<br>SoundVolume=190</div>
<br><br><hr>
<a class="headerlink" href="#Ambushpoint.uc" title="Permanent link"><h2 id="Ambushpoint.uc">Ambushpoint.uc (extends NavigationPoint)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var vector lookdir; //direction to look while ambushing<br>var byte survivecount; //used when picking ambushpoint<br>var() float SightRadius; // How far bot at this point should look for enemies<br>var() bool	bSniping;	// bots should snipe from this position</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">SightRadius=5000.000000<br>bDirectional=True<br>SoundVolume=128</div>
<h3 id="Ambushpoint.PreBeginPlay"><a class="headerlink" href="#Ambushpoint.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;lookdir = 2000 * vector(Rotation);<br><br>&#9;Super.PreBeginPlay();<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Ammo.uc" title="Permanent link"><h2 id="Ammo.uc">Ammo.uc (extends Pickup)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() travel int AmmoAmount;<br>var() travel int MaxAmmo;<br>var() class<ammo> ParentAmmo;    // Class of ammo to be represented in inventory<br>var() byte UsedInWeaponSlot[10];<br>var   ammo  PAmmo;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">PickupMessage="You picked up some ammo."<br>RespawnTime=30.000000<br>MaxDesireability=0.200000<br>Texture=Texture'Engine.S_Ammo'<br>bCollideActors=False</div>
<h3 id="Ammo.AddAmmo"><a class="headerlink" href="#Ammo.AddAmmo" title="Permanent link">AddAmmo</a> (int AmmoToAdd) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;If (AmmoAmount >= MaxAmmo) return false;<br>&#9;AmmoAmount += AmmoToAdd;<br>&#9;if (AmmoAmount > MaxAmmo) AmmoAmount = MaxAmmo;<br>&#9;return true;<br><br></div>
<h3 id="Ammo.BotDesireability"><a class="headerlink" href="#Ammo.BotDesireability" title="Permanent link">BotDesireability</a> (Pawn Bot) -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Ammo AlreadyHas;<br><br><br>&#9;if ( ParentAmmo != None )<br>&#9;&#9;AlreadyHas = Ammo(Bot.FindInventoryType(ParentAmmo));<br>&#9;else<br>&#9;&#9;AlreadyHas = Ammo(Bot.FindInventoryType(Class));<br>&#9;if ( AlreadyHas == None )<br>&#9;&#9;return (0.35 * MaxDesireability);<br>&#9;if ( AlreadyHas.AmmoAmount == 0 )<br>&#9;&#9;return MaxDesireability;<br>&#9;if (AlreadyHas.AmmoAmount >= AlreadyHas.MaxAmmo) <br>&#9;&#9;return -1;<br><br>&#9;return ( MaxDesireability * FMin(1, 0.15 * MaxAmmo/AlreadyHas.AmmoAmount) );<br><br></div>
<h3 id="Ammo.HandlePickupQuery"><a class="headerlink" href="#Ammo.HandlePickupQuery" title="Permanent link">HandlePickupQuery</a> (inventory Item) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( (class == item.class) || <br>&#9;&#9;(ClassIsChildOf(item.class, class'Ammo') && (class == Ammo(item).parentammo)) ) <br>&#9;{<br>&#9;&#9;if (AmmoAmount==MaxAmmo) return true;<br>&#9;&#9;if (Level.Game.LocalLog != None)<br>&#9;&#9;&#9;Level.Game.LocalLog.LogPickup(Item, Pawn(Owner));<br>&#9;&#9;if (Level.Game.WorldLog != None)<br>&#9;&#9;&#9;Level.Game.WorldLog.LogPickup(Item, Pawn(Owner));<br>&#9;&#9;if (Item.PickupMessageClass == None)<br>&#9;&#9;&#9;// DEUS_EX CNN - use the itemArticle and itemName<br>//&#9;&#9;&#9;Pawn(Owner).ClientMessage( Item.PickupMessage, 'Pickup' );<br>&#9;&#9;&#9;Pawn(Owner).ClientMessage( Item.PickupMessage @ Item.itemArticle @ Item.ItemName, 'Pickup' );<br>&#9;&#9;else<br>&#9;&#9;&#9;Pawn(Owner).ReceiveLocalizedMessage( Item.PickupMessageClass, 0, None, None, item.Class );<br>&#9;&#9;item.PlaySound( item.PickupSound );<br>&#9;&#9;AddAmmo(Ammo(item).AmmoAmount);<br>&#9;&#9;item.SetRespawn();<br>&#9;&#9;return true;&#9;&#9;&#9;&#9;<br>&#9;}<br>&#9;if ( Inventory == None )<br>&#9;&#9;return false;<br><br>&#9;return Inventory.HandlePickupQuery(Item);<br><br></div>
<h3 id="Ammo.SimUseAmmo"><a class="headerlink" href="#Ammo.SimUseAmmo" title="Permanent link">SimUseAmmo</a> -> bool</h3>

<h3 id="Ammo.SpawnCopy"><a class="headerlink" href="#Ammo.SpawnCopy" title="Permanent link">SpawnCopy</a> (Pawn Other) -> inventory</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Inventory Copy;<br><br><br>&#9;if ( parentammo != None )<br>&#9;{<br>&#9;&#9;Copy = spawn(parentammo,Other,,,rot(0,0,0));<br>&#9;&#9;Copy.Tag           = Tag;<br>&#9;&#9;Copy.Event         = Event;<br>&#9;&#9;Copy.Instigator    = Other;<br>&#9;&#9;Ammo(Copy).AmmoAmount = AmmoAmount;<br>&#9;&#9;Copy.BecomeItem();<br>&#9;&#9;Other.AddInventory( Copy );<br>&#9;&#9;Copy.GotoState('');<br>&#9;&#9;if ( Level.Game.ShouldRespawn(self) )<br>&#9;&#9;&#9;GotoState('Sleeping');<br>&#9;&#9;else<br>&#9;&#9;&#9;Destroy();<br>&#9;&#9;return Copy;<br>&#9;}<br>&#9;Copy = Super.SpawnCopy(Other);<br>&#9;Ammo(Copy).AmmoAmount = AmmoAmount; <br>&#9;return Copy;<br><br></div>
<h3 id="Ammo.UseAmmo"><a class="headerlink" href="#Ammo.UseAmmo" title="Permanent link">UseAmmo</a> (int AmountNeeded) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (AmmoAmount < AmountNeeded) return False;   // Can't do it<br>&#9;AmmoAmount -= AmountNeeded;<br>&#9;return True;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Bitmap.uc" title="Permanent link"><h2 id="Bitmap.uc">Bitmap.uc (extends Object)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var const enum ETextureFormat<br>var(Texture) palette Palette;<br>var const byte  UBits, VBits;<br>var const int   USize, VSize;<br>var(Texture) const int UClamp, VClamp;<br>var const color MipZero;<br>var const color MaxColor;<br>var const int   InternalTime[2];</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">MipZero=(R=64,G=128,B=64)<br>MaxColor=(R=255,G=255,B=255,A=255)</div>
<br><br><hr>
<a class="headerlink" href="#BlockAll.uc" title="Permanent link"><h2 id="BlockAll.uc">BlockAll.uc (extends Keypoint)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bCollideActors=True<br>bBlockActors=True<br>bBlockPlayers=True</div>
<br><br><hr>
<a class="headerlink" href="#BlockMonsters.uc" title="Permanent link"><h2 id="BlockMonsters.uc">BlockMonsters.uc (extends Keypoint)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bCollideActors=True<br>bBlockActors=True</div>
<br><br><hr>
<a class="headerlink" href="#BlockPlayer.uc" title="Permanent link"><h2 id="BlockPlayer.uc">BlockPlayer.uc (extends Keypoint)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bBlockPlayers=True</div>
<br><br><hr>
<a class="headerlink" href="#Brush.uc" title="Permanent link"><h2 id="Brush.uc">Brush.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() enum ECsgOper<br>var const object UnusedLightMesh;<br>var vector  PostPivot;<br>var() scale MainScale;<br>var() scale PostScale;<br>var scale   TempScale;<br>var() color BrushColor;<br>var() int	PolyFlags;<br>var() bool  bColored;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">MainScale=(Scale=(X=1.000000,Y=1.000000,Z=1.000000))<br>PostScale=(Scale=(X=1.000000,Y=1.000000,Z=1.000000))<br>TempScale=(Scale=(X=1.000000,Y=1.000000,Z=1.000000))<br>bStatic=True<br>bNoDelete=True<br>bEdShouldSnap=True<br>DrawType=DT_Brush<br>bFixedRotationDir=True</div>
<br><br><hr>
<a class="headerlink" href="#ButtonMarker.uc" title="Permanent link"><h2 id="ButtonMarker.uc">ButtonMarker.uc (extends NavigationPoint)</h2></a>

<br><br><hr>
<a class="headerlink" href="#Camera.uc" title="Permanent link"><h2 id="Camera.uc">Camera.uc (extends PlayerPawn)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Location=(X=-500.000000,Y=-300.000000,Z=300.000000)<br>Texture=Texture'Engine.S_Camera'<br>CollisionRadius=16.000000<br>CollisionHeight=39.000000<br>LightBrightness=100<br>LightRadius=16</div>
<br><br><hr>
<a class="headerlink" href="#CameraPoint.uc" title="Permanent link"><h2 id="CameraPoint.uc">CameraPoint.uc (extends Keypoint)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() ECameraCommand	cmd;			// what command to execute<br>var() float				value;			// parameter for command<br>var() name				eventName;		// used by CAMCMD_WAIT_EVENT<br>var() float				timeSmooth;		// execute command smoothly over time (0 = instant)<br>var() float				timeWaitPost;	// delay after executing command<br>var() bool				bParallel;		// execute the next command simultaneously<br>var() bool				bRandom;		// the next point is chosen at random from other bRandoms<br>var() int				randomCount;	// number of times to choose randomly<br>var() int				postRandomNum;	// sequence to start at after random sequence<br>var() const int			sequenceNum;	// assigned in editor automatically<br>var CameraPoint			nextPoint;		// next point to be executed - points linked at runtime<br>var CameraPoint			prevPoint;		// point that was just executed - used by bParallel<br>var float				curTime;		// timer used by movement routines<br>var vector				startLoc;		// init location at beginning of command<br>var rotator				startRot;		// init rotation at beginning of command<br>var float				startFOV;		// init FOV at beginning of command<br>var vector				endLoc;			// dest location<br>var rotator				endRot;			// dest rotation<br>var float				endFOV;			// dest FOV<br>var PlayerPawn			Player;			// which player is being controlled<br>var bool				bTickReady;		// can we tick now?<br>var bool				bFirstRandom;	// are we the first random point in this sequence?<br>var int					randomRemain;	// how many random choices are left?<br>var CameraPoint			continuePoint;	// where we continue after a random sequence</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">randomRemain=-1<br>bStatic=False<br>bDirectional=True<br>Texture=Texture'Engine.S_Camera'</div>
<h3 id="CameraPoint.EvaluateCommand"><a class="headerlink" href="#CameraPoint.EvaluateCommand" title="Permanent link">EvaluateCommand</a> -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector loc;<br>&#9;local Actor A;<br><br><br>&#9;loc = vect(0,0,0);<br><br>&#9;// init the movement timer<br>&#9;curTime = 0.0;<br><br>//&#9;log("** CameraPoint.EvaluateCommand - "$sequenceNum$" - cmd = "$cmd$" value = "$value$" eventName = "$eventName);<br><br>&#9;switch (cmd)<br>&#9;{<br>&#9;&#9;case CAMCMD_MOVE:&#9;&#9;endLoc = Location;<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;endRot = Rotation;<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;<br><br>&#9;&#9;case CAMCMD_PUSH:&#9;&#9;loc.X = value;<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;endLoc += (loc >> Player.ViewRotation);<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;<br><br>&#9;&#9;case CAMCMD_FOV:&#9;&#9;endFOV += value;<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;<br><br>&#9;&#9;case CAMCMD_TILT:&#9;&#9;endRot.Pitch += value;<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;<br><br>&#9;&#9;case CAMCMD_PAN:&#9;&#9;endRot.Yaw += value;<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;<br><br>&#9;&#9;case CAMCMD_ROLL:&#9;&#9;endRot.Roll += value;<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;<br><br>&#9;&#9;case CAMCMD_WAIT:&#9;&#9;if (eventName != '')<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Tag = eventName;<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;GoToSleep();<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;SetTimer(timeSmooth, False);<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;<br><br>&#9;&#9;case CAMCMD_TRIGGER:&#9;if (eventName != '')<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;foreach AllActors(class'Actor', A, eventName)<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;A.Trigger(None, None);<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;<br>&#9;}<br><br>&#9;// if we are running in parallel with the previous point,<br>&#9;// add its parameters to ours<br>&#9;if (prevPoint != None)<br>&#9;{<br>&#9;&#9;endLoc += prevPoint.endLoc - prevPoint.startLoc;<br>&#9;&#9;endRot += prevPoint.endRot - prevPoint.startRot;<br>&#9;&#9;endFOV += prevPoint.endFOV - prevPoint.startFOV;<br>&#9;}<br><br></div>
<h3 id="CameraPoint.GoToSleep"><a class="headerlink" href="#CameraPoint.GoToSleep" title="Permanent link">GoToSleep</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (IsInState('Running'))<br>&#9;&#9;GotoState('Idle', 'Wait');<br>&#9;else<br>&#9;&#9;log("** WARNING - CameraPoint.GoToSleep() - "$sequenceNum$" - already sleeping!");<br><br></div>
<h3 id="CameraPoint.InitAllPoints"><a class="headerlink" href="#CameraPoint.InitAllPoints" title="Permanent link">InitAllPoints</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local CameraPoint cur, next;<br>&#9;local int num;<br>&#9;local rotator rot;<br><br><br>&#9;cur = Self;<br>&#9;num = 0;<br>&#9;while (num != 999999)<br>&#9;{<br>&#9;&#9;num = 999999;<br>&#9;&#9;foreach AllActors(class'CameraPoint', next)<br>&#9;&#9;{<br>&#9;&#9;&#9;// clamp the rotation<br>&#9;&#9;&#9;rot.Pitch = Rotation.Pitch % 65536;<br>&#9;&#9;&#9;rot.Yaw = Rotation.Yaw % 65536;<br>&#9;&#9;&#9;rot.Roll = Rotation.Roll % 65536;<br>&#9;&#9;&#9;SetRotation(rot);<br><br>&#9;&#9;&#9;// find the next highest number in the sequence<br>&#9;&#9;&#9;if ((next.sequenceNum < num) && (next.sequenceNum > cur.sequenceNum))<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;num = next.sequenceNum;<br>&#9;&#9;&#9;&#9;cur.nextPoint = next;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br><br>&#9;&#9;if (num != 999999)<br>&#9;&#9;{<br>//&#9;&#9;&#9;log("** CameraPoint.InitAllPoints - linked "$cur.sequenceNum$" to "$num);<br>&#9;&#9;&#9;cur = cur.nextPoint;<br>&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="CameraPoint.Next"><a class="headerlink" href="#CameraPoint.Next" title="Permanent link">Next</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;GotoState('Running', 'Next');<br><br></div>
<h3 id="CameraPoint.SetContinuePoint"><a class="headerlink" href="#CameraPoint.SetContinuePoint" title="Permanent link">SetContinuePoint</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local CameraPoint point;<br><br>&#9;<br>&#9;foreach AllActors(class'CameraPoint', point)<br>&#9;&#9;if (point.sequenceNum == postRandomNum)<br>&#9;&#9;{<br>&#9;&#9;&#9;continuePoint = point;<br>&#9;&#9;&#9;break;<br>&#9;&#9;}<br><br></div>
<h3 id="CameraPoint.Tick"><a class="headerlink" href="#CameraPoint.Tick" title="Permanent link">Tick</a> (float deltaTime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float alpha, beta;<br>&#9;local vector loc;<br>&#9;local rotator rot, diffrot;<br>&#9;local float fov;<br><br><br>&#9;&#9;if (!bTickReady)<br>&#9;&#9;&#9;return;<br><br>&#9;&#9;Super.Tick(deltaTime);<br><br>&#9;&#9;// update the timer and see if we're done<br>&#9;&#9;curTime += deltaTime;<br><br>&#9;&#9;if (curTime >= timeSmooth)<br>&#9;&#9;{<br>&#9;&#9;&#9;Player.ViewRotation = endRot;<br>&#9;&#9;&#9;Player.SetLocation(endLoc);<br>&#9;&#9;&#9;Player.SetFOVAngle(endFOV);<br>&#9;&#9;&#9;Player.DesiredFOV = endFOV;<br>&#9;&#9;&#9;Next();<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;alpha = curTime / timeSmooth;<br><br>&#9;&#9;&#9;// make sure we rotate the shortest direction<br>&#9;&#9;&#9;diffrot = endRot - startRot;<br><br>&#9;&#9;&#9;if (diffrot.Pitch >= 32768)<br>&#9;&#9;&#9;&#9;diffrot.Pitch = diffrot.Pitch - 65536;<br>&#9;&#9;&#9;else if (diffrot.Pitch <= -32768)<br>&#9;&#9;&#9;&#9;diffrot.Pitch = diffrot.Pitch + 65536;<br><br>&#9;&#9;&#9;if (diffrot.Yaw >= 32768)<br>&#9;&#9;&#9;&#9;diffrot.Yaw = diffrot.Yaw - 65536;<br>&#9;&#9;&#9;else if (diffrot.Yaw <= -32768)<br>&#9;&#9;&#9;&#9;diffrot.Yaw = diffrot.Yaw + 65536;<br><br>&#9;&#9;&#9;if (diffrot.Roll >= 32768)<br>&#9;&#9;&#9;&#9;diffrot.Roll = diffrot.Roll - 65536;<br>&#9;&#9;&#9;else if (diffrot.Roll <= -32768)<br>&#9;&#9;&#9;&#9;diffrot.Roll = diffrot.Roll + 65536;<br><br>&#9;&#9;&#9;// calculate our smoothing coefficient<br>&#9;&#9;&#9;beta = 3.0*alpha*alpha - 2.0*alpha*alpha*alpha;<br><br>&#9;&#9;&#9;// smooth the camera rotation, movement, and FOV<br>&#9;&#9;&#9;rot = startRot + beta * diffrot;<br>&#9;&#9;&#9;loc = startLoc + beta * (endLoc - startLoc);<br>&#9;&#9;&#9;fov = startFOV + beta * (endFOV - startFOV);<br><br>&#9;&#9;&#9;Player.SetLocation(loc);<br>&#9;&#9;&#9;Player.ViewRotation = rot;<br>&#9;&#9;&#9;Player.SetFOVAngle(fov);<br>&#9;&#9;&#9;Player.DesiredFOV = fov;<br>&#9;&#9;}<br>&#9;<br></div>
<h3 id="CameraPoint.Timer"><a class="headerlink" href="#CameraPoint.Timer" title="Permanent link">Timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Next();<br><br></div>
<h3 id="CameraPoint.Trigger"><a class="headerlink" href="#CameraPoint.Trigger" title="Permanent link">Trigger</a> (Actor Other, Pawn Instigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;Super.Trigger(Other, Instigator);<br>&#9;&#9;Tag = '';<br>&#9;&#9;Next();<br>&#9;<br></div>
<h3 id="CameraPoint.WakeUp"><a class="headerlink" href="#CameraPoint.WakeUp" title="Permanent link">WakeUp</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;GotoState('Running', 'Begin');<br><br></div>
<h3 id="CameraPoint.WakeUpRandomPoint"><a class="headerlink" href="#CameraPoint.WakeUpRandomPoint" title="Permanent link">WakeUpRandomPoint</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local CameraPoint point;<br>&#9;local int count, rnd;<br><br><br>&#9;// count how many there are<br>&#9;count = 0;<br>&#9;foreach AllActors(class'CameraPoint', point)<br>&#9;&#9;if (point.bRandom)<br>&#9;&#9;&#9;count++;<br><br>&#9;// pick one at random<br>&#9;rnd = Rand(count);<br>&#9;count = 0;<br>&#9;foreach AllActors(class'CameraPoint', point)<br>&#9;&#9;if (point.bRandom && (count++ == rnd))<br>&#9;&#9;{<br>&#9;&#9;&#9;point.randomRemain = randomRemain - 1;<br>&#9;&#9;&#9;point.continuePoint = continuePoint;<br>&#9;&#9;&#9;point.WakeUp();<br>&#9;&#9;&#9;break;<br>&#9;&#9;}<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Canvas.uc" title="Permanent link"><h2 id="Canvas.uc">Canvas.uc (extends Object)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var font    Font;            // Font for DrawText.<br>var float   SpaceX, SpaceY;  // Spacing for after Draw*.<br>var float   OrgX, OrgY;      // Origin for drawing.<br>var float   ClipX, ClipY;    // Bottom right clipping region.<br>var float   CurX, CurY;      // Current position for drawing.<br>var float   Z;               // Z location. 1=no screenflash, 2=yes screenflash.<br>var byte    Style;           // Drawing style STY_None means don't draw.<br>var float   CurYL;           // Largest Y size since DrawText.<br>var color   DrawColor;       // Color for drawing.<br>var bool    bCenter;         // Whether to center the text.<br>var bool    bNoSmooth;       // Don't bilinear filter.<br>var const int SizeX, SizeY;  // Zero-based actual dimensions.<br>var font SmallFont;          // Small system font.<br>var font MedFont;            // Medium system font.<br>var font BigFont;            // Big system font.<br>var font LargeFont;          // Large system font.<br>var const viewport Viewport; // Viewport that owns the canvas.<br>var const int FramePtr;      // Scene frame pointer.<br>var const int RenderPtr;	 // Render device pointer, only valid during UGameEngine::Draw</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Z=1.000000<br>Style=1<br>DrawColor=(R=127,G=127,B=127)<br>SmallFont=Font'Engine.SmallFont'<br>MedFont=Font'Engine.MedFont'<br>BigFont=Font'Engine.BigFont'<br>LargeFont=Font'Engine.LargeFont'</div>
<h3 id="Canvas.DrawActor"><a class="headerlink" href="#Canvas.DrawActor" title="Permanent link">DrawActor</a> (Actor A, bool WireFrame, optional bool ClearZ) | native</h3>

<h3 id="Canvas.DrawClippedActor"><a class="headerlink" href="#Canvas.DrawClippedActor" title="Permanent link">DrawClippedActor</a> (Actor A, bool WireFrame, int X, int Y, int XB, int YB, optional bool ClearZ) | native</h3>

<h3 id="Canvas.DrawIcon"><a class="headerlink" href="#Canvas.DrawIcon" title="Permanent link">DrawIcon</a> (texture Tex, float Scale)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Tex != None )<br>&#9;&#9;DrawTile( Tex, Tex.USize*Scale, Tex.VSize*Scale, 0, 0, Tex.USize, Tex.VSize );<br><br></div>
<h3 id="Canvas.DrawPattern"><a class="headerlink" href="#Canvas.DrawPattern" title="Permanent link">DrawPattern</a> (texture Tex, float XL, float YL, float Scale)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;DrawTile( Tex, XL, YL, (CurX-OrgX)*Scale, (CurY-OrgY)*Scale, XL*Scale, YL*Scale );<br><br></div>
<h3 id="Canvas.DrawPortal"><a class="headerlink" href="#Canvas.DrawPortal" title="Permanent link">DrawPortal</a> (int X, int Y, int Width, int Height, actor CamActor, vector CamLocation, rotator CamRotation, optional int FOV, optional bool ClearZ) | native</h3>

<h3 id="Canvas.DrawRect"><a class="headerlink" href="#Canvas.DrawRect" title="Permanent link">DrawRect</a> (texture Tex, float RectX, float RectY)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;DrawTile( Tex, RectX, RectY, 0, 0, Tex.USize, Tex.VSize );<br><br></div>
<h3 id="Canvas.DrawText"><a class="headerlink" href="#Canvas.DrawText" title="Permanent link">DrawText</a> (coerce string Text, optional bool CR) | native</h3>

<h3 id="Canvas.DrawTextClipped"><a class="headerlink" href="#Canvas.DrawTextClipped" title="Permanent link">DrawTextClipped</a> (coerce string Text, optional bool bCheckHotKey) | native</h3>

<h3 id="Canvas.DrawTile"><a class="headerlink" href="#Canvas.DrawTile" title="Permanent link">DrawTile</a> (texture Tex, float XL, float YL, float U, float V, float UL, float VL) | native</h3>

<h3 id="Canvas.DrawTileClipped"><a class="headerlink" href="#Canvas.DrawTileClipped" title="Permanent link">DrawTileClipped</a> (texture Tex, float XL, float YL, float U, float V, float UL, float VL) | native</h3>

<h3 id="Canvas.Reset"><a class="headerlink" href="#Canvas.Reset" title="Permanent link">Reset</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Font        = Default.Font;<br>&#9;SpaceX      = Default.SpaceX;<br>&#9;SpaceY      = Default.SpaceY;<br>&#9;OrgX        = Default.OrgX;<br>&#9;OrgY        = Default.OrgY;<br>&#9;CurX        = Default.CurX;<br>&#9;CurY        = Default.CurY;<br>&#9;Style       = Default.Style;<br>&#9;DrawColor   = Default.DrawColor;<br>&#9;CurYL       = Default.CurYL;<br>&#9;bCenter     = false;<br>&#9;bNoSmooth   = false;<br>&#9;Z           = 1.0;<br><br></div>
<h3 id="Canvas.SetClip"><a class="headerlink" href="#Canvas.SetClip" title="Permanent link">SetClip</a> (float X, float Y)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ClipX = X;<br>&#9;ClipY = Y;<br><br></div>
<h3 id="Canvas.SetOrigin"><a class="headerlink" href="#Canvas.SetOrigin" title="Permanent link">SetOrigin</a> (float X, float Y)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;OrgX = X;<br>&#9;OrgY = Y;<br><br></div>
<h3 id="Canvas.SetPos"><a class="headerlink" href="#Canvas.SetPos" title="Permanent link">SetPos</a> (float X, float Y)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;CurX = X;<br>&#9;CurY = Y;<br><br></div>
<h3 id="Canvas.StrLen"><a class="headerlink" href="#Canvas.StrLen" title="Permanent link">StrLen</a> (coerce string String, out float XL, out float YL) | native</h3>

<h3 id="Canvas.TextSize"><a class="headerlink" href="#Canvas.TextSize" title="Permanent link">TextSize</a> (coerce string String, out float XL, out float YL) | native</h3>

<br><br><hr>
<a class="headerlink" href="#Carcass.uc" title="Permanent link"><h2 id="Carcass.uc">Carcass.uc (extends Decoration)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var bool bPlayerCarcass;<br>var() byte flies;<br>var() byte rats;<br>var() bool bReducedHeight;<br>var bool bDecorative;<br>var bool bSlidingCarcass;<br>var int CumulativeDamage;<br>var PlayerReplicationInfo PlayerOwner;<br>var Pawn Bugs;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bDecorative=True<br>bStatic=False<br>bStasis=False<br>Physics=PHYS_Falling<br>LifeSpan=180.000000<br>AnimSequence=Dead<br>AnimFrame=0.900000<br>DrawType=DT_Mesh<br>Texture=Texture'Engine.S_Corpse'<br>CollisionRadius=18.000000<br>CollisionHeight=4.000000<br>bCollideActors=True<br>bCollideWorld=True<br>bProjTarget=True<br>Mass=180.000000<br>Buoyancy=105.000000</div>
<h3 id="Carcass.AddFliesAndRats"><a class="headerlink" href="#Carcass.AddFliesAndRats" title="Permanent link">AddFliesAndRats</a></h3>

<h3 id="Carcass.AllowChunk"><a class="headerlink" href="#Carcass.AllowChunk" title="Permanent link">AllowChunk</a> (int N, name A) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;return true;<br>&#9;<br></div>
<h3 id="Carcass.BeginState"><a class="headerlink" href="#Carcass.BeginState" title="Permanent link">BeginState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( bDecorative )<br>&#9;&#9;&#9;lifespan = 0.0;<br>&#9;&#9;else<br>&#9;&#9;&#9;SetTimer(18.0, false);<br>&#9;<br></div>
<h3 id="Carcass.CheckZoneCarcasses"><a class="headerlink" href="#Carcass.CheckZoneCarcasses" title="Permanent link">CheckZoneCarcasses</a></h3>

<h3 id="Carcass.ChunkUp"><a class="headerlink" href="#Carcass.ChunkUp" title="Permanent link">ChunkUp</a> (int Damage)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;destroy();<br>&#9;<br></div>
<h3 id="Carcass.CreateReplacement"><a class="headerlink" href="#Carcass.CreateReplacement" title="Permanent link">CreateReplacement</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if (Bugs != None)<br>&#9;&#9;&#9;Bugs.Destroy();<br>&#9;<br></div>
<h3 id="Carcass.Destroyed"><a class="headerlink" href="#Carcass.Destroyed" title="Permanent link">Destroyed</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Actor A;<br><br><br>&#9;&#9;if (Bugs != None)<br>&#9;&#9;&#9;Bugs.Destroy();<br>&#9;&#9;&#9;&#9;<br>&#9;&#9;Super.Destroyed();<br>&#9;<br></div>
<h3 id="Carcass.Initfor"><a class="headerlink" href="#Carcass.Initfor" title="Permanent link">Initfor</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;//implemented in subclasses<br>&#9;<br></div>
<h3 id="Carcass.Timer"><a class="headerlink" href="#Carcass.Timer" title="Permanent link">Timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local bool bSeen;<br>&#9;local Pawn aPawn;<br>&#9;local float dist;<br><br><br>&#9;&#9;if ( Region.Zone.NumCarcasses <= Region.Zone.MaxCarcasses )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( !PlayerCanSeeMe() )<br>&#9;&#9;&#9;&#9;Destroy();<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;SetTimer(2.0, false);&#9;<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;&#9;Destroy();<br>&#9;<br></div>
<br><br><hr>
<a class="headerlink" href="#Console.uc" title="Permanent link"><h2 id="Console.uc">Console.uc (extends Object)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var private const int vtblOut;<br>var viewport Viewport;<br>var int HistoryTop, HistoryBot, HistoryCur;<br>var string TypedStr, History[16];<br>var int Scrollback, NumLines, TopLine, TextLines;<br>var float MsgTime, MsgTickTime;<br>var string MsgText[64];<br>var name MsgType[64];<br>var PlayerReplicationInfo MsgPlayer[64];<br>var float MsgTick[64];<br>var int BorderSize;<br>var int ConsoleLines, BorderLines, BorderPixels;<br>var float ConsolePos, ConsoleDest;<br>var float FrameX, FrameY;<br>var texture ConBackground, Border;<br>var bool bNoStuff, bTyping;<br>var bool bNoDrawWorld;<br>var bool bTimeDemo;<br>var bool bStartTimeDemo;<br>var bool bRestartTimeDemo;<br>var bool bSaveTimeDemoToFile;<br>var float StartTime;<br>var float ExtraTime;<br>var float LastFrameTime;<br>var float LastSecondStartTime;<br>var int FrameCount;<br>var int LastSecondFrameCount;<br>var float MinFPS;<br>var float MaxFPS;<br>var float LastSecFPS;<br>var Font TimeDemoFont;<br>var localized string LoadingMessage;<br>var localized string SavingMessage;<br>var localized string ConnectingMessage;<br>var localized string PausedMessage;<br>var localized string PrecachingMessage;<br>var localized string FrameRateText;<br>var localized string AvgText;<br>var localized string LastSecText;<br>var localized string MinText;<br>var localized string MaxText;<br>var localized string fpsText;<br>var localized string SecondsText;<br>var localized string FramesText;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">ConBackground=Texture'Engine.ConsoleBack'<br>Border=Texture'Engine.Border'<br>TimeDemoFont=Font'Engine.SmallFont'<br>LoadingMessage="LOADING"<br>SavingMessage="SAVING"<br>ConnectingMessage="CONNECTING"<br>PausedMessage="PAUSED"<br>PrecachingMessage="PRECACHING"<br>FrameRateText="Frame Rate"<br>AvgText="Avg"<br>LastSecText="Last Sec"<br>MinText="Min"<br>MaxText="Max"<br>fpsText="fps"<br>SecondsText="seconds."<br>FramesText="frames rendered in"</div>
<h3 id="Console.AddString"><a class="headerlink" href="#Console.AddString" title="Permanent link">AddString</a> (coerce string Msg)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Msg!="" )<br>&#9;{<br>&#9;&#9;TopLine&#9;&#9;     = (TopLine+1) % MaxLines;<br>&#9;&#9;NumLines&#9;     = Min(NumLines+1,MaxLines-1);<br>&#9;&#9;MsgType[TopLine] = 'Event';<br>&#9;&#9;MsgTime&#9;&#9;     = 6.0;<br>&#9;&#9;TextLines++;<br>&#9;&#9;MsgText[TopLine] = Msg;<br>&#9;&#9;MsgPlayer[TopLine] = None;<br>&#9;&#9;MsgTick[TopLine] = MsgTickTime + MsgTime;<br>&#9;}<br><br></div>
<h3 id="Console.BeginState"><a class="headerlink" href="#Console.BeginState" title="Permanent link">BeginState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;//log( "Console entering KeyMenuing" );<br>&#9;<br></div>
<h3 id="Console.ClearMessages"><a class="headerlink" href="#Console.ClearMessages" title="Permanent link">ClearMessages</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br><br><br>&#9;for (i=0; i<MaxLines; i++)<br>&#9;{<br>&#9;&#9;MsgText[i] = "";<br>&#9;&#9;MsgType[i] = '';<br>&#9;&#9;MsgPlayer[i] = None;<br>&#9;&#9;MsgTick[i] = 0.0;<br>&#9;}<br>&#9;MsgTime = 0.0;<br><br></div>
<h3 id="Console.ConnectFailure"><a class="headerlink" href="#Console.ConnectFailure" title="Permanent link">ConnectFailure</a> (string FailCode, string URL)</h3>

<h3 id="Console.ConsoleCommand"><a class="headerlink" href="#Console.ConsoleCommand" title="Permanent link">ConsoleCommand</a> (coerce string S) -> bool | native</h3>

<h3 id="Console.DrawConsoleView"><a class="headerlink" href="#Console.DrawConsoleView" title="Permanent link">DrawConsoleView</a> (Canvas C)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int Y, I, Line;<br>&#9;local float XL, YL;<br><br><br>&#9;// Console is visible; display console view.<br>&#9;Y = ConsoleLines - 1;<br>&#9;MsgText[(TopLine + 1 + MaxLines) % MaxLines] = "(>"@TypedStr;<br>&#9;for ( I = Scrollback; I < (NumLines + 1); I++ )<br>&#9;{<br>&#9;&#9;// Display all text in the buffer.<br>&#9;&#9;Line = (TopLine + MaxLines*2 - (I-1)) % MaxLines;<br>&#9;&#9;<br>&#9;&#9;C.DrawColor.R = 255;<br>&#9;&#9;C.DrawColor.G = 255;<br>&#9;&#9;C.DrawColor.B = 255;<br>&#9;&#9;C.Font = C.MedFont;<br><br>&#9;&#9;if (( MsgType[Line] == 'Say' ) || ( MsgType[Line] == 'TeamSay' ))<br>&#9;&#9;&#9;C.StrLen( MsgPlayer[Line].PlayerName$":"@MsgText[Line], XL, YL );&#9;&#9;&#9;&#9;<br>&#9;&#9;else<br>&#9;&#9;&#9;C.StrLen( MsgText[Line], XL, YL );<br>&#9;&#9;<br>&#9;&#9;// Half-space blank lines.<br>&#9;&#9;if ( YL == 0 )<br>&#9;&#9;&#9;YL = 5;<br>&#9;&#9;&#9;<br>&#9;&#9;Y -= YL;<br>&#9;&#9;if ( (Y + YL) < 0 )<br>&#9;&#9;&#9;break;<br>&#9;&#9;C.SetPos(4, Y);<br>&#9;&#9;C.Font = C.MedFont;<br><br>&#9;&#9;if (( MsgType[Line] == 'Say' ) || ( MsgType[Line] == 'TeamSay' ))<br>&#9;&#9;&#9;C.DrawText( MsgPlayer[Line].PlayerName$":"@MsgText[Line], false );<br>&#9;&#9;else<br>&#9;&#9;&#9;C.DrawText( MsgText[Line], false );<br>&#9;}&#9;&#9;&#9;&#9;<br><br></div>
<h3 id="Console.DrawLevelAction"><a class="headerlink" href="#Console.DrawLevelAction" title="Permanent link">DrawLevelAction</a> (canvas C)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string BigMessage;<br><br><br>&#9;// DEUS_EX AJY - don't want to print any text <br>&#9;// if the game is paused because we're in a menu<br>&#9;if (Viewport.Actor.bShowMenu )<br>&#9;{<br>&#9;&#9;BigMessage = "";<br>&#9;&#9;return;<br>&#9;}<br>&#9;if ( (Viewport.Actor.Level.Pauser != "") && (Viewport.Actor.Level.LevelAction == LEVACT_None) )<br>&#9;{<br>&#9;&#9;C.Font = C.BigFont;<br>&#9;&#9;C.Style = 1;<br>&#9;&#9;C.DrawColor.R = 255;<br>&#9;&#9;C.DrawColor.G = 255;<br>&#9;&#9;C.DrawColor.B = 255;<br><br>&#9;&#9;BigMessage = PausedMessage; // Add pauser name?<br>&#9;&#9;PrintActionMessage(C, BigMessage);<br>&#9;&#9;return;<br>&#9;}<br>&#9;else if ( Viewport.Actor.Level.LevelAction == LEVACT_Loading )<br>&#9;&#9;BigMessage = LoadingMessage;<br>&#9;else if ( Viewport.Actor.Level.LevelAction == LEVACT_Saving )<br>&#9;&#9;BigMessage = SavingMessage;<br>&#9;else if ( Viewport.Actor.Level.LevelAction == LEVACT_Connecting )<br>&#9;&#9;BigMessage = ConnectingMessage;<br>&#9;else if ( Viewport.Actor.Level.LevelAction == LEVACT_Precaching )<br>&#9;&#9;BigMessage = PrecachingMessage;<br>&#9;<br>&#9;if ( BigMessage != "" )<br>&#9;{<br>&#9;&#9;C.Style = 3;<br>&#9;&#9;C.DrawColor.R = 0;<br>&#9;&#9;C.DrawColor.G = 0;<br>&#9;&#9;C.DrawColor.B = 255;<br>&#9;&#9;C.Font = C.LargeFont;&#9;<br>&#9;&#9;PrintActionMessage(C, BigMessage);<br>&#9;}<br><br></div>
<h3 id="Console.DrawSingleView"><a class="headerlink" href="#Console.DrawSingleView" title="Permanent link">DrawSingleView</a> (Canvas C)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string TypingPrompt;<br>&#9;local int I, J;<br>&#9;local float XL, YL;<br>&#9;local string ShortMessages[4];<br>&#9;local int ExtraSpace;<br><br><br><br>&#9;// Console is hidden; display single-line view.<br><br>&#9;C.SetOrigin(0.0, 0.0);<br><br>&#9;// Ask the HUD to deal with messages.<br>&#9;if ( Viewport.Actor.myHUD != None <br>&#9;&#9;&& Viewport.Actor.myHUD.DisplayMessages(C) )<br>&#9;&#9;return;<br><br>&#9;C.DrawColor.R = 255;<br>&#9;C.DrawColor.G = 255;<br>&#9;C.DrawColor.B = 255;<br><br>&#9;// If the HUD doesn't deal with messages, use the default behavior<br>&#9;if (!Viewport.Actor.bShowMenu)<br>&#9;{<br>&#9;&#9;if ( bTyping )<br>&#9;&#9;{&#9;&#9;&#9;<br>&#9;&#9;&#9;TypingPrompt = "(>"@TypedStr$"_";<br>&#9;&#9;&#9;C.Font = C.MedFont;<br>&#9;&#9;&#9;C.StrLen( TypingPrompt, XL, YL );<br>&#9;&#9;&#9;C.SetPos( 2, FrameY - ConsoleLines - YL - 1 );<br>&#9;&#9;&#9;C.DrawText( TypingPrompt, false );<br>&#9;&#9;}<br>&#9;}<br>&#9;&#9;<br>&#9;if ( TextLines > 0 && (!Viewport.Actor.bShowMenu || Viewport.Actor.bShowScores) )<br>&#9;{<br>&#9;&#9;J = TopLine;<br>&#9;&#9;I = 0;<br>&#9;&#9;while ((I < 4) && (J >= 0))<br>&#9;&#9;{<br>&#9;&#9;&#9;if ((MsgText[J] != "") && (MsgTick[J] > 0.0) && (MsgTick[J] > MsgTickTime) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if (MsgType[J] == 'Say') <br>&#9;&#9;&#9;&#9;&#9;ShortMessages[I] = MsgPlayer[J].PlayerName$":"@MsgText[J];<br>&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;&#9;ShortMessages[I] = MsgText[J];<br>&#9;&#9;&#9;&#9;I++;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;J--;<br>&#9;&#9;}<br><br>&#9;&#9;J = 0;<br>&#9;&#9;C.Font = C.MedFont;<br>&#9;&#9;for ( I = 0; I < 4; I++ )<br>&#9;&#9;{<br>&#9;&#9;&#9;if (ShortMessages[3 - I] != "")<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;C.SetPos(4, 2 + (10 * J) + (10 * ExtraSpace));<br>&#9;&#9;&#9;&#9;C.StrLen( ShortMessages[3 - I], XL, YL );<br>&#9;&#9;&#9;&#9;C.DrawText( ShortMessages[3 - I], false );<br>&#9;&#9;&#9;&#9;if ( YL == 18.0 )<br>&#9;&#9;&#9;&#9;&#9;ExtraSpace++;<br>&#9;&#9;&#9;&#9;J++;<br>&#9;&#9;&#9;}<br>&#9;&#9;}&#9;&#9;<br>&#9;}<br><br></div>
<h3 id="Console.EndState"><a class="headerlink" href="#Console.EndState" title="Permanent link">EndState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;//log( "Console leaving KeyMenuing" );<br>&#9;<br></div>
<h3 id="Console.FormatFloat"><a class="headerlink" href="#Console.FormatFloat" title="Permanent link">FormatFloat</a> (float f) -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string s;<br>&#9;local int i;<br><br>&#9;s = string(f);<br>&#9;i = InStr(s, ".");<br>&#9;if(i != -1)<br>&#9;&#9;s = Left(s, i+3);<br>&#9;return s;<br><br></div>
<h3 id="Console.GetMsgPlayer"><a class="headerlink" href="#Console.GetMsgPlayer" title="Permanent link">GetMsgPlayer</a> (int Index) -> PlayerReplicationInfo</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return MsgPlayer[Index];<br><br></div>
<h3 id="Console.GetMsgText"><a class="headerlink" href="#Console.GetMsgText" title="Permanent link">GetMsgText</a> (int Index) -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return MsgText[Index];<br><br></div>
<h3 id="Console.GetMsgTick"><a class="headerlink" href="#Console.GetMsgTick" title="Permanent link">GetMsgTick</a> (int Index) -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return MsgTick[Index];<br><br></div>
<h3 id="Console.GetMsgType"><a class="headerlink" href="#Console.GetMsgType" title="Permanent link">GetMsgType</a> (int Index) -> name</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return MsgType[Index];<br><br></div>
<h3 id="Console.KeyEvent"><a class="headerlink" href="#Console.KeyEvent" title="Permanent link">KeyEvent</a> (EInputKey Key, EInputAction Action, FLOAT Delta) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if( Action==IST_Press )<br>&#9;&#9;{<br>&#9;&#9;&#9;ConsoleDest=0.0;<br>&#9;&#9;&#9;if( Viewport.Actor.myHUD!=None && Viewport.Actor.myHUD.MainMenu!=None )<br>&#9;&#9;&#9;&#9;Viewport.Actor.myHUD.MainMenu.ProcessMenuKey( Key, mid(string(GetEnum(enum'EInputKey',Key)),3) );<br>&#9;&#9;&#9;Scrollback=0;<br>&#9;&#9;&#9;GotoState( 'Menuing' );<br>&#9;&#9;&#9;return true;<br>&#9;&#9;}<br>&#9;<br></div>
<h3 id="Console.KeyType"><a class="headerlink" href="#Console.KeyType" title="Permanent link">KeyType</a> (EInputKey Key) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;ConsoleDest=0.0;<br>&#9;&#9;if( Viewport.Actor.myHUD!=None && Viewport.Actor.myHUD.MainMenu!=None )<br>&#9;&#9;&#9;Viewport.Actor.myHUD.MainMenu.ProcessMenuKey( Key, Chr(Key) );<br>&#9;&#9;Scrollback=0;<br>&#9;&#9;GotoState( 'Menuing' );<br>&#9;<br></div>
<h3 id="Console.Message"><a class="headerlink" href="#Console.Message" title="Permanent link">Message</a> (PlayerReplicationInfo PRI, coerce string Msg, name N)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Msg!="" )<br>&#9;{<br>&#9;&#9;TopLine&#9;&#9;     = (TopLine+1) % MaxLines;<br>&#9;&#9;NumLines&#9;     = Min(NumLines+1,MaxLines-1);<br>&#9;&#9;MsgType[TopLine] = N;<br>&#9;&#9;MsgTime&#9;&#9;     = 6.0;<br>&#9;&#9;TextLines++;<br>&#9;&#9;MsgText[TopLine] = Msg;<br>&#9;&#9;MsgPlayer[TopLine] = PRI;<br>&#9;&#9;MsgTick[TopLine] = MsgTickTime + MsgTime;<br>&#9;}<br><br></div>
<h3 id="Console.NotifyLevelChange"><a class="headerlink" href="#Console.NotifyLevelChange" title="Permanent link">NotifyLevelChange</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bRestartTimeDemo = True;<br>&#9;ClearMessages();<br><br></div>
<h3 id="Console.PostRender"><a class="headerlink" href="#Console.PostRender" title="Permanent link">PostRender</a> (canvas C)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int YStart, YEnd, Y, I, J, Line, iLine;<br><br><br>&#9;if(bNoDrawWorld)<br>&#9;{<br>&#9;&#9;C.SetPos(0,0);<br>&#9;&#9;C.DrawPattern( Texture'Border', C.ClipX, C.ClipY, 1.0 );<br>&#9;}<br><br>&#9;if( bTimeDemo )<br>&#9;{<br>&#9;&#9;TimeDemoCalc();<br>&#9;&#9;TimeDemoRender( C );<br>&#9;}<br><br>&#9;// call overridable "level action" rendering code to draw the "big message"<br>&#9;DrawLevelAction( C );<br><br>&#9;// If the console has changed since the previous frame, draw it.<br>&#9;if ( ConsoleLines > 0 )<br>&#9;{<br>&#9;&#9;// DEUS_EX AJY<br>&#9;&#9;C.Style = 1;<br>&#9;&#9;C.DrawColor.R = 128;<br>&#9;&#9;C.DrawColor.G = 128;<br>&#9;&#9;C.DrawColor.B = 128;<br>&#9;&#9;C.SetPos(0.0, ConsoleLines - FrameY);<br>&#9;&#9;C.SetOrigin(0.0, 0.0);<br>&#9;&#9;C.DrawTile(ConBackground, FrameX, FrameY, 0.0, 0.0, FrameX, FrameY);<br><br>&#9;}<br><br>&#9;// Draw border.<br>&#9;if ( BorderLines > 0 || BorderPixels > 0 )<br>&#9;{<br>&#9;&#9;YStart &#9;= BorderLines + ConsoleLines;<br>&#9;&#9;YEnd &#9;= FrameY - BorderLines;<br>&#9;&#9;if ( BorderLines > 0 )<br>&#9;&#9;{<br>&#9;&#9;&#9;C.SetOrigin(0.0, 0.0);<br>&#9;&#9;&#9;C.SetPos(0.0, 0.0);<br>&#9;&#9;&#9;C.DrawPattern( Border, FrameX, BorderLines, 1.0 );<br>&#9;&#9;&#9;C.SetPos(0.0, YEnd);<br>&#9;&#9;&#9;C.DrawPattern( Border, FrameX, BorderLines, 1.0 );<br>&#9;&#9;}<br>&#9;&#9;if ( BorderPixels > 0 )<br>&#9;&#9;{<br>&#9;&#9;&#9;C.SetOrigin(0.0, 0.0);<br>&#9;&#9;&#9;C.SetPos(0.0, YStart);<br>&#9;&#9;&#9;C.DrawPattern( Border, BorderPixels, YEnd - YStart, 1.0 );<br>&#9;&#9;&#9;C.SetPos( FrameX - BorderPixels, YStart );<br>&#9;&#9;&#9;C.DrawPattern( Border, BorderPixels, YEnd - YStart, 1.0 );<br>&#9;&#9;}<br>&#9;}<br><br>&#9;// Draw console text.<br>&#9;C.SetOrigin(0.0, 0.0);<br>&#9;if ( ConsoleLines > 0 )<br>&#9;&#9;DrawConsoleView( C );<br>&#9;else<br>&#9;&#9;DrawSingleView( C );<br><br></div>
<h3 id="Console.PreRender"><a class="headerlink" href="#Console.PreRender" title="Permanent link">PreRender</a> (canvas C)</h3>

<h3 id="Console.PrintActionMessage"><a class="headerlink" href="#Console.PrintActionMessage" title="Permanent link">PrintActionMessage</a> (Canvas C, string BigMessage)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float XL, YL;<br><br><br>&#9;C.bCenter = false;<br>&#9;C.StrLen( BigMessage, XL, YL );<br>&#9;C.SetPos(FrameX/2 - XL/2, FrameY/2 - YL/2);<br>&#9;C.DrawText( BigMessage, false );<br><br></div>
<h3 id="Console.PrintTimeDemoResult"><a class="headerlink" href="#Console.PrintTimeDemoResult" title="Permanent link">PrintTimeDemoResult</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local LevelInfo Entry;<br>&#9;local float Avg;<br>&#9;local float Delta;<br>&#9;local string AvgString;<br>&#9;local string Temp;<br><br><br>&#9;Entry = Viewport.Actor.GetEntryLevel();<br><br>&#9;Delta = Entry.TimeSeconds - StartTime - ExtraTime;<br>&#9;if(Delta <= 0)<br>&#9;&#9;Avg = 0;<br>&#9;else<br>&#9;&#9;Avg = FrameCount / Delta;<br>&#9;<br>&#9;AvgString = string(FrameCount)@FramesText@FormatFloat(delta)@SecondsText@MinText@FormatFloat(MinFPS)@MaxText@FormatFloat(MaxFPS)@AvgText@FormatFloat(Avg)@fpsText$".";<br>&#9;Viewport.Actor.ClientMessage(AvgString);<br>&#9;Log(AvgString);<br>&#9;if(bSaveTimeDemoToFile)<br>&#9;{&#9;&#9;<br>&#9;&#9;Temp =<br>&#9;&#9;&#9;FormatFloat(Avg) $ " Unreal "$ Viewport.Actor.Level.EngineVersion $ Chr(13) $ Chr(10) $<br>&#9;&#9;&#9;FormatFloat(MinFPS) $ " Min"$ Chr(13) $ Chr(10) $<br>&#9;&#9;&#9;FormatFloat(MaxFPS) $ " Max"$ Chr(13) $ Chr(10);<br>&#9;&#9;&#9;<br>&#9;&#9;SaveTimeDemo(Temp);<br>&#9;}<br><br></div>
<h3 id="Console.SaveTimeDemo"><a class="headerlink" href="#Console.SaveTimeDemo" title="Permanent link">SaveTimeDemo</a> (string S) | native</h3>

<h3 id="Console.SetMsgPlayer"><a class="headerlink" href="#Console.SetMsgPlayer" title="Permanent link">SetMsgPlayer</a> (int Index, PlayerReplicationInfo NewMsgPlayer)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;MsgPlayer[Index] = NewMsgPlayer;<br><br></div>
<h3 id="Console.SetMsgText"><a class="headerlink" href="#Console.SetMsgText" title="Permanent link">SetMsgText</a> (int Index, string NewMsgText)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;MsgText[Index] = NewMsgText;<br><br></div>
<h3 id="Console.SetMsgTick"><a class="headerlink" href="#Console.SetMsgTick" title="Permanent link">SetMsgTick</a> (int Index, int NewMsgTick)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;MsgTick[Index] = NewMsgTick;<br><br></div>
<h3 id="Console.SetMsgType"><a class="headerlink" href="#Console.SetMsgType" title="Permanent link">SetMsgType</a> (int Index, name NewMsgType)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;MsgType[Index] = NewMsgType;<br><br></div>
<h3 id="Console.StartTimeDemo"><a class="headerlink" href="#Console.StartTimeDemo" title="Permanent link">StartTimeDemo</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if(bTimeDemo)<br>&#9;&#9;return;<br>&#9;bTimeDemo = True;<br>&#9;bStartTimeDemo = True;<br><br></div>
<h3 id="Console.StopTimeDemo"><a class="headerlink" href="#Console.StopTimeDemo" title="Permanent link">StopTimeDemo</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if(!bTimeDemo)<br>&#9;&#9;return;<br>&#9;bTimeDemo = False;<br>&#9;PrintTimeDemoResult();<br><br></div>
<h3 id="Console.Talk"><a class="headerlink" href="#Console.Talk" title="Permanent link">Talk</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TypedStr="Say ";<br>&#9;bNoStuff = true;<br>&#9;GotoState( 'Typing' );<br><br></div>
<h3 id="Console.TeamTalk"><a class="headerlink" href="#Console.TeamTalk" title="Permanent link">TeamTalk</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TypedStr="TeamSay ";<br>&#9;bNoStuff = true;<br>&#9;GotoState( 'Typing' );<br><br></div>
<h3 id="Console.Tick"><a class="headerlink" href="#Console.Tick" title="Permanent link">Tick</a> (float Delta)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int I;<br><br>&#9;MsgTickTime += Delta;<br><br>&#9;// Slide console up or down.<br>&#9;if( ConsolePos < ConsoleDest )<br>&#9;&#9;ConsolePos = FMin(ConsolePos+Delta,ConsoleDest);<br>&#9;else if( ConsolePos > ConsoleDest )<br>&#9;&#9;ConsolePos = FMax(ConsolePos-Delta,ConsoleDest);<br><br>&#9;// Update status message.<br>&#9;if( ((MsgTime-=Delta) <= 0.0) && (TextLines > 0) )<br>&#9;&#9;TextLines--;<br><br>   // Update progress messages.<br>   if (Viewport.Actor.ProgressTimeOut > Viewport.Actor.Level.TimeSeconds)<br>   {<br>      Viewport.Actor.ShowProgress();<br>   }<br><br></div>
<h3 id="Console.TimeDemo"><a class="headerlink" href="#Console.TimeDemo" title="Permanent link">TimeDemo</a> (bool bEnabled, optional bool bSaveToFile)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bSaveTimeDemoToFile = bSaveToFile;<br>&#9;if(bEnabled)<br>&#9;&#9;StartTimeDemo();<br>&#9;else<br>&#9;&#9;StopTimeDemo();<br><br></div>
<h3 id="Console.TimeDemoCalc"><a class="headerlink" href="#Console.TimeDemoCalc" title="Permanent link">TimeDemoCalc</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local LevelInfo Entry;<br>&#9;local float Delta;<br><br>&#9;Entry = Viewport.Actor.GetEntryLevel();<br><br>&#9;if( bRestartTimeDemo )<br>&#9;{<br>&#9;&#9;StopTimeDemo();<br>&#9;&#9;StartTimeDemo();<br>&#9;&#9;bRestartTimeDemo = False;<br>&#9;}<br><br>&#9;if(&#9;bStartTimeDemo )<br>&#9;{<br>&#9;&#9;bStartTimeDemo = False;<br>&#9;&#9;StartTime = Entry.TimeSeconds;<br>&#9;&#9;ExtraTime =  0;<br>&#9;&#9;LastFrameTime = StartTime;<br>&#9;&#9;LastSecondStartTime = StartTime;<br>&#9;&#9;FrameCount = 0;<br>&#9;&#9;LastSecondFrameCount = 0;<br>&#9;&#9;MinFPS = 0;<br>&#9;&#9;MaxFPS = 0;&#9;&#9;<br>&#9;&#9;LastSecFPS = 0;<br>&#9;&#9;return;<br>&#9;}<br><br>&#9;Delta = Entry.TimeSeconds - LastFrameTime;<br><br>&#9;// If delta time is more than a half of a second, ignore frame entirely (precaching, loading etc)<br>&#9;if( Delta > 0.5 )<br>&#9;{<br>&#9;&#9;ExtraTime += Delta;<br>&#9;&#9;LastSecondStartTime = Entry.TimeSeconds;<br>&#9;&#9;LastSecondFrameCount = 0;<br>&#9;&#9;LastFrameTime = Entry.TimeSeconds;<br>&#9;&#9;return;<br>&#9;}<br><br>&#9;FrameCount++;<br>&#9;LastSecondFrameCount++;<br><br>&#9;if( Entry.TimeSeconds - LastSecondStartTime > 1)<br>&#9;{<br>&#9;&#9;LastSecFPS = LastSecondFrameCount / (Entry.TimeSeconds - LastSecondStartTime);<br>&#9;&#9;if( MinFPS == 0 || LastSecFPS < MinFPS )<br>&#9;&#9;&#9;MinFPS = LastSecFPS;<br>&#9;&#9;if( LastSecFPS > MaxFPS )<br>&#9;&#9;&#9;MaxFPS = LastSecFPS;<br>&#9;&#9;LastSecondFrameCount = 0;<br>&#9;&#9;LastSecondStartTime = Entry.TimeSeconds;<br>&#9;}<br><br>&#9;LastFrameTime = Entry.TimeSeconds;<br><br></div>
<h3 id="Console.TimeDemoRender"><a class="headerlink" href="#Console.TimeDemoRender" title="Permanent link">TimeDemoRender</a> (Canvas C)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string AText, LText;<br>&#9;local float W, H;<br><br><br>&#9;C.Font = TimeDemoFont;<br>&#9;C.DrawColor.R = 255;<br>&#9;C.DrawColor.G = 255;<br>&#9;C.DrawColor.B = 255;<br><br>&#9;AText = AvgText @ FormatFloat(FrameCount / (Viewport.Actor.GetEntryLevel().TimeSeconds - StartTime - ExtraTime));<br>&#9;LText = LastSecText @ FormatFloat(LastSecFPS);<br><br>&#9;C.TextSize(AText, W, H);<br>&#9;C.SetPos(C.ClipX - W, 0.3*C.ClipY);<br>&#9;C.DrawText(AText);<br>&#9;C.TextSize(LText, W, H);<br>&#9;C.SetPos(C.ClipX - W, 0.3*C.ClipY+H);<br>&#9;C.DrawText(LText);<br><br></div>
<h3 id="Console.Type"><a class="headerlink" href="#Console.Type" title="Permanent link">Type</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;TypedStr="";<br>&#9;&#9;gotoState( '' );<br>&#9;<br></div>
<h3 id="Console.VideoChange"><a class="headerlink" href="#Console.VideoChange" title="Permanent link">VideoChange</a></h3>

<h3 id="Console.ViewDown"><a class="headerlink" href="#Console.ViewDown" title="Permanent link">ViewDown</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>//&#9;BorderSize = Clamp( BorderSize+1, 0, MaxBorder );<br><br></div>
<h3 id="Console.ViewUp"><a class="headerlink" href="#Console.ViewUp" title="Permanent link">ViewUp</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>//&#9;BorderSize = Clamp( BorderSize-1, 0, MaxBorder );<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Counter.uc" title="Permanent link"><h2 id="Counter.uc">Counter.uc (extends Triggers)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() byte       NumToCount;                // Number to count down from.<br>var() bool       bShowMessage;              // Display count message?<br>var() localized  string CountMessage;       // Human readable count message.<br>var() localized  string CompleteMessage;    // Completion message.<br>var   byte       OriginalNum;               // Number to count at startup time.</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">NumToCount=2<br>CountMessage="Only %i more to go..."<br>CompleteMessage="Completed!"<br>Texture=Texture'Engine.S_Counter'</div>
<h3 id="Counter.BeginPlay"><a class="headerlink" href="#Counter.BeginPlay" title="Permanent link">BeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;OriginalNum = NumToCount;<br><br></div>
<h3 id="Counter.Reset"><a class="headerlink" href="#Counter.Reset" title="Permanent link">Reset</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;NumToCount = OriginalNum;<br><br></div>
<h3 id="Counter.Trigger"><a class="headerlink" href="#Counter.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string S;<br>&#9;local string Num;<br>&#9;local int i;<br>&#9;local actor A;<br><br><br>&#9;if( NumToCount > 0 )<br>&#9;{<br>&#9;&#9;if( --NumToCount == 0 )<br>&#9;&#9;{<br>&#9;&#9;&#9;// Trigger all matching actors.<br>&#9;&#9;&#9;if( bShowMessage && CompleteMessage != "" )<br>&#9;&#9;&#9;&#9;EventInstigator.ClientMessage( CompleteMessage );<br>&#9;&#9;&#9;if( Event != '' )<br>&#9;&#9;&#9;&#9;foreach AllActors( class 'Actor', A, Event )<br>&#9;&#9;&#9;&#9;&#9;A.Trigger( Other, EventInstigator );<br>&#9;&#9;}<br>&#9;&#9;else if( bShowMessage && CountMessage != "" )<br>&#9;&#9;{<br>&#9;&#9;&#9;// Still counting down.<br>&#9;&#9;&#9;switch( NumToCount )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;case 1:  Num="one"; break;<br>&#9;&#9;&#9;&#9;case 2:  Num="two"; break;<br>&#9;&#9;&#9;&#9;case 3:  Num="three"; break;<br>&#9;&#9;&#9;&#9;case 4:  Num="four"; break;<br>&#9;&#9;&#9;&#9;case 5:  Num="five"; break;<br>&#9;&#9;&#9;&#9;case 6:  Num="six"; break;<br>&#9;&#9;&#9;&#9;default: Num=string(NumToCount); break;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;S = CountMessage;<br>&#9;&#9;&#9;while( InStr(S, "%i") >= 0 )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;i = InStr(S, "%i");<br>&#9;&#9;&#9;&#9;S = Left(S,i) $ Num $ Mid(S,i+2);<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;EventInstigator.ClientMessage( S );<br>&#9;&#9;}<br>&#9;}<br><br></div>
<br><br><hr>
<a class="headerlink" href="#DamageType.uc" title="Permanent link"><h2 id="DamageType.uc">DamageType.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() localized string     Name;         // Description of damage.<br>var() localized string     AltName;      // Alternative description.<br>var() float                ViewFlash;    // View flash to play.<br>var() vector               ViewFog;      // View fog to play.<br>var() class<effects>       DamageEffect; // Special effect.</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">AltName="killed"</div>
<h3 id="DamageType.DeathMessage"><a class="headerlink" href="#DamageType.DeathMessage" title="Permanent link">DeathMessage</a> -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( FRand() < 0.5 )<br>&#9;&#9;return Default.Name;<br>&#9;else <br>&#9;&#9;return Default.AltName;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Decal.uc" title="Permanent link"><h2 id="Decal.uc">Decal.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var int MultiDecalLevel;<br>var float LastRenderedTime;<br>var const array<int> SurfList;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">MultiDecalLevel=4<br>bHighDetail=True<br>bNetTemporary=True<br>bNetOptional=True<br>RemoteRole=ROLE_None<br>DrawType=DT_None<br>bUnlit=True<br>bGameRelevant=True<br>CollisionRadius=0.000000<br>CollisionHeight=0.000000</div>
<h3 id="Decal.BeginPlay"><a class="headerlink" href="#Decal.BeginPlay" title="Permanent link">BeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if(!AttachDecal(100))&#9;// trace 100 units ahead in direction of current rotation<br>&#9;&#9;Destroy();<br><br></div>
<h3 id="Decal.Destroyed"><a class="headerlink" href="#Decal.Destroyed" title="Permanent link">Destroyed</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;DetachDecal();<br>&#9;Super.Destroyed();<br><br></div>
<h3 id="Decal.Update"><a class="headerlink" href="#Decal.Update" title="Permanent link">Update</a> (Actor L)</h3>

<br><br><hr>
<a class="headerlink" href="#Decoration.uc" title="Permanent link"><h2 id="Decoration.uc">Decoration.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() class<actor> EffectWhenDestroyed;<br>var() bool bPushable;<br>var() bool bOnlyTriggerable;<br>var bool bSplash;<br>var bool bBobbing;<br>var bool bWasCarried;<br>var() sound PushSound;<br>var const int	 numLandings; // Used by engine physics.<br>var() class<inventory> contents;<br>var() class<inventory> content2;<br>var() class<inventory> content3;<br>var() sound EndPushSound;<br>var bool bPushSoundPlaying;<br>var Float   BaseEyeHeight;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bStatic=True<br>bStasis=True<br>Texture=None<br>Mass=0.000000</div>
<h3 id="Decoration.BaseChange"><a class="headerlink" href="#Decoration.BaseChange" title="Permanent link">BaseChange</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float decorMass, decorMass2;<br><br><br>&#9;decormass= FMax(1, Mass);<br>&#9;bBobbing = false;<br>&#9;if( Velocity.Z < -500 )<br>&#9;&#9;TakeDamage( (1-Velocity.Z/30),Instigator,Location,vect(0,0,0) , 'crushed');<br><br>&#9;if( (base == None) && (bPushable || IsA('Carcass')) && (Physics == PHYS_None) )<br>&#9;&#9;SetPhysics(PHYS_Falling);<br>&#9;else if( (Pawn(base) != None) && (Pawn(Base).CarriedDecoration != self) )<br>&#9;{<br>&#9;&#9;Base.TakeDamage( (1-Velocity.Z/400)* decormass/Base.Mass,Instigator,Location,0.5 * Velocity , 'crushed');<br>&#9;&#9;Velocity.Z = 100;<br>&#9;&#9;if (FRand() < 0.5)<br>&#9;&#9;&#9;Velocity.X += 70;<br>&#9;&#9;else<br>&#9;&#9;&#9;Velocity.Y += 70;<br>&#9;&#9;SetPhysics(PHYS_Falling);<br>&#9;}<br>&#9;else if( Decoration(Base)!=None && Velocity.Z<-500 )<br>&#9;{<br>&#9;&#9;decorMass2 = FMax(Decoration(Base).Mass, 1);<br>&#9;&#9;Base.TakeDamage((1 - decorMass/decorMass2 * Velocity.Z/30), Instigator, Location, 0.2 * Velocity, 'stomped');<br>&#9;&#9;Velocity.Z = 100;<br>&#9;&#9;if (FRand() < 0.5)<br>&#9;&#9;&#9;Velocity.X += 70;<br>&#9;&#9;else<br>&#9;&#9;&#9;Velocity.Y += 70;<br>&#9;&#9;SetPhysics(PHYS_Falling);<br>&#9;}<br>&#9;else<br>&#9;&#9;instigator = None;<br><br></div>
<h3 id="Decoration.Bump"><a class="headerlink" href="#Decoration.Bump" title="Permanent link">Bump</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float speed, oldZ;<br><br>&#9;if( bPushable && (Pawn(Other)!=None) && (Other.Mass > 40) )<br>&#9;{<br>&#9;&#9;bBobbing = false;<br>&#9;&#9;oldZ = Velocity.Z;<br>&#9;&#9;speed = VSize(Other.Velocity);<br>&#9;&#9;Velocity = Other.Velocity * FMin(120.0, 20 + speed)/speed;<br>&#9;&#9;if ( Physics == PHYS_None ) {<br>&#9;&#9;&#9;Velocity.Z = 25;<br>&#9;&#9;&#9;if (!bPushSoundPlaying) PlaySound(PushSound, SLOT_Misc,0.25);<br>&#9;&#9;&#9;bPushSoundPlaying = True;&#9;&#9;&#9;<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;&#9;Velocity.Z = oldZ;<br>&#9;&#9;SetPhysics(PHYS_Falling);<br>&#9;&#9;SetTimer(0.3,False);<br>&#9;&#9;Instigator = Pawn(Other);<br>&#9;<br></div>
<h3 id="Decoration.Destroyed"><a class="headerlink" href="#Decoration.Destroyed" title="Permanent link">Destroyed</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor dropped, A;<br>&#9;local class<actor> tempClass;<br><br><br>&#9;if( (Pawn(Base) != None) && (Pawn(Base).CarriedDecoration == self) )<br>&#9;&#9;Pawn(Base).DropDecoration();<br>&#9;if( (Contents!=None) && !Level.bStartup )<br>&#9;{<br>&#9;&#9;tempClass = Contents;<br>&#9;&#9;if (Content2!=None && FRand()<0.3) tempClass = Content2;<br>&#9;&#9;if (Content3!=None && FRand()<0.3) tempClass = Content3;<br>&#9;&#9;dropped = Spawn(tempClass);<br>&#9;&#9;dropped.RemoteRole = ROLE_DumbProxy;<br>&#9;&#9;dropped.SetPhysics(PHYS_Falling);<br>&#9;&#9;dropped.bCollideWorld = true;<br>&#9;&#9;if ( inventory(dropped) != None )<br>&#9;&#9;&#9;inventory(dropped).GotoState('Pickup', 'Dropped');<br>&#9;}&#9;<br><br>&#9;if( Event != '' )<br>&#9;&#9;foreach AllActors( class 'Actor', A, Event )<br>&#9;&#9;&#9;A.Trigger( Self, None );<br><br>&#9;if ( bPushSoundPlaying )<br>&#9;&#9;PlaySound(EndPushSound, SLOT_Misc,0.0);<br>&#9;&#9;&#9;<br>&#9;Super.Destroyed();<br><br></div>
<h3 id="Decoration.Drop"><a class="headerlink" href="#Decoration.Drop" title="Permanent link">Drop</a> (vector newVel)</h3>

<h3 id="Decoration.FollowHolder"><a class="headerlink" href="#Decoration.FollowHolder" title="Permanent link">FollowHolder</a> (Actor Other)</h3>

<h3 id="Decoration.Frag"><a class="headerlink" href="#Decoration.Frag" title="Permanent link">Frag</a> (class<fragment> FragType, vector Momentum, float DSize, int NumFrags)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br>&#9;local actor A, Toucher;<br>&#9;local Fragment s;<br><br><br>&#9;if ( bOnlyTriggerable )<br>&#9;&#9;return; <br>&#9;if (Event!='')<br>&#9;&#9;foreach AllActors( class 'Actor', A, Event )<br>&#9;&#9;&#9;A.Trigger( Toucher, pawn(Toucher) );<br>&#9;if ( Region.Zone.bDestructive )<br>&#9;{<br>&#9;&#9;Destroy();<br>&#9;&#9;return;<br>&#9;}<br>&#9;for (i=0 ; i<NumFrags ; i++) <br>&#9;{<br>&#9;&#9;s = Spawn( FragType, Owner);<br>&#9;&#9;s.CalcVelocity(Momentum,0);<br>&#9;&#9;s.DrawScale = DSize*0.5+0.7*DSize*FRand();<br>&#9;}<br><br>&#9;Destroy();<br><br></div>
<h3 id="Decoration.Landed"><a class="headerlink" href="#Decoration.Landed" title="Permanent link">Landed</a> (vector HitNormall)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( bWasCarried && !SetLocation(Location) )<br>&#9;{<br>&#9;&#9;if( Instigator!=None && (VSize(Instigator.Location - Location) < CollisionRadius + Instigator.CollisionRadius) )<br>&#9;&#9;&#9;SetLocation(Instigator.Location);<br>&#9;&#9;TakeDamage( 1000, Instigator, Location, Vect(0,0,1)*900,'exploded' );<br>&#9;}<br>&#9;bWasCarried = false;<br>&#9;bBobbing = false;<br><br></div>
<h3 id="Decoration.Timer"><a class="headerlink" href="#Decoration.Timer" title="Permanent link">Timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlaySound(EndPushSound, SLOT_Misc,0.0);<br>&#9;bPushSoundPlaying=False;<br><br></div>
<h3 id="Decoration.Trigger"><a class="headerlink" href="#Decoration.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Instigator = EventInstigator;<br>&#9;TakeDamage( 1000, Instigator, Location, Vect(0,0,1)*900,'exploded' );<br><br></div>
<h3 id="Decoration.ZoneChange"><a class="headerlink" href="#Decoration.ZoneChange" title="Permanent link">ZoneChange</a> (ZoneInfo NewZone)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float splashsize;<br>&#9;local actor splash;<br><br><br>&#9;if( NewZone.bWaterZone )<br>&#9;{<br>&#9;&#9;if( bSplash && !Region.Zone.bWaterZone && Mass<=Buoyancy <br>&#9;&#9;&#9;&& ((Abs(Velocity.Z) < 100) || (Mass == 0)) && (FRand() < 0.05) && !PlayerCanSeeMe() )<br>&#9;&#9;{<br>&#9;&#9;&#9;bSplash = false;<br>&#9;&#9;&#9;SetPhysics(PHYS_None);<br>&#9;&#9;}<br>&#9;&#9;else if( !Region.Zone.bWaterZone && (Velocity.Z < -200) )<br>&#9;&#9;{<br>&#9;&#9;&#9;// Else play a splash.<br>&#9;&#9;&#9;splashSize = FClamp(0.0001 * Mass * (250 - 0.5 * FMax(-600,Velocity.Z)), 1.0, 3.0 );<br>&#9;&#9;&#9;if( NewZone.EntrySound != None )<br>&#9;&#9;&#9;&#9;PlaySound(NewZone.EntrySound, SLOT_Interact, splashSize);<br>&#9;&#9;&#9;if( NewZone.EntryActor != None )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;splash = Spawn(NewZone.EntryActor); <br>&#9;&#9;&#9;&#9;if ( splash != None )<br>&#9;&#9;&#9;&#9;&#9;splash.DrawScale = splashSize;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;&#9;bSplash = true;<br>&#9;}<br>&#9;else if( Region.Zone.bWaterZone && (Buoyancy > Mass) )<br>&#9;{<br>//&#9;&#9;bBobbing = true;      // removed (looked stupid) - DEUS_EX CNN<br>&#9;&#9;if( Buoyancy > 1.1 * Mass )<br>&#9;&#9;&#9;Buoyancy = 0.95 * Buoyancy; // waterlog<br>&#9;&#9;else if( Buoyancy > 1.03 * Mass )<br>&#9;&#9;&#9;Buoyancy = 0.99 * Buoyancy;<br>&#9;}<br><br>&#9;if( NewZone.bPainZone && (NewZone.DamagePerSec > 0) )<br>&#9;&#9;TakeDamage(100, None, location, vect(0,0,0), NewZone.DamageType);<br><br></div>
<h3 id="Decoration.skinnedFrag"><a class="headerlink" href="#Decoration.skinnedFrag" title="Permanent link">skinnedFrag</a> (class<fragment> FragType, texture FragSkin, vector Momentum, float DSize, int NumFrags)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br>&#9;local actor A, Toucher;<br>&#9;local Fragment s;<br><br><br>&#9;if ( bOnlyTriggerable )<br>&#9;&#9;return; <br>&#9;if (Event!='')<br>&#9;&#9;foreach AllActors( class 'Actor', A, Event )<br>&#9;&#9;&#9;A.Trigger( Toucher, pawn(Toucher) );<br>&#9;if ( Region.Zone.bDestructive )<br>&#9;{<br>&#9;&#9;Destroy();<br>&#9;&#9;return;<br>&#9;}<br>&#9;for (i=0 ; i<NumFrags ; i++) <br>&#9;{<br>&#9;&#9;s = Spawn( FragType, Owner);<br>&#9;&#9;s.CalcVelocity(Momentum/100,0);<br>&#9;&#9;s.Skin = FragSkin;<br>&#9;&#9;s.DrawScale = DSize*0.5+0.7*DSize*FRand();<br>&#9;}<br><br>&#9;Destroy();<br><br></div>
<br><br><hr>
<a class="headerlink" href="#DemoRecSpectator.uc" title="Permanent link"><h2 id="DemoRecSpectator.uc">DemoRecSpectator.uc (extends MessagingSpectator)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var PlayerPawn PlaybackActor;<br>var GameReplicationInfo PlaybackGRI;</div>
<h3 id="DemoRecSpectator.ClientMessage"><a class="headerlink" href="#DemoRecSpectator.ClientMessage" title="Permanent link">ClientMessage</a> (coerce string S, optional name Type, optional bool bBeep)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;RepClientMessage( S, Type, bBeep );<br><br></div>
<h3 id="DemoRecSpectator.ClientVoiceMessage"><a class="headerlink" href="#DemoRecSpectator.ClientVoiceMessage" title="Permanent link">ClientVoiceMessage</a> (PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;RepClientVoiceMessage(Sender, Recipient, messagetype, messageID);<br><br></div>
<h3 id="DemoRecSpectator.ReceiveLocalizedMessage"><a class="headerlink" href="#DemoRecSpectator.ReceiveLocalizedMessage" title="Permanent link">ReceiveLocalizedMessage</a> (class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;RepReceiveLocalizedMessage( Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );<br><br></div>
<h3 id="DemoRecSpectator.RepClientMessage"><a class="headerlink" href="#DemoRecSpectator.RepClientMessage" title="Permanent link">RepClientMessage</a> (coerce string S, optional name Type, optional bool bBeep)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre">&#9;<br>&#9;if(PlaybackActor != None && PlaybackActor.Role == ROLE_Authority)<br>&#9;&#9;PlaybackActor.ClientMessage( S, Type, bBeep );<br><br></div>
<h3 id="DemoRecSpectator.RepClientVoiceMessage"><a class="headerlink" href="#DemoRecSpectator.RepClientVoiceMessage" title="Permanent link">RepClientVoiceMessage</a> (PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if(PlaybackActor != None && PlaybackActor.Role == ROLE_Authority)<br>&#9;&#9;PlaybackActor.ClientVoiceMessage(Sender, Recipient, messagetype, messageID);<br><br></div>
<h3 id="DemoRecSpectator.RepReceiveLocalizedMessage"><a class="headerlink" href="#DemoRecSpectator.RepReceiveLocalizedMessage" title="Permanent link">RepReceiveLocalizedMessage</a> (class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if(PlaybackActor != None && PlaybackActor.Role == ROLE_Authority)<br>&#9;&#9;PlaybackActor.ReceiveLocalizedMessage( Message, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );<br><br></div>
<h3 id="DemoRecSpectator.RepTeamMessage"><a class="headerlink" href="#DemoRecSpectator.RepTeamMessage" title="Permanent link">RepTeamMessage</a> (PlayerReplicationInfo PRI, coerce string S, name Type)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if(PlaybackActor != None && PlaybackActor.Role == ROLE_Authority)<br>&#9;&#9;PlaybackActor.TeamMessage( PRI, S, Type );<br><br></div>
<h3 id="DemoRecSpectator.TeamMessage"><a class="headerlink" href="#DemoRecSpectator.TeamMessage" title="Permanent link">TeamMessage</a> (PlayerReplicationInfo PRI, coerce string S, name Type, optional bool bBeep)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;RepTeamMessage( PRI, S, Type );<br><br></div>
<h3 id="DemoRecSpectator.Tick"><a class="headerlink" href="#DemoRecSpectator.Tick" title="Permanent link">Tick</a> (float Delta)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local PlayerPawn p;<br>&#9;local GameReplicationInfo g;<br><br><br>&#9;// find local playerpawn and attach.<br>&#9;if(Level.NetMode == NM_Client)<br>&#9;{<br>&#9;&#9;if(PlaybackActor == None)<br>&#9;&#9;{<br>&#9;&#9;&#9;foreach AllActors(class'PlayerPawn', p)<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if( p.Player.IsA('Viewport') )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;PlaybackActor = p;<br>&#9;&#9;&#9;&#9;&#9;if(PlaybackGRI != None)<br>&#9;&#9;&#9;&#9;&#9;&#9;PlaybackActor.GameReplicationInfo = PlaybackGRI;<br><br>&#9;&#9;&#9;&#9;&#9;Log("Attached to player "$p);<br>&#9;&#9;&#9;&#9;&#9;<br>&#9;&#9;&#9;&#9;&#9;break;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br><br>&#9;&#9;if(PlaybackGRI == None)<br>&#9;&#9;{<br>&#9;&#9;&#9;foreach AllActors(class'GameReplicationInfo', g)<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;PlaybackGRI = g;<br>&#9;&#9;&#9;&#9;if(PlaybackActor != None)<br>&#9;&#9;&#9;&#9;&#9;PlaybackActor.GameReplicationInfo = PlaybackGRI;<br>&#9;&#9;&#9;&#9;break;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br><br>&#9;&#9;if(PlaybackActor != None && PlaybackGRI != None)<br>&#9;&#9;&#9;Disable('Tick');<br><br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;Disable('Tick');<br>&#9;}<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Dispatcher.uc" title="Permanent link"><h2 id="Dispatcher.uc">Dispatcher.uc (extends Triggers)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() name  OutEvents[8]; // Events to generate.<br>var() float OutDelays[8]; // Relative delays before generating events.<br>var int i;                // Internal counter.</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Texture=Texture'Engine.S_Dispatcher'</div>
<h3 id="Dispatcher.Trigger"><a class="headerlink" href="#Dispatcher.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Instigator = EventInstigator;<br>&#9;gotostate('Dispatch');<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Effects.uc" title="Permanent link"><h2 id="Effects.uc">Effects.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() sound 	EffectSound1;<br>var() sound 	EffectSound2;<br>var() bool bOnlyTriggerable;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">RemoteRole=ROLE_SimulatedProxy<br>DrawType=DT_None<br>bGameRelevant=True<br>CollisionRadius=0.000000<br>CollisionHeight=0.000000</div>
<br><br><hr>
<a class="headerlink" href="#Engine.uc" title="Permanent link"><h2 id="Engine.uc">Engine.uc (extends Subsystem)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var config class<RenderDevice>   GameRenderDevice;<br>var(Drivers) config class<AudioSubsystem> AudioDevice;<br>var(Drivers) config class<Console>        Console;<br>var(Drivers) config class<NetDriver>      NetworkDevice;<br>var(Drivers) config class<Language>       Language;<br>var primitive Cylinder;<br>var const client Client;<br>var const renderbase Render;<br>var const audiosubsystem Audio;<br>var int TickCycles, GameCycles, ClientCycles;<br>var(Settings) config int CacheSizeMegs;<br>var(Settings) config bool UseSound;<br>var(Settings) float CurrentTickRate;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Console=Class'Engine.Console'<br>CacheSizeMegs=2<br>UseSound=True</div>
<br><br><hr>
<a class="headerlink" href="#Fragment.uc" title="Permanent link"><h2 id="Fragment.uc">Fragment.uc (extends Projectile)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() MESH Fragments[11];<br>var int numFragmentTypes;<br>var bool bFirstHit;<br>var() float Elasticity;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bFirstHit=True<br>elasticity=0.500000<br>bNetOptional=True<br>Physics=PHYS_Falling<br>RemoteRole=ROLE_SimulatedProxy<br>LifeSpan=20.000000<br>CollisionRadius=18.000000<br>CollisionHeight=4.000000<br>bCollideActors=False<br>bBounce=True<br>bFixedRotationDir=True<br>NetPriority=1.400000</div>
<h3 id="Fragment.BeginState"><a class="headerlink" href="#Fragment.BeginState" title="Permanent link">BeginState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>//&#9;&#9;SetTimer(1.5,True);       // Removed - DEUS_EX CNN<br>&#9;&#9;SetCollision(true, false, false);<br>&#9;<br></div>
<h3 id="Fragment.CalcVelocity"><a class="headerlink" href="#Fragment.CalcVelocity" title="Permanent link">CalcVelocity</a> (vector Momentum, float ExplosionSize)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Velocity = VRand()*(ExplosionSize+FRand()*150.0+100.0 + VSize(Momentum)/80); <br><br></div>
<h3 id="Fragment.HitWall"><a class="headerlink" href="#Fragment.HitWall" title="Permanent link">HitWall</a> (vector HitNormal, actor HitWall)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;// Added elasticity - DEUS_EX CNN<br>&#9;&#9;Velocity = Elasticity*(( Velocity dot HitNormal ) * HitNormal * (-2.0) + Velocity);   // Reflect off Wall w/damping<br>&#9;&#9;speed = VSize(Velocity);&#9;<br>&#9;&#9;if (bFirstHit && speed<400) <br>&#9;&#9;{<br>&#9;&#9;&#9;bFirstHit=False;<br>&#9;&#9;&#9;bRotatetoDesired=True;<br>&#9;&#9;&#9;bFixedRotationDir=False;<br>&#9;&#9;&#9;DesiredRotation.Pitch=0;&#9;<br>&#9;&#9;&#9;DesiredRotation.Yaw=FRand()*65536;<br>&#9;&#9;&#9;DesiredRotation.roll=0;<br>&#9;&#9;}<br>&#9;&#9;RotationRate.Yaw = RotationRate.Yaw*0.75;<br>&#9;&#9;RotationRate.Roll = RotationRate.Roll*0.75;<br>&#9;&#9;RotationRate.Pitch = RotationRate.Pitch*0.75;<br>&#9;&#9;if ( (Velocity.Z < 50) && (HitNormal.Z > 0.7) )<br>&#9;&#9;{<br>&#9;&#9;&#9;SetPhysics(PHYS_none);<br>&#9;&#9;&#9;bBounce = false;<br>&#9;&#9;}<br>&#9;&#9;else If (speed > 80) <br>&#9;&#9;{<br>&#9;&#9;&#9;if (FRand()<0.5) PlaySound(ImpactSound, SLOT_None, 0.5+FRand()*0.5,, 300, 0.85+FRand()*0.3);<br>&#9;&#9;&#9;else PlaySound(MiscSound, SLOT_None, 0.5+FRand()*0.5,, 300, 0.85+FRand()*0.3);<br>&#9;&#9;}<br>&#9;<br></div>
<h3 id="Fragment.PostBeginPlay"><a class="headerlink" href="#Fragment.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Region.Zone.bDestructive )<br>&#9;&#9;Destroy();<br>&#9;else<br>&#9;&#9;Super.PostBeginPlay();<br><br></div>
<h3 id="Fragment.Touch"><a class="headerlink" href="#Fragment.Touch" title="Permanent link">Touch</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if (Pawn(Other)==None) Return;<br>&#9;&#9;if (!Pawn(Other).bIsPlayer) Destroy();<br>&#9;<br></div>
<h3 id="Fragment.ZoneChange"><a class="headerlink" href="#Fragment.ZoneChange" title="Permanent link">ZoneChange</a> (ZoneInfo NewZone)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float splashsize;<br>&#9;local actor splash;<br><br><br>&#9;&#9;if ( NewZone.bWaterZone )<br>&#9;&#9;{<br>&#9;&#9;&#9;Velocity = 0.2 * Velocity;<br>&#9;&#9;&#9;splashSize = 0.0005 * (250 - 0.5 * Velocity.Z);<br>&#9;&#9;&#9;if ( Level.NetMode != NM_DedicatedServer )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( NewZone.EntrySound != None )<br>&#9;&#9;&#9;&#9;&#9;PlaySound(NewZone.EntrySound, SLOT_Interact, splashSize);<br>&#9;&#9;&#9;&#9;if ( NewZone.EntryActor != None )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;splash = Spawn(NewZone.EntryActor); <br>&#9;&#9;&#9;&#9;&#9;if ( splash != None )<br>&#9;&#9;&#9;&#9;&#9;&#9;splash.DrawScale = 4 * splashSize;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;if (bFirstHit) <br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;bFirstHit=False;<br>&#9;&#9;&#9;&#9;bRotatetoDesired=True;<br>&#9;&#9;&#9;&#9;bFixedRotationDir=False;<br>&#9;&#9;&#9;&#9;DesiredRotation.Pitch=0;&#9;<br>&#9;&#9;&#9;&#9;DesiredRotation.Yaw=FRand()*65536;<br>&#9;&#9;&#9;&#9;DesiredRotation.roll=0;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;<br>&#9;&#9;&#9;RotationRate = 0.2 * RotationRate;<br>&#9;&#9;&#9;GotoState('Dying');<br>&#9;&#9;}<br>&#9;&#9;if ( NewZone.bPainZone && (NewZone.DamagePerSec > 0) )<br>&#9;&#9;&#9;Destroy();<br>&#9;<br></div>
<h3 id="Fragment.timer"><a class="headerlink" href="#Fragment.timer" title="Permanent link">timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if (!PlayerCanSeeMe()) <br>&#9;&#9;&#9;Destroy();<br>&#9;<br></div>
<br><br><hr>
<a class="headerlink" href="#GameInfo.uc" title="Permanent link"><h2 id="GameInfo.uc">GameInfo.uc (extends Info)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var int ItemGoals, KillGoals, SecretGoals;				// Special game goals.<br>var byte  Difficulty;									// 0=easy, 1=medium, 2=hard, 3=very hard.<br>var() config bool   		  bNoMonsters;				// Whether monsters are allowed in this play mode.<br>var() globalconfig bool		  bMuteSpectators;			// Whether spectators are allowed to speak.<br>var() config bool			  bHumansOnly;				// Whether non human player models are allowed.<br>var() bool				      bRestartLevel;<br>var() bool				      bPauseable;				// Whether the level is pauseable.<br>var() config bool			  bCoopWeaponMode;			// Whether or not weapons stay when picked up.<br>var() config bool			  bClassicDeathmessages;	// Weapon deathmessages if false.<br>var   globalconfig bool	      bLowGore;					// Whether or not to reduce gore.<br>var() bool				      bTeamGame;				// This is a teamgame.<br>var() globalconfig bool       bNoCheating;				// Disallows cheating. Hehe.<br>var() globalconfig bool       bAllowFOV;				// Allows FOV changes in net games<br>var() bool					  bDeathMatch;				// This game is some type of deathmatch (where players can respawn during gameplay)<br>var localized bool			  bAlternateMode;<br>var() globalconfig float	  AutoAim;					// How much autoaiming to do (1 = none, 0 = always).<br>var() globalconfig float	  GameSpeed;				// Scale applied to game rate.<br>var   float                   StartTime;<br>var() class<playerpawn>       DefaultPlayerClass;<br>var() class<weapon>           DefaultWeapon;			// Default weapon given to player at start.<br>var() globalconfig int	      MaxSpectators;			// Maximum number of spectators.<br>var() private globalconfig string AdminPassword;	    // Password to receive bAdmin privileges.<br>var() private globalconfig string GamePassword;		    // Password to enter game.<br>var() class<scoreboard>		  ScoreBoardType;			// Type of scoreboard this game uses.<br>var() class<menu>			  GameMenuType;				// Type of oldstyle game options menu to display.<br>var() string			      BotMenuType;				// Type of bot menu to display.<br>var() string			      RulesMenuType;			// Type of rules menu to display.<br>var() string				  SettingsMenuType;			// Type of settings menu to display.<br>var() string				  GameUMenuType;			// Type of Game dropdown to display.<br>var() string				  MultiplayerUMenuType;		// Type of Multiplayer dropdown to display.<br>var() string				  GameOptionsMenuType;		// Type of options dropdown to display.<br>var() class<hud>			  HUDType;					// HUD class this game uses.<br>var() class<MapList>		  MapListType;				// Maplist this game uses.<br>var() string			      MapPrefix;				// Prefix characters for names of maps for this game type.<br>var() string			      BeaconName;				// Identifying string used for finding LAN servers.<br>var() string			      SpecialDamageString;<br>var localized string	      SwitchLevelMessage;<br>var localized string	      DefaultPlayerName;<br>var localized string	      LeftMessage;<br>var localized string	      FailedSpawnMessage;<br>var localized string	      FailedPlaceMessage;<br>var localized string	      FailedTeamMessage;<br>var localized string	      NameChangedMessage;<br>var localized string	      EnteredMessage;<br>var localized string	      GameName;<br>var() globalconfig int		  MaxPlayers;<br>var   int					  NumPlayers;<br>var   int					  CurrentID;<br>var() globalconfig string     IPPolicies[50];<br>var class<LocalMessage>		  DeathMessageClass;<br>var class<LocalMessage>		  DMMessageClass;<br>var class<Mutator> MutatorClass;<br>var Mutator BaseMutator;<br>var Mutator DamageMutator;	// linked list of mutators which affect damage<br>var class<ZoneInfo> WaterZoneType;<br>var name DefaultPlayerState;<br>var() class<GameReplicationInfo> GameReplicationInfoClass;<br>var GameReplicationInfo GameReplicationInfo;<br>var globalconfig string         ServerLogName;<br>var StatLog						LocalLog;<br>var StatLog						WorldLog;<br>var globalconfig bool			bLocalLog;<br>var globalconfig bool			bWorldLog;<br>var globalconfig bool			bBatchLocal;<br>var bool						bLoggingGame;			// Does this gametype log?<br>var string					    LocalLogFileName;<br>var string					    WorldLogFileName;<br>var class<StatLog>				StatLogClass;<br>var globalconfig int DemoBuild;<br>var globalconfig int DemoHasTuts;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Difficulty=1<br>bRestartLevel=True<br>bPauseable=True<br>bCanChangeSkin=True<br>bNoCheating=True<br>bCanViewOthers=True<br>AutoAim=0.930000<br>GameSpeed=1.000000<br>MaxSpectators=2<br>BotMenuType="UMenu.UMenuBotConfigSClient"<br>RulesMenuType="UMenu.UMenuGameRulesSClient"<br>SettingsMenuType="UMenu.UMenuGameSettingsSClient"<br>GameUMenuType="UMenu.UMenuGameMenu"<br>MultiplayerUMenuType="UMenu.UMenuMultiplayerMenu"<br>GameOptionsMenuType="UMenu.UMenuOptionsMenu"<br>SwitchLevelMessage="Switching Levels"<br>DefaultPlayerName="Player"<br>LeftMessage=" left the game."<br>FailedSpawnMessage="Failed to spawn player actor"<br>FailedPlaceMessage="Could not find starting spot (level might need a 'PlayerStart' actor)"<br>FailedTeamMessage="Could not find team for player"<br>NameChangedMessage="Name changed to "<br>EnteredMessage=" entered the game."<br>GameName="Game"<br>MaxedOutMessage="Server is already at capacity."<br>WrongPassword="The password you entered is incorrect."<br>NeedPassword="You need to enter a password to join this game."<br>IPBanned="Your IP address has been banned on this server."<br>MaxPlayers=16<br>IPPolicies(0)="ACCEPT,*"<br>DeathMessageClass=Class'Engine.LocalMessage'<br>MutatorClass=Class'Engine.Mutator'<br>DefaultPlayerState=PlayerWalking<br>ServerLogName="server.log"<br>bLocalLog=True<br>bWorldLog=True<br>StatLogClass=Class'Engine.StatLogFile'</div>
<h3 id="GameInfo.AcceptInventory"><a class="headerlink" href="#GameInfo.AcceptInventory" title="Permanent link">AcceptInventory</a> (pawn PlayerPawn)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local inventory inv;<br><br>&#9;//default accept all inventory except default weapon (spawned explicitly)<br><br><br>&#9;// Initialize the inventory.<br>&#9;AddDefaultInventory( PlayerPawn );<br><br>&#9;log( "All inventory from" @ PlayerPawn.PlayerReplicationInfo.PlayerName @ "is accepted" );<br><br></div>
<h3 id="GameInfo.AddBot"><a class="headerlink" href="#GameInfo.AddBot" title="Permanent link">AddBot</a> -> bool</h3>

<h3 id="GameInfo.AddDefaultInventory"><a class="headerlink" href="#GameInfo.AddDefaultInventory" title="Permanent link">AddDefaultInventory</a> (pawn PlayerPawn)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Weapon newWeapon;<br>&#9;local class<Weapon> WeapClass;<br><br><br>&#9;PlayerPawn.JumpZ = PlayerPawn.Default.JumpZ * PlayerJumpZScaling();<br>&#9; <br>&#9;if( PlayerPawn.IsA('Spectator') )<br>&#9;&#9;return;<br><br>&#9;// Spawn default weapon.<br>&#9;WeapClass = BaseMutator.MutatedDefaultWeapon();<br>&#9;if( (WeapClass!=None) && (PlayerPawn.FindInventoryType(WeapClass)==None) )<br>&#9;{<br>&#9;&#9;newWeapon = Spawn(WeapClass);<br>&#9;&#9;if( newWeapon != None )<br>&#9;&#9;{<br>&#9;&#9;&#9;newWeapon.Instigator = PlayerPawn;<br>&#9;&#9;&#9;newWeapon.BecomeItem();<br>&#9;&#9;&#9;newWeapon.GiveAmmo(PlayerPawn);<br>&#9;&#9;&#9;PlayerPawn.AddInventory(newWeapon);<br>&#9;&#9;&#9;newWeapon.BringUp();<br>&#9;&#9;&#9;newWeapon.SetSwitchPriority(PlayerPawn);<br>&#9;&#9;&#9;newWeapon.WeaponSet(PlayerPawn);<br>&#9;&#9;}<br>&#9;}<br>&#9;BaseMutator.ModifyPlayer(PlayerPawn);<br><br></div>
<h3 id="GameInfo.AdminLogin"><a class="headerlink" href="#GameInfo.AdminLogin" title="Permanent link">AdminLogin</a> (PlayerPawn P, string Password)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (AdminPassword == "")<br>&#9;&#9;return;<br><br>&#9;if (Password == AdminPassword)<br>&#9;{<br>&#9;&#9;P.bAdmin = True;<br>&#9;&#9;P.PlayerReplicationInfo.bAdmin = P.bAdmin;<br>&#9;&#9;Log("Administrator logged in.");<br>&#9;&#9;BroadcastMessage( P.PlayerReplicationInfo.PlayerName@"became a server administrator." );<br>&#9;}<br><br></div>
<h3 id="GameInfo.AdminLogout"><a class="headerlink" href="#GameInfo.AdminLogout" title="Permanent link">AdminLogout</a> (PlayerPawn P)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (AdminPassword == "")<br>&#9;&#9;return;<br><br>&#9;if (P.bAdmin)<br>&#9;{<br>&#9;&#9;P.bAdmin = False;<br>&#9;&#9;P.PlayerReplicationInfo.bAdmin = P.bAdmin;<br>&#9;&#9;Log("Administrator logged out.");<br>&#9;&#9;BroadcastMessage( P.PlayerReplicationInfo.PlayerName@"gave up administrator abilities." );<br>&#9;}<br><br></div>
<h3 id="GameInfo.AllowsBroadcast"><a class="headerlink" href="#GameInfo.AllowsBroadcast" title="Permanent link">AllowsBroadcast</a> (actor broadcaster, int Len) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;SentText += Len;<br><br>&#9;return (SentText < 260);<br><br></div>
<h3 id="GameInfo.AtCapacity"><a class="headerlink" href="#GameInfo.AtCapacity" title="Permanent link">AtCapacity</a> (string Options) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return ( (MaxPlayers>0) && (NumPlayers>=MaxPlayers) );<br><br></div>
<h3 id="GameInfo.BroadcastRegularDeathMessage"><a class="headerlink" href="#GameInfo.BroadcastRegularDeathMessage" title="Permanent link">BroadcastRegularDeathMessage</a> (pawn Killer, pawn Other, name damageType)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;BroadcastLocalizedMessage(DeathMessageClass, 0, Killer.PlayerReplicationInfo, Other.PlayerReplicationInfo, Killer.Weapon.Class);<br><br></div>
<h3 id="GameInfo.CanSpectate"><a class="headerlink" href="#GameInfo.CanSpectate" title="Permanent link">CanSpectate</a> (pawn Viewer, actor ViewTarget) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return true;<br><br></div>
<h3 id="GameInfo.ChangeName"><a class="headerlink" href="#GameInfo.ChangeName" title="Permanent link">ChangeName</a> (Pawn Other, coerce string S, bool bNameChange)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( S == "" )<br>&#9;&#9;return;<br>&#9;if (LocalLog != None)<br>&#9;&#9;LocalLog.LogNameChange(Other);<br>&#9;if (WorldLog != None)<br>&#9;&#9;WorldLog.LogNameChange(Other);<br>&#9;Other.PlayerReplicationInfo.PlayerName = S;<br>&#9;if( bNameChange )<br>&#9;&#9;Other.ClientMessage( NameChangedMessage $ Other.PlayerReplicationInfo.PlayerName );<br><br></div>
<h3 id="GameInfo.ChangeTeam"><a class="headerlink" href="#GameInfo.ChangeTeam" title="Permanent link">ChangeTeam</a> (Pawn Other, int N) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Other.PlayerReplicationInfo.Team = N;<br>&#9;if (LocalLog != None)<br>&#9;&#9;LocalLog.LogTeamChange(Other);<br>&#9;if (WorldLog != None)<br>&#9;&#9;WorldLog.LogTeamChange(Other);<br>&#9;return true;<br><br></div>
<h3 id="GameInfo.CheckIPPolicy"><a class="headerlink" href="#GameInfo.CheckIPPolicy" title="Permanent link">CheckIPPolicy</a> (string Address) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i, j, LastMatchingPolicy;<br>&#9;local string Policy, Mask;<br>&#9;local bool bAcceptAddress, bAcceptPolicy;<br><br>&#9;<br>&#9;// strip port number<br>&#9;j = InStr(Address, ":");<br>&#9;if(j != -1)<br>&#9;&#9;Address = Left(Address, j);<br><br>&#9;bAcceptAddress = True;<br>&#9;for(i=0; i<50 && IPPolicies[i] != ""; i++)<br>&#9;{<br>&#9;&#9;j = InStr(IPPolicies[i], ",");<br>&#9;&#9;if(j==-1)<br>&#9;&#9;&#9;continue;<br>&#9;&#9;Policy = Left(IPPolicies[i], j);<br>&#9;&#9;Mask = Mid(IPPolicies[i], j+1);<br>&#9;&#9;if(Policy ~= "ACCEPT") <br>&#9;&#9;&#9;bAcceptPolicy = True;<br>&#9;&#9;else<br>&#9;&#9;if(Policy ~= "DENY") <br>&#9;&#9;&#9;bAcceptPolicy = False;<br>&#9;&#9;else<br>&#9;&#9;&#9;continue;<br><br>&#9;&#9;j = InStr(Mask, "*");<br>&#9;&#9;if(j != -1)<br>&#9;&#9;{<br>&#9;&#9;&#9;if(Left(Mask, j) == Left(Address, j))<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;bAcceptAddress = bAcceptPolicy;<br>&#9;&#9;&#9;&#9;LastMatchingPolicy = i;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;if(Mask == Address)<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;bAcceptAddress = bAcceptPolicy;<br>&#9;&#9;&#9;&#9;LastMatchingPolicy = i;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;}<br><br>&#9;if(!bAcceptAddress)<br>&#9;&#9;Log("Denied connection for "$Address$" with IP policy "$IPPolicies[LastMatchingPolicy]);<br>&#9;&#9;<br>&#9;return bAcceptAddress;<br><br></div>
<h3 id="GameInfo.CreatureKillMessage"><a class="headerlink" href="#GameInfo.CreatureKillMessage" title="Permanent link">CreatureKillMessage</a> (name damageType, pawn Other) -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return " was killed by a ";<br><br></div>
<h3 id="GameInfo.DetailChange"><a class="headerlink" href="#GameInfo.DetailChange" title="Permanent link">DetailChange</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor A;<br>&#9;local zoneinfo Z;<br>&#9;local skyzoneinfo S;<br><br>&#9;if( !Level.bHighDetailMode )<br>&#9;{<br>&#9;&#9;foreach AllActors(class'Actor', A)<br>&#9;&#9;{<br>&#9;&#9;&#9;if( A.bHighDetail && !A.bGameRelevant )<br>&#9;&#9;&#9;&#9;A.Destroy();<br>&#9;&#9;}<br>&#9;}<br>&#9;foreach AllActors(class'ZoneInfo', Z)<br>&#9;&#9;Z.LinkToSkybox();<br><br></div>
<h3 id="GameInfo.DiscardInventory"><a class="headerlink" href="#GameInfo.DiscardInventory" title="Permanent link">DiscardInventory</a> (Pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor dropped;<br>&#9;local inventory Inv;<br>&#9;local weapon weap;<br>&#9;local float speed;<br><br><br>&#9;if( Other.DropWhenKilled != None )<br>&#9;{<br>&#9;&#9;dropped = Spawn(Other.DropWhenKilled,,,Other.Location);<br>&#9;&#9;Inv = Inventory(dropped);<br>&#9;&#9;if ( Inv != None )<br>&#9;&#9;{ <br>&#9;&#9;&#9;Inv.RespawnTime = 0.0; //don't respawn<br>&#9;&#9;&#9;Inv.BecomePickup();&#9;&#9;<br>&#9;&#9;}<br>&#9;&#9;if ( dropped != None )<br>&#9;&#9;{<br>&#9;&#9;&#9;dropped.RemoteRole = ROLE_DumbProxy;<br>&#9;&#9;&#9;dropped.SetPhysics(PHYS_Falling);<br>&#9;&#9;&#9;dropped.bCollideWorld = true;<br>&#9;&#9;&#9;dropped.Velocity = Other.Velocity + VRand() * 280;<br>&#9;&#9;}<br>&#9;&#9;if ( Inv != None )<br>&#9;&#9;&#9;Inv.GotoState('PickUp', 'Dropped');<br>&#9;}&#9;&#9;&#9;&#9;&#9;<br>&#9;if( (Other.Weapon!=None) && (Other.Weapon.Class!=Level.Game.BaseMutator.MutatedDefaultWeapon()) <br>&#9;&#9;&& Other.Weapon.bCanThrow )<br>&#9;{<br>&#9;&#9;speed = VSize(Other.Velocity);<br>&#9;&#9;weap = Other.Weapon;<br>&#9;&#9;if (speed != 0)<br>&#9;&#9;&#9;weap.Velocity = Normal(Other.Velocity/speed + 0.5 * VRand()) * (speed + 280);<br>&#9;&#9;else {<br>&#9;&#9;&#9;weap.Velocity.X = 0;<br>&#9;&#9;&#9;weap.Velocity.Y = 0;<br>&#9;&#9;&#9;weap.Velocity.Z = 0;<br>&#9;&#9;}<br>&#9;&#9;Other.TossWeapon();<br>&#9;&#9;if ( weap.PickupAmmoCount == 0 )<br>&#9;&#9;&#9;weap.PickupAmmoCount = 1;<br>&#9;<br></div>
<h3 id="GameInfo.EndGame"><a class="headerlink" href="#GameInfo.EndGame" title="Permanent link">EndGame</a> (string Reason)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor A;<br><br><br>&#9;// don't end game if not really ready<br>&#9;if ( !SetEndCams(Reason) )<br>&#9;{<br>&#9;&#9;bOverTime = true;<br>&#9;&#9;return;<br>&#9;}<br>&#9;bGameEnded = true;<br>&#9;foreach AllActors(class'Actor', A, 'EndGame')<br>&#9;&#9;A.trigger(self, none);<br><br>&#9;if (LocalLog != None)<br>&#9;{<br>&#9;&#9;LocalLog.LogGameEnd(Reason);<br>&#9;&#9;LocalLog.StopLog();<br>&#9;&#9;if (bBatchLocal)<br>&#9;&#9;&#9;LocalLog.ExecuteSilentLogBatcher();<br>&#9;&#9;LocalLog.Destroy();<br>&#9;&#9;LocalLog = None;<br>&#9;}<br>&#9;if (WorldLog != None)<br>&#9;{<br>&#9;&#9;WorldLog.LogGameEnd(Reason);<br>&#9;&#9;WorldLog.StopLog();<br>&#9;&#9;WorldLog.ExecuteWorldLogBatcher();<br>&#9;&#9;WorldLog.Destroy();<br>&#9;&#9;WorldLog = None;<br>&#9;}<br><br></div>
<h3 id="GameInfo.FindPlayerStart"><a class="headerlink" href="#GameInfo.FindPlayerStart" title="Permanent link">FindPlayerStart</a> (Pawn Player, optional byte InTeam, optional string incomingName) -> NavigationPoint</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local PlayerStart Dest;<br>&#9;local Teleporter Tel;<br><br>&#9;if( incomingName!="" )<br>&#9;&#9;foreach AllActors( class 'Teleporter', Tel )<br>&#9;&#9;&#9;if( string(Tel.Tag)~=incomingName )<br>&#9;&#9;&#9;&#9;return Tel;<br>&#9;foreach AllActors( class 'PlayerStart', Dest )<br>&#9;&#9;if( Dest.bSinglePlayerStart && Dest.bEnabled )<br>&#9;&#9;&#9;return Dest;<br><br>&#9;// if none, check for any that aren't enabled<br>&#9;log("WARNING: All single player starts were disabled - picking one anyway!");<br>&#9;foreach AllActors( class 'PlayerStart', Dest )<br>&#9;&#9;if( Dest.bSinglePlayerStart )<br>&#9;&#9;&#9;return Dest;<br>&#9;log( "No single player start found" );<br>&#9;return None;<br><br></div>
<h3 id="GameInfo.ForceAddBot"><a class="headerlink" href="#GameInfo.ForceAddBot" title="Permanent link">ForceAddBot</a> -> bool</h3>

<h3 id="GameInfo.GameEnding"><a class="headerlink" href="#GameInfo.GameEnding" title="Permanent link">GameEnding</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (LocalLog != None)<br>&#9;{<br>&#9;&#9;LocalLog.LogGameEnd("serverquit");<br>&#9;&#9;LocalLog.StopLog();<br>&#9;&#9;LocalLog.Destroy();<br>&#9;&#9;LocalLog = None;<br>&#9;}<br><br>&#9;if (WorldLog != None)<br>&#9;{<br>&#9;&#9;WorldLog.LogGameEnd("serverquit");<br>&#9;&#9;WorldLog.StopLog();<br>&#9;&#9;WorldLog.Destroy();<br>&#9;&#9;WorldLog = None;<br>&#9;}<br><br></div>
<h3 id="GameInfo.GetBeaconText"><a class="headerlink" href="#GameInfo.GetBeaconText" title="Permanent link">GetBeaconText</a> -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre">&#9;<br>&#9;return<br>&#9;&#9;Level.ComputerName<br>&#9;$&#9;" "<br>&#9;$&#9;Left(Level.Title,24) <br>&#9;$&#9;" "<br>&#9;$&#9;BeaconName<br>&#9;$&#9;" "<br>&#9;$&#9;NumPlayers<br>&#9;$&#9;"/"<br>&#9;$&#9;MaxPlayers;<br><br></div>
<h3 id="GameInfo.GetInfo"><a class="headerlink" href="#GameInfo.GetInfo" title="Permanent link">GetInfo</a> -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string ResultSet;<br><br><br>&#9;if (GamePassword != "")<br>&#9;&#9;ResultSet = "\\password\\True";<br>&#9;else<br>&#9;&#9;ResultSet = "\\password\\False";<br><br><br>&#9;return ResultSet;<br><br></div>
<h3 id="GameInfo.GetIntOption"><a class="headerlink" href="#GameInfo.GetIntOption" title="Permanent link">GetIntOption</a> (string Options, string ParseString, int CurrentValue) -> int</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string InOpt;<br><br><br>&#9;InOpt = ParseOption( Options, ParseString );<br>&#9;if ( InOpt != "" )<br>&#9;{<br>&#9;&#9;log(ParseString@InOpt);<br>&#9;&#9;return int(InOpt);<br>&#9;}&#9;<br>&#9;return CurrentValue;<br><br></div>
<h3 id="GameInfo.GetKeyValue"><a class="headerlink" href="#GameInfo.GetKeyValue" title="Permanent link">GetKeyValue</a> (string Pair, out string Key, out string Value)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( InStr(Pair,"=")>=0 )<br>&#9;{<br>&#9;&#9;Key   = Left(Pair,InStr(Pair,"="));<br>&#9;&#9;Value = Mid(Pair,InStr(Pair,"=")+1);<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;Key   = Pair;<br>&#9;&#9;Value = "";<br>&#9;}<br><br></div>
<h3 id="GameInfo.GetNetworkNumber"><a class="headerlink" href="#GameInfo.GetNetworkNumber" title="Permanent link">GetNetworkNumber</a> -> string | native</h3>

<h3 id="GameInfo.GetRules"><a class="headerlink" href="#GameInfo.GetRules" title="Permanent link">GetRules</a> -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string ResultSet;<br>&#9;local Mutator M;<br>&#9;local string NextMutator, NextDesc;<br>&#9;local string EnabledMutators;<br>&#9;local int Num, i;<br><br><br>&#9;ResultSet = "";<br><br>&#9;EnabledMutators = "";<br>&#9;for (M = BaseMutator.NextMutator; M != None; M = M.NextMutator)<br>&#9;{<br>&#9;&#9;Num = 0;<br>&#9;&#9;NextMutator = "";<br>&#9;&#9;GetNextIntDesc("Engine.Mutator", 0, NextMutator, NextDesc);<br>&#9;&#9;while( (NextMutator != "") && (Num < 50) )<br>&#9;&#9;{<br>&#9;&#9;&#9;if(NextMutator ~= string(M.Class))<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;i = InStr(NextDesc, ",");<br>&#9;&#9;&#9;&#9;if(i != -1)<br>&#9;&#9;&#9;&#9;&#9;NextDesc = Left(NextDesc, i);<br><br>&#9;&#9;&#9;&#9;if(EnabledMutators != "")<br>&#9;&#9;&#9;&#9;&#9;EnabledMutators = EnabledMutators $ ", ";<br>&#9;&#9;&#9;&#9; EnabledMutators = EnabledMutators $ NextDesc;<br>&#9;&#9;&#9;&#9; break;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;<br>&#9;&#9;&#9;Num++;<br>&#9;&#9;&#9;GetNextIntDesc("Engine.Mutator", Num, NextMutator, NextDesc);<br>&#9;&#9;}<br>&#9;}<br>&#9;if(EnabledMutators != "")<br>&#9;&#9;ResultSet = ResultSet $ "\\mutators\\"$EnabledMutators;<br><br>&#9;ResultSet = ResultSet $ "\\listenserver\\"$string(Level.NetMode==NM_ListenServer);<br><br>&#9;if (GamePassword != "")<br>&#9;&#9;ResultSet = ResultSet $ "\\password\\True";<br>&#9;else<br>&#9;&#9;ResultSet = ResultSet $ "\\password\\False";<br><br>&#9;return ResultSet;<br><br></div>
<h3 id="GameInfo.GetServerPort"><a class="headerlink" href="#GameInfo.GetServerPort" title="Permanent link">GetServerPort</a> -> int</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string S;<br>&#9;local int i;<br><br><br>&#9;// Figure out the server's port.<br>&#9;S = Level.GetAddressURL();<br>&#9;i = InStr( S, ":" );<br>&#9;assert(i>=0);<br>&#9;return int(Mid(S,i+1));<br><br></div>
<h3 id="GameInfo.GrabOption"><a class="headerlink" href="#GameInfo.GrabOption" title="Permanent link">GrabOption</a> (out string Options, out string Result) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Left(Options,1)=="?" )<br>&#9;{<br>&#9;&#9;// Get result.<br>&#9;&#9;Result = Mid(Options,1);<br>&#9;&#9;if( InStr(Result,"?")>=0 )<br>&#9;&#9;&#9;Result = Left( Result, InStr(Result,"?") );<br><br>&#9;&#9;// Update options.<br>&#9;&#9;Options = Mid(Options,1);<br>&#9;&#9;if( InStr(Options,"?")>=0 )<br>&#9;&#9;&#9;Options = Mid( Options, InStr(Options,"?") );<br>&#9;&#9;else<br>&#9;&#9;&#9;Options = "";<br><br>&#9;&#9;return true;<br>&#9;}<br>&#9;else return false;<br><br></div>
<h3 id="GameInfo.HasOption"><a class="headerlink" href="#GameInfo.HasOption" title="Permanent link">HasOption</a> (string Options, string InKey) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string Pair, Key, Value;<br><br>&#9;while( GrabOption( Options, Pair ) )<br>&#9;{<br>&#9;&#9;GetKeyValue( Pair, Key, Value );<br>&#9;&#9;if( Key ~= InKey )<br>&#9;&#9;&#9;return true;<br>&#9;}<br>&#9;return false;<br><br></div>
<h3 id="GameInfo.InitGame"><a class="headerlink" href="#GameInfo.InitGame" title="Permanent link">InitGame</a> (string Options, out string Error)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string InOpt, LeftOpt;<br>&#9;local int pos;<br>&#9;local class<Mutator> MClass;<br><br><br>&#9;log( "InitGame:" @ Options );<br>&#9;MaxPlayers = Min( 32,GetIntOption( Options, "MaxPlayers", MaxPlayers ));<br>&#9;InOpt = ParseOption( Options, "Difficulty" );<br>&#9;if( InOpt != "" )<br>&#9;&#9;Difficulty = int(InOpt);<br><br>&#9;InOpt = ParseOption( Options, "AdminPassword");<br>&#9;if( InOpt!="" )<br>&#9;&#9;AdminPassword = InOpt;<br><br>&#9;InOpt = ParseOption( Options, "GameSpeed");<br>&#9;if( InOpt != "" )<br>&#9;{<br>&#9;&#9;log("GameSpeed"@InOpt);<br>&#9;&#9;SetGameSpeed(float(InOpt));<br>&#9;}<br><br>&#9;BaseMutator = spawn(MutatorClass);<br>&#9;log("Base Mutator is "$BaseMutator);<br>&#9;InOpt = ParseOption( Options, "Mutator");<br>&#9;if ( InOpt != "" )<br>&#9;{<br>&#9;&#9;log("Mutators"@InOpt);<br>&#9;&#9;while ( InOpt != "" )<br>&#9;&#9;{<br>&#9;&#9;&#9;pos = InStr(InOpt,",");<br>&#9;&#9;&#9;if ( pos > 0 )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;LeftOpt = Left(InOpt, pos);<br>&#9;&#9;&#9;&#9;InOpt = Right(InOpt, Len(InOpt) - pos - 1);<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;LeftOpt = InOpt;<br>&#9;&#9;&#9;&#9;InOpt = "";<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;log("Add mutator "$LeftOpt);<br>&#9;&#9;&#9;MClass = class<Mutator>(DynamicLoadObject(LeftOpt, class'Class'));&#9;<br>&#9;&#9;&#9;BaseMutator.AddMutator(Spawn(MClass));<br>&#9;&#9;}<br>&#9;}<br><br>&#9;InOpt = ParseOption( Options, "GamePassword");<br>&#9;if( InOpt != "" )<br>&#9;{<br>&#9;&#9;GamePassWord = InOpt;<br>&#9;&#9;log( "GamePassword" @ InOpt );<br>&#9;}<br><br>&#9;InOpt = ParseOption( Options, "LocalLog");<br>&#9;if( InOpt ~= "true" )<br>&#9;&#9;bLocalLog = True;<br><br>&#9;InOpt = ParseOption( Options, "WorldLog");<br>&#9;if( InOpt ~= "true" )<br>&#9;&#9;bWorldLog = True;<br><br></div>
<h3 id="GameInfo.InitGameReplicationInfo"><a class="headerlink" href="#GameInfo.InitGameReplicationInfo" title="Permanent link">InitGameReplicationInfo</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;GameReplicationInfo.bTeamGame = bTeamGame;<br>&#9;GameReplicationInfo.GameName = GameName;<br>&#9;GameReplicationInfo.GameClass = string(Class);<br>&#9;GameReplicationInfo.bClassicDeathmessages = bClassicDeathmessages;<br><br></div>
<h3 id="GameInfo.InitLogging"><a class="headerlink" href="#GameInfo.InitLogging" title="Permanent link">InitLogging</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Mutator M;<br><br><br>&#9;if (bLocalLog && bLoggingGame)<br>&#9;{<br>&#9;&#9;Log("Initiating local logging...");<br>&#9;&#9;LocalLog = spawn(StatLogClass);<br>&#9;&#9;LocalLog.bWorld = False;<br>&#9;&#9;LocalLog.StartLog();<br>&#9;&#9;LocalLog.LogStandardInfo();<br>&#9;&#9;LocalLog.LogServerInfo();<br>&#9;&#9;LocalLog.LogMapParameters();<br>&#9;&#9;for (M = BaseMutator; M != None; M = M.NextMutator)<br>&#9;&#9;&#9;LocalLog.LogMutator(M);<br>&#9;&#9;LogGameParameters(LocalLog);<br>&#9;&#9;LocalLogFileName = LocalLog.GetLogFileName();<br>&#9;}<br><br>&#9;// Setup world statistics logging.<br>&#9;if ((Level.NetMode != NM_DedicatedServer) && (Level.NetMode != NM_ListenServer))<br>&#9;&#9;return;<br><br>&#9;if (bWorldLog && bLoggingGame)<br>&#9;{<br>&#9;&#9;Log("Initiating world logging...");<br>&#9;&#9;WorldLog = spawn(StatLogClass);<br>&#9;&#9;WorldLog.bWorld = True;<br>&#9;&#9;WorldLog.StartLog();<br>&#9;&#9;WorldLog.LogStandardInfo();<br>&#9;&#9;WorldLog.LogServerInfo();<br>&#9;&#9;WorldLog.LogMapParameters();<br>&#9;&#9;WorldLog.InitialCheck(Self);<br>&#9;&#9;for (M = BaseMutator; M != None; M = M.NextMutator)<br>&#9;&#9;&#9;WorldLog.LogMutator(M);<br>&#9;&#9;LogGameParameters(WorldLog);<br>&#9;&#9;WorldLogFileName = WorldLog.GetLogFileName();<br>&#9;}<br><br></div>
<h3 id="GameInfo.IsRelevant"><a class="headerlink" href="#GameInfo.IsRelevant" title="Permanent link">IsRelevant</a> (actor Other) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local byte bSuperRelevant;<br><br><br>&#9;// let the mutators mutate the actor or choose to remove it<br>&#9;if ( BaseMutator.AlwaysKeep(Other) )<br>&#9;&#9;return true;<br>&#9;if ( BaseMutator.IsRelevant(Other, bSuperRelevant) )<br>&#9;{<br>&#9;&#9;if ( bSuperRelevant == 1 ) // mutator wants to override any logic in here<br>&#9;&#9;&#9;return true;<br>&#9;}<br>&#9;else return false;<br><br>&#9;if<br>&#9;(&#9;(Difficulty==0 && !Other.bDifficulty0 )<br>&#9;||  (Difficulty==1 && !Other.bDifficulty1 )<br>&#9;||  (Difficulty==2 && !Other.bDifficulty2 )<br>&#9;||  (Difficulty==3 && !Other.bDifficulty3 )<br>&#9;||  (!Other.bSinglePlayer && (Level.NetMode==NM_Standalone) ) <br>&#9;||  (!Other.bNet && ((Level.NetMode == NM_DedicatedServer) || (Level.NetMode == NM_ListenServer)) )<br>&#9;||  (!Other.bNetSpecial  && (Level.NetMode==NM_Client)) )<br>&#9;&#9;return False;<br><br>&#9;if( bNoMonsters && (Pawn(Other) != None) && !Pawn(Other).bIsPlayer )<br>&#9;&#9;return False;<br><br>&#9;if( FRand() > Other.OddsOfAppearing )<br>&#9;&#9;return False;<br><br>    // Update the level info goal counts.<br>    if( Other.bIsSecretGoal )<br>       SecretGoals++;<br><br>    if( Other.bIsItemGoal )<br>       ItemGoals++;<br><br>    if( Other.bIsKillGoal )<br>       KillGoals++;<br><br>&#9;return True;<br><br></div>
<h3 id="GameInfo.KillMessage"><a class="headerlink" href="#GameInfo.KillMessage" title="Permanent link">KillMessage</a> (name damageType, pawn Other) -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return " died.";<br><br></div>
<h3 id="GameInfo.Killed"><a class="headerlink" href="#GameInfo.Killed" title="Permanent link">Killed</a> (pawn Killer, pawn Other, name damageType)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local String Message, KillerWeapon, OtherWeapon;<br>&#9;local bool bSpecialDamage;<br><br><br>&#9;if (Other.bIsPlayer)<br>&#9;{<br>&#9;&#9;if ( (Killer != None) && (!Killer.bIsPlayer) )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( Level.NetMode != NM_Standalone )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;Message = Other.PlayerReplicationInfo.PlayerName$Killer.KillMessage(damageType, Other);<br>&#9;&#9;&#9;&#9;BroadcastMessage( Message, false, 'DeathMessage');<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;if ( LocalLog != None )<br>&#9;&#9;&#9;&#9;LocalLog.LogSuicide(Other, DamageType, None);<br>&#9;&#9;&#9;if ( WorldLog != None )<br>&#9;&#9;&#9;&#9;WorldLog.LogSuicide(Other, DamageType, None);<br>&#9;&#9;&#9;return;<br>&#9;&#9;}<br>&#9;&#9;if ( (DamageType == 'SpecialDamage') && (SpecialDamageString != "") )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( Level.NetMode != NM_Standalone )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;BroadcastMessage( ParseKillMessage(<br>&#9;&#9;&#9;&#9;&#9;&#9;Killer.PlayerReplicationInfo.PlayerName,<br>&#9;&#9;&#9;&#9;&#9;&#9;Other.PlayerReplicationInfo.PlayerName,<br>&#9;&#9;&#9;&#9;&#9;&#9;Killer.Weapon.ItemName,<br>&#9;&#9;&#9;&#9;&#9;&#9;SpecialDamageString<br>&#9;&#9;&#9;&#9;&#9;&#9;),<br>&#9;&#9;&#9;&#9;&#9;false, 'DeathMessage');<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;bSpecialDamage = True;<br>&#9;&#9;}<br>&#9;&#9;if ( (Killer == Other) || (Killer == None) )<br>&#9;&#9;{<br>&#9;&#9;&#9;// Suicide<br>&#9;&#9;&#9;if (damageType == '')<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( LocalLog != None )<br>&#9;&#9;&#9;&#9;&#9;LocalLog.LogSuicide(Other, 'Unknown', Killer);<br>&#9;&#9;&#9;&#9;if ( WorldLog != None )<br>&#9;&#9;&#9;&#9;&#9;WorldLog.LogSuicide(Other, 'Unknown', Killer);<br>&#9;&#9;&#9;} else {<br>&#9;&#9;&#9;&#9;if ( LocalLog != None )<br>&#9;&#9;&#9;&#9;&#9;LocalLog.LogSuicide(Other, damageType, Killer);<br>&#9;&#9;&#9;&#9;if ( WorldLog != None )<br>&#9;&#9;&#9;&#9;&#9;WorldLog.LogSuicide(Other, damageType, Killer);<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;if (!bSpecialDamage)<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( damageType == 'Fell' )<br>&#9;&#9;&#9;&#9;&#9;BroadcastLocalizedMessage(DeathMessageClass, 2, Other.PlayerReplicationInfo, None);<br>&#9;&#9;&#9;&#9;else if ( damageType == 'Eradicated' )<br>&#9;&#9;&#9;&#9;&#9;BroadcastLocalizedMessage(DeathMessageClass, 3, Other.PlayerReplicationInfo, None);<br>&#9;&#9;&#9;&#9;else if ( damageType == 'Drowned' )<br>&#9;&#9;&#9;&#9;&#9;BroadcastLocalizedMessage(DeathMessageClass, 4, Other.PlayerReplicationInfo, None);<br>&#9;&#9;&#9;&#9;else if ( damageType == 'Burned' )<br>&#9;&#9;&#9;&#9;&#9;BroadcastLocalizedMessage(DeathMessageClass, 5, Other.PlayerReplicationInfo, None);<br>&#9;&#9;&#9;&#9;else if ( damageType == 'Corroded' )<br>&#9;&#9;&#9;&#9;&#9;BroadcastLocalizedMessage(DeathMessageClass, 6, Other.PlayerReplicationInfo, None);<br>&#9;&#9;&#9;&#9;else if ( damageType == 'Mortared' )<br>&#9;&#9;&#9;&#9;&#9;BroadcastLocalizedMessage(DeathMessageClass, 7, Other.PlayerReplicationInfo, None);<br>&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;&#9;BroadcastLocalizedMessage(DeathMessageClass, 1, Other.PlayerReplicationInfo, None);<br>&#9;&#9;&#9;}<br>&#9;&#9;} <br>&#9;&#9;else <br>&#9;&#9;{<br>&#9;&#9;&#9;// Increment deaths if you were killed by another player. (But not for suicides.)<br>&#9;&#9;&#9;Other.PlayerReplicationInfo.Deaths += 1;<br>&#9;&#9;&#9;if ( Killer.bIsPlayer )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;KillerWeapon = "None";<br>&#9;&#9;&#9;&#9;if (Killer.Weapon != None)<br>&#9;&#9;&#9;&#9;&#9;KillerWeapon = Killer.Weapon.ItemName;<br>&#9;&#9;&#9;&#9;OtherWeapon = "None";<br>&#9;&#9;&#9;&#9;if (Other.Weapon != None)<br>&#9;&#9;&#9;&#9;&#9;OtherWeapon = Other.Weapon.ItemName;<br>&#9;&#9;&#9;&#9;if ( Killer.PlayerReplicationInfo.Team == Other.PlayerReplicationInfo.Team )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;if ( LocalLog != None )<br>&#9;&#9;&#9;&#9;&#9;&#9;LocalLog.LogTeamKill(<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Killer.PlayerReplicationInfo.PlayerID,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Other.PlayerReplicationInfo.PlayerID,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;KillerWeapon,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;OtherWeapon,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;damageType<br>&#9;&#9;&#9;&#9;&#9;&#9;);<br>&#9;&#9;&#9;&#9;&#9;if ( WorldLog != None )<br>&#9;&#9;&#9;&#9;&#9;&#9;WorldLog.LogTeamKill(<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Killer.PlayerReplicationInfo.PlayerID,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Other.PlayerReplicationInfo.PlayerID,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;KillerWeapon,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;OtherWeapon,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;damageType<br>&#9;&#9;&#9;&#9;&#9;&#9;);<br>&#9;&#9;&#9;&#9;} else {<br>&#9;&#9;&#9;&#9;&#9;if ( LocalLog != None )<br>&#9;&#9;&#9;&#9;&#9;&#9;LocalLog.LogKill(<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Killer.PlayerReplicationInfo.PlayerID,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Other.PlayerReplicationInfo.PlayerID,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;KillerWeapon,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;OtherWeapon,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;damageType<br>&#9;&#9;&#9;&#9;&#9;&#9;);<br>&#9;&#9;&#9;&#9;&#9;if ( WorldLog != None )<br>&#9;&#9;&#9;&#9;&#9;&#9;WorldLog.LogKill(<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Killer.PlayerReplicationInfo.PlayerID,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Other.PlayerReplicationInfo.PlayerID,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;KillerWeapon,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;OtherWeapon,<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;damageType<br>&#9;&#9;&#9;&#9;&#9;&#9;);<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;if (!bSpecialDamage && (Other != None))<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;BroadcastRegularDeathMessage(Killer, Other, damageType);<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;}<br>&#9;&#9;<br></div>
<h3 id="GameInfo.LogGameParameters"><a class="headerlink" href="#GameInfo.LogGameParameters" title="Permanent link">LogGameParameters</a> (StatLog StatLog)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (StatLog == None)<br>&#9;&#9;return;<br><br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"GameName"$Chr(9)$GameName);<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"GameClass"$Chr(9)$Class);// <-- Move to c++<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"GameVersion"$Chr(9)$Level.EngineVersion);<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"MinNetVersion"$Chr(9)$Level.MinNetVersion);<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"NoMonsters"$Chr(9)$bNoMonsters);<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"MuteSpectators"$Chr(9)$bMuteSpectators);<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"HumansOnly"$Chr(9)$bHumansOnly);<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"WeaponsStay"$Chr(9)$bCoopWeaponMode);<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"ClassicDeathmessages"$Chr(9)$bClassicDeathmessages);<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"LowGore"$Chr(9)$bLowGore);<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"VeryLowGore"$Chr(9)$bVeryLowGore);<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"TeamGame"$Chr(9)$bTeamGame);<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"GameSpeed"$Chr(9)$int(GameSpeed*100));<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"MaxSpectators"$Chr(9)$MaxSpectators);<br>&#9;StatLog.LogEventString(StatLog.GetTimeStamp()$Chr(9)$"game"$Chr(9)$"MaxPlayers"$Chr(9)$MaxPlayers);<br><br></div>
<h3 id="GameInfo.Logout"><a class="headerlink" href="#GameInfo.Logout" title="Permanent link">Logout</a> (pawn Exiting)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local bool bMessage;<br><br><br>&#9;bMessage = true;<br>&#9;if ( Exiting.IsA('PlayerPawn') )<br>&#9;{<br>&#9;&#9;if ( Exiting.IsA('Spectator') )<br>&#9;&#9;{<br>&#9;&#9;&#9;bMessage = false;<br>&#9;&#9;&#9;if ( Level.NetMode == NM_DedicatedServer )<br>&#9;&#9;&#9;&#9;NumSpectators--;<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;&#9;NumPlayers--;<br>&#9;}<br>&#9;if( bMessage && (Level.NetMode==NM_DedicatedServer || Level.NetMode==NM_ListenServer) )<br>&#9;&#9;BroadcastMessage( Exiting.PlayerReplicationInfo.PlayerName$LeftMessage, false );<br><br>&#9;if ( LocalLog != None )<br>&#9;&#9;LocalLog.LogPlayerDisconnect(Exiting);<br>&#9;if ( WorldLog != None )<br>&#9;&#9;WorldLog.LogPlayerDisconnect(Exiting);<br><br></div>
<h3 id="GameInfo.ParseKillMessage"><a class="headerlink" href="#GameInfo.ParseKillMessage" title="Permanent link">ParseKillMessage</a> (string KillerName, string VictimName, string WeaponName, string DeathMessage) -> string</h3>

<h3 id="GameInfo.ParseOption"><a class="headerlink" href="#GameInfo.ParseOption" title="Permanent link">ParseOption</a> (string Options, string InKey) -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string Pair, Key, Value;<br><br>&#9;while( GrabOption( Options, Pair ) )<br>&#9;{<br>&#9;&#9;GetKeyValue( Pair, Key, Value );<br>&#9;&#9;if( Key ~= InKey )<br>&#9;&#9;&#9;return Value;<br>&#9;}<br>&#9;return "";<br><br></div>
<h3 id="GameInfo.PickupQuery"><a class="headerlink" href="#GameInfo.PickupQuery" title="Permanent link">PickupQuery</a> (Pawn Other, Inventory item) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Other.Inventory == None )<br>&#9;&#9;return true;<br>&#9;else<br>&#9;&#9;return !Other.Inventory.HandlePickupQuery(Item);<br><br></div>
<h3 id="GameInfo.PlaySpawnEffect"><a class="headerlink" href="#GameInfo.PlaySpawnEffect" title="Permanent link">PlaySpawnEffect</a> (inventory Inv) -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return 0.3;<br><br></div>
<h3 id="GameInfo.PlayTeleportEffect"><a class="headerlink" href="#GameInfo.PlayTeleportEffect" title="Permanent link">PlayTeleportEffect</a> (actor Incoming, bool bOut, bool bSound)</h3>

<h3 id="GameInfo.PlayerJumpZScaling"><a class="headerlink" href="#GameInfo.PlayerJumpZScaling" title="Permanent link">PlayerJumpZScaling</a> -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return 1.0;<br><br></div>
<h3 id="GameInfo.PlayerKillMessage"><a class="headerlink" href="#GameInfo.PlayerKillMessage" title="Permanent link">PlayerKillMessage</a> (name damageType, PlayerReplicationInfo Other) -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string message;<br><br><br>&#9;message = " was killed by ";<br>&#9;return message;<br><br></div>
<h3 id="GameInfo.PostBeginPlay"><a class="headerlink" href="#GameInfo.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local ZoneInfo W;<br><br><br>&#9;if ( bAlternateMode )<br>&#9;{<br>&#9;&#9;bLowGore = true;<br>&#9;&#9;bVeryLowGore = true;<br>&#9;}<br><br>&#9;if ( bVeryLowGore )<br>&#9;&#9;bLowGore = true;<br><br>&#9;if ( WaterZoneType != None )<br>&#9;{<br>&#9;&#9;ForEach AllActors(class'ZoneInfo', W )<br>&#9;&#9;&#9;if ( W.bWaterZone )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if( W.EntryActor == None )<br>&#9;&#9;&#9;&#9;&#9;W.EntryActor = WaterZoneType.Default.EntryActor;<br>&#9;&#9;&#9;&#9;if( W.ExitActor == None )<br>&#9;&#9;&#9;&#9;&#9;W.ExitActor = WaterZoneType.Default.ExitActor;<br>&#9;&#9;&#9;&#9;if( W.EntrySound == None )<br>&#9;&#9;&#9;&#9;&#9;W.EntrySound = WaterZoneType.Default.EntrySound;<br>&#9;&#9;&#9;&#9;if( W.ExitSound == None )<br>&#9;&#9;&#9;&#9;&#9;W.ExitSound = WaterZoneType.Default.ExitSound;<br>&#9;&#9;&#9;}<br>&#9;}<br><br>&#9;// Setup local statistics logging.<br>&#9;InitLogging();<br><br>&#9;Super.PostBeginPlay();<br><br></div>
<h3 id="GameInfo.PostLogin"><a class="headerlink" href="#GameInfo.PostLogin" title="Permanent link">PostLogin</a> (playerpawn NewPlayer)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br><br>&#9;// Start player's music.<br>&#9;NewPlayer.ClientSetMusic( Level.Song, Level.SongSection, Level.CdTrack, MTRAN_Fade );<br>&#9;if ( Level.NetMode != NM_Standalone )<br>&#9;{<br>&#9;&#9;// replicate skins<br>&#9;&#9;for ( P=Level.PawnList; P!=None; P=P.NextPawn )<br>&#9;&#9;&#9;if ( P.bIsPlayer && (P != NewPlayer) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( P.bIsMultiSkinned )<br>&#9;&#9;&#9;&#9;&#9;NewPlayer.ClientReplicateSkins(P.MultiSkins[0], P.MultiSkins[1], P.MultiSkins[2], P.MultiSkins[3]);<br>&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;&#9;NewPlayer.ClientReplicateSkins(P.Skin);&#9;<br>&#9;&#9;&#9;&#9;&#9;<br>&#9;&#9;&#9;&#9;if ( (P.PlayerReplicationInfo != None) && P.PlayerReplicationInfo.bWaitingPlayer && P.IsA('PlayerPawn') )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;if ( NewPlayer.bIsMultiSkinned )<br>&#9;&#9;&#9;&#9;&#9;&#9;PlayerPawn(P).ClientReplicateSkins(NewPlayer.MultiSkins[0], NewPlayer.MultiSkins[1], NewPlayer.MultiSkins[2], NewPlayer.MultiSkins[3]);<br>&#9;&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;&#9;&#9;PlayerPawn(P).ClientReplicateSkins(NewPlayer.Skin);&#9;<br>&#9;&#9;&#9;&#9;}&#9;&#9;&#9;&#9;&#9;&#9;<br>&#9;&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="GameInfo.PreBeginPlay"><a class="headerlink" href="#GameInfo.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;StartTime = 0;<br>&#9;SetGameSpeed(GameSpeed);<br>&#9;Level.bNoCheating = bNoCheating;<br>&#9;Level.bAllowFOV = bAllowFOV;<br>&#9;<br>&#9;if (GameReplicationInfoClass != None)<br>&#9;&#9;GameReplicationInfo = Spawn(GameReplicationInfoClass);<br>&#9;else<br>&#9;&#9;GameReplicationInfo = Spawn(class'GameReplicationInfo');<br>&#9;InitGameReplicationInfo();<br><br></div>
<h3 id="GameInfo.ProcessServerTravel"><a class="headerlink" href="#GameInfo.ProcessServerTravel" title="Permanent link">ProcessServerTravel</a> (string URL, bool bItems)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local playerpawn P, LocalPlayer;<br><br><br>&#9;if (LocalLog != None)<br>&#9;{<br>&#9;&#9;LocalLog.LogGameEnd("mapchange");<br>&#9;&#9;LocalLog.StopLog();<br>&#9;&#9;LocalLog.Destroy();<br>&#9;&#9;LocalLog = None;<br>&#9;}<br><br>&#9;if (WorldLog != None)<br>&#9;{<br>&#9;&#9;WorldLog.LogGameEnd("mapchange");<br>&#9;&#9;WorldLog.StopLog();<br>&#9;&#9;WorldLog.Destroy();<br>&#9;&#9;WorldLog = None;<br>&#9;}<br><br>&#9;// Notify clients we're switching level and give them time to receive.<br>&#9;// We call PreClientTravel directly on any local PlayerPawns (ie listen server)<br>&#9;log("ProcessServerTravel:"@URL);<br>&#9;foreach AllActors( class'PlayerPawn', P )<br>&#9;&#9;if( NetConnection(P.Player)!=None )<br>&#9;&#9;&#9;P.ClientTravel( URL, TRAVEL_Relative, bItems );<br>&#9;&#9;else<br>&#9;&#9;{&#9;<br>&#9;&#9;&#9;LocalPlayer = P;<br>&#9;&#9;&#9;P.PreClientTravel();<br>&#9;&#9;}<br><br>&#9;if ( (Level.NetMode == NM_ListenServer) && (LocalPlayer != None) )<br>&#9;&#9;Level.NextURL = Level.NextURL$"?Skin="$LocalPlayer.GetDefaultURL("Skin")<br>&#9;&#9;&#9;&#9;&#9; $"?Face="$LocalPlayer.GetDefaultURL("Face")<br>&#9;&#9;&#9;&#9;&#9; $"?Team="$LocalPlayer.GetDefaultURL("Team")<br>&#9;&#9;&#9;&#9;&#9; $"?Name="$LocalPlayer.GetDefaultURL("Name")<br>&#9;&#9;&#9;&#9;&#9; $"?Class="$LocalPlayer.GetDefaultURL("Class");<br><br>&#9;// Switch immediately if not networking.<br>&#9;if( Level.NetMode!=NM_DedicatedServer && Level.NetMode!=NM_ListenServer )<br>&#9;&#9;Level.NextSwitchCountdown = 0.0;<br><br></div>
<h3 id="GameInfo.ReduceDamage"><a class="headerlink" href="#GameInfo.ReduceDamage" title="Permanent link">ReduceDamage</a> (int Damage, name DamageType, pawn injured, pawn instigatedBy) -> int</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( injured.Region.Zone.bNeutralZone )<br>&#9;&#9;return 0;&#9;<br>&#9;return Damage;<br><br></div>
<h3 id="GameInfo.RegisterDamageMutator"><a class="headerlink" href="#GameInfo.RegisterDamageMutator" title="Permanent link">RegisterDamageMutator</a> (Mutator M)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;M.NextDamageMutator = DamageMutator;<br>&#9;DamageMutator = M;<br><br></div>
<h3 id="GameInfo.ResetGame"><a class="headerlink" href="#GameInfo.ResetGame" title="Permanent link">ResetGame</a></h3>

<h3 id="GameInfo.RestartGame"><a class="headerlink" href="#GameInfo.RestartGame" title="Permanent link">RestartGame</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Level.ServerTravel( "?Restart", false );<br><br></div>
<h3 id="GameInfo.RestartPlayer"><a class="headerlink" href="#GameInfo.RestartPlayer" title="Permanent link">RestartPlayer</a> (pawn aPlayer) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local NavigationPoint startSpot;<br>&#9;local bool foundStart;<br><br><br>&#9;if( bRestartLevel && Level.NetMode!=NM_DedicatedServer && Level.NetMode!=NM_ListenServer )<br>&#9;&#9;return true;<br><br>&#9;startSpot = FindPlayerStart(aPlayer, 255);<br>&#9;if( startSpot == None )<br>&#9;{<br>&#9;&#9;log(" Player start not found!!!");<br>&#9;&#9;return false;<br>&#9;}&#9;<br>&#9;foundStart = aPlayer.SetLocation(startSpot.Location);<br>&#9;if( foundStart )<br>&#9;{<br>&#9;&#9;startSpot.PlayTeleportEffect(aPlayer, true);<br>&#9;&#9;aPlayer.SetRotation(startSpot.Rotation);<br>&#9;&#9;aPlayer.ViewRotation = aPlayer.Rotation;<br>&#9;&#9;aPlayer.Acceleration = vect(0,0,0);<br>&#9;&#9;aPlayer.Velocity = vect(0,0,0);<br>&#9;&#9;aPlayer.Health = aPlayer.Default.Health;<br>&#9;&#9;aPlayer.SetCollision( true, true, true );<br>&#9;&#9;aPlayer.ClientSetLocation( startSpot.Location, startSpot.Rotation );<br>&#9;&#9;aPlayer.bHidden = false;<br>&#9;&#9;aPlayer.DamageScaling = aPlayer.Default.DamageScaling;<br>&#9;&#9;aPlayer.SoundDampening = aPlayer.Default.SoundDampening;<br>&#9;&#9;AddDefaultInventory(aPlayer);<br>&#9;}<br>&#9;else<br>&#9;&#9;log(startspot$" Player start not useable!!!");<br>&#9;return foundStart;<br><br></div>
<h3 id="GameInfo.ScoreEvent"><a class="headerlink" href="#GameInfo.ScoreEvent" title="Permanent link">ScoreEvent</a> (name EventName, actor EventActor, pawn InstigatedBy)</h3>

<h3 id="GameInfo.ScoreKill"><a class="headerlink" href="#GameInfo.ScoreKill" title="Permanent link">ScoreKill</a> (pawn Killer, pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Other.DieCount++;<br>&#9;if( (killer == Other) || (killer == None) )<br>&#9;&#9;Other.PlayerReplicationInfo.Score -= 1;<br>&#9;else if ( killer != None )<br>&#9;{<br>&#9;&#9;killer.killCount++;<br>&#9;&#9;if ( killer.PlayerReplicationInfo != None )<br>&#9;&#9;&#9;killer.PlayerReplicationInfo.Score += 1;<br>&#9;}<br><br>&#9;BaseMutator.ScoreKill(Killer, Other);<br><br></div>
<h3 id="GameInfo.SendPlayer"><a class="headerlink" href="#GameInfo.SendPlayer" title="Permanent link">SendPlayer</a> (PlayerPawn aPlayer, string URL)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;aPlayer.ClientTravel( URL, TRAVEL_Relative, true );<br><br></div>
<h3 id="GameInfo.SetEndCams"><a class="headerlink" href="#GameInfo.SetEndCams" title="Permanent link">SetEndCams</a> (string Reason) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local pawn aPawn;<br><br><br>&#9;for ( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )<br>&#9;&#9;if ( aPawn.bIsPlayer )<br>&#9;&#9;{<br>&#9;&#9;&#9;aPawn.GotoState('GameEnded');<br>&#9;&#9;&#9;aPawn.ClientGameEnded();<br>&#9;&#9;}&#9;<br><br>&#9;return true;<br><br></div>
<h3 id="GameInfo.SetGameSpeed"><a class="headerlink" href="#GameInfo.SetGameSpeed" title="Permanent link">SetGameSpeed</a> (Float T)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;GameSpeed = FMax(T, 0.1);<br>&#9;Level.TimeDilation = GameSpeed;<br>&#9;SetTimer(Level.TimeDilation, true);<br><br></div>
<h3 id="GameInfo.SetPause"><a class="headerlink" href="#GameInfo.SetPause" title="Permanent link">SetPause</a> (BOOL bPause, PlayerPawn P) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( bPauseable || P.bAdmin || Level.Netmode==NM_Standalone )<br>&#9;{<br>&#9;&#9;if( bPause )<br>&#9;&#9;&#9;Level.Pauser=P.PlayerReplicationInfo.PlayerName;<br>&#9;&#9;else<br>&#9;&#9;&#9;Level.Pauser="";<br>&#9;&#9;return True;<br>&#9;}<br>&#9;else return False;<br><br></div>
<h3 id="GameInfo.ShouldRespawn"><a class="headerlink" href="#GameInfo.ShouldRespawn" title="Permanent link">ShouldRespawn</a> (actor Other) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Level.NetMode == NM_StandAlone )<br>&#9;&#9;return false;<br>&#9;return Inventory(Other)!=None && Inventory(Other).ReSpawnTime!=0.0;<br><br></div>
<h3 id="GameInfo.StartPlayer"><a class="headerlink" href="#GameInfo.StartPlayer" title="Permanent link">StartPlayer</a> (PlayerPawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Level.NetMode==NM_DedicatedServer || Level.NetMode==NM_ListenServer || !bRestartLevel )<br>&#9;&#9;Other.GotoState(Other.PlayerRestartState);<br>&#9;else<br>&#9;&#9;Other.ClientTravel( "?restart", TRAVEL_Relative, false );<br><br></div>
<h3 id="GameInfo.Timer"><a class="headerlink" href="#GameInfo.Timer" title="Permanent link">Timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;SentText = 0;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#GameReplicationInfo.uc" title="Permanent link"><h2 id="GameReplicationInfo.uc">GameReplicationInfo.uc (extends ReplicationInfo)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var string GameName;						// Assigned by GameInfo.<br>var string GameClass;						// Assigned by GameInfo.<br>var bool bTeamGame;							// Assigned by GameInfo.<br>var bool bClassicDeathMessages;<br>var bool bStopCountDown;<br>var int  RemainingTime, ElapsedTime, RemainingMinute;<br>var float SecondCount;<br>var int NumPlayers;<br>var int SumFrags;<br>var float UpdateTimer;<br>var() globalconfig string ServerName;		// Name of the server, i.e.: Bob's Server.<br>var() globalconfig string ShortName;		// Abbreviated name of server, i.e.: B's Serv (stupid example)<br>var() globalconfig string AdminName;		// Name of the server admin.<br>var() globalconfig string AdminEmail;		// Email address of the server admin.<br>var() globalconfig int 		 Region;		// Region of the game server.<br>var() globalconfig string MOTDLine1;		// Message<br>var() globalconfig string MOTDLine2;		// Of<br>var() globalconfig string MOTDLine3;		// The<br>var() globalconfig string MOTDLine4;		// Day<br>var string GameEndedComments;				// set by gameinfo when game ends<br>var PlayerReplicationInfo PRIArray[32];</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bStopCountDown=True<br>ServerName="Kaiser trying to make DXMP work"<br>RemoteRole=ROLE_SimulatedProxy<br>NetUpdateFrequency=4.000000</div>
<h3 id="GameReplicationInfo.PostBeginPlay"><a class="headerlink" href="#GameReplicationInfo.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Level.NetMode == NM_Client )<br>&#9;{<br>&#9;&#9;// clear variables so we don't display our own values if the server has them left blank <br>&#9;&#9;ServerName = "";<br>&#9;&#9;AdminName = "";<br>&#9;&#9;AdminEmail = "";<br>&#9;&#9;MOTDLine1 = "";<br>&#9;&#9;MOTDLine2 = "";<br>&#9;&#9;MOTDLine3 = "";<br>&#9;&#9;MOTDLine4 = "";<br>&#9;}<br><br>&#9;SecondCount = Level.TimeSeconds;<br>&#9;SetTimer(0.2, true);<br><br></div>
<h3 id="GameReplicationInfo.Timer"><a class="headerlink" href="#GameReplicationInfo.Timer" title="Permanent link">Timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local PlayerReplicationInfo PRI;<br>&#9;local int i, FragAcc;<br><br><br>&#9;if ( Level.NetMode == NM_Client )<br>&#9;{<br>&#9;&#9;if (Level.TimeSeconds - SecondCount >= Level.TimeDilation)<br>&#9;&#9;{<br>&#9;&#9;&#9;ElapsedTime++;<br>&#9;&#9;&#9;if ( RemainingMinute != 0 )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;RemainingTime = RemainingMinute;<br>&#9;&#9;&#9;&#9;RemainingMinute = 0;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;if ( (RemainingTime > 0) && !bStopCountDown )<br>&#9;&#9;&#9;&#9;RemainingTime--;<br>&#9;&#9;&#9;SecondCount += Level.TimeDilation;<br>&#9;&#9;}<br>&#9;}<br><br>&#9;for (i=0; i<32; i++)<br>&#9;&#9;PRIArray[i] = None;<br>&#9;i=0;<br>&#9;foreach AllActors(class'PlayerReplicationInfo', PRI)<br>&#9;{<br>&#9;&#9;PRIArray[i++] = PRI;<br>&#9;}<br><br>&#9;// Update various information.<br>&#9;UpdateTimer = 0;<br>&#9;for (i=0; i<32; i++)<br>&#9;&#9;if (PRIArray[i] != None)<br>&#9;&#9;&#9;FragAcc += PRIArray[i].Score;<br>&#9;SumFrags = FragAcc;<br><br>&#9;if ( Level.Game != None )<br>&#9;&#9;NumPlayers = Level.Game.NumPlayers;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#HUD.uc" title="Permanent link"><h2 id="HUD.uc">HUD.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var globalconfig int HudMode;<br>var globalconfig int Crosshair;<br>var() class<menu> MainMenuType;<br>var() string HUDConfigWindowType;<br>var color WhiteColor;<br>var Mutator HUDMutator;<br>var PlayerPawn PlayerOwner; // always the actual owner<br>var Class<LocalMessage> Message;<br>var int Switch;<br>var PlayerReplicationInfo RelatedPRI;<br>var Object OptionalObject;<br>var float EndOfLife;<br>var float LifeTime;<br>var bool bDrawing;<br>var int numLines;<br>var string StringMessage;<br>var color DrawColor;<br>var font StringFont;<br>var float XL, YL;<br>var float YPos;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">HUDConfigWindowType="UMenu.UMenuHUDConfigCW"<br>WhiteColor=(G=128,B=255)<br>bHidden=True<br>RemoteRole=ROLE_SimulatedProxy</div>
<h3 id="HUD.ChangeCrosshair"><a class="headerlink" href="#HUD.ChangeCrosshair" title="Permanent link">ChangeCrosshair</a> (int d)</h3>

<h3 id="HUD.ChangeHud"><a class="headerlink" href="#HUD.ChangeHud" title="Permanent link">ChangeHud</a> (int d)</h3>

<h3 id="HUD.ClearMessage"><a class="headerlink" href="#HUD.ClearMessage" title="Permanent link">ClearMessage</a> (out HUDLocalizedMessage M)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;M.Message = None;<br>&#9;M.Switch = 0;<br>&#9;M.RelatedPRI = None;<br>&#9;M.OptionalObject = None;<br>&#9;M.EndOfLife = 0;<br>&#9;M.StringMessage = "";<br>&#9;M.DrawColor = WhiteColor;<br>&#9;M.XL = 0;<br>&#9;M.bDrawing = false;<br><br></div>
<h3 id="HUD.CopyMessage"><a class="headerlink" href="#HUD.CopyMessage" title="Permanent link">CopyMessage</a> (out HUDLocalizedMessage M1, HUDLocalizedMessage M2)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;M1.Message = M2.Message;<br>&#9;M1.Switch = M2.Switch;<br>&#9;M1.RelatedPRI = M2.RelatedPRI;<br>&#9;M1.OptionalObject = M2.OptionalObject;<br>&#9;M1.EndOfLife = M2.EndOfLife;<br>&#9;M1.StringMessage = M2.StringMessage;<br>&#9;M1.DrawColor = M2.DrawColor;<br>&#9;M1.XL = M2.XL;<br>&#9;M1.YL = M2.YL;<br>&#9;M1.YPos = M2.YPos;<br>&#9;M1.bDrawing = M2.bDrawing;<br>&#9;M1.LifeTime = M2.LifeTime;<br>&#9;M1.numLines = M2.numLines;<br><br></div>
<h3 id="HUD.DisplayMessages"><a class="headerlink" href="#HUD.DisplayMessages" title="Permanent link">DisplayMessages</a> (canvas Canvas) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return false;<br><br></div>
<h3 id="HUD.DrawCrossHair"><a class="headerlink" href="#HUD.DrawCrossHair" title="Permanent link">DrawCrossHair</a> (canvas Canvas, int StartX, int StartY)</h3>

<h3 id="HUD.InputNumber"><a class="headerlink" href="#HUD.InputNumber" title="Permanent link">InputNumber</a> (byte F)</h3>

<h3 id="HUD.LocalizedMessage"><a class="headerlink" href="#HUD.LocalizedMessage" title="Permanent link">LocalizedMessage</a> (class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject, optional string CriticalString)</h3>

<h3 id="HUD.Message"><a class="headerlink" href="#HUD.Message" title="Permanent link">Message</a> (PlayerReplicationInfo PRI, coerce string Msg, name N)</h3>

<h3 id="HUD.PlayReceivedMessage"><a class="headerlink" href="#HUD.PlayReceivedMessage" title="Permanent link">PlayReceivedMessage</a> (string S, string PName, ZoneInfo PZone)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlayerPawn(Owner).ClientMessage(S);<br>&#9;if (PlayerPawn(Owner).bMessageBeep)<br>&#9;&#9;PlayerPawn(Owner).PlayBeepSound();<br><br></div>
<h3 id="HUD.PostRender"><a class="headerlink" href="#HUD.PostRender" title="Permanent link">PostRender</a> (canvas Canvas)</h3>

<h3 id="HUD.PreRender"><a class="headerlink" href="#HUD.PreRender" title="Permanent link">PreRender</a> (canvas Canvas)</h3>

<br><br><hr>
<a class="headerlink" href="#HomeBase.uc" title="Permanent link"><h2 id="HomeBase.uc">HomeBase.uc (extends NavigationPoint)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() float extent; //how far the base extends from central point (in line of sight)</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Extent=700.000000<br>Texture=Texture'Engine.S_Flag'<br>SoundVolume=128</div>
<h3 id="HomeBase.PreBeginPlay"><a class="headerlink" href="#HomeBase.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;lookdir = 200 * vector(Rotation);<br>&#9;Super.PreBeginPlay();<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Info.uc" title="Permanent link"><h2 id="Info.uc">Info.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bHidden=True</div>
<br><br><hr>
<a class="headerlink" href="#InternetInfo.uc" title="Permanent link"><h2 id="InternetInfo.uc">InternetInfo.uc (extends Info)</h2></a>

<h3 id="InternetInfo.GetBeaconAddress"><a class="headerlink" href="#InternetInfo.GetBeaconAddress" title="Permanent link">GetBeaconAddress</a> (int i) -> string</h3>

<h3 id="InternetInfo.GetBeaconText"><a class="headerlink" href="#InternetInfo.GetBeaconText" title="Permanent link">GetBeaconText</a> (int i) -> string</h3>

<br><br><hr>
<a class="headerlink" href="#InterpolationPoint.uc" title="Permanent link"><h2 id="InterpolationPoint.uc">InterpolationPoint.uc (extends Keypoint)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() int    Position;<br>var() float  RateModifier;<br>var() float  GameSpeedModifier;<br>var() float  FovModifier;<br>var() bool   bEndOfPath;<br>var() bool   bSkipNextPath;<br>var() float  ScreenFlashScale;<br>var() vector ScreenFlashFog;<br>var InterpolationPoint Prev, Next;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">RateModifier=1.000000<br>GameSpeedModifier=1.000000<br>FovModifier=1.000000<br>ScreenFlashScale=1.000000<br>bStatic=False<br>bDirectional=True<br>Texture=Texture'Engine.S_Interp'</div>
<h3 id="InterpolationPoint.BeginPlay"><a class="headerlink" href="#InterpolationPoint.BeginPlay" title="Permanent link">BeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.BeginPlay();<br><br>&#9;// Try to find previous.<br>&#9;foreach AllActors( class 'InterpolationPoint', Prev, Tag )<br>&#9;&#9;if( Prev.Position == Position-1 )<br>&#9;&#9;&#9;break;<br>&#9;if( Prev != None )<br>&#9;&#9;Prev.Next = Self;<br><br>&#9;// Try to find next.<br>&#9;foreach AllActors( class 'InterpolationPoint', Next, Tag )<br>&#9;&#9;if( Next.Position == Position+1 )<br>&#9;&#9;&#9;break;<br>&#9;if( Next == None )<br>&#9;&#9;foreach AllActors( class 'InterpolationPoint', Next, Tag )<br>&#9;&#9;&#9;if( Next.Position == 0 )<br>&#9;&#9;&#9;&#9;break;<br>&#9;if( Next != None )<br>&#9;&#9;Next.Prev = Self;<br><br></div>
<h3 id="InterpolationPoint.InterpolateEnd"><a class="headerlink" href="#InterpolationPoint.InterpolateEnd" title="Permanent link">InterpolateEnd</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( bEndOfPath )&#9;<br>&#9;{<br>&#9;&#9;if( Pawn(Other)!=None && Pawn(Other).bIsPlayer )<br>&#9;&#9;{<br>&#9;&#9;&#9;Other.bCollideWorld = True;<br>&#9;&#9;&#9;Other.bInterpolating = false;<br>&#9;&#9;&#9;if ( Pawn(Other).Health > 0 )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;Other.SetCollision(true,true,true);<br>&#9;&#9;&#9;&#9;Other.SetPhysics(PHYS_Falling);<br>&#9;&#9;&#9;&#9;Other.AmbientSound = None;<br>&#9;&#9;&#9;&#9;// DEUS_EX CNN - removed by CNN - don't change the player state<br>&#9;&#9;&#9;&#9;// the player will handle that itself<br>//&#9;&#9;&#9;&#9;if ( Other.IsA('PlayerPawn') )<br>//&#9;&#9;&#9;&#9;&#9;Other.GotoState('PlayerWalking');<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;&#9;else if (Other != None)<br>&#9;&#9;{<br>&#9;&#9;&#9;// DEUS_EX - added by CNN - lets non players interpolate also<br>&#9;&#9;&#9;Other.bInterpolating = False;<br>&#9;&#9;&#9;Other.SetPhysics(PHYS_Falling);<br>&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="InterpolationPoint.PostBeginPlay"><a class="headerlink" href="#InterpolationPoint.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.PostBeginPlay();<br>&#9;//log( "Interpolation point" @ Tag @ Position $ ":" );<br>&#9;//if( Prev != None )<br>&#9;//&#9;log( "   Prev # " $ Prev.Position );<br>&#9;//if( Next != None )<br>&#9;//&#9;log( "   Next # " $ Next.Position );<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Inventory.uc" title="Permanent link"><h2 id="Inventory.uc">Inventory.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() travel byte AutoSwitchPriority; // Autoswitch value, 0=never autoswitch.<br>var() byte        InventoryGroup;     // The weapon/inventory set, 1-9 (0=none).<br>var() bool        bActivatable;       // Whether item can be activated.<br>var() bool	 	  bDisplayableInv;	  // Item displayed in HUD.<br>var(Display) bool bAmbientGlow;		  // Whether to glow or not.<br>var() bool		bInstantRespawn;	  // Can be tagged so this item respawns instantly.<br>var() bool		bRotatingPickup;	  // Rotates when in pickup state.<br>var() localized string PickupMessage; // Human readable description when picked up.<br>var() localized string ItemName;      // Human readable name of item<br>var() localized string ItemArticle;   // Human readable article (e.g. "a", "an")<br>var() float     RespawnTime;          // Respawn after this time, 0 for instant.<br>var name 		PlayerLastTouched;    // Player who last touched this item.<br>var() vector      PlayerViewOffset;   // Offset from view center.<br>var() mesh        PlayerViewMesh;     // Mesh to render.<br>var() float       PlayerViewScale;    // Mesh scale.<br>var() float		  BobDamping;		  // how much to damp view bob<br>var() mesh        PickupViewMesh;     // Mesh to render.<br>var() float       PickupViewScale;    // Mesh scale.<br>var() mesh        ThirdPersonMesh;    // Mesh to render.<br>var() float       ThirdPersonScale;   // Mesh scale.<br>var() texture     StatusIcon;         // Icon used with ammo/charge/power count.<br>var() name		  ProtectionType1;	  // Protects against DamageType (None if non-armor).<br>var() name		  ProtectionType2;	  // Secondary protection type (None if non-armor).<br>var() travel int  Charge;			  // Amount of armor or charge if not an armor (charge in time*10).<br>var() int		  ArmorAbsorption;	  // Percent of damage item absorbs 0-100.<br>var() bool		  bIsAnArmor;		  // Item will protect player.<br>var() int		  AbsorptionPriority; // Which items absorb damage first (higher=first).<br>var() inventory	  NextArmor;		  // Temporary list created by Armors to prioritize damage absorption.<br>var() float		  MaxDesireability;	  // Maximum desireability this item will ever have.<br>var bool bSteadyFlash3rd;<br>var bool bFirstFrame;<br>var(MuzzleFlash) bool bMuzzleFlashParticles;<br>var(MuzzleFlash) bool bToggleSteadyFlash;<br>var bool	bSteadyToggle;<br>var byte FlashCount, OldFlashCount;<br>var(MuzzleFlash) ERenderStyle MuzzleFlashStyle;<br>var(MuzzleFlash) mesh MuzzleFlashMesh;<br>var(MuzzleFlash) float MuzzleFlashScale;<br>var(MuzzleFlash) texture MuzzleFlashTexture;<br>var() sound PickupSound, ActivateSound, DeActivateSound, RespawnSound;<br>var sound LandSound;<br>var() texture Icon;<br>var() localized String M_Activated;<br>var() localized String M_Selected;<br>var() localized String M_Deactivated;<br>var() class<LocalMessage> PickupMessageClass;<br>var() class<LocalMessage> ItemMessageClass;<br>var bool					bCanUseObjectBelt; // Can this object be placed on the object belt?<br>var texture					largeIcon;         // Larger-than-usual icon for the inventory window<br>var int						largeIconWidth;    // Width of graphic in texture<br>var int						largeIconHeight;   // Height of graphic in texture<br>var int						invSlotsX;         // Number of horizontal inv. slots this item takes<br>var int						invSlotsY;         // Number of vertical inv. slots this item takes<br>var travel int				invPosX;           // X position on the inventory window<br>var travel int				invPosY;           // Y position on the inventory window<br>var travel bool				bInObjectBelt;     // Is this object actually in the object belt?<br>var travel int				beltPos;           // Position on the object belt<br>var() localized String		description;       // Description<br>var localized String		beltDescription;   // Description used on the object belt</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bDisplayableInv=True<br>bRotatingPickup=True<br>PickupMessage="Snagged an item"<br>ItemArticle="a"<br>PlayerViewScale=1.000000<br>BobDamping=0.960000<br>PickupViewScale=1.000000<br>ThirdPersonScale=1.000000<br>MaxDesireability=0.005000<br>bFirstFrame=True<br>bToggleSteadyFlash=True<br>M_Activated=" activated"<br>M_Selected=" selected"<br>M_Deactivated=" deactivated"<br>bCanUseObjectBelt=True<br>invSlotsX=1<br>invSlotsY=1<br>invPosX=-1<br>invPosY=-1<br>beltPos=-1<br>Description="Made by the ABC Widget ACME Corporation"<br>bIsItemGoal=True<br>bTravel=True<br>Physics=PHYS_Falling<br>RemoteRole=ROLE_SimulatedProxy<br>DrawType=DT_Mesh<br>Texture=Texture'Engine.S_Inventory'<br>CollisionRadius=30.000000<br>CollisionHeight=30.000000<br>bCollideActors=True<br>bBlockActors=True<br>bFixedRotationDir=True<br>NetPriority=1.400000</div>
<h3 id="Inventory.Activate"><a class="headerlink" href="#Inventory.Activate" title="Permanent link">Activate</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( (Pawn(Owner) != None) && (M_Deactivated != "") )<br>&#9;&#9;&#9;Pawn(Owner).ClientMessage(ItemName$M_Deactivated);&#9;<br>&#9;&#9;GoToState('DeActivated');&#9;<br>&#9;<br></div>
<h3 id="Inventory.ActivateTranslator"><a class="headerlink" href="#Inventory.ActivateTranslator" title="Permanent link">ActivateTranslator</a> (bool bHint)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Inventory!=None )<br>&#9;&#9;Inventory.ActivateTranslator( bHint );<br><br></div>
<h3 id="Inventory.AltFire"><a class="headerlink" href="#Inventory.AltFire" title="Permanent link">AltFire</a> (float Value)</h3>

<h3 id="Inventory.ArmorAbsorbDamage"><a class="headerlink" href="#Inventory.ArmorAbsorbDamage" title="Permanent link">ArmorAbsorbDamage</a> (int Damage, name DamageType, vector HitLocation) -> int</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int ArmorDamage;<br><br><br>&#9;if ( DamageType != 'Drowned' )<br>&#9;&#9;ArmorImpactEffect(HitLocation);<br>&#9;if( (DamageType!='None') && ((ProtectionType1==DamageType) || (ProtectionType2==DamageType)) )<br>&#9;&#9;return 0;<br>&#9;<br>&#9;if (DamageType=='Drowned') Return Damage;<br>&#9;<br>&#9;ArmorDamage = (Damage * ArmorAbsorption) / 100;<br>&#9;if( ArmorDamage >= Charge )<br>&#9;{<br>&#9;&#9;ArmorDamage = Charge;<br>&#9;&#9;Destroy();<br>&#9;}<br>&#9;else <br>&#9;&#9;Charge -= ArmorDamage;<br>&#9;return (Damage - ArmorDamage);<br><br></div>
<h3 id="Inventory.ArmorPriority"><a class="headerlink" href="#Inventory.ArmorPriority" title="Permanent link">ArmorPriority</a> (name DamageType) -> int</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( DamageType == 'Drowned' )<br>&#9;&#9;return 0;<br>&#9;if( (DamageType!='None') <br>&#9;&#9;&& ((ProtectionType1==DamageType) || (ProtectionType2==DamageType)) )<br>&#9;&#9;return 1000000;<br><br>&#9;return AbsorptionPriority;<br><br></div>
<h3 id="Inventory.BecomeItem"><a class="headerlink" href="#Inventory.BecomeItem" title="Permanent link">BecomeItem</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;RemoteRole    = ROLE_SimulatedProxy;<br>&#9;Mesh          = PlayerViewMesh;<br>&#9;DrawScale     = PlayerViewScale;<br>&#9;bOnlyOwnerSee = true;<br>&#9;bHidden       = true;<br>&#9;bCarriedItem  = true;<br>&#9;NetPriority   = 1.4;<br>&#9;SetCollision( false, false, false );<br>&#9;SetPhysics(PHYS_None);<br>//&#9;SetTimer(0.0,False);&#9;// DEUS_EX CNN - removed<br>&#9;AmbientGlow = 0;<br><br></div>
<h3 id="Inventory.BecomePickup"><a class="headerlink" href="#Inventory.BecomePickup" title="Permanent link">BecomePickup</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Physics != PHYS_Falling )<br>&#9;&#9;RemoteRole    = ROLE_SimulatedProxy;<br>&#9;Mesh          = PickupViewMesh;<br>&#9;DrawScale     = PickupViewScale;<br>&#9;bOnlyOwnerSee = false;<br>&#9;bHidden       = false;<br>&#9;bCarriedItem  = false;<br>&#9;NetPriority   = 1.4;<br>&#9;SetCollision( true, true, false );&#9;&#9;// make things block actors as well - DEUS_EX CNN<br><br></div>
<h3 id="Inventory.BeginState"><a class="headerlink" href="#Inventory.BeginState" title="Permanent link">BeginState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;BecomePickup();<br>&#9;&#9;bHidden = true;<br>&#9;<br></div>
<h3 id="Inventory.BotDesireability"><a class="headerlink" href="#Inventory.BotDesireability" title="Permanent link">BotDesireability</a> (pawn Bot) -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Inventory AlreadyHas;<br>&#9;local float desire;<br>&#9;local bool bChecked;<br><br><br>&#9;desire = MaxDesireability;<br><br>&#9;if ( RespawnTime < 10 )<br>&#9;{<br>&#9;&#9;bChecked = true;<br>&#9;&#9;AlreadyHas = Bot.FindInventoryType(class); <br>&#9;&#9;if ( (AlreadyHas != None) <br>&#9;&#9;&#9;&& (AlreadyHas.Charge >= Charge) )<br>&#9;&#9;&#9;&#9;return -1;<br>&#9;}<br><br>&#9;if( bIsAnArmor )<br>&#9;{<br>&#9;&#9;if ( !bChecked )<br>&#9;&#9;&#9;AlreadyHas = Bot.FindInventoryType(class); <br>&#9;&#9;if ( AlreadyHas != None )<br>&#9;&#9;&#9;desire *= (1 - AlreadyHas.Charge * AlreadyHas.ArmorAbsorption * 0.00003);<br>&#9;&#9;<br>&#9;&#9;desire *= (Charge * 0.005);<br>&#9;&#9;desire *= (ArmorAbsorption * 0.01);<br>&#9;&#9;return desire;<br>&#9;}<br>&#9;else return desire;<br><br></div>
<h3 id="Inventory.CalcDrawOffset"><a class="headerlink" href="#Inventory.CalcDrawOffset" title="Permanent link">CalcDrawOffset</a> -> vector</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector DrawOffset, WeaponBob;<br>&#9;local Pawn PawnOwner;<br><br><br>&#9;PawnOwner = Pawn(Owner);<br>&#9;DrawOffset = ((0.9/PawnOwner.FOVAngle * PlayerViewOffset) >> PawnOwner.ViewRotation);<br><br>&#9;if ( (Level.NetMode == NM_DedicatedServer) <br>&#9;&#9;|| ((Level.NetMode == NM_ListenServer) && (Owner.RemoteRole == ROLE_AutonomousProxy)) )<br>&#9;&#9;DrawOffset += (PawnOwner.BaseEyeHeight * vect(0,0,1));<br>&#9;else<br>&#9;{&#9;<br>&#9;&#9;DrawOffset += (PawnOwner.EyeHeight * vect(0,0,1));<br>&#9;&#9;WeaponBob = BobDamping * PawnOwner.WalkBob;<br>&#9;&#9;WeaponBob.Z = (0.45 + 0.55 * BobDamping) * PawnOwner.WalkBob.Z;<br>&#9;&#9;DrawOffset += WeaponBob;<br>&#9;}<br>&#9;return DrawOffset;<br><br></div>
<h3 id="Inventory.ChangedWeapon"><a class="headerlink" href="#Inventory.ChangedWeapon" title="Permanent link">ChangedWeapon</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Inventory != None )<br>&#9;&#9;Inventory.ChangedWeapon();<br><br></div>
<h3 id="Inventory.CheckTouching"><a class="headerlink" href="#Inventory.CheckTouching" title="Permanent link">CheckTouching</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br><br><br>&#9;&#9;bSleepTouch = false;<br>&#9;&#9;for ( i=0; i<4; i++ )<br>&#9;&#9;&#9;if ( (Touching[i] != None) && Touching[i].IsA('Pawn') )<br>&#9;&#9;&#9;&#9;Touch(Touching[i]);<br>&#9;<br></div>
<h3 id="Inventory.Destroyed"><a class="headerlink" href="#Inventory.Destroyed" title="Permanent link">Destroyed</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (MyMarker != None )<br>&#9;&#9;MyMarker.markedItem = None;&#9;&#9;<br>&#9;// Remove from owner's inventory.<br>&#9;if( Pawn(Owner)!=None )<br>&#9;&#9;Pawn(Owner).DeleteInventory( Self );<br><br></div>
<h3 id="Inventory.DrawStatusIconAt"><a class="headerlink" href="#Inventory.DrawStatusIconAt" title="Permanent link">DrawStatusIconAt</a> (canvas Canvas, int X, int Y, optional float Scale)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Scale == 0.0 )<br>&#9;&#9;Scale = 1.0;<br>&#9;Canvas.SetPos( X, Y );<br>&#9;Canvas.DrawIcon( StatusIcon, Scale );<br><br></div>
<h3 id="Inventory.DropFrom"><a class="headerlink" href="#Inventory.DropFrom" title="Permanent link">DropFrom</a> (vector StartLocation)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( !SetLocation(StartLocation) )<br>&#9;&#9;return; <br>&#9;RespawnTime = 0.0; //don't respawn<br>&#9;SetPhysics(PHYS_Falling);<br>&#9;RemoteRole = ROLE_DumbProxy;<br>&#9;BecomePickup();<br>&#9;NetPriority = 2.5;<br>&#9;bCollideWorld = true;<br>&#9;if ( Pawn(Owner) != None )<br>&#9;&#9;Pawn(Owner).DeleteInventory(self);<br>&#9;Inventory = None;<br>&#9;GotoState('PickUp', 'Dropped');<br><br></div>
<h3 id="Inventory.DropInventory"><a class="headerlink" href="#Inventory.DropInventory" title="Permanent link">DropInventory</a></h3>

<h3 id="Inventory.EndState"><a class="headerlink" href="#Inventory.EndState" title="Permanent link">EndState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br><br><br>&#9;&#9;bSleepTouch = false;<br>&#9;&#9;for ( i=0; i<4; i++ )<br>&#9;&#9;&#9;if ( (Touching[i] != None) && Touching[i].IsA('Pawn') )<br>&#9;&#9;&#9;&#9;bSleepTouch = true;<br>&#9;<br></div>
<h3 id="Inventory.Fire"><a class="headerlink" href="#Inventory.Fire" title="Permanent link">Fire</a> (float Value)</h3>

<h3 id="Inventory.Frob"><a class="headerlink" href="#Inventory.Frob" title="Permanent link">Frob</a> (Actor Other, Inventory frobWith)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre">/&#9;function Touch( actor Other <br></div>
<h3 id="Inventory.GetHumanName"><a class="headerlink" href="#Inventory.GetHumanName" title="Permanent link">GetHumanName</a> -> String</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return ItemArticle@ItemName;<br><br></div>
<h3 id="Inventory.GiveTo"><a class="headerlink" href="#Inventory.GiveTo" title="Permanent link">GiveTo</a> (pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Instigator = Other;<br>&#9;BecomeItem();<br>&#9;Other.AddInventory( Self );<br>&#9;GotoState('Idle2');<br><br></div>
<h3 id="Inventory.HandlePickupQuery"><a class="headerlink" href="#Inventory.HandlePickupQuery" title="Permanent link">HandlePickupQuery</a> (inventory Item) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Item.Class == Class )<br>&#9;&#9;return true;<br>&#9;if ( Inventory == None )<br>&#9;&#9;return false;<br><br>&#9;return Inventory.HandlePickupQuery(Item);<br><br></div>
<h3 id="Inventory.InventoryCapsFloat"><a class="headerlink" href="#Inventory.InventoryCapsFloat" title="Permanent link">InventoryCapsFloat</a> (name Property, pawn Other, actor Test) -> float</h3>

<h3 id="Inventory.InventoryCapsString"><a class="headerlink" href="#Inventory.InventoryCapsString" title="Permanent link">InventoryCapsString</a> (name Property, pawn Other, actor Test) -> string</h3>

<h3 id="Inventory.Landed"><a class="headerlink" href="#Inventory.Landed" title="Permanent link">Landed</a> (Vector HitNormal)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local rotator newRot;<br><br>&#9;&#9;newRot = Rotation;<br>&#9;&#9;newRot.pitch = 0;<br>&#9;&#9;SetRotation(newRot);<br>&#9;&#9;PlayLandingSound();  // DEUS_EX STM - added<br>//&#9;&#9;SetTimer(2.0, false);&#9;// DEUS_EX CNN - removed<br>&#9;<br></div>
<h3 id="Inventory.OwnerJumped"><a class="headerlink" href="#Inventory.OwnerJumped" title="Permanent link">OwnerJumped</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Inventory != None )<br>&#9;&#9;Inventory.OwnerJumped();<br><br></div>
<h3 id="Inventory.PlayLandingSound"><a class="headerlink" href="#Inventory.PlayLandingSound" title="Permanent link">PlayLandingSound</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (LandSound != None)<br>&#9;&#9;PlaySound(LandSound);<br><br></div>
<h3 id="Inventory.PostBeginPlay"><a class="headerlink" href="#Inventory.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>   PickupMessageClass = None;<br>&#9;if ( ItemName == "" )<br>&#9;&#9;ItemName = GetItemName(string(Class));<br><br>&#9;// DEUS_EX CNN - scale since network passes vector components as ints<br>&#9;PlayerViewOffset = Default.PlayerViewOffset * 100;<br><br>&#9;Super.PostBeginPlay();<br><br></div>
<h3 id="Inventory.PrioritizeArmor"><a class="headerlink" href="#Inventory.PrioritizeArmor" title="Permanent link">PrioritizeArmor</a> (int Damage, name DamageType, vector HitLocation) -> inventory</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Inventory FirstArmor, InsertAfter;<br><br><br>&#9;if ( Inventory != None )<br>&#9;&#9;FirstArmor = Inventory.PrioritizeArmor(Damage, DamageType, HitLocation);<br>&#9;else<br>&#9;&#9;FirstArmor = None;<br><br>&#9;if ( bIsAnArmor)<br>&#9;{<br>&#9;&#9;if ( FirstArmor == None )<br>&#9;&#9;{<br>&#9;&#9;&#9;nextArmor = None;<br>&#9;&#9;&#9;return self;<br>&#9;&#9;}<br><br>&#9;&#9;// insert this armor into the prioritized armor list<br>&#9;&#9;if ( FirstArmor.ArmorPriority(DamageType) < ArmorPriority(DamageType) )<br>&#9;&#9;{<br>&#9;&#9;&#9;nextArmor = FirstArmor;<br>&#9;&#9;&#9;return self;<br>&#9;&#9;}<br>&#9;&#9;InsertAfter = FirstArmor;<br>&#9;&#9;while ( (InsertAfter.nextArmor != None) <br>&#9;&#9;&#9;&& (InsertAfter.nextArmor.ArmorPriority(DamageType) > ArmorPriority(DamageType)) )<br>&#9;&#9;&#9;InsertAfter = InsertAfter.nextArmor;<br><br>&#9;&#9;nextArmor = InsertAfter.nextArmor;<br>&#9;&#9;InsertAfter.nextArmor = self;<br>&#9;}<br>&#9;return FirstArmor;<br><br></div>
<h3 id="Inventory.RecommendWeapon"><a class="headerlink" href="#Inventory.RecommendWeapon" title="Permanent link">RecommendWeapon</a> (out float rating, out int bUseAltMode) -> Weapon</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( inventory != None )<br>&#9;&#9;return inventory.RecommendWeapon(rating, bUseAltMode);<br>&#9;else<br>&#9;{<br>&#9;&#9;rating = -1;<br>&#9;&#9;return None;<br>&#9;}<br><br></div>
<h3 id="Inventory.ReduceDamage"><a class="headerlink" href="#Inventory.ReduceDamage" title="Permanent link">ReduceDamage</a> (int Damage, name DamageType, vector HitLocation) -> int</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Inventory FirstArmor;<br>&#9;local int ReducedAmount,ArmorDamage;<br><br>&#9;<br>&#9;if( Damage<0 )<br>&#9;&#9;return 0;<br>&#9;<br>&#9;ReducedAmount = Damage;<br>&#9;FirstArmor = PrioritizeArmor(Damage, DamageType, HitLocation);<br>&#9;while( (FirstArmor != None) && (ReducedAmount > 0) )<br>&#9;{<br>&#9;&#9;ReducedAmount = FirstArmor.ArmorAbsorbDamage(ReducedAmount, DamageType, HitLocation);<br>&#9;&#9;FirstArmor = FirstArmor.nextArmor;<br>&#9;} <br>&#9;return ReducedAmount;<br><br></div>
<h3 id="Inventory.RenderOverlays"><a class="headerlink" href="#Inventory.RenderOverlays" title="Permanent link">RenderOverlays</a> (canvas Canvas)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Owner == None )<br>&#9;&#9;return;<br>&#9;if ( (Level.NetMode == NM_Client) && (!Owner.IsA('PlayerPawn') || (PlayerPawn(Owner).Player == None)) )<br>&#9;&#9;return;<br>&#9;SetLocation( Owner.Location + CalcDrawOffset() );<br>&#9;SetRotation( Pawn(Owner).ViewRotation );<br>&#9;Canvas.DrawActor(self, false);<br><br></div>
<h3 id="Inventory.SelectNext"><a class="headerlink" href="#Inventory.SelectNext" title="Permanent link">SelectNext</a> -> Inventory</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( bActivatable ) <br>&#9;{<br>&#9;&#9;if ( M_Selected != "" )<br>&#9;&#9;&#9;Pawn(Owner).ClientMessage(ItemName$M_Selected);<br>&#9;&#9;return self;<br>&#9;}<br>&#9;if ( Inventory != None )<br>&#9;&#9;return Inventory.SelectNext();<br>&#9;else<br>&#9;&#9;return None;<br><br></div>
<h3 id="Inventory.SetOwnerDisplay"><a class="headerlink" href="#Inventory.SetOwnerDisplay" title="Permanent link">SetOwnerDisplay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Inventory != None )<br>&#9;&#9;Inventory.SetOwnerDisplay();<br><br></div>
<h3 id="Inventory.SetRespawn"><a class="headerlink" href="#Inventory.SetRespawn" title="Permanent link">SetRespawn</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Level.Game.ShouldRespawn(self) )<br>&#9;&#9;GotoState('Sleeping');<br>&#9;else<br>&#9;&#9;Destroy();<br><br></div>
<h3 id="Inventory.SpawnCopy"><a class="headerlink" href="#Inventory.SpawnCopy" title="Permanent link">SpawnCopy</a> (pawn Other) -> inventory</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local inventory Copy;<br><br>&#9;if( Level.Game.ShouldRespawn(self) )<br>&#9;{<br>&#9;&#9;Copy = spawn(Class,Other,,,rot(0,0,0));<br>&#9;&#9;Copy.Tag           = Tag;<br>&#9;&#9;Copy.Event         = Event;<br>&#9;&#9;GotoState('Sleeping');<br>&#9;}<br>&#9;else<br>&#9;&#9;Copy = self;<br><br>&#9;Copy.RespawnTime = 0.0;<br>&#9;Copy.bHeldItem = true;<br>&#9;Copy.GiveTo( Other );<br>&#9;return Copy;<br><br></div>
<h3 id="Inventory.TestMPBeltSpot"><a class="headerlink" href="#Inventory.TestMPBeltSpot" title="Permanent link">TestMPBeltSpot</a> (int BeltSpot) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>   return ((BeltSpot <= 3) && (BeltSpot > 0));<br><br></div>
<h3 id="Inventory.Timer"><a class="headerlink" href="#Inventory.Timer" title="Permanent link">Timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( RemoteRole != ROLE_SimulatedProxy )<br>&#9;&#9;{<br>&#9;&#9;&#9;NetPriority = 1.4;<br>&#9;&#9;&#9;RemoteRole = ROLE_SimulatedProxy;<br><br>&#9;&#9;&#9;// DEUS_EX STM - ick<br>//&#9;&#9;&#9;if ( bHeldItem )<br>//&#9;&#9;&#9;&#9;SetTimer(40.0, false);<br><br>&#9;&#9;&#9;if ( bHeldItem )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( bTossedOut )<br>&#9;&#9;&#9;&#9;&#9;SetTimer(15.0, false);<br>&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;&#9;SetTimer(40.0, false);<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;return;<br>&#9;&#9;}<br><br>&#9;&#9;// DEUS_EX CNN<br>//&#9;&#9;if ( bHeldItem )<br>//&#9;&#9;&#9;Destroy();<br><br>&#9;&#9;if ( bHeldItem )<br>&#9;&#9;{<br>&#9;&#9;&#9;if (  (FRand() < 0.1) || !PlayerCanSeeMe() )<br>&#9;&#9;&#9;&#9;Destroy();<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;SetTimer(3.0, true);<br>&#9;&#9;}<br>&#9;<br></div>
<h3 id="Inventory.TravelPreAccept"><a class="headerlink" href="#Inventory.TravelPreAccept" title="Permanent link">TravelPreAccept</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.TravelPreAccept();<br>&#9;GiveTo( Pawn(Owner) );<br>&#9;if( bActive )<br>&#9;&#9;Activate();<br><br></div>
<h3 id="Inventory.UpdateInfo"><a class="headerlink" href="#Inventory.UpdateInfo" title="Permanent link">UpdateInfo</a> (Object winObject) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return False;<br><br></div>
<h3 id="Inventory.Use"><a class="headerlink" href="#Inventory.Use" title="Permanent link">Use</a> (pawn User)</h3>

<h3 id="Inventory.ValidTouch"><a class="headerlink" href="#Inventory.ValidTouch" title="Permanent link">ValidTouch</a> (actor Other) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Actor A;<br><br><br>&#9;&#9;if( Other.bIsPawn && Pawn(Other).bIsPlayer && (Pawn(Other).Health > 0) && Level.Game.PickupQuery(Pawn(Other), self) )<br>&#9;&#9;{<br>&#9;&#9;&#9;if( Event != '' )<br>&#9;&#9;&#9;&#9;foreach AllActors( class 'Actor', A, Event )<br>&#9;&#9;&#9;&#9;&#9;A.Trigger( Other, Other.Instigator );<br>&#9;&#9;&#9;return true;<br>&#9;&#9;}<br>&#9;&#9;return false;<br>&#9;<br></div>
<h3 id="Inventory.WeaponChange"><a class="headerlink" href="#Inventory.WeaponChange" title="Permanent link">WeaponChange</a> (byte F) -> Weapon</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Inventory == None)<br>&#9;&#9;return None;<br>&#9;else<br>&#9;&#9;return Inventory.WeaponChange( F );<br><br></div>
<h3 id="Inventory.ZoneChange"><a class="headerlink" href="#Inventory.ZoneChange" title="Permanent link">ZoneChange</a> (ZoneInfo NewZone)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float splashsize;<br>&#9;local actor splash;<br><br><br>&#9;&#9;if( NewZone.bWaterZone && !Region.Zone.bWaterZone ) <br>&#9;&#9;{<br>&#9;&#9;&#9;splashSize = 0.000025 * Mass * (250 - 0.5 * Velocity.Z);<br>&#9;&#9;&#9;if ( NewZone.EntrySound != None )<br>&#9;&#9;&#9;&#9;PlaySound(NewZone.EntrySound, SLOT_Interact, splashSize);<br>&#9;&#9;&#9;if ( NewZone.EntryActor != None )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;splash = Spawn(NewZone.EntryActor); <br>&#9;&#9;&#9;&#9;if ( splash != None )<br>&#9;&#9;&#9;&#9;&#9;splash.DrawScale = 2 * splashSize;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;<br></div>
<br><br><hr>
<a class="headerlink" href="#InventorySpot.uc" title="Permanent link"><h2 id="InventorySpot.uc">InventorySpot.uc (extends NavigationPoint)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var Inventory markedItem;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bEndPointOnly=True<br>bCollideWhenPlacing=False<br>bHiddenEd=True<br>CollisionRadius=20.000000<br>CollisionHeight=40.000000</div>
<br><br><hr>
<a class="headerlink" href="#Keypoint.uc" title="Permanent link"><h2 id="Keypoint.uc">Keypoint.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bStatic=True<br>bHidden=True<br>Texture=Texture'Engine.S_Keypoint'<br>SoundVolume=0<br>CollisionRadius=10.000000<br>CollisionHeight=10.000000</div>
<br><br><hr>
<a class="headerlink" href="#LevelInfo.uc" title="Permanent link"><h2 id="LevelInfo.uc">LevelInfo.uc (extends ZoneInfo)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() float TimeDilation;          // Normally 1 - scales real time passage.<br>var           float	TimeSeconds;   // Time in seconds since level began play.<br>var transient int   Year;          // Year.<br>var transient int   Month;         // Month.<br>var transient int   Day;           // Day of month.<br>var transient int   DayOfWeek;     // Day of week.<br>var transient int   Hour;          // Hour.<br>var transient int   Minute;        // Minute.<br>var transient int   Second;        // Second.<br>var transient int   Millisecond;   // Millisecond.<br>var() localized string Title;<br>var()           string Author;		    // Who built it.<br>var() localized string IdealPlayerCount;// Ideal number of players for this level. I.E.: 6-8<br>var() int	RecommendedEnemies;			// number of enemy bots recommended (used by rated games)<br>var() int	RecommendedTeammates;		// number of friendly bots recommended (used by rated games)<br>var() localized string LevelEnterText;  // Message to tell players when they enter.<br>var()           string LocalizedPkg;    // Package to look in for localizations.<br>var             string Pauser;          // If paused, name of person pausing the game.<br>var levelsummary Summary;<br>var() bool           bLonePlayer;     // No multiplayer coordination, i.e. for entranceways.<br>var bool             bBegunPlay;      // Whether gameplay has begun.<br>var bool             bPlayersOnly;    // Only update players.<br>var bool             bHighDetailMode; // Client high-detail mode.<br>var bool			 bDropDetail;	  // frame rate is below DesiredFrameRate, so drop high detail actors<br>var bool			 bAggressiveLOD;  // frame rate is well below DesiredFrameRate, so make LOD more aggressive<br>var bool             bStartup;        // Starting gameplay.<br>var() bool			 bHumansOnly;	  // Only allow "human" player pawns in this level<br>var bool			 bNoCheating;<br>var bool			 bAllowFOV;<br>var(Audio) const music  Song;          // Default song for level.<br>var(Audio) const byte   SongSection;   // Default song order for level.<br>var(Audio) const byte   CdTrack;       // Default CD track for level.<br>var(Audio) float        PlayerDoppler; // Player doppler shift, 0=none, 1=full.<br>var() float Brightness;<br>var() texture Screenshot;<br>var texture DefaultTexture;<br>var int HubStackLevel;<br>var transient enum ELevelAction<br>var() bool bNeverPrecache;<br>var enum ENetMode<br>var string ComputerName;  // Machine's name according to the OS.<br>var string EngineVersion; // Engine version.<br>var string MinNetVersion; // Min engine version that is net compatible.<br>var() class<gameinfo> DefaultGameType;<br>var GameInfo Game;<br>var const NavigationPoint NavigationPointList;<br>var const Pawn PawnList;<br>var const EventManager EventManager;<br>var string NextURL;<br>var bool bNextItems;<br>var float NextSwitchCountdown;<br>var int AIProfile[8]; // TEMP statistics<br>var float AvgAITime;	//moving average of Actor time<br>var() bool bCheckWalkSurfaces; // enable texture-specific physics code for Pawns.<br>var SpawnNotify SpawnNotify;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">TimeDilation=1.000000<br>Title="Untitled"<br>bHighDetailMode=True<br>CdTrack=255<br>Brightness=1.000000<br>DefaultTexture=Texture'Engine.DefaultTexture'<br>bHiddenEd=True</div>
<h3 id="LevelInfo.GetAddressURL"><a class="headerlink" href="#LevelInfo.GetAddressURL" title="Permanent link">GetAddressURL</a> -> string | native</h3>

<h3 id="LevelInfo.GetLocalURL"><a class="headerlink" href="#LevelInfo.GetLocalURL" title="Permanent link">GetLocalURL</a> -> string | native</h3>

<h3 id="LevelInfo.InitEventManager"><a class="headerlink" href="#LevelInfo.InitEventManager" title="Permanent link">InitEventManager</a> | native</h3>

<h3 id="LevelInfo.PreBeginPlay"><a class="headerlink" href="#LevelInfo.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.PreBeginPlay();<br>&#9;InitEventManager();<br><br></div>
<h3 id="LevelInfo.ServerTravel"><a class="headerlink" href="#LevelInfo.ServerTravel" title="Permanent link">ServerTravel</a> (string URL, bool bItems)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>   if (NetMode == NM_Standalone)<br>      return;<br>&#9;if( NextURL=="" )<br>&#9;{<br>&#9;&#9;bNextItems          = bItems;<br>&#9;&#9;NextURL             = URL;<br>&#9;&#9;if( Game!=None )<br>&#9;&#9;&#9;Game.ProcessServerTravel( URL, bItems );<br>&#9;&#9;else<br>&#9;&#9;&#9;NextSwitchCountdown = 0;<br>&#9;}<br><br></div>
<br><br><hr>
<a class="headerlink" href="#LevelSummary.uc" title="Permanent link"><h2 id="LevelSummary.uc">LevelSummary.uc (extends Object)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() localized string Title;<br>var()           string Author;<br>var() localized string IdealPlayerCount;<br>var() int	RecommendedEnemies;<br>var() int	RecommendedTeammates;<br>var() localized string LevelEnterText;</div>
<br><br><hr>
<a class="headerlink" href="#LiftCenter.uc" title="Permanent link"><h2 id="LiftCenter.uc">LiftCenter.uc (extends NavigationPoint)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() name LiftTag;<br>var() name LiftTrigger;<br>var trigger RecommendedTrigger;<br>var float LastTriggerTime;<br>var() float MaxZDiffAdd;  //added threshold for Z difference between pawn and lift (for lifts which are at the end of a ramp or stairs)<br>var() float MaxDist2D;<br>var vector LiftOffset;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">MaxDist2D=400.000000<br>ExtraCost=400<br>bStatic=False<br>bNoDelete=True<br>RemoteRole=ROLE_None</div>
<h3 id="LiftCenter.PostBeginPlay"><a class="headerlink" href="#LiftCenter.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( LiftTag != '' )<br>&#9;&#9;ForEach AllActors(class'Mover', MyLift, LiftTag )<br>&#9;&#9;{<br>&#9;&#9;&#9;MyLift.myMarker = self;<br>&#9;&#9;&#9;SetBase(MyLift);<br>&#9;&#9;&#9;LiftOffset = Location - MyLift.Location;<br>&#9;&#9;&#9;if ( MyLift.InitialState == 'BumpOpenTimed' )<br>&#9;&#9;&#9;&#9;log("Warning: "$MyLift$" is BumpOpenTimed.  Bots don't understand this well - use StandOpenTimed instead!");<br>&#9;&#9;&#9;break;<br>&#9;&#9;}<br>&#9;// log(self$" attached to "$MyLift);<br>&#9;if ( LiftTrigger != '' )<br>&#9;&#9;ForEach AllActors(class'Trigger', RecommendedTrigger, LiftTrigger )<br>&#9;&#9;&#9;break;<br>&#9;Super.PostBeginPlay();<br><br></div>
<h3 id="LiftCenter.SpecialHandling"><a class="headerlink" href="#LiftCenter.SpecialHandling" title="Permanent link">SpecialHandling</a> (Pawn Other) -> Actor</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float dist2d;<br>&#9;local NavigationPoint N, Exit;<br><br><br>&#9;if ( MyLift == None )<br>&#9;&#9;return self;<br>&#9;if ( Other.base == MyLift )<br>&#9;{<br>&#9;&#9;if ( (RecommendedTrigger != None) <br>&#9;&#9;&& (myLift.SavedTrigger == None)<br>&#9;&#9;&& (Level.TimeSeconds - LastTriggerTime > 5) )<br>&#9;&#9;{<br>&#9;&#9;&#9;Other.SpecialGoal = RecommendedTrigger;<br>&#9;&#9;&#9;LastTriggerTime = Level.TimeSeconds;<br>&#9;&#9;&#9;return RecommendedTrigger;<br>&#9;&#9;}<br><br>&#9;&#9;return self;<br>&#9;}<br><br>&#9;if ( (LiftExit(Other.MoveTarget) != None) <br>&#9;&#9;&& (LiftExit(Other.MoveTarget).RecommendedTrigger != None)<br>&#9;&#9;&& (LiftExit(Other.MoveTarget).LiftTag == LiftTag)<br>&#9;&#9;&& (Level.TimeSeconds - LiftExit(Other.MoveTarget).LastTriggerTime > 5)<br>&#9;&#9;&& (MyLift.SavedTrigger == None)<br>&#9;&#9;&& (Abs(Other.Location.X - Other.MoveTarget.Location.X) < Other.CollisionRadius)<br>&#9;&#9;&& (Abs(Other.Location.Y - Other.MoveTarget.Location.Y) < Other.CollisionRadius)<br>&#9;&#9;&& (Abs(Other.Location.Z - Other.MoveTarget.Location.Z) < Other.CollisionHeight) )<br>&#9;{<br>&#9;&#9;LiftExit(Other.MoveTarget).LastTriggerTime = Level.TimeSeconds;<br>&#9;&#9;Other.SpecialGoal = LiftExit(Other.MoveTarget).RecommendedTrigger;<br>&#9;&#9;return LiftExit(Other.MoveTarget).RecommendedTrigger;<br>&#9;}<br><br>&#9;SetLocation(MyLift.Location + LiftOffset);<br>&#9;SetBase(MyLift);<br>&#9;dist2d = square(Location.X - Other.Location.X) + square(Location.Y - Other.Location.Y);<br>&#9;if ( (Location.Z - CollisionHeight - MaxZDiffAdd < Other.Location.Z - Other.CollisionHeight + Other.MaxStepHeight)<br>&#9;&#9;&& (Location.Z - CollisionHeight > Other.Location.Z - Other.CollisionHeight - 1200)<br>&#9;&#9;&& ( dist2D < MaxDist2D * MaxDist2D) )<br>&#9;{<br>&#9;&#9;return self;<br>&#9;}<br><br>&#9;if ( MyLift.BumpType == BT_PlayerBump && !Other.bIsPlayer )<br>&#9;&#9;return None;<br>&#9;Other.SpecialGoal = None;<br>&#9;&#9;<br>&#9;// make sure Other is at valid lift exit<br>&#9;if ( LiftExit(Other.MoveTarget) == None )<br>&#9;{<br>&#9;&#9;for ( N=Level.NavigationPointList; N!=None; N=N.NextNavigationPoint )<br>&#9;&#9;&#9;if ( N.IsA('LiftExit') && (LiftExit(N).LiftTag == LiftTag) <br>&#9;&#9;&#9;&#9;&& (Abs(Other.Location.X - N.Location.X) < Other.CollisionRadius)<br>&#9;&#9;&#9;&#9;&& (Abs(Other.Location.Y - N.Location.Y) < Other.CollisionRadius)<br>&#9;&#9;&#9;&#9;&& (Abs(Other.Location.Z - N.Location.Z) < Other.CollisionHeight) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;Exit = N;<br>&#9;&#9;&#9;&#9;break;<br>&#9;&#9;&#9;}<br>&#9;&#9;if ( Exit == None )<br>&#9;&#9;&#9;return self;<br>&#9;}<br><br>&#9;MyLift.HandleDoor(Other);<br>&#9;MyLift.RecommendedTrigger = None;<br><br>&#9;if ( (Other.SpecialGoal == MyLift) || (Other.SpecialGoal == None) )<br>&#9;&#9;Other.SpecialGoal = self;<br><br>&#9;return Other.SpecialGoal;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#LiftExit.uc" title="Permanent link"><h2 id="LiftExit.uc">LiftExit.uc (extends NavigationPoint)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() name LiftTag;<br>var() name LiftTrigger;<br>var trigger RecommendedTrigger;<br>var float LastTriggerTime;</div>
<h3 id="LiftExit.PostBeginPlay"><a class="headerlink" href="#LiftExit.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( LiftTag != '' )<br>&#9;&#9;ForEach AllActors(class'Mover', MyLift, LiftTag )<br>&#9;&#9;&#9;break;<br>&#9;//log(self$" attached to "$MyLift);<br>&#9;if ( LiftTrigger != '' )<br>&#9;&#9;ForEach AllActors(class'Trigger', RecommendedTrigger, LiftTrigger )<br>&#9;&#9;&#9;break;<br>&#9;Super.PostBeginPlay();<br><br></div>
<h3 id="LiftExit.SpecialHandling"><a class="headerlink" href="#LiftExit.SpecialHandling" title="Permanent link">SpecialHandling</a> (Pawn Other) -> Actor</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br><br>&#9;if ( (Other.Base == MyLift) && (MyLift != None) )<br>&#9;{<br>&#9;&#9;if ( (self.Location.Z < Other.Location.Z + Other.CollisionHeight)<br>&#9;&#9;&#9; && Other.LineOfSightTo(self) )<br>&#9;&#9;&#9;return self;<br>&#9;&#9;Other.SpecialGoal = None;<br>&#9;&#9;Other.DesiredRotation = rotator(Location - Other.Location);<br>&#9;&#9;MyLift.HandleDoor(Other);<br><br>&#9;&#9;if ( (Other.SpecialGoal == MyLift) || (Other.SpecialGoal == None) )<br>&#9;&#9;&#9;Other.SpecialGoal = MyLift.myMarker;<br>&#9;&#9;return Other.SpecialGoal;<br>&#9;}<br>&#9;return self;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Light.uc" title="Permanent link"><h2 id="Light.uc">Light.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bStatic=True<br>bHidden=True<br>bNoDelete=True<br>bMovable=False<br>Texture=Texture'Engine.S_Light'<br>CollisionRadius=24.000000<br>CollisionHeight=24.000000<br>LightType=LT_Steady<br>LightBrightness=64<br>LightSaturation=255<br>LightRadius=64<br>LightPeriod=32<br>LightCone=128<br>VolumeBrightness=64</div>
<br><br><hr>
<a class="headerlink" href="#LocalMessage.uc" title="Permanent link"><h2 id="LocalMessage.uc">LocalMessage.uc (extends Info)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var bool	bComplexString;									// Indicates a multicolor string message class.<br>var bool	bIsSpecial;										// If true, don't add to normal queue.<br>var bool	bIsUnique;										// If true and special, only one can be in the HUD queue at a time.<br>var bool	bIsConsoleMessage;								// If true, put a GetString on the console.<br>var bool	bFadeMessage;									// If true, use fade out effect on message.<br>var bool	bBeep;											// If true, beep!<br>var bool	bOffsetYPos;									// If the YPos indicated isn't where the message appears.<br>var int		Lifetime;										// # of seconds to stay in HUD message queue.<br>var class<LocalMessage> ChildMessage;						// In some cases, we need to refer to a child message.<br>var bool	bFromBottom;									// Subtract YPos.<br>var color	DrawColor;										// Color to display message with.<br>var float	XPos, YPos;										// Coordinates to print message at.<br>var bool	bCenter;										// Whether or not to center the message.</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Lifetime=3<br>DrawColor=(R=255,G=255,B=255)</div>
<h3 id="LocalMessage.GetFontSize"><a class="headerlink" href="#LocalMessage.GetFontSize" title="Permanent link">GetFontSize</a> (int Switch) -> int</h3>

<h3 id="LocalMessage.GetOffset"><a class="headerlink" href="#LocalMessage.GetOffset" title="Permanent link">GetOffset</a> (int Switch, float YL, float ClipY) -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return Default.YPos;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#MapList.uc" title="Permanent link"><h2 id="MapList.uc">MapList.uc (extends Info)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var(Maps) globalconfig string Maps[32];<br>var globalconfig int MapNum;</div>
<h3 id="MapList.GetNextMap"><a class="headerlink" href="#MapList.GetNextMap" title="Permanent link">GetNextMap</a> -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string CurrentMap;<br>&#9;local int i;<br><br><br>&#9;CurrentMap = GetURLMap();<br>&#9;if ( CurrentMap != "" )<br>&#9;{<br>&#9;&#9;if ( Right(CurrentMap,4) ~= ".unr" )<br>&#9;&#9;&#9;CurrentMap = CurrentMap;<br>&#9;&#9;else<br>&#9;&#9;&#9;CurrentMap = CurrentMap$".unr";<br><br>&#9;&#9;for ( i=0; i<ArrayCount(Maps); i++ )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( CurrentMap ~= Maps[i] )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;MapNum = i;<br>&#9;&#9;&#9;&#9;break;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;}<br><br>&#9;// search vs. w/ or w/out .unr extension<br><br>&#9;MapNum++;<br>&#9;if ( MapNum > ArrayCount(Maps) - 1 )<br>&#9;&#9;MapNum = 0;<br>&#9;if ( Maps[MapNum] == "" )<br>&#9;&#9;MapNum = 0;<br><br>&#9;SaveConfig();<br>&#9;return Maps[MapNum];<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Menu.uc" title="Permanent link"><h2 id="Menu.uc">Menu.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var Menu	ParentMenu;<br>var int		Selection;<br>var() int	MenuLength;<br>var bool	bConfigChanged;<br>var bool    bExitAllMenus;<br>var PlayerPawn PlayerOwner;<br>var() localized string HelpMessage[24];<br>var() localized string MenuList[24];<br>var() localized string LeftString;<br>var() localized string RightString;<br>var() localized string CenterString;<br>var() localized string EnabledString;<br>var() localized string DisabledString;<br>var() localized string MenuTitle;<br>var() localized string YesString;<br>var() localized string NoString;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Selection=1<br>HelpMessage(1)="This menu has not yet been implemented."<br>LeftString="Left"<br>RightString="Right"<br>CenterString="Center"<br>EnabledString="Enabled"<br>DisabledString="Disabled"<br>YesString="yes"<br>NoString="no"<br>bHidden=True</div>
<h3 id="Menu.DrawMenu"><a class="headerlink" href="#Menu.DrawMenu" title="Permanent link">DrawMenu</a> (canvas Canvas)</h3>

<h3 id="Menu.ExitAllMenus"><a class="headerlink" href="#Menu.ExitAllMenus" title="Permanent link">ExitAllMenus</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;while ( Hud(Owner).MainMenu != None )<br>&#9;&#9;Hud(Owner).MainMenu.ExitMenu();<br><br></div>
<h3 id="Menu.ExitMenu"><a class="headerlink" href="#Menu.ExitMenu" title="Permanent link">ExitMenu</a> -> Menu</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Hud(Owner).MainMenu = ParentMenu;<br>&#9;if ( bConfigChanged )<br>&#9;&#9;SaveConfigs();<br>&#9;if ( ParentMenu == None )<br>&#9;{<br>&#9;&#9;PlayerOwner.bShowMenu = false;<br>&#9;&#9;PlayerOwner.Player.Console.GotoState('');<br>&#9;&#9;if( Level.Netmode == NM_Standalone )<br>&#9;&#9;&#9;PlayerOwner.SetPause(False);<br>&#9;}<br><br>&#9;Destroy();<br><br></div>
<h3 id="Menu.MenuInit"><a class="headerlink" href="#Menu.MenuInit" title="Permanent link">MenuInit</a></h3>

<h3 id="Menu.MenuProcessInput"><a class="headerlink" href="#Menu.MenuProcessInput" title="Permanent link">MenuProcessInput</a> (byte KeyNum, byte ActionNum)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( KeyNum == EInputKey.IK_Escape )<br>&#9;{<br>&#9;&#9;PlayEnterSound();<br>&#9;&#9;ExitMenu();<br>&#9;&#9;return;<br>&#9;}&#9;<br>&#9;else if ( KeyNum == EInputKey.IK_Up )<br>&#9;{<br>&#9;&#9;PlaySelectSound();<br>&#9;&#9;Selection--;<br>&#9;&#9;if ( Selection < 1 )<br>&#9;&#9;&#9;Selection = MenuLength;<br>&#9;}<br>&#9;else if ( KeyNum == EInputKey.IK_Down )<br>&#9;{<br>&#9;&#9;PlaySelectSound();<br>&#9;&#9;Selection++;<br>&#9;&#9;if ( Selection > MenuLength )<br>&#9;&#9;&#9;Selection = 1;<br>&#9;}<br>&#9;else if ( KeyNum == EInputKey.IK_Enter )<br>&#9;{<br>&#9;&#9;bConfigChanged=true;<br>&#9;&#9;if ( ProcessSelection() )<br>&#9;&#9;&#9;PlayEnterSound();<br>&#9;}<br>&#9;else if ( KeyNum == EInputKey.IK_Left )<br>&#9;{<br>&#9;&#9;bConfigChanged=true;<br>&#9;&#9;if ( ProcessLeft() )<br>&#9;&#9;&#9;PlayModifySound();<br>&#9;}<br>&#9;else if ( KeyNum == EInputKey.IK_Right )<br>&#9;{<br>&#9;&#9;bConfigChanged=true;<br>&#9;&#9;if ( ProcessRight() )<br>&#9;&#9;&#9;PlayModifySound();<br>&#9;}<br>&#9;else if ( Chr(KeyNum) ~= left(YesString, 1) ) <br>&#9;{<br>&#9;&#9;bConfigChanged=true;<br>&#9;&#9;if ( ProcessYes() )<br>&#9;&#9;&#9;PlayModifySound();<br>&#9;}<br>&#9;else if ( Chr(KeyNum) ~= left(NoString, 1) )<br>&#9;{<br>&#9;&#9;bConfigChanged=true;<br>&#9;&#9;if ( ProcessNo() )<br>&#9;&#9;&#9;PlayModifySound();<br>&#9;}<br><br>&#9;if ( bExitAllMenus )<br>&#9;&#9;ExitAllMenus(); <br>&#9;<br><br></div>
<h3 id="Menu.MenuTick"><a class="headerlink" href="#Menu.MenuTick" title="Permanent link">MenuTick</a> (float DeltaTime)</h3>

<h3 id="Menu.PlayEnterSound"><a class="headerlink" href="#Menu.PlayEnterSound" title="Permanent link">PlayEnterSound</a></h3>

<h3 id="Menu.PlayModifySound"><a class="headerlink" href="#Menu.PlayModifySound" title="Permanent link">PlayModifySound</a></h3>

<h3 id="Menu.PlaySelectSound"><a class="headerlink" href="#Menu.PlaySelectSound" title="Permanent link">PlaySelectSound</a></h3>

<h3 id="Menu.ProcessLeft"><a class="headerlink" href="#Menu.ProcessLeft" title="Permanent link">ProcessLeft</a> -> bool</h3>

<h3 id="Menu.ProcessMenuEscape"><a class="headerlink" href="#Menu.ProcessMenuEscape" title="Permanent link">ProcessMenuEscape</a></h3>

<h3 id="Menu.ProcessMenuInput"><a class="headerlink" href="#Menu.ProcessMenuInput" title="Permanent link">ProcessMenuInput</a> (coerce string InputString)</h3>

<h3 id="Menu.ProcessMenuKey"><a class="headerlink" href="#Menu.ProcessMenuKey" title="Permanent link">ProcessMenuKey</a> (int KeyNo, string KeyName)</h3>

<h3 id="Menu.ProcessMenuUpdate"><a class="headerlink" href="#Menu.ProcessMenuUpdate" title="Permanent link">ProcessMenuUpdate</a> (coerce string InputString)</h3>

<h3 id="Menu.ProcessNo"><a class="headerlink" href="#Menu.ProcessNo" title="Permanent link">ProcessNo</a> -> bool</h3>

<h3 id="Menu.ProcessRight"><a class="headerlink" href="#Menu.ProcessRight" title="Permanent link">ProcessRight</a> -> bool</h3>

<h3 id="Menu.ProcessSelection"><a class="headerlink" href="#Menu.ProcessSelection" title="Permanent link">ProcessSelection</a> -> bool</h3>

<h3 id="Menu.ProcessYes"><a class="headerlink" href="#Menu.ProcessYes" title="Permanent link">ProcessYes</a> -> bool</h3>

<h3 id="Menu.SaveConfigs"><a class="headerlink" href="#Menu.SaveConfigs" title="Permanent link">SaveConfigs</a></h3>

<h3 id="Menu.SetFontBrightness"><a class="headerlink" href="#Menu.SetFontBrightness" title="Permanent link">SetFontBrightness</a> (canvas Canvas, bool bBright)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( bBright )<br>&#9;{<br>&#9;&#9;Canvas.DrawColor.R = 255;<br>&#9;&#9;Canvas.DrawColor.G = 255;<br>&#9;&#9;Canvas.DrawColor.B = 255;<br>&#9;}<br>&#9;else <br>&#9;&#9;Canvas.DrawColor = Canvas.Default.DrawColor;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#MessagingSpectator.uc" title="Permanent link"><h2 id="MessagingSpectator.uc">MessagingSpectator.uc (extends Spectator)</h2></a>

<h3 id="MessagingSpectator.PostBeginPlay"><a class="headerlink" href="#MessagingSpectator.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.PostBeginPlay();<br>&#9;bIsPlayer = False;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Mover.uc" title="Permanent link"><h2 id="Mover.uc">Mover.uc (extends Brush)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() enum EMoverEncroachType<br>var() enum EMoverGlideType<br>var() enum EBumpType<br>var() byte       KeyNum;           // Current or destination keyframe.<br>var byte         PrevKeyNum;       // Previous keyframe.<br>var() const byte NumKeys;          // Number of keyframes in total (0-3).<br>var() const byte WorldRaytraceKey; // Raytrace the world with the brush here.<br>var() const byte BrushRaytraceKey; // Raytrace the brush here.<br>var() float      MoveTime;         // Time to spend moving between keyframes.<br>var() float      StayOpenTime;     // How long to remain open before closing.<br>var() float      OtherTime;        // TriggerPound stay-open time.<br>var() int        EncroachDamage;   // How much to damage encroached actors.<br>var() bool       bTriggerOnceOnly; // Go dormant after first trigger.<br>var() bool       bSlave;           // This brush is a slave.<br>var() bool		 bUseTriggered;		// Triggered by player grab<br>var() bool		 bDamageTriggered;	// Triggered by taking damage<br>var() bool       bDynamicLightMover; // Apply dynamic lighting to mover.<br>var() name       PlayerBumpEvent;  // Optional event to cause when the player bumps the mover.<br>var() name       BumpEvent;			// Optional event to cause when any valid bumper bumps the mover.<br>var   actor      SavedTrigger;      // Who we were triggered by.<br>var() float		 DamageThreshold;	// minimum damage to trigger<br>var() name		 ReturnGroup;		// if none, same as tag<br>var() float		 DelayTime;			// delay before starting to open<br>var(MoverSounds) sound      OpeningSound;     // When start opening.<br>var(MoverSounds) sound      OpenedSound;      // When finished opening.<br>var(MoverSounds) sound      ClosingSound;     // When start closing.<br>var(MoverSounds) sound      ClosedSound;      // When finish closing.<br>var(MoverSounds) sound      MoveAmbientSound; // Optional ambient sound when moving.<br>var vector       KeyPos[8];<br>var rotator      KeyRot[8];<br>var vector       BasePos, OldPos, OldPrePivot, SavedPos;<br>var rotator      BaseRot, OldRot, SavedRot;<br>var       NavigationPoint  myMarker;<br>var     rotator			RealRotation;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">MoverEncroachType=ME_ReturnWhenEncroach<br>MoverGlideType=MV_GlideByTime<br>NumKeys=2<br>MoveTime=1.000000<br>StayOpenTime=4.000000<br>bStatic=False<br>Physics=PHYS_MovingBrush<br>RemoteRole=ROLE_SimulatedProxy<br>InitialState=BumpOpenTimed<br>bIsMover=True<br>bAlwaysRelevant=True<br>SoundVolume=228<br>TransientSoundVolume=3.000000<br>CollisionRadius=160.000000<br>CollisionHeight=160.000000<br>bCollideActors=True<br>bBlockActors=True<br>bBlockPlayers=True<br>NetPriority=2.700000</div>
<h3 id="Mover.Attach"><a class="headerlink" href="#Mover.Attach" title="Permanent link">Attach</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local pawn  P;<br><br><br>&#9;&#9;P = Pawn(Other);<br>&#9;&#9;if ( (BumpType != BT_AnyBump) && (P == None) )<br>&#9;&#9;&#9;return;<br>&#9;&#9;if ( (BumpType == BT_PlayerBump) && !P.bIsPlayer )<br>&#9;&#9;&#9;return;<br>&#9;&#9;if ( (BumpType == BT_PawnBump) && (Other.Mass < 10) )<br>&#9;&#9;&#9;return;<br>&#9;&#9;SavedTrigger = None;<br>&#9;&#9;GotoState( 'StandOpenTimed', 'Open' );<br>&#9;<br></div>
<h3 id="Mover.BeginEvent"><a class="headerlink" href="#Mover.BeginEvent" title="Permanent link">BeginEvent</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;bSlave=true;<br>&#9;<br></div>
<h3 id="Mover.BeginPlay"><a class="headerlink" href="#Mover.BeginPlay" title="Permanent link">BeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local rotator R;<br><br><br>&#9;// timer updates real position every second in network play<br>&#9;if ( Level.NetMode != NM_Standalone )<br>&#9;{<br>&#9;&#9;if ( Level.NetMode == NM_Client )<br>&#9;&#9;&#9;settimer(4.0, true);<br>&#9;&#9;else<br>&#9;&#9;&#9;settimer(1.0, true);<br>&#9;&#9;if ( Role < ROLE_Authority )<br>&#9;&#9;&#9;return;<br>&#9;}<br><br>&#9;if ( Level.NetMode != NM_Client )<br>&#9;{<br>&#9;&#9;RealPosition = Location;<br>&#9;&#9;RealRotation = Rotation;<br>&#9;}<br><br>&#9;// Init key info.<br>&#9;Super.BeginPlay();<br>&#9;KeyNum         = Clamp( KeyNum, 0, ArrayCount(KeyPos)-1 );<br>&#9;PhysAlpha      = 0.0;<br><br>&#9;// Set initial location.<br>&#9;Move( BasePos + KeyPos[KeyNum] - Location );<br><br>&#9;// Initial rotation.<br>&#9;SetRotation( BaseRot + KeyRot[KeyNum] );<br><br>&#9;// find movers in same group<br>&#9;if ( ReturnGroup == '' )<br>&#9;&#9;ReturnGroup = tag;<br><br></div>
<h3 id="Mover.BeginState"><a class="headerlink" href="#Mover.BeginState" title="Permanent link">BeginState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;numTriggerEvents = 0;<br>&#9;<br></div>
<h3 id="Mover.Bump"><a class="headerlink" href="#Mover.Bump" title="Permanent link">Bump</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( (BumpType != BT_AnyBump) && (Pawn(Other) == None) )<br>&#9;&#9;&#9;return;<br>&#9;&#9;if ( (BumpType == BT_PlayerBump) && !Pawn(Other).bIsPlayer )<br>&#9;&#9;&#9;return;<br>&#9;&#9;if ( (BumpType == BT_PawnBump) && (Other.Mass < 10) )<br>&#9;&#9;&#9;return;<br>&#9;&#9;Global.Bump( Other );<br>&#9;&#9;SavedTrigger = Other;<br>&#9;&#9;Instigator = Pawn( Other );<br>&#9;&#9;GotoState( 'BumpButton', 'Open' );<br>&#9;<br></div>
<h3 id="Mover.DoClose"><a class="headerlink" href="#Mover.DoClose" title="Permanent link">DoClose</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor A;<br><br><br>&#9;bOpening = false;<br>&#9;bDelaying = false;<br>&#9;InterpolateTo( Max(0,KeyNum-1), MoveTime );<br>//&#9;PlaySound( ClosingSound, SLOT_None );<br>&#9;// DEUS_EX CNN - make the sounds use SoundRadius and SoundVolume<br>&#9;PlaySound( ClosingSound, SLOT_None, TransientSoundVolume*SoundVolume/255.0,, 25.0*(SoundRadius+1) );<br>&#9;if( Event != '' )<br>&#9;&#9;foreach AllActors( class 'Actor', A, Event )<br>&#9;&#9;&#9;A.UnTrigger( Self, Instigator );<br>&#9;AmbientSound = MoveAmbientSound;<br><br></div>
<h3 id="Mover.DoOpen"><a class="headerlink" href="#Mover.DoOpen" title="Permanent link">DoOpen</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bOpening = true;<br>&#9;bDelaying = false;<br>&#9;InterpolateTo( 1, MoveTime );<br>//&#9;PlaySound( OpeningSound, SLOT_None );<br>&#9;// DEUS_EX CNN - make the sounds use SoundRadius and SoundVolume<br>&#9;PlaySound( OpeningSound, SLOT_None, TransientSoundVolume*SoundVolume/255.0,, 25.0*(SoundRadius+1) );<br>&#9;AmbientSound = MoveAmbientSound;<br><br></div>
<h3 id="Mover.EncroachingOn"><a class="headerlink" href="#Mover.EncroachingOn" title="Permanent link">EncroachingOn</a> (actor Other) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br><br>&#9;if ( Other.IsA('Carcass') || Other.IsA('Decoration') )<br>&#9;{<br>&#9;&#9;Other.TakeDamage(10000, None, Other.Location, vect(0,0,0), 'Crushed');<br>&#9;&#9;return false;<br>&#9;}<br>&#9;// DEUS_EX CNN - Don't destroy inventory items when encroached!<br>//&#9;if ( Other.IsA('Fragment') || (Other.IsA('Inventory') && (Other.Owner == None)) )<br>&#9;if (Other.IsA('Fragment'))<br>&#9;{<br>&#9;&#9;Other.Destroy();<br>&#9;&#9;return false;<br>&#9;}<br><br>&#9;// DEUS_EX CNN - make based actors not stop movers<br>&#9;if (Other.Base == Self)<br>&#9;{<br>&#9;&#9;return False;<br>&#9;}<br><br>&#9;// Damage the encroached actor.<br>&#9;if( EncroachDamage != 0 )<br>&#9;&#9;Other.TakeDamage( EncroachDamage, Instigator, Other.Location, vect(0,0,0), 'Crushed' );<br><br>&#9;// If we have a bump-player event, and Other is a pawn, do the bump thing.<br>&#9;P = Pawn(Other);<br>&#9;if( P!=None && P.bIsPlayer )<br>&#9;{<br>&#9;&#9;if ( PlayerBumpEvent!='' )<br>&#9;&#9;&#9;Bump( Other );<br>&#9;&#9;if ( (MyMarker != None) && (P.Base != self) <br>&#9;&#9;&#9;&& (P.Location.Z < MyMarker.Location.Z - P.CollisionHeight - 0.7 * MyMarker.CollisionHeight) )<br>&#9;&#9;&#9;// pawn is under lift - tell him to move<br>&#9;&#9;&#9;P.UnderLift(self);<br>&#9;}<br><br>&#9;// Stop, return, or whatever.<br>&#9;if( MoverEncroachType == ME_StopWhenEncroach )<br>&#9;{<br>&#9;&#9;Leader.MakeGroupStop();<br>&#9;&#9;return true;<br>&#9;}<br>&#9;else if( MoverEncroachType == ME_ReturnWhenEncroach )<br>&#9;{<br>&#9;&#9;Leader.MakeGroupReturn();<br>&#9;&#9;if ( Other.IsA('Pawn') )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( Pawn(Other).bIsPlayer )<br>&#9;&#9;&#9;&#9;Pawn(Other).PlaySound(Pawn(Other).Land, SLOT_None);&#9;&#9;&#9;// DEUS_EX CNN - Changed from SLOT_Talk<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;Pawn(Other).PlaySound(Pawn(Other).HitSound1, SLOT_None);&#9;// DEUS_EX CNN - Changed from SLOT_Talk<br>&#9;&#9;}&#9;<br>&#9;&#9;return true;<br>&#9;}<br>&#9;else if( MoverEncroachType == ME_CrushWhenEncroach )<br>&#9;{<br>&#9;&#9;// Kill it.<br>&#9;&#9;Other.KilledBy( Instigator );<br>&#9;&#9;return false;<br>&#9;}<br>&#9;else if( MoverEncroachType == ME_IgnoreWhenEncroach )<br>&#9;{<br>&#9;&#9;// Ignore it.<br>&#9;&#9;return false;<br>&#9;}<br><br></div>
<h3 id="Mover.EndEvent"><a class="headerlink" href="#Mover.EndEvent" title="Permanent link">EndEvent</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;bSlave     = false;<br>&#9;&#9;Instigator = None;<br>&#9;&#9;GotoState( 'BumpButton', 'Close' );<br>&#9;<br></div>
<h3 id="Mover.FindTriggerActor"><a class="headerlink" href="#Mover.FindTriggerActor" title="Permanent link">FindTriggerActor</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Actor A;<br><br><br>&#9;TriggerActor = None;<br>&#9;TriggerActor2 = None;<br>&#9;ForEach AllActors(class 'Actor', A)<br>&#9;&#9;if ( (A.Event == Tag) && (A.IsA('Trigger') || A.IsA('Mover')) )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( A.IsA('Counter') || A.IsA('Pawn') )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;bPlayerOnly = true;<br>&#9;&#9;&#9;&#9;return; //FIXME - handle counters<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;if (TriggerActor == None)<br>&#9;&#9;&#9;&#9;TriggerActor = A;<br>&#9;&#9;&#9;else if ( TriggerActor2 == None )<br>&#9;&#9;&#9;&#9;TriggerActor2 = A;<br>&#9;&#9;}<br><br>&#9;if ( TriggerActor == None )<br>&#9;{<br>&#9;&#9;bPlayerOnly = (BumpType == BT_PlayerBump);<br>&#9;&#9;return;<br>&#9;}<br><br>&#9;bPlayerOnly = ( TriggerActor.IsA('Trigger') && (Trigger(TriggerActor).TriggerType == TT_PlayerProximity) );<br>&#9;if ( bPlayerOnly && ( TriggerActor2 != None) )<br>&#9;{<br>&#9;&#9;bPlayerOnly = ( TriggerActor2.IsA('Trigger') && (Trigger(TriggerActor).TriggerType == TT_PlayerProximity) );<br>&#9;&#9;if ( !bPlayerOnly )<br>&#9;&#9;{<br>&#9;&#9;&#9;A = TriggerActor;<br>&#9;&#9;&#9;TriggerActor = TriggerActor2;<br>&#9;&#9;&#9;TriggerActor2 = A;<br>&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="Mover.FinishNotify"><a class="headerlink" href="#Mover.FinishNotify" title="Permanent link">FinishNotify</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br><br><br>&#9;if ( StandingCount > 0 )<br>&#9;&#9;for ( P=Level.PawnList; P!=None; P=P.nextPawn )<br>&#9;&#9;&#9;if ( P.Base == self )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;P.StopWaiting();<br>&#9;&#9;&#9;&#9;if ( (P.SpecialGoal == self) || (P.SpecialGoal == myMarker) )<br>&#9;&#9;&#9;&#9;&#9;P.SpecialGoal = None; <br>&#9;&#9;&#9;&#9;if ( P == WaitingPawn )<br>&#9;&#9;&#9;&#9;&#9;WaitingPawn = None;<br>&#9;&#9;&#9;}<br><br>&#9;if ( WaitingPawn != None )<br>&#9;{<br>&#9;&#9;WaitingPawn.StopWaiting();<br>&#9;&#9;if ( (WaitingPawn.SpecialGoal == self) || (WaitingPawn.SpecialGoal == myMarker) )<br>&#9;&#9;&#9;WaitingPawn.SpecialGoal = None; <br>&#9;&#9;WaitingPawn = None;<br>&#9;}<br><br></div>
<h3 id="Mover.FinishedClosing"><a class="headerlink" href="#Mover.FinishedClosing" title="Permanent link">FinishedClosing</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// Update sound effects.<br>//&#9;PlaySound( ClosedSound, SLOT_None );<br>&#9;// DEUS_EX CNN - make the sounds use SoundRadius and SoundVolume<br>&#9;PlaySound( ClosedSound, SLOT_None, TransientSoundVolume*SoundVolume/255.0,, 25.0*(SoundRadius+1) );<br><br>&#9;// Notify our triggering actor that we have completed.<br>&#9;if( SavedTrigger != None )<br>&#9;&#9;SavedTrigger.EndEvent();<br>&#9;SavedTrigger = None;<br>&#9;Instigator = None;<br>&#9;FinishNotify(); <br><br></div>
<h3 id="Mover.FinishedOpening"><a class="headerlink" href="#Mover.FinishedOpening" title="Permanent link">FinishedOpening</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor A;<br><br><br>&#9;// Update sound effects.<br>//&#9;PlaySound( OpenedSound, SLOT_None );<br>&#9;// DEUS_EX CNN - make the sounds use SoundRadius and SoundVolume<br>&#9;PlaySound( OpenedSound, SLOT_None, TransientSoundVolume*SoundVolume/255.0,, 25.0*(SoundRadius+1) );<br>&#9;<br>&#9;// Trigger any chained movers.<br>&#9;if( Event != '' )<br>&#9;&#9;foreach AllActors( class 'Actor', A, Event )<br>&#9;&#9;&#9;A.Trigger( Self, Instigator );<br><br>&#9;FinishNotify();<br><br></div>
<h3 id="Mover.HandleDoor"><a class="headerlink" href="#Mover.HandleDoor" title="Permanent link">HandleDoor</a> (pawn Other) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( bPlayerOnly && !Other.bIsPlayer )<br>&#9;&#9;&#9;return false;<br>&#9;&#9;Other.SpecialPause = 2.5;<br>&#9;&#9;WaitingPawn = Other;<br>&#9;&#9;if ( Other.Base == self )<br>&#9;&#9;&#9;Attach(Other);<br>&#9;&#9;return true;<br>&#9;<br></div>
<h3 id="Mover.HandleTriggerDoor"><a class="headerlink" href="#Mover.HandleTriggerDoor" title="Permanent link">HandleTriggerDoor</a> (pawn Other) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local bool bOne, bTwo;<br>&#9;local float DP1, DP2, Dist1, Dist2;<br><br><br>&#9;if ( bOpening || bDelaying )<br>&#9;{<br>&#9;&#9;WaitingPawn = Other;<br>&#9;&#9;Other.SpecialPause = 2.5;<br>&#9;&#9;return true;<br>&#9;}<br>&#9;if ( bPlayerOnly && !Other.bIsPlayer )<br>&#9;&#9;return false;<br>&#9;if ( bUseTriggered )<br>&#9;{<br>&#9;&#9;WaitingPawn = Other;<br>&#9;&#9;Other.SpecialPause = 2.5;<br>&#9;&#9;Trigger(Other, Other);<br>&#9;&#9;return true;<br>&#9;}<br>&#9;if ( (BumpEvent == tag) || (Other.bIsPlayer && (PlayerBumpEvent == tag)) )<br>&#9;{<br>&#9;&#9;WaitingPawn = Other;<br>&#9;&#9;Other.SpecialPause = 2.5;<br>&#9;&#9;if ( Other.Base == Self )<br>&#9;&#9;&#9;Trigger(Other, Other);<br>&#9;&#9;return true;<br>&#9;}<br>&#9;if ( bDamageTriggered )<br>&#9;{<br>&#9;&#9;WaitingPawn = Other;<br>&#9;&#9;Other.SpecialGoal = self;<br>&#9;&#9;if ( !Other.bCanDoSpecial || (Other.Weapon == None) )<br>&#9;&#9;&#9;return false;<br><br>&#9;&#9;Other.Target = self;<br>&#9;&#9;Other.bShootSpecial = true;<br>&#9;&#9;Other.FireWeapon();<br>&#9;&#9;Trigger(Self, Other);<br>&#9;&#9;Other.bFire = 0;<br>&#9;&#9;Other.bAltFire = 0;<br>&#9;&#9;return true;<br>&#9;}<br><br>&#9;if ( RecommendedTrigger != None )<br>&#9;{<br>&#9;&#9;Other.SpecialGoal = RecommendedTrigger;<br>&#9;&#9;Other.MoveTarget = RecommendedTrigger;<br>&#9;&#9;return True;<br>&#9;}<br><br>&#9;bOne = ( (TriggerActor != None) <br>&#9;&#9;&#9;&& (!TriggerActor.IsA('Trigger') || Trigger(TriggerActor).IsRelevant(Other)) );<br>&#9;bTwo = ( (TriggerActor2 != None) <br>&#9;&#9;&#9;&& (!TriggerActor2.IsA('Trigger') || Trigger(TriggerActor2).IsRelevant(Other)) );<br>&#9;<br>&#9;if ( bOne && bTwo )<br>&#9;{<br>&#9;&#9;// Dotp, dist<br>&#9;&#9;Dist1 = VSize(TriggerActor.Location - Other.Location);<br>&#9;&#9;Dist2 = VSize(TriggerActor2.Location - Other.Location);<br>&#9;&#9;if ( Dist1 < Dist2 )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( (Dist1 < 500) && Other.ActorReachable(TriggerActor) )<br>&#9;&#9;&#9;&#9;bTwo = false;<br>&#9;&#9;}<br>&#9;&#9;else if ( (Dist2 < 500) && Other.ActorReachable(TriggerActor2) )<br>&#9;&#9;&#9;bOne = false;<br>&#9;&#9;<br>&#9;&#9;if ( bOne && bTwo )<br>&#9;&#9;{<br>&#9;&#9;&#9;DP1 = Normal(Location - Other.Location) Dot (TriggerActor.Location - Other.Location)/Dist1;<br>&#9;&#9;&#9;DP2 = Normal(Location - Other.Location) Dot (TriggerActor2.Location - Other.Location)/Dist2;<br>&#9;&#9;&#9;if ( (DP1 > 0) && (DP2 < 0) )<br>&#9;&#9;&#9;&#9;bOne = false;<br>&#9;&#9;&#9;else if ( (DP1 < 0) && (DP2 > 0) )<br>&#9;&#9;&#9;&#9;bTwo = false;<br>&#9;&#9;&#9;else if ( Dist1 < Dist2 )<br>&#9;&#9;&#9;&#9;bTwo = false;<br>&#9;&#9;&#9;else <br>&#9;&#9;&#9;&#9;bOne = false;<br>&#9;&#9;}<br>&#9;}<br><br>&#9;if ( bOne )<br>&#9;{<br>&#9;&#9;Other.SpecialGoal = TriggerActor;<br>&#9;&#9;Other.MoveTarget = TriggerActor;<br>&#9;&#9;return True;<br>&#9;}<br>&#9;else if ( bTwo )<br>&#9;{<br>&#9;&#9;Other.SpecialGoal = TriggerActor2;<br>&#9;&#9;Other.MoveTarget = TriggerActor2;<br>&#9;&#9;return True;<br>&#9;}<br>&#9;return false;<br><br></div>
<h3 id="Mover.InterpolateEnd"><a class="headerlink" href="#Mover.InterpolateEnd" title="Permanent link">InterpolateEnd</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local byte OldKeyNum;<br><br><br>&#9;OldKeyNum  = PrevKeyNum;<br>&#9;PrevKeyNum = KeyNum;<br>&#9;PhysAlpha  = 0;<br>&#9;ClientUpdate--;<br><br>&#9;// If more than two keyframes, chain them.<br>&#9;if( KeyNum>0 && KeyNum<OldKeyNum )<br>&#9;{<br>&#9;&#9;// Chain to previous.<br>&#9;&#9;InterpolateTo(KeyNum-1,MoveTime);<br>&#9;}<br>&#9;else if( KeyNum<NumKeys-1 && KeyNum>OldKeyNum )<br>&#9;{<br>&#9;&#9;// Chain to next.<br>&#9;&#9;InterpolateTo(KeyNum+1,MoveTime);<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;// Finished interpolating.<br>&#9;&#9;AmbientSound = None;<br>&#9;&#9;if ( (ClientUpdate == 0) && (Level.NetMode != NM_Client) )<br>&#9;&#9;{<br>&#9;&#9;&#9;RealPosition = Location;<br>&#9;&#9;&#9;RealRotation = Rotation;<br>&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="Mover.InterpolateTo"><a class="headerlink" href="#Mover.InterpolateTo" title="Permanent link">InterpolateTo</a> (byte NewKeyNum, float Seconds)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;NewKeyNum = Clamp( NewKeyNum, 0, ArrayCount(KeyPos)-1 );<br>&#9;if( NewKeyNum==PrevKeyNum && KeyNum!=PrevKeyNum )<br>&#9;{<br>&#9;&#9;// Reverse the movement smoothly.<br>&#9;&#9;PhysAlpha = 1.0 - PhysAlpha;<br>&#9;&#9;OldPos    = BasePos + KeyPos[KeyNum];<br>&#9;&#9;OldRot    = BaseRot + KeyRot[KeyNum];<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;// Start a new movement.<br>&#9;&#9;OldPos    = Location;<br>&#9;&#9;OldRot    = Rotation;<br>&#9;&#9;PhysAlpha = 0.0;<br>&#9;}<br><br>&#9;// Setup physics.<br>&#9;SetPhysics(PHYS_MovingBrush);<br>&#9;bInterpolating   = true;<br>&#9;PrevKeyNum       = KeyNum;<br>&#9;KeyNum&#9;&#9;&#9; = NewKeyNum;<br>&#9;PhysRate         = 1.0 / FMax(Seconds, 0.005);<br><br>&#9;ClientUpdate++;<br>&#9;SimOldPos = OldPos;<br>&#9;SimOldRotYaw = OldRot.Yaw;<br>&#9;SimOldRotPitch = OldRot.Pitch;<br>&#9;SimOldRotRoll = OldRot.Roll;<br>&#9;SimInterpolate.X = 100 * PhysAlpha;<br>&#9;SimInterpolate.Y = 100 * FMax(0.01, PhysRate);<br>&#9;SimInterpolate.Z = 256 * PrevKeyNum + KeyNum;<br><br></div>
<h3 id="Mover.MakeGroupReturn"><a class="headerlink" href="#Mover.MakeGroupReturn" title="Permanent link">MakeGroupReturn</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// Abort move and reverse course.<br>&#9;bInterpolating = false;<br>&#9;AmbientSound = None;<br>&#9;if( KeyNum<PrevKeyNum )<br>&#9;&#9;GotoState( , 'Open' );<br>&#9;else<br>&#9;&#9;GotoState( , 'Close' );<br><br>&#9;if ( Follower != None )<br>&#9;&#9;Follower.MakeGroupReturn();<br><br></div>
<h3 id="Mover.MakeGroupStop"><a class="headerlink" href="#Mover.MakeGroupStop" title="Permanent link">MakeGroupStop</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// Stop moving immediately.<br>&#9;bInterpolating = false;<br>&#9;AmbientSound = None;<br>&#9;GotoState( , '' );<br><br>&#9;if ( Follower != None )<br>&#9;&#9;Follower.MakeGroupStop();<br><br></div>
<h3 id="Mover.PostBeginPlay"><a class="headerlink" href="#Mover.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local mover M;<br><br><br>&#9;//brushes can't be deleted, so if not relevant, make it invisible and non-colliding<br>&#9;if ( !Level.Game.IsRelevant(self) )<br>&#9;{<br>&#9;&#9;SetCollision(false, false, false);<br>&#9;&#9;SetLocation(Location + vect(0,0,20000)); // temp since still in bsp<br>&#9;&#9;bHidden = true;<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;FindTriggerActor();<br>&#9;&#9;// Initialize all slaves.<br>&#9;&#9;if( !bSlave )<br>&#9;&#9;{<br>&#9;&#9;&#9;foreach AllActors( class 'Mover', M, Tag )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if( M.bSlave )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;M.GotoState('');<br>&#9;&#9;&#9;&#9;&#9;M.SetBase( Self );<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;&#9;if ( Leader == None )<br>&#9;&#9;{&#9;<br>&#9;&#9;&#9;Leader = self;<br>&#9;&#9;&#9;ForEach AllActors( class'Mover', M )<br>&#9;&#9;&#9;&#9;if ( (M != self) && (M.ReturnGroup == ReturnGroup) )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;M.Leader = self;<br>&#9;&#9;&#9;&#9;&#9;M.Follower = Follower;<br>&#9;&#9;&#9;&#9;&#9;Follower = M;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="Mover.SetKeyframe"><a class="headerlink" href="#Mover.SetKeyframe" title="Permanent link">SetKeyframe</a> (byte NewKeyNum, vector NewLocation, rotator NewRotation)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;KeyNum         = Clamp( NewKeyNum, 0, ArrayCount(KeyPos)-1 );<br>&#9;KeyPos[KeyNum] = NewLocation;<br>&#9;KeyRot[KeyNum] = NewRotation;<br><br></div>
<h3 id="Mover.SpecialHandling"><a class="headerlink" href="#Mover.SpecialHandling" title="Permanent link">SpecialHandling</a> (Pawn Other) -> Actor</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( bDamageTriggered )&#9;<br>&#9;{<br>&#9;&#9;if ( !Other.bCanDoSpecial || (Other.Weapon == None) )<br>&#9;&#9;&#9;return None;<br><br>&#9;&#9;Other.Target = self;<br>&#9;&#9;Other.bShootSpecial = true;<br>&#9;&#9;Other.FireWeapon();<br>&#9;&#9;Other.bFire = 0;<br>&#9;&#9;Other.bAltFire = 0;<br>&#9;&#9;return self;<br>&#9;}<br><br>&#9;if ( BumpType == BT_PlayerBump && !Other.bIsPlayer )<br>&#9;&#9;return None;<br><br>&#9;return self;<br><br></div>
<h3 id="Mover.Timer"><a class="headerlink" href="#Mover.Timer" title="Permanent link">Timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Velocity != vect(0,0,0) )<br>&#9;{<br>&#9;&#9;bClientPause = false;<br>&#9;&#9;return;&#9;&#9;<br>&#9;}<br>&#9;if ( Level.NetMode == NM_Client )<br>&#9;{<br>&#9;&#9;if ( ClientUpdate == 0 ) // not doing a move<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( bClientPause )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( VSize(RealPosition - Location) > 3 )<br>&#9;&#9;&#9;&#9;&#9;SetLocation(RealPosition);<br>&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;&#9;RealPosition = Location;<br>&#9;&#9;&#9;&#9;SetRotation(RealRotation);<br>&#9;&#9;&#9;&#9;bClientPause = false;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;else if ( RealPosition != Location )<br>&#9;&#9;&#9;&#9;bClientPause = true;<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;&#9;bClientPause = false;<br>&#9;}<br>&#9;else <br>&#9;{<br>&#9;&#9;RealPosition = Location;<br>&#9;&#9;RealRotation = Rotation;<br>&#9;}<br><br></div>
<h3 id="Mover.Trigger"><a class="headerlink" href="#Mover.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;numTriggerEvents++;<br>&#9;&#9;SavedTrigger = Other;<br>&#9;&#9;Instigator = EventInstigator;<br>&#9;&#9;GotoState( 'TriggerPound', 'Open' );<br>&#9;<br></div>
<h3 id="Mover.UnTrigger"><a class="headerlink" href="#Mover.UnTrigger" title="Permanent link">UnTrigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;numTriggerEvents--;<br>&#9;&#9;if ( numTriggerEvents <= 0 )<br>&#9;&#9;{<br>&#9;&#9;&#9;numTriggerEvents = 0;<br>&#9;&#9;&#9;SavedTrigger = None;<br>&#9;&#9;&#9;Instigator = None;<br>&#9;&#9;&#9;GotoState( 'TriggerPound', 'Close' );<br>&#9;&#9;}<br>&#9;<br></div>
<br><br><hr>
<a class="headerlink" href="#MusicEvent.uc" title="Permanent link"><h2 id="MusicEvent.uc">MusicEvent.uc (extends Triggers)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() music            Song;<br>var() byte             SongSection;<br>var() byte             CdTrack;<br>var() EMusicTransition Transition;<br>var() bool             bSilence;<br>var() bool             bOnceOnly;<br>var() bool             bAffectAllPlayers;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">CdTrack=255<br>Transition=MTRAN_Fade<br>bAffectAllPlayers=True</div>
<h3 id="MusicEvent.BeginPlay"><a class="headerlink" href="#MusicEvent.BeginPlay" title="Permanent link">BeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Song==None )<br>&#9;{<br>&#9;&#9;Song = Level.Song;<br>&#9;}<br>&#9;if( bSilence )<br>&#9;{<br>&#9;&#9;SongSection = 255;<br>&#9;&#9;CdTrack     = 255;<br>&#9;}<br><br></div>
<h3 id="MusicEvent.Trigger"><a class="headerlink" href="#MusicEvent.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local PlayerPawn P;<br>&#9;local Pawn A;<br><br><br>&#9;if( bAffectAllPlayers )<br>&#9;{<br>&#9;&#9;A = Level.PawnList;<br>&#9;&#9;While ( A != None )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( A.IsA('PlayerPawn') )<br>&#9;&#9;&#9;&#9;PlayerPawn(A).ClientSetMusic( Song, SongSection, CdTrack, Transition );<br>&#9;&#9;&#9;A = A.nextPawn;<br>&#9;&#9;}<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;// Only affect the one player.<br>&#9;&#9;P = PlayerPawn(EventInstigator);<br>&#9;&#9;if( P==None )<br>&#9;&#9;&#9;return;<br>&#9;&#9;&#9;<br>&#9;&#9;// Go to music.<br>&#9;&#9;P.ClientSetMusic( Song, SongSection, CdTrack, Transition );<br>&#9;}&#9;<br><br>&#9;// Turn off if once-only.<br>&#9;if( bOnceOnly )<br>&#9;{<br>&#9;&#9;SetCollision(false,false,false);<br>&#9;&#9;disable( 'Trigger' );<br>&#9;}<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Mutator.uc" title="Permanent link"><h2 id="Mutator.uc">Mutator.uc (extends Info)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var Mutator NextMutator;<br>var Mutator NextDamageMutator;<br>var class<Weapon> DefaultWeapon;</div>
<h3 id="Mutator.AddMutator"><a class="headerlink" href="#Mutator.AddMutator" title="Permanent link">AddMutator</a> (Mutator M)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( NextMutator == None )<br>&#9;&#9;NextMutator = M;<br>&#9;else<br>&#9;&#9;NextMutator.AddMutator(M);<br><br></div>
<h3 id="Mutator.AlwaysKeep"><a class="headerlink" href="#Mutator.AlwaysKeep" title="Permanent link">AlwaysKeep</a> (Actor Other) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( NextMutator != None )<br>&#9;&#9;return ( NextMutator.AlwaysKeep(Other) );<br>&#9;return false;<br><br></div>
<h3 id="Mutator.CheckReplacement"><a class="headerlink" href="#Mutator.CheckReplacement" title="Permanent link">CheckReplacement</a> (Actor Other, out byte bSuperRelevant) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return true;<br><br></div>
<h3 id="Mutator.IsRelevant"><a class="headerlink" href="#Mutator.IsRelevant" title="Permanent link">IsRelevant</a> (Actor Other, out byte bSuperRelevant) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local bool bResult;<br><br><br>&#9;// allow mutators to remove actors<br>&#9;bResult = CheckReplacement(Other, bSuperRelevant);<br>&#9;if ( bResult && (NextMutator != None) )<br>&#9;&#9;bResult = NextMutator.IsRelevant(Other, bSuperRelevant);<br><br>&#9;return bResult;<br><br></div>
<h3 id="Mutator.ModifyPlayer"><a class="headerlink" href="#Mutator.ModifyPlayer" title="Permanent link">ModifyPlayer</a> (Pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// called by GameInfo.RestartPlayer()<br>&#9;if ( NextMutator != None )<br>&#9;&#9;NextMutator.ModifyPlayer(Other);<br><br></div>
<h3 id="Mutator.Mutate"><a class="headerlink" href="#Mutator.Mutate" title="Permanent link">Mutate</a> (string MutateString, PlayerPawn Sender)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( NextMutator != None )<br>&#9;&#9;NextMutator.Mutate(MutateString, Sender);<br><br></div>
<h3 id="Mutator.MutatedDefaultWeapon"><a class="headerlink" href="#Mutator.MutatedDefaultWeapon" title="Permanent link">MutatedDefaultWeapon</a> -> Class<Weapon></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Class<Weapon> W;<br><br><br>&#9;if ( NextMutator != None )<br>&#9;{<br>&#9;&#9;W = NextMutator.MutatedDefaultWeapon();<br>&#9;&#9;if ( W == Level.Game.DefaultWeapon )<br>&#9;&#9;&#9;W = MyDefaultWeapon();<br>&#9;}<br>&#9;else<br>&#9;&#9;W = MyDefaultWeapon();<br>&#9;return W;<br><br></div>
<h3 id="Mutator.MyDefaultWeapon"><a class="headerlink" href="#Mutator.MyDefaultWeapon" title="Permanent link">MyDefaultWeapon</a> -> Class<Weapon></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( DefaultWeapon != None )<br>&#9;&#9;return DefaultWeapon;<br>&#9;else<br>&#9;&#9;return Level.Game.DefaultWeapon;<br><br></div>
<h3 id="Mutator.PostRender"><a class="headerlink" href="#Mutator.PostRender" title="Permanent link">PostRender</a> (canvas Canvas)</h3>

<h3 id="Mutator.PreBeginPlay"><a class="headerlink" href="#Mutator.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;//Don't call Actor PreBeginPlay()<br><br></div>
<h3 id="Mutator.ReplaceWith"><a class="headerlink" href="#Mutator.ReplaceWith" title="Permanent link">ReplaceWith</a> (actor Other, string aClassName) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Actor A;<br>&#9;local class<Actor> aClass;<br><br><br>&#9;if ( Other.IsA('Inventory') && (Other.Location == vect(0,0,0)) )<br>&#9;&#9;return false;<br>&#9;aClass = class<Actor>(DynamicLoadObject(aClassName, class'Class'));<br>&#9;if ( aClass != None )<br>&#9;&#9;A = Spawn(aClass,,Other.tag,Other.Location, Other.Rotation);<br>&#9;if ( Other.IsA('Inventory') )<br>&#9;{<br>&#9;&#9;if ( Inventory(Other).MyMarker != None )<br>&#9;&#9;{<br>&#9;&#9;&#9;Inventory(Other).MyMarker.markedItem = Inventory(A);<br>&#9;&#9;&#9;if ( Inventory(A) != None )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;Inventory(A).MyMarker = Inventory(Other).MyMarker;<br>&#9;&#9;&#9;&#9;A.SetLocation(A.Location <br>&#9;&#9;&#9;&#9;&#9;+ (A.CollisionHeight - Other.CollisionHeight) * vect(0,0,1));<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;Inventory(Other).MyMarker = None;<br>&#9;&#9;}<br>&#9;&#9;else if ( A.IsA('Inventory') )<br>&#9;&#9;{<br>&#9;&#9;&#9;Inventory(A).bHeldItem = true;<br>&#9;&#9;&#9;Inventory(A).Respawntime = 0.0;<br>&#9;&#9;}<br>&#9;}<br>&#9;if ( A != None )<br>&#9;{<br>&#9;&#9;A.event = Other.event;<br>&#9;&#9;A.tag = Other.tag;<br>&#9;&#9;return true;<br>&#9;}<br>&#9;return false;<br><br></div>
<h3 id="Mutator.ScoreKill"><a class="headerlink" href="#Mutator.ScoreKill" title="Permanent link">ScoreKill</a> (Pawn Killer, Pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// called by GameInfo.ScoreKill()<br>&#9;if ( NextMutator != None )<br>&#9;&#9;NextMutator.ScoreKill(Killer, Other);<br><br></div>
<br><br><hr>
<a class="headerlink" href="#NavigationPoint.uc" title="Permanent link"><h2 id="NavigationPoint.uc">NavigationPoint.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() name ownerTeam;	//creature clan owning this area (area visible from this point)<br>var bool taken; //set when a creature is occupying this spot<br>var int upstreamPaths[16];<br>var int Paths[16]; //index of reachspecs (used by C++ Navigation code)<br>var int PrunedPaths[16];<br>var NavigationPoint VisNoReachPaths[16]; //paths that are visible but not directly reachable<br>var int visitedWeight;<br>var actor routeCache;<br>var const int bestPathWeight;<br>var const NavigationPoint nextNavigationPoint;<br>var const NavigationPoint nextOrdered;<br>var const NavigationPoint prevOrdered;<br>var const NavigationPoint startPath;<br>var const NavigationPoint previousPath;<br>var int cost; //added cost to visit this pathnode<br>var() int ExtraCost;<br>var() bool bPlayerOnly;	//only players should use this path<br>var bool bEndPoint; //used by C++ navigation code<br>var bool bEndPointOnly; //only used as an endpoint in routing network<br>var bool bSpecialCost;	//if true, navigation code will call SpecialCost function for this navigation point<br>var() bool bOneWayPath;	//reachspecs from this path only in the direction the path is facing (180 degrees)<br>var() bool bNeverUseStrafing; // shouldn't use bAdvancedTactics going to this point</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">upstreamPaths(0)=-1<br>upstreamPaths(1)=-1<br>upstreamPaths(2)=-1<br>upstreamPaths(3)=-1<br>upstreamPaths(4)=-1<br>upstreamPaths(5)=-1<br>upstreamPaths(6)=-1<br>upstreamPaths(7)=-1<br>upstreamPaths(8)=-1<br>upstreamPaths(9)=-1<br>upstreamPaths(10)=-1<br>upstreamPaths(11)=-1<br>upstreamPaths(12)=-1<br>upstreamPaths(13)=-1<br>upstreamPaths(14)=-1<br>upstreamPaths(15)=-1<br>Paths(0)=-1<br>Paths(1)=-1<br>Paths(2)=-1<br>Paths(3)=-1<br>Paths(4)=-1<br>Paths(5)=-1<br>Paths(6)=-1<br>Paths(7)=-1<br>Paths(8)=-1<br>Paths(9)=-1<br>Paths(10)=-1<br>Paths(11)=-1<br>Paths(12)=-1<br>Paths(13)=-1<br>Paths(14)=-1<br>Paths(15)=-1<br>PrunedPaths(0)=-1<br>PrunedPaths(1)=-1<br>PrunedPaths(2)=-1<br>PrunedPaths(3)=-1<br>PrunedPaths(4)=-1<br>PrunedPaths(5)=-1<br>PrunedPaths(6)=-1<br>PrunedPaths(7)=-1<br>PrunedPaths(8)=-1<br>PrunedPaths(9)=-1<br>PrunedPaths(10)=-1<br>PrunedPaths(11)=-1<br>PrunedPaths(12)=-1<br>PrunedPaths(13)=-1<br>PrunedPaths(14)=-1<br>PrunedPaths(15)=-1<br>bStatic=True<br>bHidden=True<br>bCollideWhenPlacing=True<br>SoundVolume=0<br>CollisionRadius=12.000000<br>CollisionHeight=15.000000</div>
<h3 id="NavigationPoint.Accept"><a class="headerlink" href="#NavigationPoint.Accept" title="Permanent link">Accept</a> (actor Incoming, actor Source) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// Move the actor here.<br>&#9;taken = Incoming.SetLocation( Location + vect (0,0,20));<br>&#9;if (taken)<br>&#9;{<br>&#9;&#9;Incoming.Velocity = vect(0,0,0);<br>&#9;&#9;Incoming.SetRotation(Rotation);<br>&#9;}<br>&#9;// Play teleport-in effect.<br>&#9;PlayTeleportEffect(Incoming, true);<br>&#9;return taken;<br><br></div>
<h3 id="NavigationPoint.PlayTeleportEffect"><a class="headerlink" href="#NavigationPoint.PlayTeleportEffect" title="Permanent link">PlayTeleportEffect</a> (actor Incoming, bool bOut)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Level.Game.PlayTeleportEffect(Incoming, bOut, false);<br><br></div>
<h3 id="NavigationPoint.SpecialCost"><a class="headerlink" href="#NavigationPoint.SpecialCost" title="Permanent link">SpecialCost</a> (Pawn Seeker) -> int</h3>

<h3 id="NavigationPoint.describeSpec"><a class="headerlink" href="#NavigationPoint.describeSpec" title="Permanent link">describeSpec</a> (int iSpec, out Actor Start, out Actor End, out int ReachFlags, out int Distance) | native</h3>

<br><br><hr>
<a class="headerlink" href="#Palette.uc" title="Permanent link"><h2 id="Palette.uc">Palette.uc (extends Object)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var native const array<Color> Colors;</div>
<br><br><hr>
<a class="headerlink" href="#PathNode.uc" title="Permanent link"><h2 id="PathNode.uc">PathNode.uc (extends NavigationPoint)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Texture=Texture'Engine.S_Pickup'<br>SoundVolume=128</div>
<br><br><hr>
<a class="headerlink" href="#PatrolPoint.uc" title="Permanent link"><h2 id="PatrolPoint.uc">PatrolPoint.uc (extends NavigationPoint)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() name Nextpatrol; //next point to go to<br>var() float pausetime; //how long to pause here<br>var() name PatrolAnim;<br>var() sound PatrolSound;<br>var() byte numAnims;<br>var int	AnimCount;<br>var PatrolPoint NextPatrolPoint;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bDirectional=True<br>Texture=Texture'Engine.S_Patrol'<br>SoundVolume=128</div>
<h3 id="PatrolPoint.PreBeginPlay"><a class="headerlink" href="#PatrolPoint.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local PatrolPoint CurPoint;<br><br><br>&#9;lookdir = 200 * vector(Rotation);<br><br>&#9;//find the patrol point with the tag specified by Nextpatrol<br>&#9;NextPatrolPoint = None;<br>&#9;if (NextPatrol != '')<br>&#9;{<br>&#9;&#9;foreach AllActors(class 'PatrolPoint', CurPoint, Nextpatrol)<br>&#9;&#9;{<br>&#9;&#9;&#9;if (CurPoint != self)<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;NextPatrolPoint = CurPoint;<br>&#9;&#9;&#9;&#9;break;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;}<br>&#9;<br>&#9;Super.PreBeginPlay();<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Pawn.uc" title="Permanent link"><h2 id="Pawn.uc">Pawn.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var bool		bBehindView;    // Outside-the-player view.<br>var bool        bIsPlayer;      // Pawn is a player or a player-bot.<br>var bool		bJustLanded;	// used by eyeheight adjustment<br>var bool		bUpAndOut;		// used by swimming<br>var bool		bIsWalking;<br>var const bool	bHitSlopedWall;	// used by Physics<br>var globalconfig bool	bNeverSwitchOnPickup;	// if true, don't automatically switch to picked up weapon<br>var bool		bWarping;		// Set when travelling through warpzone (so shouldn't telefrag)<br>var bool		bUpdatingDisplay; // to avoid infinite recursion through inventory setdisplay<br>var(Combat) bool	bCanStrafe;<br>var(Orders) bool	bFixedStart;<br>var const bool		bReducedSpeed;		//used by movement natives<br>var const bool		bLOSflag;			// used for alternating LineOfSight traces<br>var 	bool 		bFromWall;<br>var const	float		AvgPhysicsTime;<br>var PointRegion FootRegion;<br>var PointRegion HeadRegion;<br>var 	float		MoveTimer;<br>var 	Actor		MoveTarget;		// set by movement natives<br>var(Combat) float	MeleeRange; // Max range for melee attack (not including collision radii)<br>var(Movement) float      GroundSpeed;     // The maximum ground speed.<br>var(Movement) float      WaterSpeed;      // The maximum swimming speed.<br>var(Movement) float      AirSpeed;        // The maximum flying speed.<br>var(Movement) float		 AccelRate;		  // max acceleration rate<br>var(Movement) float		 JumpZ;      		// vertical acceleration w/ jump<br>var(Movement) float      MaxStepHeight;   // Maximum size of upward/downward step.<br>var(Movement) float      AirControl;		// amount of AirControl available to the pawn<br>var() 	byte       	Visibility;      //How visible is the pawn? 0 = invisible.<br>var(AI) float		SightRadius;     //Maximum seeing distance.<br>var(AI) float		PeripheralVision;//Cosine of limits of peripheral vision.<br>var(AI) float		HearingThreshold;  //Minimum noise loudness for hearing<br>var travel Weapon       Weapon;        // The pawn's current weapon.<br>var Weapon				PendingWeapon;	// Will become weapon once current weapon is put down<br>var travel Inventory	SelectedItem;	// currently selected inventory item<br>var rotator     	ViewRotation;  	// View rotation.<br>var vector			WalkBob;<br>var() float      	BaseEyeHeight; 	// Base eye height above collision center.<br>var float        	EyeHeight;     	// Current eye height, adjusted for bobbing and stairs.<br>var float			SplashTime;		// time of last splash<br>var float        OrthoZoom;     // Orthogonal/map view zoom factor.<br>var() float      FovAngle;      // X field of view angle in degrees, usually 90.<br>var int			DieCount, ItemCount, KillCount, SecretCount, Spree;<br>var() travel int      Health;          // Health: 100 = normal maximum<br>var() string			SelectionMesh;<br>var() string			SpecialMesh;<br>var() name	ReducedDamageType; //Either a damagetype name or 'All', 'AllEnvironment' (Burned, Corroded, Frozen)<br>var() float ReducedDamagePct;<br>var() class<inventory> DropWhenKilled;<br>var(Movement) float		UnderWaterTime;  	//how much time pawn can go without air (in seconds)<br>var(AI) enum EAttitude  //important - order in decreasing importance<br>var(AI) enum EIntelligence //important - order in increasing intelligence<br>var(AI) float		Skill;			// skill, scaled by game difficulty (add difficulty to this value)<br>var const 	vector 		noise1spot;<br>var const 	float 		noise1time;<br>var const	pawn		noise1other;<br>var const	float		noise1loudness;<br>var const 	vector 		noise2spot;<br>var const 	float 		noise2time;<br>var const	pawn		noise2other;<br>var const	float		noise2loudness;<br>var const	pawn		nextPawn;<br>var(Sounds)	sound	HitSound1;<br>var(Sounds)	sound	HitSound2;<br>var(Sounds)	sound	Land;<br>var(Sounds)	sound	Die;<br>var(Sounds) sound	WaterStep;<br>var input byte<br>var(Combat) float CombatStyle; // -1 to 1 = low means tends to stay off and snipe, high means tends to charge and melee<br>var NavigationPoint home; //set when begin play, used for retreating and attitude checks<br>var name NextState; //for queueing states<br>var name NextLabel; //for queueing states<br>var float SoundDampening;<br>var float DamageScaling;<br>var(Orders) name AlarmTag; // tag of object to go to when see player<br>var(Orders) name SharedAlarmTag;<br>var Name PlayerReStartState;<br>var() localized  string MenuName; //Name used for this pawn type in menus (e.g. player selection)<br>var() localized  string NameArticle; //article used in conjunction with this class (e.g. "a", "an")<br>var() byte VoicePitch; //for speech<br>var() string VoiceType; //for speech<br>var float OldMessageTime; //to limit frequency of voice messages<br>var NavigationPoint RouteCache[16];<br>var() class<PlayerReplicationInfo> PlayerReplicationInfoClass;<br>var PlayerReplicationInfo PlayerReplicationInfo;<br>var Decal Shadow;<br>var() travel int HealthHead;<br>var() travel int HealthTorso;<br>var() travel int HealthLegLeft;<br>var() travel int HealthLegRight;<br>var() travel int HealthArmLeft;<br>var() travel int HealthArmRight;<br>var bool bIsSpeaking;		// are we speaking now<br>var bool bWasSpeaking;		// were we speaking last frame?  (should we close our mouth?)<br>var string lastPhoneme;	// phoneme last spoken<br>var string nextPhoneme;	// phoneme to speak next<br>var float animTimer[4];		// misc. timers for ambient anims (blink, head, etc.)<br>var bool bOnFire;<br>var float burnTimer;<br>var(AI)        float   AIHorizontalFov;            // degrees<br>var(AI)        float   AspectRatio;                // horizontal/vertical ratio<br>var(AI)        float   AngularResolution;          // degrees<br>var            float   MinAngularSize;             // tan(AngularResolution)^2<br>var(AI)        float   VisibilityThreshold;        // lowest visible brightness (0-1)<br>var(AI)        float   SmellThreshold;             // lowest smellable odor (0-1)<br>var(Alliances) Name    Alliance;                   // alliance tag<br>var            Rotator AIAddViewRotation;          // rotation added to view rotation for AICanSee()</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bCanGlide=True<br>AvgPhysicsTime=0.100000<br>MaxDesiredSpeed=1.000000<br>GroundSpeed=320.000000<br>WaterSpeed=200.000000<br>AccelRate=500.000000<br>JumpZ=325.000000<br>MaxStepHeight=25.000000<br>AirControl=0.050000<br>Visibility=128<br>SightRadius=2500.000000<br>OrthoZoom=40000.000000<br>FovAngle=90.000000<br>Health=100<br>AttitudeToPlayer=ATTITUDE_Hate<br>Intelligence=BRAINS_MAMMAL<br>noise1time=-10.000000<br>noise2time=-10.000000<br>SoundDampening=1.000000<br>DamageScaling=1.000000<br>PlayerReStartState=PlayerWalking<br>NameArticle=" a "<br>PlayerReplicationInfoClass=Class'Engine.PlayerReplicationInfo'<br>HealthHead=100<br>HealthTorso=100<br>HealthLegLeft=100<br>HealthLegRight=100<br>HealthArmLeft=100<br>HealthArmRight=100<br>AIHorizontalFov=75.000000<br>AspectRatio=1.333333<br>AngularResolution=1.000000<br>SmellThreshold=0.500000<br>bCanTeleport=True<br>bIsKillGoal=True<br>bStasis=True<br>bIsPawn=True<br>RemoteRole=ROLE_SimulatedProxy<br>AnimSequence=Fighter<br>bDirectional=True<br>Texture=Texture'Engine.S_Pawn'<br>SoundRadius=9<br>SoundVolume=240<br>TransientSoundVolume=2.000000<br>bCollideActors=True<br>bCollideWorld=True<br>bBlockActors=True<br>bBlockPlayers=True<br>bProjTarget=True<br>bRotateToDesired=True<br>RotationRate=(Pitch=4096,Yaw=50000,Roll=3072)<br>bVisionImportant=True<br>NetPriority=2.000000</div>
<h3 id="Pawn.AICanHear"><a class="headerlink" href="#Pawn.AICanHear" title="Permanent link">AICanHear</a> (actor other, optional float Volume, optional float Radius) | native</h3>

<h3 id="Pawn.AICanSmell"><a class="headerlink" href="#Pawn.AICanSmell" title="Permanent link">AICanSmell</a> (actor other, optional float smell) | native</h3>

<h3 id="Pawn.AddInventory"><a class="headerlink" href="#Pawn.AddInventory" title="Permanent link">AddInventory</a> (inventory NewItem) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local inventory Inv;<br><br>&#9;// Skip if already in the inventory.<br>&#9;<br>&#9;// The item should not have been destroyed if we get here.<br>&#9;if (NewItem ==None )<br>&#9;&#9;log("tried to add none inventory to "$self);<br><br>&#9;for( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )<br>&#9;&#9;if( Inv == NewItem )<br>&#9;&#9;&#9;return false;<br><br>&#9;// DEUS_EX AJY<br>&#9;// Update the previous owner's inventory chain<br>&#9;if (NewItem.Owner != None)<br>&#9;&#9;Pawn(NewItem.Owner).DeleteInventory(NewItem);<br><br>&#9;// Add to front of inventory chain.<br>&#9;NewItem.SetOwner(Self);<br>&#9;NewItem.Inventory = Inventory;<br>&#9;Inventory = NewItem;<br><br><br>&#9;return true;<br><br></div>
<h3 id="Pawn.AddPawn"><a class="headerlink" href="#Pawn.AddPawn" title="Permanent link">AddPawn</a> | native</h3>

<h3 id="Pawn.AddVelocity"><a class="headerlink" href="#Pawn.AddVelocity" title="Permanent link">AddVelocity</a> (vector NewVelocity)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Physics == PHYS_Walking)<br>&#9;&#9;SetPhysics(PHYS_Falling);<br>&#9;if ( (Velocity.Z > 380) && (NewVelocity.Z > 0) )<br>&#9;&#9;NewVelocity.Z *= 0.5;<br>&#9;Velocity += NewVelocity;<br><br></div>
<h3 id="Pawn.AdjustAim"><a class="headerlink" href="#Pawn.AdjustAim" title="Permanent link">AdjustAim</a> (float projSpeed, vector projStart, int aimerror, bool bLeadTarget, bool bWarnTarget) -> rotator</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return ViewRotation;<br><br></div>
<h3 id="Pawn.AdjustDesireFor"><a class="headerlink" href="#Pawn.AdjustDesireFor" title="Permanent link">AdjustDesireFor</a> (Inventory Inv) -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return 0;<br><br></div>
<h3 id="Pawn.AdjustHitLocation"><a class="headerlink" href="#Pawn.AdjustHitLocation" title="Permanent link">AdjustHitLocation</a> (out vector HitLocation, vector TraceDir) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float adjZ, maxZ;<br><br><br>&#9;TraceDir = Normal(TraceDir);<br>&#9;HitLocation = HitLocation + 0.4 * CollisionRadius * TraceDir;<br><br>/* DEUS_EX STM -- took this out because it fucks up crouching<br>&#9;if ( (GetAnimGroup(AnimSequence) == 'Ducking') && (AnimFrame > -0.03) )<br>&#9;{<br>&#9;&#9;maxZ = Location.Z + 0.25 * CollisionHeight;<br>&#9;&#9;if ( HitLocation.Z > maxZ )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( TraceDir.Z >= 0 )<br>&#9;&#9;&#9;&#9;return false;<br>&#9;&#9;&#9;adjZ = (maxZ - HitLocation.Z)/TraceDir.Z;<br>&#9;&#9;&#9;HitLocation.Z = maxZ;<br>&#9;&#9;&#9;HitLocation.X = HitLocation.X + TraceDir.X * adjZ;<br>&#9;&#9;&#9;HitLocation.Y = HitLocation.Y + TraceDir.Y * adjZ;<br>&#9;&#9;&#9;if ( VSize(HitLocation - Location) > CollisionRadius )&#9;<br>&#9;&#9;&#9;&#9;return false;<br>&#9;&#9;}<br>&#9;}<br>*/<br><br>&#9;return true;<br><br></div>
<h3 id="Pawn.AdjustToss"><a class="headerlink" href="#Pawn.AdjustToss" title="Permanent link">AdjustToss</a> (float projSpeed, vector projStart, int aimerror, bool bLeadTarget, bool bWarnTarget) -> rotator</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return ViewRotation;<br><br></div>
<h3 id="Pawn.BaseChange"><a class="headerlink" href="#Pawn.BaseChange" title="Permanent link">BaseChange</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float decorMass;<br><br><br>&#9;if ( (base == None) && (Physics == PHYS_None) )<br>&#9;&#9;SetPhysics(PHYS_Falling);<br>&#9;else if (Pawn(Base) != None)<br>&#9;{<br>&#9;&#9;Base.TakeDamage( (1-Velocity.Z/400)* Mass/Base.Mass, Self,Location,0.5 * Velocity , 'stomped');<br>&#9;&#9;JumpOffPawn();<br>&#9;}<br>&#9;else if ( (Decoration(Base) != None) && (Velocity.Z < -400) )<br>&#9;{<br>&#9;&#9;decorMass = FMax(Decoration(Base).Mass, 1);<br>&#9;&#9;Base.TakeDamage((-2* Mass/decorMass * Velocity.Z/400), Self, Location, 0.5 * Velocity, 'stomped');<br>&#9;}<br><br></div>
<h3 id="Pawn.BecomeViewTarget"><a class="headerlink" href="#Pawn.BecomeViewTarget" title="Permanent link">BecomeViewTarget</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bViewTarget = true;<br><br></div>
<h3 id="Pawn.BeginState"><a class="headerlink" href="#Pawn.BeginState" title="Permanent link">BeginState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;SetPhysics(PHYS_None);<br>&#9;&#9;HidePlayer();<br>&#9;<br></div>
<h3 id="Pawn.BotVoiceMessage"><a class="headerlink" href="#Pawn.BotVoiceMessage" title="Permanent link">BotVoiceMessage</a> (name messagetype, byte MessageID, Pawn Sender)</h3>

<h3 id="Pawn.CanSee"><a class="headerlink" href="#Pawn.CanSee" title="Permanent link">CanSee</a> (actor Other) | native</h3>

<h3 id="Pawn.ChangedWeapon"><a class="headerlink" href="#Pawn.ChangedWeapon" title="Permanent link">ChangedWeapon</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Weapon OldWeapon;<br><br><br>&#9;OldWeapon = Weapon;<br><br>&#9;if (Weapon == PendingWeapon)<br>&#9;{<br>&#9;&#9;if ( Weapon == None )<br>&#9;&#9;&#9;SwitchToBestWeapon();<br>&#9;&#9;else if ( Weapon.IsInState('DownWeapon') ) <br>&#9;&#9;&#9;Weapon.BringUp();<br>&#9;&#9;if ( Weapon != None )<br>&#9;&#9;&#9;Weapon.SetDefaultDisplayProperties();<br>&#9;&#9;Inventory.ChangedWeapon(); // tell inventory that weapon changed (in case any effect was being applied)<br>&#9;&#9;PendingWeapon = None;<br>&#9;&#9;return;<br>&#9;}<br>&#9;// removed these lines so you don't automatically pick another weapon - DEUS_EX CNN<br>//&#9;if ( PendingWeapon == None )<br>//&#9;&#9;PendingWeapon = Weapon;<br><br>&#9;PlayWeaponSwitch(PendingWeapon);<br>&#9;if ( (PendingWeapon != None) && (PendingWeapon.Mass > 20) && (carriedDecoration != None) )<br>&#9;&#9;DropDecoration();<br>&#9;if ( Weapon != None )<br>&#9;&#9;Weapon.SetDefaultDisplayProperties();<br>&#9;&#9;<br>&#9;Weapon = PendingWeapon;<br>&#9;Inventory.ChangedWeapon(); // tell inventory that weapon changed (in case any effect was being applied)<br>&#9;if ( Weapon != None )<br>&#9;{<br>&#9;&#9;Weapon.RaiseUp(OldWeapon);<br>&#9;&#9;if ( (Level.Game != None) && (Level.Game.Difficulty > 1) )<br>&#9;&#9;&#9;MakeNoise(0.1 * Level.Game.Difficulty);&#9;&#9;<br>&#9;}<br>&#9;PendingWeapon = None;<br><br></div>
<h3 id="Pawn.CheckFutureSight"><a class="headerlink" href="#Pawn.CheckFutureSight" title="Permanent link">CheckFutureSight</a> (float DeltaTime) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return true;<br><br></div>
<h3 id="Pawn.CheckWaterJump"><a class="headerlink" href="#Pawn.CheckWaterJump" title="Permanent link">CheckWaterJump</a> (out vector WallNormal) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor HitActor;<br>&#9;local vector HitLocation, HitNormal, checkpoint, start, checkNorm, Extent;<br><br><br>&#9;if (CarriedDecoration != None)<br>&#9;&#9;return false;<br>&#9;checkpoint = vector(Rotation);<br>&#9;checkpoint.Z = 0.0;<br>&#9;checkNorm = Normal(checkpoint);<br>&#9;checkPoint = Location + CollisionRadius * checkNorm;<br>&#9;Extent = CollisionRadius * vect(1,1,0);<br>&#9;Extent.Z = CollisionHeight;<br>&#9;HitActor = Trace(HitLocation, HitNormal, checkpoint, Location, true, Extent);<br>&#9;if ( (HitActor != None) && (Pawn(HitActor) == None) )<br>&#9;{<br>&#9;&#9;WallNormal = -1 * HitNormal;<br>&#9;&#9;start = Location;<br>&#9;&#9;start.Z += 1.1 * MaxStepHeight;<br>&#9;&#9;checkPoint = start + 2 * CollisionRadius * checkNorm;<br>&#9;&#9;HitActor = Trace(HitLocation, HitNormal, checkpoint, start, true);<br>&#9;&#9;if (HitActor == None)<br>&#9;&#9;&#9;return true;<br>&#9;}<br><br>&#9;return false;<br><br></div>
<h3 id="Pawn.ClearPaths"><a class="headerlink" href="#Pawn.ClearPaths" title="Permanent link">ClearPaths</a> | native</h3>

<h3 id="Pawn.ClientDying"><a class="headerlink" href="#Pawn.ClientDying" title="Permanent link">ClientDying</a> (name DamageType, vector HitLocation)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlayDying(DamageType, HitLocation);<br>&#9;GotoState('Dying');<br><br></div>
<h3 id="Pawn.ClientGameEnded"><a class="headerlink" href="#Pawn.ClientGameEnded" title="Permanent link">ClientGameEnded</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;GotoState('GameEnded');<br><br></div>
<h3 id="Pawn.ClientMessage"><a class="headerlink" href="#Pawn.ClientMessage" title="Permanent link">ClientMessage</a> (coerce string S, optional name Type, optional bool bBeep)</h3>

<h3 id="Pawn.ClientPutDown"><a class="headerlink" href="#Pawn.ClientPutDown" title="Permanent link">ClientPutDown</a> (Weapon Current, Weapon Next)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Current.ClientPutDown(Next);<br><br></div>
<h3 id="Pawn.ClientReStart"><a class="headerlink" href="#Pawn.ClientReStart" title="Permanent link">ClientReStart</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;//log("client restart");<br><br>&#9;Velocity = vect(0,0,0);<br>&#9;Acceleration = vect(0,0,0);<br>&#9;BaseEyeHeight = Default.BaseEyeHeight;<br>&#9;EyeHeight = BaseEyeHeight;<br>&#9;PlayWaiting();<br><br>&#9;if ( Region.Zone.bWaterZone && (PlayerRestartState == 'PlayerWalking') )<br>&#9;{<br>&#9;&#9;if (HeadRegion.Zone.bWaterZone)<br>&#9;&#9;&#9;&#9;PainTime = UnderWaterTime;<br>&#9;&#9;setPhysics(PHYS_Swimming);<br>&#9;&#9;GotoState('PlayerSwimming');<br>&#9;}<br>&#9;else<br>&#9;&#9;GotoState(PlayerReStartState);<br><br></div>
<h3 id="Pawn.ClientSetLocation"><a class="headerlink" href="#Pawn.ClientSetLocation" title="Permanent link">ClientSetLocation</a> (vector NewLocation, rotator NewRotation)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br><br><br>&#9;ViewRotation      = NewRotation;<br>&#9;If ( (ViewRotation.Pitch > RotationRate.Pitch) && (ViewRotation.Pitch < 65536 - RotationRate.Pitch) )<br>&#9;{<br>&#9;&#9;If (ViewRotation.Pitch < 32768) <br>&#9;&#9;&#9;NewRotation.Pitch = RotationRate.Pitch;<br>&#9;&#9;else<br>&#9;&#9;&#9;NewRotation.Pitch = 65536 - RotationRate.Pitch;<br>&#9;}<br><br>&#9;NewRotation.Roll  = 0;<br>&#9;SetRotation( NewRotation );<br>&#9;SetLocation( NewLocation );<br><br></div>
<h3 id="Pawn.ClientSetRotation"><a class="headerlink" href="#Pawn.ClientSetRotation" title="Permanent link">ClientSetRotation</a> (rotator NewRotation)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br><br><br>&#9;ViewRotation      = NewRotation;<br>&#9;NewRotation.Pitch = 0;<br>&#9;NewRotation.Roll  = 0;<br>&#9;SetRotation( NewRotation );<br><br></div>
<h3 id="Pawn.ClientVoiceMessage"><a class="headerlink" href="#Pawn.ClientVoiceMessage" title="Permanent link">ClientVoiceMessage</a> (PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID)</h3>

<h3 id="Pawn.ComputePathnodeDistances"><a class="headerlink" href="#Pawn.ComputePathnodeDistances" title="Permanent link">ComputePathnodeDistances</a> (optional actor startActor) | native</h3>

<h3 id="Pawn.DeleteInventory"><a class="headerlink" href="#Pawn.DeleteInventory" title="Permanent link">DeleteInventory</a> (inventory Item) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor Link;<br><br>&#9;// If this item is in our inventory chain, unlink it.<br><br>&#9;if ( Item == Weapon )<br>&#9;&#9;Weapon = None;<br>&#9;if ( Item == SelectedItem )<br>&#9;&#9;SelectedItem = None;<br>&#9;for( Link = Self; Link!=None; Link=Link.Inventory )<br>&#9;{<br>&#9;&#9;if( Link.Inventory == Item )<br>&#9;&#9;{<br>&#9;&#9;&#9;Link.Inventory = Item.Inventory;<br>&#9;&#9;&#9;break;<br>&#9;&#9;}<br>&#9;}<br>&#9;Item.SetOwner(None);<br><br></div>
<h3 id="Pawn.Destroyed"><a class="headerlink" href="#Pawn.Destroyed" title="Permanent link">Destroyed</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Inventory Inv;<br>&#9;local Pawn OtherPawn;<br><br><br>&#9;if ( Shadow != None )<br>&#9;&#9;Shadow.Destroy();<br>&#9;RemovePawn();<br>&#9;if ( Role < ROLE_Authority )<br>&#9;&#9;return;<br><br>&#9;for( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )   <br>&#9;&#9;Inv.Destroy();<br>&#9;Weapon = None;<br>&#9;Inventory = None;<br>&#9;if ( bIsPlayer && (Level.Game != None) )<br>&#9;&#9;Level.Game.logout(self);<br>&#9;if ( PlayerReplicationInfo != None )<br>&#9;&#9;PlayerReplicationInfo.Destroy();<br>&#9;for ( OtherPawn=Level.PawnList; OtherPawn!=None; OtherPawn=OtherPawn.nextPawn )<br>&#9;&#9;OtherPawn.Killed(None, self, '');<br>&#9;Super.Destroyed();<br><br></div>
<h3 id="Pawn.Died"><a class="headerlink" href="#Pawn.Died" title="Permanent link">Died</a> (pawn Killer, name damageType, vector HitLocation)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local pawn OtherPawn;<br>&#9;local actor A;<br><br><br>&#9;if ( bDeleteMe )<br>&#9;&#9;return; //already destroyed<br>&#9;Health = Min(0, Health);<br>&#9;for ( OtherPawn=Level.PawnList; OtherPawn!=None; OtherPawn=OtherPawn.nextPawn )<br>&#9;&#9;OtherPawn.Killed(Killer, self, damageType);<br>&#9;if ( CarriedDecoration != None )<br>&#9;&#9;DropDecoration();<br>&#9;level.game.Killed(Killer, self, damageType);<br>&#9;//log(class$" dying");<br>&#9;if( Event != '' )<br>&#9;&#9;foreach AllActors( class 'Actor', A, Event )<br>&#9;&#9;&#9;A.Trigger( Self, Killer );<br>&#9;Level.Game.DiscardInventory(self);<br>&#9;Velocity.Z *= 1.3;<br>   if ( Gibbed(damageType) )<br>   {<br>      SpawnGibbedCarcass();<br>      if ( bIsPlayer )<br>         HidePlayer();<br>      else<br>         Destroy();<br>   }<br>&#9;PlayDying(DamageType, HitLocation);<br>&#9;if ( Level.Game.bGameEnded )<br>&#9;&#9;return;<br>&#9;if ( RemoteRole == ROLE_AutonomousProxy )<br>&#9;&#9;ClientDying(DamageType, HitLocation);<br>&#9;GotoState('Dying');<br><br></div>
<h3 id="Pawn.DropDecoration"><a class="headerlink" href="#Pawn.DropDecoration" title="Permanent link">DropDecoration</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (CarriedDecoration != None)<br>&#9;{<br>&#9;&#9;CarriedDecoration.bWasCarried = true;<br>&#9;&#9;CarriedDecoration.SetBase(None);<br>&#9;&#9;CarriedDecoration.SetPhysics(PHYS_Falling);<br>&#9;&#9;CarriedDecoration.Velocity = Velocity + 10 * VRand();<br>&#9;&#9;CarriedDecoration.Instigator = self;<br><br>&#9;&#9;// turn off translucency - DEUS_EX CNN<br>&#9;&#9;CarriedDecoration.Style = CarriedDecoration.Default.Style;<br>&#9;&#9;CarriedDecoration.ScaleGlow = CarriedDecoration.Default.ScaleGlow;<br>&#9;&#9;CarriedDecoration.bUnlit = CarriedDecoration.Default.bUnlit;<br><br>&#9;&#9;CarriedDecoration = None;<br>&#9;}<br><br></div>
<h3 id="Pawn.EAdjustJump"><a class="headerlink" href="#Pawn.EAdjustJump" title="Permanent link">EAdjustJump</a> | native</h3>

<h3 id="Pawn.EncroachedBy"><a class="headerlink" href="#Pawn.EncroachedBy" title="Permanent link">EncroachedBy</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Pawn(Other) != None )<br>&#9;&#9;gibbedBy(Other);<br>&#9;&#9;<br><br></div>
<h3 id="Pawn.EncroachingOn"><a class="headerlink" href="#Pawn.EncroachingOn" title="Permanent link">EncroachingOn</a> (actor Other) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( (Other.Brush != None) || (Brush(Other) != None) )<br>&#9;&#9;return true;<br>&#9;&#9;<br>&#9;if ( (!bIsPlayer || bWarping) && (Pawn(Other) != None))<br>&#9;&#9;return true;<br>&#9;&#9;<br>&#9;return false;<br><br></div>
<h3 id="Pawn.EnemyNotVisible"><a class="headerlink" href="#Pawn.EnemyNotVisible" title="Permanent link">EnemyNotVisible</a></h3>

<h3 id="Pawn.Falling"><a class="headerlink" href="#Pawn.Falling" title="Permanent link">Falling</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;//SetPhysics(PHYS_Falling); //Note - physics changes type to PHYS_Falling by default<br>&#9;&#9;//log(class$" Falling");<br>&#9;&#9;PlayInAir();<br>&#9;<br></div>
<h3 id="Pawn.FearThisSpot"><a class="headerlink" href="#Pawn.FearThisSpot" title="Permanent link">FearThisSpot</a> (Actor ASpot)</h3>

<h3 id="Pawn.FellOutOfWorld"><a class="headerlink" href="#Pawn.FellOutOfWorld" title="Permanent link">FellOutOfWorld</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Health = -1;<br>&#9;SetPhysics(PHYS_None);<br>&#9;Weapon = None;<br>&#9;Died(None, 'Fell', Location);<br><br></div>
<h3 id="Pawn.FindBestInventoryPath"><a class="headerlink" href="#Pawn.FindBestInventoryPath" title="Permanent link">FindBestInventoryPath</a> (out float MinWeight, bool bPredictRespawns) | native</h3>

<h3 id="Pawn.FindRandomDest"><a class="headerlink" href="#Pawn.FindRandomDest" title="Permanent link">FindRandomDest</a> (optional bool bClearPaths) | native</h3>

<h3 id="Pawn.FindStairRotation"><a class="headerlink" href="#Pawn.FindStairRotation" title="Permanent link">FindStairRotation</a> (float DeltaTime) | native</h3>

<h3 id="Pawn.FireWeapon"><a class="headerlink" href="#Pawn.FireWeapon" title="Permanent link">FireWeapon</a></h3>

<h3 id="Pawn.FootZoneChange"><a class="headerlink" href="#Pawn.FootZoneChange" title="Permanent link">FootZoneChange</a> (ZoneInfo newFootZone)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor HitActor;<br>&#9;local vector HitNormal, HitLocation;<br>&#9;local float splashSize;<br>&#9;local actor splash;<br><br>&#9;<br>&#9;if ( Level.NetMode == NM_Client )<br>&#9;&#9;return;<br>&#9;if ( Level.TimeSeconds - SplashTime > 0.25 ) <br>&#9;{<br>&#9;&#9;SplashTime = Level.TimeSeconds;<br>&#9;&#9;if (Physics == PHYS_Falling)<br>&#9;&#9;&#9;MakeNoise(1.0);<br>&#9;&#9;else<br>&#9;&#9;&#9;MakeNoise(0.3);<br>&#9;&#9;if ( FootRegion.Zone.bWaterZone )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( !newFootZone.bWaterZone && (Role==ROLE_Authority) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( FootRegion.Zone.ExitSound != None )<br>&#9;&#9;&#9;&#9;&#9;PlaySound(FootRegion.Zone.ExitSound, SLOT_Interact, 1); <br>&#9;&#9;&#9;&#9;if ( FootRegion.Zone.ExitActor != None )<br>&#9;&#9;&#9;&#9;&#9;Spawn(FootRegion.Zone.ExitActor,,,Location - CollisionHeight * vect(0,0,1));<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;&#9;else if ( newFootZone.bWaterZone && (Role==ROLE_Authority) )<br>&#9;&#9;{<br>&#9;&#9;&#9;splashSize = FClamp(0.000025 * Mass * (300 - 0.5 * FMax(-500, Velocity.Z)), 1.0, 4.0 );<br>&#9;&#9;&#9;if ( newFootZone.EntrySound != None )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;HitActor = Trace(HitLocation, HitNormal, <br>&#9;&#9;&#9;&#9;&#9;&#9;Location - (CollisionHeight + 40) * vect(0,0,0.8), Location - CollisionHeight * vect(0,0,0.8), false);<br>&#9;&#9;&#9;&#9;if ( HitActor == None )<br>&#9;&#9;&#9;&#9;&#9;PlaySound(newFootZone.EntrySound, SLOT_Misc, 2 * splashSize);<br>&#9;&#9;&#9;&#9;else <br>&#9;&#9;&#9;&#9;&#9;PlaySound(WaterStep, SLOT_Misc, 1.5 + 0.5 * splashSize);<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;if( newFootZone.EntryActor != None )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;splash = Spawn(newFootZone.EntryActor,,,Location - CollisionHeight * vect(0,0,1));<br>&#9;&#9;&#9;&#9;if ( splash != None )<br>&#9;&#9;&#9;&#9;&#9;splash.DrawScale = splashSize;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;//log("Feet entering water");<br>&#9;&#9;}<br>&#9;}<br>&#9;<br>&#9;if (FootRegion.Zone.bPainZone)<br>&#9;{<br>&#9;&#9;if ( !newFootZone.bPainZone && !HeadRegion.Zone.bWaterZone )<br>&#9;&#9;&#9;PainTime = -1.0;<br>&#9;}<br>&#9;else if (newFootZone.bPainZone)<br>&#9;&#9;PainTime = 0.01;<br><br></div>
<h3 id="Pawn.Gasp"><a class="headerlink" href="#Pawn.Gasp" title="Permanent link">Gasp</a></h3>

<h3 id="Pawn.GetHumanName"><a class="headerlink" href="#Pawn.GetHumanName" title="Permanent link">GetHumanName</a> -> String</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( PlayerReplicationInfo != None )<br>&#9;&#9;return PlayerReplicationInfo.PlayerName;<br>&#9;return NameArticle$MenuName;<br><br></div>
<h3 id="Pawn.GetMultiSkin"><a class="headerlink" href="#Pawn.GetMultiSkin" title="Permanent link">GetMultiSkin</a> (Actor SkinActor, out string SkinName, out string FaceName)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;SkinName = String(SkinActor.Skin);<br>&#9;FaceName = "";<br><br></div>
<h3 id="Pawn.GetRating"><a class="headerlink" href="#Pawn.GetRating" title="Permanent link">GetRating</a> -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return 1000;<br><br></div>
<h3 id="Pawn.Gibbed"><a class="headerlink" href="#Pawn.Gibbed" title="Permanent link">Gibbed</a> (name damageType) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return false;<br><br></div>
<h3 id="Pawn.GrabDecoration"><a class="headerlink" href="#Pawn.GrabDecoration" title="Permanent link">GrabDecoration</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector lookDir, HitLocation, HitNormal, T1, T2, extent;<br>&#9;local actor HitActor;<br><br><br>&#9;if ( carriedDecoration == None )<br>&#9;{<br>&#9;&#9;//first trace to find it<br>&#9;&#9;lookDir = vector(Rotation);<br>&#9;&#9;lookDir.Z = 0;<br>&#9;&#9;T1 = Location + BaseEyeHeight * vect(0,0,1) + lookDir * 0.8 * CollisionRadius;<br>&#9;&#9;T2 = T1 + lookDir * 1.2 * CollisionRadius;<br>&#9;&#9;HitActor = Trace(HitLocation, HitNormal, T2, T1, true);<br>&#9;&#9;if ( HitActor == None )<br>&#9;&#9;{<br>&#9;&#9;&#9;T1 = T2 - (BaseEyeHeight + CollisionHeight - 2) * vect(0,0,1);<br>&#9;&#9;&#9;HitActor = Trace(HitLocation, HitNormal, T1, T2, true);<br>&#9;&#9;}<br>&#9;&#9;else if ( HitActor == Level )<br>&#9;&#9;{<br>&#9;&#9;&#9;T2 = HitLocation - lookDir;<br>&#9;&#9;&#9;T1 = T2 - (BaseEyeHeight + CollisionHeight - 2) * vect(0,0,1);<br>&#9;&#9;&#9;HitActor = Trace(HitLocation, HitNormal, T1, T2, true);<br>&#9;&#9;}&#9;<br>&#9;&#9;if ( (HitActor == None) || (HitActor == Level) )<br>&#9;&#9;{<br>&#9;&#9;&#9;extent.X = CollisionRadius;<br>&#9;&#9;&#9;extent.Y = CollisionRadius;<br>&#9;&#9;&#9;extent.Z = CollisionHeight;<br>&#9;&#9;&#9;HitActor = Trace(HitLocation, HitNormal, Location + lookDir * 1.2 * CollisionRadius, Location, true, extent);<br>&#9;&#9;}<br><br>&#9;&#9;if ( Mover(HitActor) != None )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( Mover(HitActor).bUseTriggered )<br>&#9;&#9;&#9;&#9;HitActor.Trigger( self, self );<br>&#9;&#9;}&#9;&#9;<br>&#9;&#9;else if ( (Decoration(HitActor) != None)  && ((weapon == None) || (weapon.Mass < 20)) )<br>&#9;&#9;{<br>&#9;&#9;&#9;CarriedDecoration = Decoration(HitActor);<br>&#9;&#9;&#9;if ( !CarriedDecoration.bPushable || (CarriedDecoration.Mass > 40) <br>&#9;&#9;&#9;&#9;|| (CarriedDecoration.StandingCount > 0) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;CarriedDecoration = None;<br>&#9;&#9;&#9;&#9;return;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;lookDir.Z = 0;&#9;&#9;&#9;&#9;<br>&#9;&#9;&#9;if ( CarriedDecoration.SetLocation(Location + (0.5 * CollisionRadius + CarriedDecoration.CollisionRadius) * lookDir) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;CarriedDecoration.SetPhysics(PHYS_None);<br>&#9;&#9;&#9;&#9;CarriedDecoration.SetBase(self);<br><br>&#9;&#9;&#9;&#9;// make it translucent - DEUS_EX CNN<br>&#9;&#9;&#9;&#9;CarriedDecoration.Style = STY_Translucent;<br>&#9;&#9;&#9;&#9;CarriedDecoration.ScaleGlow = 1.0;<br>&#9;&#9;&#9;&#9;CarriedDecoration.bUnlit = True;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;CarriedDecoration = None;<br>&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="Pawn.HandleHelpMessageFrom"><a class="headerlink" href="#Pawn.HandleHelpMessageFrom" title="Permanent link">HandleHelpMessageFrom</a> (Pawn Other)</h3>

<h3 id="Pawn.HeadZoneChange"><a class="headerlink" href="#Pawn.HeadZoneChange" title="Permanent link">HeadZoneChange</a> (ZoneInfo newHeadZone)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Level.NetMode == NM_Client )<br>&#9;&#9;return;<br>&#9;if (HeadRegion.Zone.bWaterZone)<br>&#9;{<br>&#9;&#9;if (!newHeadZone.bWaterZone)<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( bIsPlayer && (PainTime > 0) && (PainTime < 8) )<br>&#9;&#9;&#9;&#9;Gasp();<br>&#9;&#9;&#9;if ( Inventory != None )<br>&#9;&#9;&#9;&#9;Inventory.ReduceDamage(0, 'Breathe', Location); //inform inventory of zone change<br>&#9;&#9;&#9;bDrowning = false;<br>&#9;&#9;&#9;if ( !FootRegion.Zone.bPainZone )<br>&#9;&#9;&#9;&#9;PainTime = -1.0;<br>&#9;&#9;}<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;if (newHeadZone.bWaterZone)<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( !FootRegion.Zone.bPainZone )<br>&#9;&#9;&#9;&#9;PainTime = UnderWaterTime;<br>&#9;&#9;&#9;if ( Inventory != None )<br>&#9;&#9;&#9;&#9;Inventory.ReduceDamage(0, 'Drowned', Location); //inform inventory of zone change<br>&#9;&#9;&#9;//log("Can't breathe");<br>&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="Pawn.HearNoise"><a class="headerlink" href="#Pawn.HearNoise" title="Permanent link">HearNoise</a> (float Loudness, Actor NoiseMaker)</h3>

<h3 id="Pawn.HidePlayer"><a class="headerlink" href="#Pawn.HidePlayer" title="Permanent link">HidePlayer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;SetCollision(false, false, false);<br>&#9;TweenToFighter(0.01);<br>&#9;bHidden = true;<br><br></div>
<h3 id="Pawn.InitPlayerReplicationInfo"><a class="headerlink" href="#Pawn.InitPlayerReplicationInfo" title="Permanent link">InitPlayerReplicationInfo</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (PlayerReplicationInfo.PlayerName == "")<br>&#9;&#9;PlayerReplicationInfo.PlayerName = class'GameInfo'.Default.DefaultPlayerName;<br><br></div>
<h3 id="Pawn.JumpOffPawn"><a class="headerlink" href="#Pawn.JumpOffPawn" title="Permanent link">JumpOffPawn</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Velocity += 60 * VRand();<br>&#9;Velocity.Z = 180;<br>&#9;SetPhysics(PHYS_Falling);<br><br></div>
<h3 id="Pawn.KillMessage"><a class="headerlink" href="#Pawn.KillMessage" title="Permanent link">KillMessage</a> (name damageType, pawn Other) -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string message;<br><br><br>&#9;message = Level.Game.CreatureKillMessage(damageType, Other);<br>&#9;return (message$namearticle$menuname);<br><br></div>
<h3 id="Pawn.Killed"><a class="headerlink" href="#Pawn.Killed" title="Permanent link">Killed</a> (pawn Killer, pawn Other, name damageType)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Enemy == Other )<br>&#9;&#9;Enemy = None;<br><br></div>
<h3 id="Pawn.Landed"><a class="headerlink" href="#Pawn.Landed" title="Permanent link">Landed</a> (vector HitNormal)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;SetPhysics(PHYS_None);<br>&#9;<br></div>
<h3 id="Pawn.LineOfSightTo"><a class="headerlink" href="#Pawn.LineOfSightTo" title="Permanent link">LineOfSightTo</a> (actor Other, optional bool bIgnoreDistance) | native</h3>

<h3 id="Pawn.LipSynch"><a class="headerlink" href="#Pawn.LipSynch" title="Permanent link">LipSynch</a> (float deltaTime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local name animseq;<br>&#9;local float rnd;<br>&#9;local float tweentime;<br><br><br>&#9;// update the animation timers that we are using<br>&#9;animTimer[0] += deltaTime;<br>&#9;animTimer[1] += deltaTime;<br>&#9;animTimer[2] += deltaTime;<br><br>&#9;if (bIsSpeaking)<br>&#9;{<br>&#9;&#9;// if our framerate is high enough (>20fps), tween the lips smoothly<br>&#9;&#9;if (Level.TimeSeconds - animTimer[3]  < 0.05)<br>&#9;&#9;&#9;tweentime = 0.1;<br>&#9;&#9;else<br>&#9;&#9;&#9;tweentime = 0.0;<br><br>&#9;&#9;// the last animTimer slot is used to check framerate<br>&#9;&#9;animTimer[3] = Level.TimeSeconds;<br><br>&#9;&#9;if (nextPhoneme == "A")<br>&#9;&#9;&#9;animseq = 'MouthA';<br>&#9;&#9;else if (nextPhoneme == "E")<br>&#9;&#9;&#9;animseq = 'MouthE';<br>&#9;&#9;else if (nextPhoneme == "F")<br>&#9;&#9;&#9;animseq = 'MouthF';<br>&#9;&#9;else if (nextPhoneme == "M")<br>&#9;&#9;&#9;animseq = 'MouthM';<br>&#9;&#9;else if (nextPhoneme == "O")<br>&#9;&#9;&#9;animseq = 'MouthO';<br>&#9;&#9;else if (nextPhoneme == "T")<br>&#9;&#9;&#9;animseq = 'MouthT';<br>&#9;&#9;else if (nextPhoneme == "U")<br>&#9;&#9;&#9;animseq = 'MouthU';<br>&#9;&#9;else if (nextPhoneme == "X")<br>&#9;&#9;&#9;animseq = 'MouthClosed';<br><br>&#9;&#9;if (animseq != '')<br>&#9;&#9;{<br>&#9;&#9;&#9;if (lastPhoneme != nextPhoneme)<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;lastPhoneme = nextPhoneme;<br>&#9;&#9;&#9;&#9;TweenBlendAnim(animseq, tweentime);<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;}<br>&#9;else if (bWasSpeaking)<br>&#9;{<br>&#9;&#9;bWasSpeaking = False;<br>&#9;&#9;TweenBlendAnim('MouthClosed', tweentime);<br>&#9;}<br><br>&#9;// blink randomly<br>&#9;if (animTimer[0] > 2.0)<br>&#9;{<br>&#9;&#9;animTimer[0] = 0;<br>&#9;&#9;if (FRand() < 0.4)<br>&#9;&#9;&#9;PlayBlendAnim('Blink', 1.0, 0.1, 1);<br>&#9;}<br><br>&#9;LoopHeadConvoAnim();<br>&#9;LoopBaseConvoAnim();<br><br></div>
<h3 id="Pawn.LongFall"><a class="headerlink" href="#Pawn.LongFall" title="Permanent link">LongFall</a></h3>

<h3 id="Pawn.LoopBaseConvoAnim"><a class="headerlink" href="#Pawn.LoopBaseConvoAnim" title="Permanent link">LoopBaseConvoAnim</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float rnd;<br><br><br>&#9;rnd = FRand();<br><br>&#9;// move arms randomly<br>&#9;if (bIsSpeaking)<br>&#9;{<br>&#9;&#9;if (animTimer[2] > 2.5)<br>&#9;&#9;{<br>&#9;&#9;&#9;animTimer[2] = 0;<br>&#9;&#9;&#9;if (rnd < 0.1)<br>&#9;&#9;&#9;&#9;PlayAnim('GestureLeft', 0.35, 0.4);<br>&#9;&#9;&#9;else if (rnd < 0.2)<br>&#9;&#9;&#9;&#9;PlayAnim('GestureRight', 0.35, 0.4);<br>&#9;&#9;&#9;else if (rnd < 0.3)<br>&#9;&#9;&#9;&#9;PlayAnim('GestureBoth', 0.35, 0.4);<br>&#9;&#9;}<br>&#9;}<br><br>&#9;// if we're not playing an animation, loop the breathe<br>&#9;if (!IsAnimating())<br>&#9;&#9;LoopAnim('BreatheLight',, 0.4);<br><br></div>
<h3 id="Pawn.LoopHeadConvoAnim"><a class="headerlink" href="#Pawn.LoopHeadConvoAnim" title="Permanent link">LoopHeadConvoAnim</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float rnd;<br><br><br>&#9;rnd = FRand();<br><br>&#9;// move head randomly (only while not speaking)<br>&#9;if (!bIsSpeaking && (animTimer[1] > 0.5))<br>&#9;{<br>&#9;&#9;if (rnd < 0.01)<br>&#9;&#9;&#9;PlayTurnHead(LOOK_Left, 1.0, 2.0);<br>&#9;&#9;else if (rnd < 0.02)<br>&#9;&#9;&#9;PlayTurnHead(LOOK_Right, 1.0, 2.0);<br>&#9;&#9;else<br>&#9;&#9;&#9;PlayTurnHead(LOOK_Forward, 1.0, 1.0);<br>&#9;}<br><br></div>
<h3 id="Pawn.MoveTo"><a class="headerlink" href="#Pawn.MoveTo" title="Permanent link">MoveTo</a> (vector NewDestination, optional float speed) | native</h3>

<h3 id="Pawn.MoveToward"><a class="headerlink" href="#Pawn.MoveToward" title="Permanent link">MoveToward</a> (actor NewTarget, optional float speed) | native</h3>

<h3 id="Pawn.NextItem"><a class="headerlink" href="#Pawn.NextItem" title="Permanent link">NextItem</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Inventory Inv;<br><br><br>&#9;// DEUS_EX CNN - this function is EVIL!<br>&#9;return;<br><br>&#9;if (SelectedItem==None) {<br>&#9;&#9;SelectedItem = Inventory.SelectNext();<br>&#9;&#9;Return;<br>&#9;<br></div>
<h3 id="Pawn.PainTimer"><a class="headerlink" href="#Pawn.PainTimer" title="Permanent link">PainTimer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float depth;<br><br><br>&#9;//log("Pain Timer");<br>&#9;if ( (Health < 0) || (Level.NetMode == NM_Client) )<br>&#9;&#9;return;<br>&#9;&#9;<br>&#9;if ( FootRegion.Zone.bPainZone )<br>&#9;{<br>&#9;&#9;depth = 0.4;<br>&#9;&#9;if (Region.Zone.bPainZone)<br>&#9;&#9;&#9;depth += 0.4;<br>&#9;&#9;if (HeadRegion.Zone.bPainZone)<br>&#9;&#9;&#9;depth += 0.2;<br><br>&#9;&#9;if (FootRegion.Zone.DamagePerSec > 0)<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( IsA('PlayerPawn') )<br>&#9;&#9;&#9;&#9;Level.Game.SpecialDamageString = FootRegion.Zone.DamageString;<br>&#9;&#9;&#9;TakeDamage(int(float(FootRegion.Zone.DamagePerSec) * depth), None, Location, vect(0,0,0), FootRegion.Zone.DamageType); <br>&#9;&#9;}<br>&#9;&#9;else if ( Health < Default.Health )<br>&#9;&#9;&#9;Health = Min(Default.Health, Health - depth * FootRegion.Zone.DamagePerSec);<br><br>&#9;&#9;if (Health > 0)<br>&#9;&#9;&#9;PainTime = 1.0;<br>&#9;}<br>&#9;else if ( HeadRegion.Zone.bWaterZone )<br>&#9;{<br>&#9;&#9;// DEUS_EX CNN - make drowning damage happen from center<br>&#9;&#9;TakeDamage(5, None, Location, vect(0,0,0), 'Drowned'); <br>&#9;&#9;if ( Health > 0 )<br>&#9;&#9;&#9;PainTime = 2.0;<br>&#9;}<br><br></div>
<h3 id="Pawn.PickAnyTarget"><a class="headerlink" href="#Pawn.PickAnyTarget" title="Permanent link">PickAnyTarget</a> (out float bestAim, out float bestDist, vector FireDir, vector projStart) | native</h3>

<h3 id="Pawn.PickTarget"><a class="headerlink" href="#Pawn.PickTarget" title="Permanent link">PickTarget</a> (out float bestAim, out float bestDist, vector FireDir, vector projStart) | native</h3>

<h3 id="Pawn.PickWallAdjust"><a class="headerlink" href="#Pawn.PickWallAdjust" title="Permanent link">PickWallAdjust</a> | native</h3>

<h3 id="Pawn.PlayBigDeath"><a class="headerlink" href="#Pawn.PlayBigDeath" title="Permanent link">PlayBigDeath</a> (name DamageType)</h3>

<h3 id="Pawn.PlayCrawling"><a class="headerlink" href="#Pawn.PlayCrawling" title="Permanent link">PlayCrawling</a></h3>

<h3 id="Pawn.PlayDeathHit"><a class="headerlink" href="#Pawn.PlayDeathHit" title="Permanent link">PlayDeathHit</a> (float Damage, vector HitLocation, name damageType, vector Momentum)</h3>

<h3 id="Pawn.PlayDive"><a class="headerlink" href="#Pawn.PlayDive" title="Permanent link">PlayDive</a></h3>

<h3 id="Pawn.PlayDuck"><a class="headerlink" href="#Pawn.PlayDuck" title="Permanent link">PlayDuck</a></h3>

<h3 id="Pawn.PlayDying"><a class="headerlink" href="#Pawn.PlayDying" title="Permanent link">PlayDying</a> (name DamageType, vector HitLoc)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector X,Y,Z, HitVec, HitVec2D;<br>&#9;local float dotp;<br><br><br>&#9;if ( Velocity.Z > 250 )<br>&#9;{<br>&#9;&#9;PlayBigDeath(DamageType);<br>&#9;&#9;return;<br>&#9;}<br>&#9;<br>&#9;if ( DamageType == 'Decapitated' )<br>&#9;{<br>&#9;&#9;PlayHeadDeath(DamageType);<br>&#9;&#9;return;<br>&#9;}<br>&#9;&#9;&#9;<br>&#9;GetAxes(Rotation,X,Y,Z);<br>&#9;X.Z = 0;<br>&#9;HitVec = Normal(HitLoc - Location);<br>&#9;HitVec2D= HitVec;<br>&#9;HitVec2D.Z = 0;<br>&#9;dotp = HitVec2D dot X;<br><br>&#9;//first check for head hit<br>&#9;if ( HitLoc.Z - Location.Z > 0.5 * CollisionHeight )<br>&#9;{<br>&#9;&#9;if (dotp > 0)<br>&#9;&#9;&#9;PlayHeadDeath(DamageType);<br>&#9;&#9;else<br>&#9;&#9;&#9;PlayGutDeath(DamageType);<br>&#9;&#9;return;<br>&#9;}<br>&#9;<br>&#9;if (dotp > 0.71) //then hit in front<br>&#9;&#9;PlayGutDeath(DamageType);<br>&#9;else<br>&#9;{<br>&#9;&#9;dotp = HitVec dot Y;<br>&#9;&#9;if (dotp > 0.0)<br>&#9;&#9;&#9;PlayLeftDeath(DamageType);<br>&#9;&#9;else<br>&#9;&#9;&#9;PlayRightDeath(DamageType);<br>&#9;}<br><br></div>
<h3 id="Pawn.PlayFiring"><a class="headerlink" href="#Pawn.PlayFiring" title="Permanent link">PlayFiring</a></h3>

<h3 id="Pawn.PlayGutDeath"><a class="headerlink" href="#Pawn.PlayGutDeath" title="Permanent link">PlayGutDeath</a> (name DamageType)</h3>

<h3 id="Pawn.PlayGutHit"><a class="headerlink" href="#Pawn.PlayGutHit" title="Permanent link">PlayGutHit</a> (float tweentime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;log("Error - play gut hit must be implemented in subclass of"@class);<br><br></div>
<h3 id="Pawn.PlayHeadDeath"><a class="headerlink" href="#Pawn.PlayHeadDeath" title="Permanent link">PlayHeadDeath</a> (name DamageType)</h3>

<h3 id="Pawn.PlayHeadHit"><a class="headerlink" href="#Pawn.PlayHeadHit" title="Permanent link">PlayHeadHit</a> (float tweentime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlayGutHit(tweentime);<br><br></div>
<h3 id="Pawn.PlayHit"><a class="headerlink" href="#Pawn.PlayHit" title="Permanent link">PlayHit</a> (float Damage, vector HitLocation, name damageType, vector Momentum)</h3>

<h3 id="Pawn.PlayInAir"><a class="headerlink" href="#Pawn.PlayInAir" title="Permanent link">PlayInAir</a></h3>

<h3 id="Pawn.PlayLanded"><a class="headerlink" href="#Pawn.PlayLanded" title="Permanent link">PlayLanded</a> (float impactVel)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float landVol;<br><br>&#9;//default - do nothing (keep playing existing animation)<br>&#9;landVol = impactVel/JumpZ;<br>&#9;landVol = 0.005 * Mass * landVol * landVol;<br>&#9;PlaySound(Land, SLOT_Interact, FMin(20, landVol));<br><br></div>
<h3 id="Pawn.PlayLeftDeath"><a class="headerlink" href="#Pawn.PlayLeftDeath" title="Permanent link">PlayLeftDeath</a> (name DamageType)</h3>

<h3 id="Pawn.PlayLeftHit"><a class="headerlink" href="#Pawn.PlayLeftHit" title="Permanent link">PlayLeftHit</a> (float tweentime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlayGutHit(tweentime);<br><br></div>
<h3 id="Pawn.PlayMovingAttack"><a class="headerlink" href="#Pawn.PlayMovingAttack" title="Permanent link">PlayMovingAttack</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;////log("Error - PlayMovingAttack should be implemented in subclass");<br>&#9;//Note - must restart attack timer when done with moving attack<br>&#9;PlayRunning();<br><br></div>
<h3 id="Pawn.PlayOutOfWater"><a class="headerlink" href="#Pawn.PlayOutOfWater" title="Permanent link">PlayOutOfWater</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TweenToFalling();<br><br></div>
<h3 id="Pawn.PlayPatrolStop"><a class="headerlink" href="#Pawn.PlayPatrolStop" title="Permanent link">PlayPatrolStop</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlayWaiting();<br><br></div>
<h3 id="Pawn.PlayRecoil"><a class="headerlink" href="#Pawn.PlayRecoil" title="Permanent link">PlayRecoil</a> (float Rate)</h3>

<h3 id="Pawn.PlayRightDeath"><a class="headerlink" href="#Pawn.PlayRightDeath" title="Permanent link">PlayRightDeath</a> (name DamageType)</h3>

<h3 id="Pawn.PlayRightHit"><a class="headerlink" href="#Pawn.PlayRightHit" title="Permanent link">PlayRightHit</a> (float tweentime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlayGutHit(tweentime);<br><br></div>
<h3 id="Pawn.PlayRunning"><a class="headerlink" href="#Pawn.PlayRunning" title="Permanent link">PlayRunning</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;////log("Error - PlayRunning should be implemented in subclass of"@class);<br><br></div>
<h3 id="Pawn.PlayTakeHit"><a class="headerlink" href="#Pawn.PlayTakeHit" title="Permanent link">PlayTakeHit</a> (float tweentime, vector HitLoc, int damage)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector X,Y,Z, HitVec, HitVec2D;<br>&#9;local float dotp;<br><br>&#9;<br>&#9;GetAxes(Rotation,X,Y,Z);<br>&#9;X.Z = 0;<br>&#9;HitVec = Normal(HitLoc - Location);<br>&#9;HitVec2D= HitVec;<br>&#9;HitVec2D.Z = 0;<br>&#9;dotp = HitVec2D dot X;<br><br>&#9;//first check for head hit<br>&#9;if ( HitLoc.Z - Location.Z > 0.5 * CollisionHeight )<br>&#9;{<br>&#9;&#9;if (dotp > 0)<br>&#9;&#9;&#9;PlayHeadHit(tweentime);<br>&#9;&#9;else<br>&#9;&#9;&#9;PlayGutHit(tweentime);<br>&#9;&#9;return;<br>&#9;}<br>&#9;<br>&#9;if (dotp > 0.71) //then hit in front<br>&#9;&#9;PlayGutHit( tweentime);<br>&#9;else if (dotp < -0.71) // then hit in back<br>&#9;&#9;PlayHeadHit(tweentime);<br>&#9;else<br>&#9;{<br>&#9;&#9;dotp = HitVec dot Y;<br>&#9;&#9;if (dotp > 0.0)<br>&#9;&#9;&#9;PlayLeftHit(tweentime);<br>&#9;&#9;else<br>&#9;&#9;&#9;PlayRightHit(tweentime);<br>&#9;}<br><br></div>
<h3 id="Pawn.PlayTakeHitSound"><a class="headerlink" href="#Pawn.PlayTakeHitSound" title="Permanent link">PlayTakeHitSound</a> (int Damage, name damageType, int Mult)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Level.TimeSeconds - LastPainSound < 0.25 )<br>&#9;&#9;return;<br><br>&#9;if (HitSound1 == None)return;<br>&#9;LastPainSound = Level.TimeSeconds;<br>&#9;if (FRand() < 0.5)<br>&#9;&#9;PlaySound(HitSound1, SLOT_Pain, FMax(Mult * TransientSoundVolume, Mult * 2.0));<br>&#9;else<br>&#9;&#9;PlaySound(HitSound2, SLOT_Pain, FMax(Mult * TransientSoundVolume, Mult * 2.0));<br><br></div>
<h3 id="Pawn.PlayThreatening"><a class="headerlink" href="#Pawn.PlayThreatening" title="Permanent link">PlayThreatening</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TweenToFighter(0.1);<br><br></div>
<h3 id="Pawn.PlayTurnHead"><a class="headerlink" href="#Pawn.PlayTurnHead" title="Permanent link">PlayTurnHead</a> (ELookDirection dir, float rate, float tweentime) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local name lookName;<br>&#9;local bool bSuccess;<br><br><br>&#9;if (dir == LOOK_Left)<br>&#9;&#9;lookName = 'HeadLeft';<br>&#9;else if (dir == LOOK_Right)<br>&#9;&#9;lookName = 'HeadRight';<br>&#9;else if (dir == LOOK_Up)<br>&#9;&#9;lookName = 'HeadUp';<br>&#9;else if (dir == LOOK_Down)<br>&#9;&#9;lookName = 'HeadDown';<br>&#9;else<br>&#9;&#9;lookName = 'Still';<br><br>&#9;bSuccess = false;<br>&#9;if (BlendAnimSequence[3] != lookName)<br>&#9;{<br>&#9;&#9;if (animTimer[1] > 0.00)<br>&#9;&#9;{<br>&#9;&#9;&#9;animTimer[1] = 0;<br>&#9;&#9;&#9;if (BlendAnimSequence[3] == '')<br>&#9;&#9;&#9;&#9;BlendAnimSequence[3] = 'Still';<br>&#9;&#9;&#9;PlayBlendAnim(lookName, rate, tweentime, 3);<br>&#9;&#9;&#9;bSuccess = true;<br>&#9;&#9;}<br>&#9;}<br><br>&#9;return (bSuccess);<br><br></div>
<h3 id="Pawn.PlayTurning"><a class="headerlink" href="#Pawn.PlayTurning" title="Permanent link">PlayTurning</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TweenToFighter(0.1);<br><br></div>
<h3 id="Pawn.PlayVictoryDance"><a class="headerlink" href="#Pawn.PlayVictoryDance" title="Permanent link">PlayVictoryDance</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TweenToFighter(0.1);<br><br></div>
<h3 id="Pawn.PlayWaiting"><a class="headerlink" href="#Pawn.PlayWaiting" title="Permanent link">PlayWaiting</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;////log("Error - PlayWaiting should be implemented in subclass");<br><br></div>
<h3 id="Pawn.PlayWaitingAmbush"><a class="headerlink" href="#Pawn.PlayWaitingAmbush" title="Permanent link">PlayWaitingAmbush</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlayWaiting();<br><br></div>
<h3 id="Pawn.PlayWalking"><a class="headerlink" href="#Pawn.PlayWalking" title="Permanent link">PlayWalking</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlayRunning(); <br><br></div>
<h3 id="Pawn.PlayWeaponSwitch"><a class="headerlink" href="#Pawn.PlayWeaponSwitch" title="Permanent link">PlayWeaponSwitch</a> (Weapon NewWeapon)</h3>

<h3 id="Pawn.PlayerTimeOut"><a class="headerlink" href="#Pawn.PlayerTimeOut" title="Permanent link">PlayerTimeOut</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Health > 0)<br>&#9;&#9;Died(None, 'Suicided', Location);<br><br></div>
<h3 id="Pawn.PostBeginPlay"><a class="headerlink" href="#Pawn.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.PostBeginPlay();<br>&#9;SplashTime = 0;<br><br></div>
<h3 id="Pawn.PostNetBeginPlay"><a class="headerlink" href="#Pawn.PostNetBeginPlay" title="Permanent link">PostNetBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local pawn CurPawn;<br>&#9;local bool bAlreadyAdded;<br><br>   <br>   Super.PostNetBeginPlay();<br>   bAlreadyAdded = false;<br>   for (CurPawn = Level.PawnList; CurPawn != None; CurPawn = CurPawn.NextPawn)<br>   {<br>      if (CurPawn == Self)<br>      {<br>         bAlreadyAdded = true;<br>         break;<br>      }<br>   }<br>   if (!bAlreadyAdded)<br>   {<br>      AddPawn();<br>   }<br>   return;<br><br></div>
<h3 id="Pawn.PreBeginPlay"><a class="headerlink" href="#Pawn.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;AddPawn();<br>&#9;Super.PreBeginPlay();<br>&#9;if ( bDeleteMe )<br>&#9;&#9;return;<br><br>&#9;// Added angular size computation - DEUS_EX STM<br>&#9;MinAngularSize = tan(AngularResolution*0.5*Pi/180.0);<br>&#9;MinAngularSize *= MinAngularSize;<br><br>&#9;// Set instigator to self.<br>&#9;Instigator = Self;<br>&#9;DesiredRotation = Rotation;<br>&#9;SightCounter = 0.2 * FRand();  //offset randomly <br>&#9;if ( Level.Game != None )<br>&#9;&#9;Skill += Level.Game.Difficulty; <br>&#9;Skill = FClamp(Skill, 0, 3);<br>&#9;PreSetMovement();<br>&#9;<br>&#9;if ( DrawScale != Default.Drawscale )<br>&#9;{<br>&#9;&#9;SetCollisionSize(CollisionRadius*DrawScale/Default.DrawScale, CollisionHeight*DrawScale/Default.DrawScale);<br>&#9;&#9;Health = Health * DrawScale/Default.DrawScale;<br>&#9;}<br><br>&#9;if (bIsPlayer)<br>&#9;{<br>&#9;&#9;if (PlayerReplicationInfoClass != None)<br>&#9;&#9;&#9;PlayerReplicationInfo = Spawn(PlayerReplicationInfoClass, Self,,vect(0,0,0),rot(0,0,0));<br>&#9;&#9;else<br>&#9;&#9;&#9;PlayerReplicationInfo = Spawn(class'PlayerReplicationInfo', Self,,vect(0,0,0),rot(0,0,0));<br>&#9;&#9;InitPlayerReplicationInfo();<br>&#9;}<br><br>&#9;if (!bIsPlayer) <br>&#9;{<br>&#9;&#9;if ( BaseEyeHeight == 0 )<br>&#9;&#9;&#9;BaseEyeHeight = 0.8 * CollisionHeight;<br>&#9;&#9;EyeHeight = BaseEyeHeight;<br>&#9;&#9;if (Fatness == 0) //vary monster fatness slightly if at default<br>&#9;&#9;&#9;Fatness = 120 + Rand(8) + Rand(8);<br>&#9;}<br><br>&#9;if ( menuname == "" )<br>&#9;&#9;menuname = GetItemName(string(class));<br><br>&#9;if (SelectionMesh == "")<br>&#9;&#9;SelectionMesh = string(Mesh);<br><br></div>
<h3 id="Pawn.PreSetMovement"><a class="headerlink" href="#Pawn.PreSetMovement" title="Permanent link">PreSetMovement</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (JumpZ > 0)<br>&#9;&#9;bCanJump = true;<br>&#9;bCanWalk = true;<br>&#9;bCanSwim = false;<br>&#9;bCanFly = false;<br>&#9;MinHitWall = -0.6;<br>&#9;if (Intelligence > BRAINS_Reptile)<br>&#9;&#9;bCanOpenDoors = true;<br>&#9;if (Intelligence == BRAINS_Human)<br>&#9;&#9;bCanDoSpecial = true;<br><br></div>
<h3 id="Pawn.ReceiveLocalizedMessage"><a class="headerlink" href="#Pawn.ReceiveLocalizedMessage" title="Permanent link">ReceiveLocalizedMessage</a> (class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)</h3>

<h3 id="Pawn.RemovePawn"><a class="headerlink" href="#Pawn.RemovePawn" title="Permanent link">RemovePawn</a> | native</h3>

<h3 id="Pawn.RenderOverlays"><a class="headerlink" href="#Pawn.RenderOverlays" title="Permanent link">RenderOverlays</a> (canvas Canvas)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Weapon != None )<br>&#9;&#9;Weapon.RenderOverlays(Canvas);<br><br></div>
<h3 id="Pawn.RestartPlayer"><a class="headerlink" href="#Pawn.RestartPlayer" title="Permanent link">RestartPlayer</a></h3>

<h3 id="Pawn.SeePlayer"><a class="headerlink" href="#Pawn.SeePlayer" title="Permanent link">SeePlayer</a> (actor Seen)</h3>

<h3 id="Pawn.SendGlobalMessage"><a class="headerlink" href="#Pawn.SendGlobalMessage" title="Permanent link">SendGlobalMessage</a> (PlayerReplicationInfo Recipient, name MessageType, byte MessageID, float Wait)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;SendVoiceMessage(PlayerReplicationInfo, Recipient, MessageType, MessageID, 'GLOBAL');<br><br></div>
<h3 id="Pawn.SendTeamMessage"><a class="headerlink" href="#Pawn.SendTeamMessage" title="Permanent link">SendTeamMessage</a> (PlayerReplicationInfo Recipient, name MessageType, byte MessageID, float Wait)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;SendVoiceMessage(PlayerReplicationInfo, Recipient, MessageType, MessageID, 'TEAM');<br><br></div>
<h3 id="Pawn.SendVoiceMessage"><a class="headerlink" href="#Pawn.SendVoiceMessage" title="Permanent link">SendVoiceMessage</a> (PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID, name broadcasttype)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br>&#9;local bool bNoSpeak;<br><br><br>&#9;if ( Level.TimeSeconds - OldMessageTime < 2.5 )<br>&#9;&#9;bNoSpeak = true;<br>&#9;else<br>&#9;&#9;OldMessageTime = Level.TimeSeconds;<br><br>&#9;for ( P=Level.PawnList; P!=None; P=P.NextPawn )<br>&#9;{<br>&#9;&#9;if ( P.IsA('PlayerPawn') )<br>&#9;&#9;{  <br>&#9;&#9;&#9;if ( !bNoSpeak )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( (broadcasttype == 'GLOBAL') || !Level.Game.bTeamGame )<br>&#9;&#9;&#9;&#9;&#9;P.ClientVoiceMessage(Sender, Recipient, messagetype, messageID);<br>&#9;&#9;&#9;&#9;else if ( Sender.Team == P.PlayerReplicationInfo.Team )<br>&#9;&#9;&#9;&#9;&#9;P.ClientVoiceMessage(Sender, Recipient, messagetype, messageID);<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;&#9;else if ( (P.PlayerReplicationInfo == Recipient) || ((messagetype == 'ORDER') && (Recipient == None)) )<br>&#9;&#9;&#9;P.BotVoiceMessage(messagetype, messageID, self);<br>&#9;}<br><br></div>
<h3 id="Pawn.SetDefaultDisplayProperties"><a class="headerlink" href="#Pawn.SetDefaultDisplayProperties" title="Permanent link">SetDefaultDisplayProperties</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Style = Default.Style;<br>&#9;texture = Default.Texture;<br>&#9;bUnlit = Default.bUnlit;<br>&#9;bMeshEnviromap = Default.bMeshEnviromap;<br>&#9;if ( Weapon != None )<br>&#9;&#9;Weapon.SetDisplayProperties(Weapon.Default.Style, Weapon.Default.Texture, Weapon.Default.bUnlit, Weapon.Default.bMeshEnviromap);<br><br>&#9;if ( !bUpdatingDisplay && (Inventory != None) )<br>&#9;{<br>&#9;&#9;bUpdatingDisplay = true;<br>&#9;&#9;Inventory.SetOwnerDisplay();<br>&#9;}<br>&#9;bUpdatingDisplay = false;<br><br></div>
<h3 id="Pawn.SetDisplayProperties"><a class="headerlink" href="#Pawn.SetDisplayProperties" title="Permanent link">SetDisplayProperties</a> (ERenderStyle NewStyle, texture NewTexture, bool bLighting, bool bEnviroMap)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Style = NewStyle;<br>&#9;texture = NewTexture;<br>&#9;bUnlit = bLighting;<br>&#9;bMeshEnviromap = bEnviromap;<br>&#9;if ( Weapon != None )<br>&#9;&#9;Weapon.SetDisplayProperties(Style, Texture, bUnlit, bMeshEnviromap);<br><br>&#9;if ( !bUpdatingDisplay && (Inventory != None) )<br>&#9;{<br>&#9;&#9;bUpdatingDisplay = true;<br>&#9;&#9;Inventory.SetOwnerDisplay();<br>&#9;}<br>&#9;bUpdatingDisplay = false;<br><br></div>
<h3 id="Pawn.SetMovementPhysics"><a class="headerlink" href="#Pawn.SetMovementPhysics" title="Permanent link">SetMovementPhysics</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;//implemented in sub-class<br><br></div>
<h3 id="Pawn.SetMultiSkin"><a class="headerlink" href="#Pawn.SetMultiSkin" title="Permanent link">SetMultiSkin</a> (actor SkinActor, string SkinName, string FaceName, byte TeamNum)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Texture NewSkin;<br><br><br>&#9;if(SkinName != "")<br>&#9;{<br>&#9;&#9;NewSkin = texture(DynamicLoadObject(SkinName, class'Texture'));<br>&#9;&#9;if ( NewSkin != None )<br>&#9;&#9;&#9;SkinActor.Skin = NewSkin;<br>&#9;}<br><br></div>
<h3 id="Pawn.SetSkinElement"><a class="headerlink" href="#Pawn.SetSkinElement" title="Permanent link">SetSkinElement</a> (Actor SkinActor, int SkinNo, string SkinName, string DefaultSkinName) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Texture NewSkin;<br><br><br>&#9;NewSkin = Texture(DynamicLoadObject(SkinName, class'Texture'));<br>&#9;if ( NewSkin != None )<br>&#9;{<br>&#9;&#9;SkinActor.Multiskins[SkinNo] = NewSkin;<br>&#9;&#9;return True;<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;log("Failed to load "$SkinName);<br>&#9;&#9;if(DefaultSkinName != "")<br>&#9;&#9;{<br>&#9;&#9;&#9;NewSkin = Texture(DynamicLoadObject(DefaultSkinName, class'Texture'));<br>&#9;&#9;&#9;SkinActor.Multiskins[SkinNo] = NewSkin;<br>&#9;&#9;}<br>&#9;&#9;return False;<br>&#9;}<br><br></div>
<h3 id="Pawn.ShakeView"><a class="headerlink" href="#Pawn.ShakeView" title="Permanent link">ShakeView</a> (float shaketime, float RollMag, float vertmag)</h3>

<h3 id="Pawn.SpawnCarcass"><a class="headerlink" href="#Pawn.SpawnCarcass" title="Permanent link">SpawnCarcass</a> -> Carcass</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;log(self$" should never call base spawncarcass");<br>&#9;return None;<br><br></div>
<h3 id="Pawn.SpawnGibbedCarcass"><a class="headerlink" href="#Pawn.SpawnGibbedCarcass" title="Permanent link">SpawnGibbedCarcass</a></h3>

<h3 id="Pawn.SpecialFire"><a class="headerlink" href="#Pawn.SpecialFire" title="Permanent link">SpecialFire</a></h3>

<h3 id="Pawn.SpeechTimer"><a class="headerlink" href="#Pawn.SpeechTimer" title="Permanent link">SpeechTimer</a></h3>

<h3 id="Pawn.StopFiring"><a class="headerlink" href="#Pawn.StopFiring" title="Permanent link">StopFiring</a></h3>

<h3 id="Pawn.StopWaiting"><a class="headerlink" href="#Pawn.StopWaiting" title="Permanent link">StopWaiting</a> | native</h3>

<h3 id="Pawn.SwitchToBestWeapon"><a class="headerlink" href="#Pawn.SwitchToBestWeapon" title="Permanent link">SwitchToBestWeapon</a> -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float rating;<br>&#9;local int usealt;<br><br><br>&#9;if ( Inventory == None )<br>&#9;&#9;return false;<br><br>&#9;PendingWeapon = Inventory.RecommendWeapon(rating, usealt);<br>&#9;if ( PendingWeapon == Weapon )<br>&#9;&#9;PendingWeapon = None;<br>&#9;if ( PendingWeapon == None )<br>&#9;&#9;return false;<br><br>&#9;if ( Weapon == None )<br>&#9;&#9;ChangedWeapon();<br>&#9;if ( Weapon != PendingWeapon )<br>&#9;&#9;Weapon.PutDown();<br><br>&#9;return (usealt > 0);<br><br></div>
<h3 id="Pawn.TakeFallingDamage"><a class="headerlink" href="#Pawn.TakeFallingDamage" title="Permanent link">TakeFallingDamage</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Velocity.Z < -1.4 * JumpZ)<br>&#9;{<br>&#9;&#9;MakeNoise(-0.5 * Velocity.Z/(FMax(JumpZ, 150.0)));<br>&#9;&#9;if (Velocity.Z <= -750 - JumpZ)<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( (Velocity.Z < -1650 - JumpZ) && (ReducedDamageType != 'All') )<br>&#9;&#9;&#9;&#9;TakeDamage(1000, None, Location, vect(0,0,0), 'Fell');<br>&#9;&#9;&#9;else if ( Role == ROLE_Authority )<br>&#9;&#9;&#9;&#9;TakeDamage(-0.15 * (Velocity.Z + 700 + JumpZ), None, Location, vect(0,0,0), 'Fell');<br>&#9;&#9;&#9;ShakeView(0.175 - 0.00007 * Velocity.Z, -0.85 * Velocity.Z, -0.002 * Velocity.Z);<br>&#9;&#9;}<br>&#9;}<br>&#9;else if ( Velocity.Z > 0.5 * Default.JumpZ )<br>&#9;&#9;MakeNoise(0.35);&#9;&#9;&#9;&#9;<br><br></div>
<h3 id="Pawn.TeamBroadcast"><a class="headerlink" href="#Pawn.TeamBroadcast" title="Permanent link">TeamBroadcast</a> (coerce string Msg)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br>&#9;local bool bGlobal;<br><br><br>&#9;if ( Left(Msg, 1) ~= "@" )<br>&#9;{<br>&#9;&#9;Msg = Right(Msg, Len(Msg)-1);<br>&#9;&#9;bGlobal = true;<br>&#9;}<br><br>&#9;if ( Left(Msg, 1) ~= "." )<br>&#9;&#9;Msg = "."$VoicePitch$Msg;<br><br>&#9;if ( bGlobal || !Level.Game.bTeamGame )<br>&#9;{<br>&#9;&#9;if ( Level.Game.AllowsBroadcast(self, Len(Msg)) )<br>&#9;&#9;&#9;for( P=Level.PawnList; P!=None; P=P.nextPawn )<br>&#9;&#9;&#9;&#9;if( P.bIsPlayer  || P.IsA('MessagingSpectator') )<br>&#9;&#9;&#9;&#9;&#9;P.TeamMessage( PlayerReplicationInfo, Msg, 'Say' );<br>&#9;&#9;return;<br>&#9;}<br>&#9;&#9;<br>&#9;if ( Level.Game.AllowsBroadcast(self, Len(Msg)) )<br>&#9;&#9;for( P=Level.PawnList; P!=None; P=P.nextPawn )<br>&#9;&#9;&#9;if( P.bIsPlayer && (P.PlayerReplicationInfo.Team == PlayerReplicationInfo.Team) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( P.IsA('PlayerPawn') )<br>&#9;&#9;&#9;&#9;&#9;P.TeamMessage( PlayerReplicationInfo, Msg, 'TeamSay' );<br>&#9;&#9;&#9;}<br><br></div>
<h3 id="Pawn.TeamMessage"><a class="headerlink" href="#Pawn.TeamMessage" title="Permanent link">TeamMessage</a> (PlayerReplicationInfo PRI, coerce string S, name Type, optional bool bBeep)</h3>

<h3 id="Pawn.Timer"><a class="headerlink" href="#Pawn.Timer" title="Permanent link">Timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( !bHidden )<br>&#9;&#9;{<br>&#9;&#9;&#9;bHidden = true;<br>&#9;&#9;&#9;SpawnCarcass();<br>&#9;&#9;&#9;if ( bIsPlayer )<br>&#9;&#9;&#9;&#9;HidePlayer();<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;Destroy();<br>&#9;&#9;}<br>&#9;<br></div>
<h3 id="Pawn.TossWeapon"><a class="headerlink" href="#Pawn.TossWeapon" title="Permanent link">TossWeapon</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector X,Y,Z;<br><br>&#9;if ( Weapon == None )<br>&#9;&#9;return;<br>&#9;GetAxes(Rotation,X,Y,Z);<br>&#9;Weapon.DropFrom(Location + 0.8 * CollisionRadius * X + - 0.5 * CollisionRadius * Y); <br><br></div>
<h3 id="Pawn.TraceShot"><a class="headerlink" href="#Pawn.TraceShot" title="Permanent link">TraceShot</a> (out vector HitLocation, out vector HitNormal, vector EndTrace, vector StartTrace) -> actor</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector realHit;<br>&#9;local actor Other;<br><br>&#9;Other = Trace(HitLocation,HitNormal,EndTrace,StartTrace,True);<br>&#9;if ( Pawn(Other) != None )<br>&#9;{<br>&#9;&#9;realHit = HitLocation;<br>&#9;&#9;if ( !Pawn(Other).AdjustHitLocation(HitLocation, EndTrace - StartTrace) )<br>&#9;&#9;&#9;Other = Pawn(Other).TraceShot(HitLocation,HitNormal,EndTrace,realHit);<br>&#9;}<br>&#9;return Other;<br><br></div>
<h3 id="Pawn.TurnTo"><a class="headerlink" href="#Pawn.TurnTo" title="Permanent link">TurnTo</a> (vector NewFocus) | native</h3>

<h3 id="Pawn.TurnToward"><a class="headerlink" href="#Pawn.TurnToward" title="Permanent link">TurnToward</a> (actor NewTarget) | native</h3>

<h3 id="Pawn.TweenToFalling"><a class="headerlink" href="#Pawn.TweenToFalling" title="Permanent link">TweenToFalling</a></h3>

<h3 id="Pawn.TweenToFighter"><a class="headerlink" href="#Pawn.TweenToFighter" title="Permanent link">TweenToFighter</a> (float tweentime)</h3>

<h3 id="Pawn.TweenToPatrolStop"><a class="headerlink" href="#Pawn.TweenToPatrolStop" title="Permanent link">TweenToPatrolStop</a> (float tweentime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TweenToFighter(tweentime);<br><br></div>
<h3 id="Pawn.TweenToRunning"><a class="headerlink" href="#Pawn.TweenToRunning" title="Permanent link">TweenToRunning</a> (float tweentime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TweenToFighter(0.1);<br><br></div>
<h3 id="Pawn.TweenToSwimming"><a class="headerlink" href="#Pawn.TweenToSwimming" title="Permanent link">TweenToSwimming</a> (float tweentime)</h3>

<h3 id="Pawn.TweenToWaiting"><a class="headerlink" href="#Pawn.TweenToWaiting" title="Permanent link">TweenToWaiting</a> (float tweentime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TweenToFighter(tweentime);<br><br></div>
<h3 id="Pawn.TweenToWalking"><a class="headerlink" href="#Pawn.TweenToWalking" title="Permanent link">TweenToWalking</a> (float tweentime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TweenToRunning(tweentime);<br><br></div>
<h3 id="Pawn.UnderLift"><a class="headerlink" href="#Pawn.UnderLift" title="Permanent link">UnderLift</a> (Mover M)</h3>

<h3 id="Pawn.UpdateEyeHeight"><a class="headerlink" href="#Pawn.UpdateEyeHeight" title="Permanent link">UpdateEyeHeight</a> (float DeltaTime)</h3>

<h3 id="Pawn.WaitForLanding"><a class="headerlink" href="#Pawn.WaitForLanding" title="Permanent link">WaitForLanding</a> | native</h3>

<h3 id="Pawn.WalkTexture"><a class="headerlink" href="#Pawn.WalkTexture" title="Permanent link">WalkTexture</a> (texture Texture, vector StepLocation, vector StepNormal)</h3>

<h3 id="Pawn.WarnTarget"><a class="headerlink" href="#Pawn.WarnTarget" title="Permanent link">WarnTarget</a> (Pawn shooter, float projSpeed, vector FireDir)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// AI controlled creatures may duck<br>&#9;// if not falling, and projectile time is long enough<br>&#9;// often pick opposite to current direction (relative to shooter axis)<br><br></div>
<h3 id="Pawn.actorReachable"><a class="headerlink" href="#Pawn.actorReachable" title="Permanent link">actorReachable</a> (actor anActor) | native</h3>

<h3 id="Pawn.damageAttitudeTo"><a class="headerlink" href="#Pawn.damageAttitudeTo" title="Permanent link">damageAttitudeTo</a> (pawn Other)</h3>

<h3 id="Pawn.gibbedBy"><a class="headerlink" href="#Pawn.gibbedBy" title="Permanent link">gibbedBy</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local pawn instigatedBy;<br><br><br>&#9;instigatedBy = pawn(Other);<br>&#9;if (instigatedBy == None)<br>&#9;&#9;instigatedBy = Other.instigator;<br>&#9;health = -1000; //make sure gibs<br>&#9;Died(instigatedBy, 'Gibbed', Location);<br><br></div>
<h3 id="Pawn.pointReachable"><a class="headerlink" href="#Pawn.pointReachable" title="Permanent link">pointReachable</a> (vector aPoint) | native</h3>

<br><br><hr>
<a class="headerlink" href="#Pickup.uc" title="Permanent link"><h2 id="Pickup.uc">Pickup.uc (extends Inventory)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var inventory Inv;<br>var travel int NumCopies;<br>var() bool bCanHaveMultipleCopies;  // if player can possess more than one of this<br>var() bool bCanActivate;			// Item can be selected and activated<br>var() localized String ExpireMessage; // Messages shown when pickup charge runs out<br>var() bool bAutoActivate;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bRotatingPickup=False</div>
<h3 id="Pickup.Activate"><a class="headerlink" href="#Pickup.Activate" title="Permanent link">Activate</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( (Pawn(Owner) != None) && Pawn(Owner).bAutoActivate <br>&#9;&#9;&#9;&& bAutoActivate && (Charge>0) )<br>&#9;&#9;&#9;&#9;return;<br><br>&#9;&#9;Super.Activate();&#9;<br>&#9;<br></div>
<h3 id="Pickup.BeginState"><a class="headerlink" href="#Pickup.BeginState" title="Permanent link">BeginState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;Super.BeginState();<br><br>&#9;&#9;// NumCopies = 1 means we have ONE of this item now<br>&#9;&#9;// DEUS_EX AJY<br><br>//&#9;&#9;NumCopies = 0;<br>&#9;<br></div>
<h3 id="Pickup.Frob"><a class="headerlink" href="#Pickup.Frob" title="Permanent link">Frob</a> (Actor Other, Inventory frobWith)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre">/&#9;function Touch( actor Other <br></div>
<h3 id="Pickup.HandlePickupQuery"><a class="headerlink" href="#Pickup.HandlePickupQuery" title="Permanent link">HandlePickupQuery</a> (inventory Item) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (item.class == class) <br>&#9;{<br>&#9;&#9;if (bCanHaveMultipleCopies) <br>&#9;&#9;{   // for items like Artifact<br>&#9;&#9;&#9;NumCopies++;<br>&#9;&#9;&#9;if (Level.Game.LocalLog != None)<br>&#9;&#9;&#9;&#9;Level.Game.LocalLog.LogPickup(Item, Pawn(Owner));<br>&#9;&#9;&#9;if (Level.Game.WorldLog != None)<br>&#9;&#9;&#9;&#9;Level.Game.WorldLog.LogPickup(Item, Pawn(Owner));<br>&#9;&#9;&#9;if ( Item.PickupMessageClass == None )<br>&#9;&#9;&#9;&#9;// DEUS_EX CNN - use the itemArticle and itemName<br>//&#9;&#9;&#9;&#9;Pawn(Owner).ClientMessage(item.PickupMessage, 'Pickup');<br>&#9;&#9;&#9;&#9;Pawn(Owner).ClientMessage(item.PickupMessage @ item.itemArticle @ item.itemName, 'Pickup');<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;Pawn(Owner).ReceiveLocalizedMessage( item.PickupMessageClass, 0, None, None, item.Class );<br>&#9;&#9;&#9;Item.PlaySound (Item.PickupSound,,2.0);<br>&#9;&#9;&#9;Item.SetRespawn();<br>&#9;&#9;}<br>&#9;&#9;/* DEUS_EX AJY<br>&#9;&#9;else if ( bDisplayableInv ) <br>&#9;&#9;{&#9;&#9;<br>&#9;&#9;&#9;if ( Charge<Item.Charge )&#9;<br>&#9;&#9;&#9;&#9;Charge= Item.Charge;<br>&#9;&#9;&#9;if (Level.Game.LocalLog != None)<br>&#9;&#9;&#9;&#9;Level.Game.LocalLog.LogPickup(Item, Pawn(Owner));<br>&#9;&#9;&#9;if (Level.Game.WorldLog != None)<br>&#9;&#9;&#9;&#9;Level.Game.WorldLog.LogPickup(Item, Pawn(Owner));<br>&#9;&#9;&#9;if ( Item.PickupMessageClass == None )<br>&#9;&#9;&#9;&#9;Pawn(Owner).ClientMessage(item.PickupMessage, 'Pickup');<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;Pawn(Owner).ReceiveLocalizedMessage( item.PickupMessageClass, 0, None, None, item.Class );<br>&#9;&#9;&#9;Item.PlaySound (item.PickupSound,,2.0);<br>&#9;&#9;&#9;Item.SetReSpawn();<br>&#9;&#9;}<br>&#9;&#9;*/<br>&#9;&#9;else if ( bDisplayableInv ) <br>&#9;&#9;&#9;return false;<br><br>&#9;&#9;return true;&#9;&#9;&#9;&#9;<br>&#9;<br></div>
<h3 id="Pickup.PickupFunction"><a class="headerlink" href="#Pickup.PickupFunction" title="Permanent link">PickupFunction</a> (Pawn Other)</h3>

<h3 id="Pickup.SetRespawn"><a class="headerlink" href="#Pickup.SetRespawn" title="Permanent link">SetRespawn</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Level.Game.ShouldRespawn(self) )<br>&#9;{<br>&#9;&#9;GotoState('Sleeping');<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;//because of latent destroy, we just need to make sure num copies is 0 and then <br>&#9;&#9;//you at least won't be able to doublefrob.<br>&#9;&#9;NumCopies = 0;<br>&#9;&#9;Destroy();<br>&#9;}<br><br></div>
<h3 id="Pickup.SpawnCopy"><a class="headerlink" href="#Pickup.SpawnCopy" title="Permanent link">SpawnCopy</a> (pawn Other) -> inventory</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local inventory Copy;<br><br><br>&#9;Copy = Super.SpawnCopy(Other);<br>&#9;Copy.Charge = Charge;<br>&#9;return Copy;<br><br></div>
<h3 id="Pickup.TravelPostAccept"><a class="headerlink" href="#Pickup.TravelPostAccept" title="Permanent link">TravelPostAccept</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.TravelPostAccept();<br>&#9;PickupFunction(Pawn(Owner));<br><br></div>
<h3 id="Pickup.UseCharge"><a class="headerlink" href="#Pickup.UseCharge" title="Permanent link">UseCharge</a> (float Amount) -> float</h3>

<h3 id="Pickup.UsedUp"><a class="headerlink" href="#Pickup.UsedUp" title="Permanent link">UsedUp</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Pawn(Owner) != None )<br>&#9;{<br>&#9;&#9;bActivatable = false;<br>&#9;&#9;Pawn(Owner).NextItem();<br>&#9;&#9;if (Pawn(Owner).SelectedItem == Self) {<br>&#9;&#9;&#9;Pawn(Owner).NextItem();&#9;<br>&#9;&#9;&#9;if (Pawn(Owner).SelectedItem == Self) Pawn(Owner).SelectedItem=None;<br>&#9;&#9;}<br>&#9;&#9;if (Level.Game.LocalLog != None)<br>&#9;&#9;&#9;Level.Game.LocalLog.LogItemDeactivate(Self, Pawn(Owner));<br>&#9;&#9;if (Level.Game.WorldLog != None)<br>&#9;&#9;&#9;Level.Game.WorldLog.LogItemDeactivate(Self, Pawn(Owner));<br>&#9;&#9;if ( ItemMessageClass != None )<br>&#9;&#9;&#9;Pawn(Owner).ReceiveLocalizedMessage( ItemMessageClass, 0, None, None, Self.Class );<br>&#9;&#9;else<br>&#9;&#9;&#9;Pawn(Owner).ClientMessage(ExpireMessage);&#9;<br>&#9;<br></div>
<br><br><hr>
<a class="headerlink" href="#Player.uc" title="Permanent link"><h2 id="Player.uc">Player.uc (extends Object)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var native const int vfOut;<br>var native const int vfExec;<br>var transient const playerpawn Actor;<br>var transient const console Console;<br>var transient const bool bWindowsMouseAvailable;<br>var bool bShowWindowsMouse;<br>var bool bSuspendPrecaching;<br>var transient const float WindowsMouseX;<br>var transient const float WindowsMouseY;<br>var int CurrentNetSpeed;<br>var globalconfig int ConfiguredInternetSpeed, ConfiguredLanSpeed;<br>var float StaticUpdateInterval, DynamicUpdateInterval;<br>var byte SelectedCursor;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">ConfiguredInternetSpeed=2600<br>ConfiguredLanSpeed=20000</div>
<br><br><hr>
<a class="headerlink" href="#PlayerPawn.uc" title="Permanent link"><h2 id="PlayerPawn.uc">PlayerPawn.uc (extends Pawn)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var const player Player;<br>var(Movement) globalconfig float	DodgeClickTime;<br>var(Movement) globalconfig float Bob;<br>var float bobtime;<br>var int ShowFlags;<br>var int RendMap;<br>var int Misc1;<br>var int Misc2;<br>var actor ViewTarget;<br>var vector FlashScale, FlashFog;<br>var HUD	myHUD;<br>var ScoreBoard Scoring;<br>var class<hud> HUDType;<br>var class<scoreboard> ScoringType;<br>var float DesiredFlashScale, ConstantGlowScale, InstantFlash;<br>var vector DesiredFlashFog, ConstantGlowFog, InstantFog;<br>var globalconfig float DesiredFOV;<br>var globalconfig float DefaultFOV;<br>var music Song;<br>var byte  SongSection;<br>var byte  CdTrack;<br>var EMusicTransition Transition;<br>var float shaketimer; // player uses this for shaking view<br>var int shakemag;	// max magnitude in degrees of shaking<br>var float shakevert; // max vertical shake magnitude<br>var float maxshake;<br>var float verttimer;<br>var(Pawn) class<carcass> CarcassType;<br>var travel float MyAutoAim;<br>var travel globalconfig float Handedness;<br>var(Sounds) sound JumpSound;<br>var bool		bAdmin;<br>var() globalconfig bool 		bLookUpStairs;	// look up/down stairs (player)<br>var() globalconfig bool		bSnapToLevel;	// Snap to level eyeheight when not mouselooking<br>var() globalconfig bool		bAlwaysMouseLook;<br>var globalconfig bool 		bKeyboardLook;	// no snapping when true<br>var bool		bWasForward;	// used for dodge move<br>var bool		bWasBack;<br>var bool		bWasLeft;<br>var bool		bWasRight;<br>var bool		bEdgeForward;<br>var bool		bEdgeBack;<br>var bool		bEdgeLeft;<br>var bool 		bEdgeRight;<br>var bool		bIsCrouching;<br>var bool		bAnimTransition;<br>var bool		bIsTurning;<br>var bool		bFrozen;<br>var bool        bBadConnectionAlert;<br>var globalconfig bool	bInvertMouse;<br>var bool		bShowScores;<br>var bool		bShowMenu;<br>var bool		bSpecialMenu;<br>var bool		bWokeUp;<br>var bool		bPressedJump;<br>var bool		bUpdatePosition;<br>var bool		bDelayedCommand;<br>var bool		bRising;<br>var bool		bReducedVis;<br>var bool		bCenterView;<br>var() globalconfig bool bMaxMouseSmoothing;<br>var bool		bMouseZeroed;<br>var bool		bReadyToPlay;<br>var bool bNoFlash;<br>var globalconfig bool bNoVoices;<br>var globalconfig bool bMessageBeep;<br>var bool		bZooming;<br>var() bool		bSinglePlayer;		// this class allowed in single player<br>var bool		bJustFired;<br>var bool		bJustAltFired;<br>var bool		bIsTyping;<br>var bool		bFixedCamera;<br>var globalconfig bool	bNeverAutoSwitch;	// if true, don't automatically switch to picked up weapon<br>var bool		bJumpStatus;	// used in net games<br>var bool		bCheatsEnabled;  // DEUS_EX STM - added globalconfig (CNN - removed for command line cheats)<br>var float		ZoomLevel;<br>var const Actor   AdditionalViews[3]; // If the pawn can see from the point of view of any additional actors.<br>var class<menu> SpecialMenu;<br>var string DelayedCommand;<br>var globalconfig float	MouseSensitivity;<br>var globalconfig name	WeaponPriority[20]; //weapon class priorities (9 is highest)<br>var float SmoothMouseX, SmoothMouseY, BorrowedMouseX, BorrowedMouseY;<br>var() globalconfig float MouseSmoothThreshold;<br>var float MouseZeroTime;<br>var input float<br>var SavedMove SavedMoves;<br>var SavedMove FreeMoves;<br>var SavedMove PendingMove;<br>var float CurrentTimeStamp,LastUpdateTime,ServerTimeStamp,TimeMargin, ClientUpdateTime;<br>var globalconfig float MaxTimeMargin;<br>var string ProgressMessage[8];<br>var color ProgressColor[8];<br>var float ProgressTimeOut;<br>var localized string QuickSaveString;<br>var localized string NoPauseMessage;<br>var localized string ViewingFrom;<br>var localized string OwnCamera;<br>var localized string FailedView;<br>var GameReplicationInfo GameReplicationInfo;<br>var() globalconfig string ngWorldSecret;<br>var() globalconfig bool ngSecretSet;<br>var rotator TargetViewRotation;<br>var float TargetEyeHeight;<br>var vector TargetWeaponViewOffset;<br>var int DemoViewPitch;<br>var int DemoViewYaw;<br>var float LastPlaySound;<br>var float TurnRateAdjuster;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Password="momsblend"<br>DodgeClickTime=0.100000<br>FlashScale=(X=1.000000,Y=1.000000,Z=1.000000)<br>DesiredFOV=90.000000<br>DefaultFOV=90.000000<br>CdTrack=255<br>MyAutoAim=1.000000<br>Handedness=-1.000000<br>bAlwaysMouseLook=True<br>bKeyboardLook=True<br>bNoFlash=True<br>bMessageBeep=True<br>MouseSensitivity=3.000000<br>WeaponPriority(0)=WeaponEMPGrenade<br>WeaponPriority(1)=WeaponGasGrenade<br>WeaponPriority(2)=WeaponLAM<br>WeaponPriority(3)=CBPWeaponRifle<br>WeaponPriority(4)=NailGun<br>WeaponPriority(5)=WeaponDesertEagle<br>MouseSmoothThreshold=0.160000<br>MaxTimeMargin=1.000000<br>QuickSaveString="Quick Saving"<br>NoPauseMessage="Game is not pauseable"<br>ViewingFrom="Now viewing from"<br>OwnCamera="own camera"<br>FailedView="Failed to change view."<br>TurnRateAdjuster=1.000000<br>bIsPlayer=True<br>bCanJump=True<br>bViewTarget=True<br>DesiredSpeed=0.300000<br>SightRadius=4100.000000<br>bTravel=True<br>bStasis=False<br>NetPriority=3.000000</div>
<h3 id="PlayerPawn.ActivateHint"><a class="headerlink" href="#PlayerPawn.ActivateHint" title="Permanent link">ActivateHint</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( bShowMenu || Level.Pauser!="" )<br>&#9;&#9;return;<br>&#9;If (Inventory!=None) Inventory.ActivateTranslator(True);<br><br></div>
<h3 id="PlayerPawn.ActivateItem"><a class="headerlink" href="#PlayerPawn.ActivateItem" title="Permanent link">ActivateItem</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( bShowMenu || Level.Pauser!="" )<br>&#9;&#9;return;<br>&#9;if (SelectedItem!=None) <br>&#9;&#9;SelectedItem.Activate();<br><br></div>
<h3 id="PlayerPawn.ActivateTranslator"><a class="headerlink" href="#PlayerPawn.ActivateTranslator" title="Permanent link">ActivateTranslator</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( bShowMenu || Level.Pauser!="" )<br>&#9;&#9;return;<br>&#9;If (Inventory!=None) Inventory.ActivateTranslator(False);<br><br></div>
<h3 id="PlayerPawn.AddBots"><a class="headerlink" href="#PlayerPawn.AddBots" title="Permanent link">AddBots</a> (int N)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ServerAddBots(N);<br><br></div>
<h3 id="PlayerPawn.AdjustAim"><a class="headerlink" href="#PlayerPawn.AdjustAim" title="Permanent link">AdjustAim</a> (float projSpeed, vector projStart, int aimerror, bool bLeadTarget, bool bWarnTarget) -> rotator</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector FireDir, AimSpot, HitNormal, HitLocation;<br>&#9;local actor BestTarget;<br>&#9;local float bestAim, bestDist;<br>&#9;local actor HitActor;<br><br>&#9;<br>&#9;FireDir = vector(ViewRotation);<br>&#9;HitActor = Trace(HitLocation, HitNormal, projStart + 4000 * FireDir, projStart, true);<br>&#9;if ( (HitActor != None) && HitActor.bProjTarget )<br>&#9;{<br>&#9;&#9;if ( bWarnTarget && HitActor.IsA('Pawn') )<br>&#9;&#9;&#9;Pawn(HitActor).WarnTarget(self, projSpeed, FireDir);<br>&#9;&#9;return ViewRotation;<br>&#9;}<br><br>&#9;bestAim = FMin(0.93, MyAutoAim);<br>&#9;BestTarget = PickTarget(bestAim, bestDist, FireDir, projStart);<br><br>&#9;if ( bWarnTarget && (Pawn(BestTarget) != None) )<br>&#9;&#9;Pawn(BestTarget).WarnTarget(self, projSpeed, FireDir);&#9;<br><br>&#9;if ( (Level.NetMode != NM_Standalone) || (Level.Game.Difficulty > 2) <br>&#9;&#9;|| bAlwaysMouseLook || ((BestTarget != None) && (bestAim < MyAutoAim)) || (MyAutoAim >= 1) )<br>&#9;&#9;return ViewRotation;<br>&#9;<br>&#9;if ( BestTarget == None )<br>&#9;{<br>&#9;&#9;bestAim = MyAutoAim;<br>&#9;&#9;BestTarget = PickAnyTarget(bestAim, bestDist, FireDir, projStart);<br>&#9;&#9;if ( BestTarget == None )<br>&#9;&#9;&#9;return ViewRotation;<br>&#9;}<br><br>&#9;AimSpot = projStart + FireDir * bestDist;<br>&#9;AimSpot.Z = BestTarget.Location.Z + 0.3 * BestTarget.CollisionHeight;<br><br>&#9;return rotator(AimSpot - projStart);<br><br></div>
<h3 id="PlayerPawn.AdjustHitLocation"><a class="headerlink" href="#PlayerPawn.AdjustHitLocation" title="Permanent link">AdjustHitLocation</a> (out vector HitLocation, vector TraceDir) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float adjZ, maxZ, scale;<br>&#9;local Vector adjTraceDir;<br><br><br>&#9;if ( Level.NetMode != NM_Standalone )<br>&#9;{<br>&#9;&#9;TraceDir = Normal(TraceDir);<br>&#9;&#9;AdjTraceDir = TraceDir;<br>&#9;&#9;AdjTraceDir.Z = 0.0;<br>&#9;&#9;AdjTraceDir = Normal(AdjTraceDir);<br>&#9;&#9;scale = TraceDir dot AdjTraceDir;<br>&#9;&#9;HitLocation = HitLocation + ( CollisionRadius * 0.60 * TraceDir ) / scale;<br>&#9;&#9;if ( BaseEyeHeight == Default.BaseEyeHeight )<br>&#9;&#9;&#9;return true;<br><br>&#9;&#9;maxZ = Location.Z + EyeHeight + 0.25 * CollisionHeight;<br>&#9;&#9;if ( HitLocation.Z > maxZ )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( TraceDir.Z >= 0 )<br>&#9;&#9;&#9;&#9;return false;<br>&#9;&#9;&#9;adjZ = (maxZ - HitLocation.Z)/TraceDir.Z;<br>&#9;&#9;&#9;HitLocation.Z = maxZ;<br>&#9;&#9;&#9;HitLocation.X = HitLocation.X + TraceDir.X * adjZ;<br>&#9;&#9;&#9;HitLocation.Y = HitLocation.Y + TraceDir.Y * adjZ;<br>&#9;&#9;&#9;if ( VSize(HitLocation - Location) > CollisionRadius )&#9;<br>&#9;&#9;&#9;&#9;return false;<br>&#9;&#9;}<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;TraceDir = Normal(TraceDir);<br>&#9;&#9;HitLocation = HitLocation + 0.5 * CollisionRadius * TraceDir;<br>&#9;&#9;if ( BaseEyeHeight == Default.BaseEyeHeight )<br>&#9;&#9;&#9;return true;<br>&#9;&#9;maxZ = Location.Z + EyeHeight + 0.25 * CollisionHeight;<br>&#9;&#9;if ( HitLocation.Z > maxZ )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( TraceDir.Z >= 0 )<br>&#9;&#9;&#9;&#9;return false;<br>&#9;&#9;&#9;adjZ = (maxZ - HitLocation.Z)/TraceDir.Z;<br>&#9;&#9;&#9;HitLocation.Z = maxZ;<br>&#9;&#9;&#9;HitLocation.X = HitLocation.X + TraceDir.X * adjZ;<br>&#9;&#9;&#9;HitLocation.Y = HitLocation.Y + TraceDir.Y * adjZ;<br>&#9;&#9;&#9;if ( VSize(HitLocation - Location) > CollisionRadius )&#9;<br>&#9;&#9;&#9;&#9;return false;<br>&#9;&#9;}<br>&#9;}<br>&#9;return true;<br><br></div>
<h3 id="PlayerPawn.Admin"><a class="headerlink" href="#PlayerPawn.Admin" title="Permanent link">Admin</a> (string CommandLine)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string Result;<br><br>&#9;if( bAdmin )<br>&#9;&#9;Result = ConsoleCommand( CommandLine );<br>&#9;if( Result!="" )<br>&#9;&#9;ClientMessage( Result );<br><br></div>
<h3 id="PlayerPawn.AdminLogin"><a class="headerlink" href="#PlayerPawn.AdminLogin" title="Permanent link">AdminLogin</a> (string Password)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Level.Game.AdminLogin( Self, Password );<br><br></div>
<h3 id="PlayerPawn.AdminLogout"><a class="headerlink" href="#PlayerPawn.AdminLogout" title="Permanent link">AdminLogout</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Level.Game.AdminLogout( Self );<br><br></div>
<h3 id="PlayerPawn.AllAmmo"><a class="headerlink" href="#PlayerPawn.AllAmmo" title="Permanent link">AllAmmo</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Inventory Inv;<br><br><br>&#9;if( !bCheatsEnabled )<br>&#9;&#9;return;<br><br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br><br>&#9;// DEUS_EX CNN - make this be limited by the MaxAmmo per ammo instead of 999<br>&#9;for( Inv=Inventory; Inv!=None; Inv=Inv.Inventory ) <br>&#9;&#9;if (Ammo(Inv)!=None) <br>&#9;&#9;&#9;Ammo(Inv).AmmoAmount  = Ammo(Inv).MaxAmmo;<br><br></div>
<h3 id="PlayerPawn.AltFire"><a class="headerlink" href="#PlayerPawn.AltFire" title="Permanent link">AltFire</a> (optional float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;Fire(F);<br>&#9;<br></div>
<h3 id="PlayerPawn.AlwaysMouseLook"><a class="headerlink" href="#PlayerPawn.AlwaysMouseLook" title="Permanent link">AlwaysMouseLook</a> (Bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ChangeAlwaysMouseLook(B);<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.Amphibious"><a class="headerlink" href="#PlayerPawn.Amphibious" title="Permanent link">Amphibious</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( !bCheatsEnabled )<br>&#9;&#9;return;<br><br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br>&#9;UnderwaterTime = +999999.0;<br><br></div>
<h3 id="PlayerPawn.AnimEnd"><a class="headerlink" href="#PlayerPawn.AnimEnd" title="Permanent link">AnimEnd</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;PlaySwimming();<br>&#9;<br></div>
<h3 id="PlayerPawn.AttitudeTo"><a class="headerlink" href="#PlayerPawn.AttitudeTo" title="Permanent link">AttitudeTo</a> (Pawn Other) -> eAttitude</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Other.bIsPlayer)<br>&#9;&#9;return AttitudeToPlayer;<br>&#9;else <br>&#9;&#9;return Other.AttitudeToPlayer;<br><br></div>
<h3 id="PlayerPawn.BeginState"><a class="headerlink" href="#PlayerPawn.BeginState" title="Permanent link">BeginState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;EndZoom();<br>&#9;&#9;AnimRate = 0.0;<br>&#9;&#9;SimAnim.Y = 0;<br>&#9;&#9;bFire = 0;<br>&#9;&#9;bAltFire = 0;<br>&#9;&#9;SetCollision(false,false,false);<br>&#9;&#9;bShowScores = true;<br>&#9;&#9;bFrozen = true;<br>&#9;&#9;if ( !bFixedCamera )<br>&#9;&#9;{<br>&#9;&#9;&#9;FindGoodView();<br>&#9;&#9;&#9;bBehindView = true;<br>&#9;&#9;}<br>&#9;&#9;SetTimer(1.5, false);<br>&#9;&#9;SetPhysics(PHYS_None);<br>&#9;<br></div>
<h3 id="PlayerPawn.BehindView"><a class="headerlink" href="#PlayerPawn.BehindView" title="Permanent link">BehindView</a> (Bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// DEUS_EX CNN - This needs to be here!<br>&#9;if (!bCheatsEnabled)<br>&#9;&#9;return;<br><br>&#9;bBehindView = B;<br><br></div>
<h3 id="PlayerPawn.CalcBehindView"><a class="headerlink" href="#PlayerPawn.CalcBehindView" title="Permanent link">CalcBehindView</a> (out vector CameraLocation, out rotator CameraRotation, float Dist)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector View,HitLocation,HitNormal;<br>&#9;local float ViewDist;<br><br><br>&#9;CameraRotation = ViewRotation;<br>&#9;View = vect(1,0,0) >> CameraRotation;<br>&#9;if( Trace( HitLocation, HitNormal, CameraLocation - (Dist + 30) * vector(CameraRotation), CameraLocation ) != None )<br>&#9;&#9;ViewDist = FMin( (CameraLocation - HitLocation) Dot View, Dist );<br>&#9;else<br>&#9;&#9;ViewDist = Dist;<br>&#9;CameraLocation -= (ViewDist - 30) * View; <br><br></div>
<h3 id="PlayerPawn.CallForHelp"><a class="headerlink" href="#PlayerPawn.CallForHelp" title="Permanent link">CallForHelp</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br><br><br>&#9;if ( !Level.Game.bTeamGame || (Enemy == None) || (Enemy.Health <= 0) )<br>&#9;&#9;return;<br><br>&#9;for ( P=Level.PawnList; P!=None; P=P.NextPawn )<br>&#9;&#9;if ( P.bIsPlayer && (P.PlayerReplicationInfo.Team == PlayerReplicationInfo.Team) )<br>&#9;&#9;&#9;P.HandleHelpMessageFrom(self);<br><br></div>
<h3 id="PlayerPawn.CauseEvent"><a class="headerlink" href="#PlayerPawn.CauseEvent" title="Permanent link">CauseEvent</a> (name N)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor A;<br><br>&#9;if( !bCheatsEnabled )<br>&#9;&#9;return;<br>&#9;if( (bAdmin || (Level.Netmode == NM_Standalone)) && (N != '') )<br>&#9;&#9;foreach AllActors( class 'Actor', A, N )<br>&#9;&#9;&#9;A.Trigger( Self, Self );<br><br></div>
<h3 id="PlayerPawn.ChangeAlwaysMouseLook"><a class="headerlink" href="#PlayerPawn.ChangeAlwaysMouseLook" title="Permanent link">ChangeAlwaysMouseLook</a> (Bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bAlwaysMouseLook = B;<br>&#9;if ( bAlwaysMouseLook )<br>&#9;&#9;bLookUpStairs = false;<br><br></div>
<h3 id="PlayerPawn.ChangeAutoAim"><a class="headerlink" href="#PlayerPawn.ChangeAutoAim" title="Permanent link">ChangeAutoAim</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;MyAutoAim = FMax(Level.Game.AutoAim, F);<br><br></div>
<h3 id="PlayerPawn.ChangeCrosshair"><a class="headerlink" href="#PlayerPawn.ChangeCrosshair" title="Permanent link">ChangeCrosshair</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( myHud != None ) <br>&#9;&#9;myHUD.ChangeCrosshair(1);<br>&#9;myHUD.SaveConfig();<br><br></div>
<h3 id="PlayerPawn.ChangeDodgeClickTime"><a class="headerlink" href="#PlayerPawn.ChangeDodgeClickTime" title="Permanent link">ChangeDodgeClickTime</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;DodgeClickTime = FMin(0.3, F);<br><br></div>
<h3 id="PlayerPawn.ChangeHud"><a class="headerlink" href="#PlayerPawn.ChangeHud" title="Permanent link">ChangeHud</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( myHud != None )<br>&#9;&#9;myHUD.ChangeHud(1);<br>&#9;myHUD.SaveConfig();<br><br></div>
<h3 id="PlayerPawn.ChangeName"><a class="headerlink" href="#PlayerPawn.ChangeName" title="Permanent link">ChangeName</a> (coerce string S)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Level.Game.ChangeName( self, S, false );<br><br></div>
<h3 id="PlayerPawn.ChangeSetHand"><a class="headerlink" href="#PlayerPawn.ChangeSetHand" title="Permanent link">ChangeSetHand</a> (string S)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( S ~= "Left" )<br>&#9;&#9;Handedness = 1;<br>&#9;else if ( S~= "Right" )<br>&#9;&#9;Handedness = -1;<br>&#9;else if ( S ~= "Center" )<br>&#9;&#9;Handedness = 0;<br>&#9;else if ( S ~= "Hidden" )<br>&#9;&#9;Handedness = 2;<br>&#9;ServerSetHandedness(Handedness);<br><br></div>
<h3 id="PlayerPawn.ChangeSnapView"><a class="headerlink" href="#PlayerPawn.ChangeSnapView" title="Permanent link">ChangeSnapView</a> (bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bSnapToLevel = B;<br><br></div>
<h3 id="PlayerPawn.ChangeStairLook"><a class="headerlink" href="#PlayerPawn.ChangeStairLook" title="Permanent link">ChangeStairLook</a> (bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bLookUpStairs = B;<br>&#9;if ( bLookUpStairs )<br>&#9;&#9;bAlwaysMouseLook = false;<br><br></div>
<h3 id="PlayerPawn.ChangeTeam"><a class="headerlink" href="#PlayerPawn.ChangeTeam" title="Permanent link">ChangeTeam</a> (int N)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;Level.Game.ChangeTeam(self, N);<br>&#9;<br></div>
<h3 id="PlayerPawn.ChangedWeapon"><a class="headerlink" href="#PlayerPawn.ChangedWeapon" title="Permanent link">ChangedWeapon</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;Weapon = None;<br>&#9;&#9;Inventory.ChangedWeapon();<br>&#9;<br></div>
<h3 id="PlayerPawn.CheckBob"><a class="headerlink" href="#PlayerPawn.CheckBob" title="Permanent link">CheckBob</a> (float DeltaTime, float Speed2D, vector Y)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float OldBobTime;<br><br><br>&#9;OldBobTime = BobTime;<br>&#9;if ( Speed2D < 10 )<br>&#9;&#9;BobTime += 0.2 * DeltaTime;<br>&#9;else<br>&#9;&#9;BobTime += DeltaTime * (0.3 + 0.7 * Speed2D/GroundSpeed);<br>&#9;WalkBob = Y * 0.65 * Bob * Speed2D * sin(6 * BobTime);<br>&#9;AppliedBob = AppliedBob * (1 - FMin(1, 16 * deltatime));<br>&#9;if ( LandBob > 0.01 )<br>&#9;{<br>&#9;&#9;AppliedBob += FMin(1, 16 * deltatime) * LandBob;<br>&#9;&#9;LandBob *= (1 - 8*Deltatime);<br>&#9;}<br>&#9;if ( Speed2D < 10 )<br>&#9;&#9;WalkBob.Z = 0; // AppliedBob + Bob * 30 * sin(12 * BobTime);   // take out the "breathe" effect - DEUS_EX CNN<br>&#9;else<br>&#9;&#9;WalkBob.Z = AppliedBob + Bob * Speed2D * sin(12 * BobTime);<br><br></div>
<h3 id="PlayerPawn.ClearProgressMessages"><a class="headerlink" href="#PlayerPawn.ClearProgressMessages" title="Permanent link">ClearProgressMessages</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br><br><br>&#9;for (i=0; i<8; i++)<br>&#9;{<br>&#9;&#9;ProgressMessage[i] = "";<br>&#9;&#9;ProgressColor[i].R = 255;<br>&#9;&#9;ProgressColor[i].G = 255;<br>&#9;&#9;ProgressColor[i].B = 255;<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.ClientAdjustGlow"><a class="headerlink" href="#PlayerPawn.ClientAdjustGlow" title="Permanent link">ClientAdjustGlow</a> (float scale, vector fog)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ConstantGlowScale += scale;<br>&#9;ConstantGlowFog += 0.001 * fog;<br><br></div>
<h3 id="PlayerPawn.ClientChangeTeam"><a class="headerlink" href="#PlayerPawn.ClientChangeTeam" title="Permanent link">ClientChangeTeam</a> (int N)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br><br>&#9;&#9;<br>&#9;if ( PlayerReplicationInfo != None )<br>&#9;&#9;PlayerReplicationInfo.Team = N;<br><br>&#9;// if listen server, this may be called for non-local players that are logging in<br>&#9;// if so, don't update URL<br>&#9;if ( (Level.NetMode == NM_ListenServer) && (Player == None) )<br>&#9;{<br>&#9;&#9;// check if any other players exist<br>&#9;&#9;for ( P=Level.PawnList; P!=None; P=P.NextPawn )<br>&#9;&#9;&#9;if ( P.IsA('PlayerPawn') && (ViewPort(PlayerPawn(P).Player) != None) )<br>&#9;&#9;&#9;&#9;return;<br>&#9;}<br>&#9;&#9;<br>&#9;UpdateURL("Team",string(N), true);&#9;<br><br></div>
<h3 id="PlayerPawn.ClientFlash"><a class="headerlink" href="#PlayerPawn.ClientFlash" title="Permanent link">ClientFlash</a> (float scale, vector fog)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;DesiredFlashScale = scale;<br>&#9;DesiredFlashFog = 0.001 * fog;<br><br></div>
<h3 id="PlayerPawn.ClientInstantFlash"><a class="headerlink" href="#PlayerPawn.ClientInstantFlash" title="Permanent link">ClientInstantFlash</a> (float scale, vector fog)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;InstantFlash = scale;<br>&#9;InstantFog = 0.001 * fog;<br><br></div>
<h3 id="PlayerPawn.ClientMessage"><a class="headerlink" href="#PlayerPawn.ClientMessage" title="Permanent link">ClientMessage</a> (coerce string S, optional Name Type, optional bool bBeep)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Player == None)<br>&#9;&#9;return;<br><br>&#9;if (Type == '')<br>&#9;&#9;Type = 'Event';<br><br>&#9;if (Player.Console != None)<br>&#9;&#9;Player.Console.Message( PlayerReplicationInfo, S, Type );<br><br>&#9;if (bBeep && bMessageBeep)<br>&#9;&#9;PlayBeepSound();<br>&#9;if ( myHUD != None )<br>&#9;&#9;myHUD.Message( PlayerReplicationInfo, S, Type );<br><br></div>
<h3 id="PlayerPawn.ClientPlaySound"><a class="headerlink" href="#PlayerPawn.ClientPlaySound" title="Permanent link">ClientPlaySound</a> (sound ASound, optional bool bInterrupt, optional bool bVolumeControl)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor SoundPlayer;<br>&#9;<br><br>&#9;LastPlaySound = Level.TimeSeconds;&#9;// so voice messages won't overlap<br>&#9;if ( ViewTarget != None )<br>&#9;&#9;SoundPlayer = ViewTarget;<br>&#9;else<br>&#9;&#9;SoundPlayer = self;<br><br>&#9;SoundPlayer.PlaySound(ASound, SLOT_None, 16.0, bInterrupt);<br>&#9;SoundPlayer.PlaySound(ASound, SLOT_Interface, 16.0, bInterrupt);<br>&#9;SoundPlayer.PlaySound(ASound, SLOT_Misc, 16.0, bInterrupt);<br>&#9;SoundPlayer.PlaySound(ASound, SLOT_Talk, 16.0, bInterrupt);<br><br></div>
<h3 id="PlayerPawn.ClientReliablePlaySound"><a class="headerlink" href="#PlayerPawn.ClientReliablePlaySound" title="Permanent link">ClientReliablePlaySound</a> (sound ASound, optional bool bInterrupt, optional bool bVolumeControl)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ClientPlaySound(ASound, bInterrupt, bVolumeControl);<br><br></div>
<h3 id="PlayerPawn.ClientReplicateSkins"><a class="headerlink" href="#PlayerPawn.ClientReplicateSkins" title="Permanent link">ClientReplicateSkins</a> (texture Skin1, optional texture Skin2, optional texture Skin3, optional texture Skin4)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// do nothing (just loading other player skins onto client)<br>&#9;log("Getting "$Skin1$", "$Skin2$", "$Skin3$", "$Skin4);<br>&#9;return;<br><br></div>
<h3 id="PlayerPawn.ClientSetMusic"><a class="headerlink" href="#PlayerPawn.ClientSetMusic" title="Permanent link">ClientSetMusic</a> (music NewSong, byte NewSection, byte NewCdTrack, EMusicTransition NewTransition)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Song        = NewSong;<br>&#9;SongSection = NewSection;<br>&#9;CdTrack     = NewCdTrack;<br>&#9;Transition  = NewTransition;<br><br></div>
<h3 id="PlayerPawn.ClientShake"><a class="headerlink" href="#PlayerPawn.ClientShake" title="Permanent link">ClientShake</a> (vector shake)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( (shakemag < shake.X) || (shaketimer <= 0.01 * shake.Y) )<br>&#9;{<br>&#9;&#9;shakemag = shake.X;<br>&#9;&#9;shaketimer = 0.01 * shake.Y;&#9;<br>&#9;&#9;maxshake = 0.01 * shake.Z;<br>&#9;&#9;verttimer = 0;<br>&#9;&#9;ShakeVert = -1.1 * maxshake;<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.ClientTravel"><a class="headerlink" href="#PlayerPawn.ClientTravel" title="Permanent link">ClientTravel</a> (string URL, ETravelType TravelType, bool bItems) | native</h3>

<h3 id="PlayerPawn.ClientUpdatePosition"><a class="headerlink" href="#PlayerPawn.ClientUpdatePosition" title="Permanent link">ClientUpdatePosition</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local SavedMove CurrentMove;<br>&#9;local int realbRun, realbDuck;<br>&#9;local bool bRealJump;<br>&#9;local float AdjPCol, SavedRadius, TotalTime;<br>&#9;local pawn SavedPawn, P;<br>&#9;local vector Dist;<br><br><br><br>&#9;bUpdatePosition = false;<br>&#9;realbRun= bRun;<br>&#9;realbDuck = bDuck;<br>&#9;bRealJump = bPressedJump;<br>&#9;CurrentMove = SavedMoves;<br>&#9;bUpdating = true;<br>&#9;while ( CurrentMove != None )<br>&#9;{<br>&#9;&#9;if ( CurrentMove.TimeStamp <= CurrentTimeStamp )<br>&#9;&#9;{<br>&#9;&#9;&#9;SavedMoves = CurrentMove.NextMove;<br>&#9;&#9;&#9;CurrentMove.NextMove = FreeMoves;<br>&#9;&#9;&#9;FreeMoves = CurrentMove;<br>&#9;&#9;&#9;FreeMoves.Clear();<br>&#9;&#9;&#9;CurrentMove = SavedMoves;<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;// adjust radius of nearby players with uncertain location<br>&#9;&#9;&#9;if ( TotalTime > 0 )<br>               // XXXDEUS_EX AMSD Slow Pawn Iterator<br>&#9;&#9;&#9;&#9;//ForEach AllActors(class'Pawn', P)<br>            for (p = Level.PawnList; p != None; p = p.NextPawn)<br>               if ( (P != self) && (P.Velocity != vect(0,0,0)) && P.bBlockPlayers )<br>&#9;&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;&#9;Dist = P.Location - Location;<br>&#9;&#9;&#9;&#9;&#9;&#9;AdjPCol = 0.0004 * PlayerReplicationInfo.Ping * ((P.Velocity - Velocity) Dot Normal(Dist));<br>&#9;&#9;&#9;&#9;&#9;&#9;if ( VSize(Dist) < AdjPCol + P.CollisionRadius + CollisionRadius + CurrentMove.Delta * GroundSpeed * (Normal(Velocity) Dot Normal(Dist)) )<br>&#9;&#9;&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;SavedPawn = P;<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;SavedRadius = P.CollisionRadius;<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;Dist.Z = 0;<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;P.SetCollisionSize(FClamp(AdjPCol + P.CollisionRadius, 0.5 * P.CollisionRadius, VSize(Dist) - CollisionRadius - P.CollisionRadius), P.CollisionHeight);<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;break;<br>&#9;&#9;&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;&#9;} <br>&#9;&#9;&#9;TotalTime += CurrentMove.Delta;<br>&#9;&#9;&#9;MoveAutonomous(CurrentMove.Delta, CurrentMove.bRun, CurrentMove.bDuck, CurrentMove.bPressedJump, CurrentMove.DodgeMove, CurrentMove.Acceleration, rot(0,0,0));<br>&#9;&#9;&#9;CurrentMove = CurrentMove.NextMove;<br>&#9;&#9;&#9;if ( SavedPawn != None )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;SavedPawn.SetCollisionSize(SavedRadius, P.CollisionHeight);<br>&#9;&#9;&#9;&#9;SavedPawn = None;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>      // DEUS_EX AMSD Must also do the pending move that we've been building up.<br>      if ((CurrentMove == None) && (PendingMove != None))<br>      {<br>         CurrentMove = PendingMove;<br>         PendingMove = None;<br>      }<br>&#9;}<br>&#9;bUpdating = false;<br>&#9;bDuck = realbDuck;<br>&#9;bRun = realbRun;<br>&#9;bPressedJump = bRealJump;<br>   //DEUS_EX AMSD Whenever we adjust our position, we need to reset pending moves as well.<br>   PendingMove = None;<br>&#9;//log("Client adjusted "$self$" stamp "$CurrentTimeStamp$" location "$Location$" dodge "$DodgeDir);<br><br></div>
<h3 id="PlayerPawn.ClientVoiceMessage"><a class="headerlink" href="#PlayerPawn.ClientVoiceMessage" title="Permanent link">ClientVoiceMessage</a> (PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local VoicePack V;<br><br><br>&#9;if ( (Sender.voicetype == None) || (Player.Console == None) )<br>&#9;&#9;return;<br>&#9;&#9;<br>&#9;V = Spawn(Sender.voicetype, self);<br>&#9;if ( V != None )<br>&#9;&#9;V.ClientInitialize(Sender, Recipient, messagetype, messageID);<br><br></div>
<h3 id="PlayerPawn.ClientWeaponEvent"><a class="headerlink" href="#PlayerPawn.ClientWeaponEvent" title="Permanent link">ClientWeaponEvent</a> (name EventType)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Weapon != None )<br>&#9;&#9;Weapon.ClientWeaponEvent(EventType);<br><br></div>
<h3 id="PlayerPawn.CompressAccel"><a class="headerlink" href="#PlayerPawn.CompressAccel" title="Permanent link">CompressAccel</a> (int C) -> int</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( C >= 0 )<br>&#9;&#9;C = Min(C, 127);<br>&#9;else<br>&#9;&#9;C = Min(abs(C), 127) + 128;<br>&#9;return C;<br><br></div>
<h3 id="PlayerPawn.ConsoleCommand"><a class="headerlink" href="#PlayerPawn.ConsoleCommand" title="Permanent link">ConsoleCommand</a> (string Command) -> string | native</h3>

<h3 id="PlayerPawn.CopyToClipboard"><a class="headerlink" href="#PlayerPawn.CopyToClipboard" title="Permanent link">CopyToClipboard</a> (string Text) | native</h3>

<h3 id="PlayerPawn.Destroyed"><a class="headerlink" href="#PlayerPawn.Destroyed" title="Permanent link">Destroyed</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.Destroyed();<br>&#9;if ( myHud != None )<br>&#9;&#9;myHud.Destroy();<br>&#9;if ( Scoring != None )<br>&#9;&#9;Scoring.Destroy();<br><br>&#9;While ( FreeMoves != None )<br>&#9;{<br>&#9;&#9;FreeMoves.Destroy();<br>&#9;&#9;FreeMoves = FreeMoves.NextMove;<br>&#9;}<br><br>&#9;While ( SavedMoves != None )<br>&#9;{<br>&#9;&#9;SavedMoves.Destroy();<br>&#9;&#9;SavedMoves = SavedMoves.NextMove;<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.Died"><a class="headerlink" href="#PlayerPawn.Died" title="Permanent link">Died</a> (pawn Killer, name damageType, vector HitLocation)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;StopZoom();<br><br>&#9;Super.Died(Killer, damageType, HitLocation);&#9;<br><br></div>
<h3 id="PlayerPawn.DoJump"><a class="headerlink" href="#PlayerPawn.DoJump" title="Permanent link">DoJump</a> (optional float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( CarriedDecoration != None )<br>&#9;&#9;return;<br>&#9;if ( !bIsCrouching && (Physics == PHYS_Walking) )<br>&#9;{<br>&#9;&#9;if ( !bUpdating )<br>&#9;&#9;&#9;PlayOwnedSound(JumpSound, SLOT_Talk, 1.5, true, 1200, 1.0 );<br>&#9;&#9;if ( (Level.Game != None) && (Level.Game.Difficulty > 0) )<br>&#9;&#9;&#9;MakeNoise(0.1 * Level.Game.Difficulty);<br>&#9;&#9;PlayInAir();<br>&#9;&#9;if ( bCountJumps && (Role == ROLE_Authority) && (Inventory != None) )<br>&#9;&#9;&#9;Inventory.OwnerJumped();<br>&#9;&#9;Velocity.Z = JumpZ;<br>&#9;&#9;if ( (Base != Level) && (Base != None) )<br>&#9;&#9;&#9;Velocity.Z += Base.Velocity.Z; <br>&#9;&#9;SetPhysics(PHYS_Falling);<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.Dodge"><a class="headerlink" href="#PlayerPawn.Dodge" title="Permanent link">Dodge</a> (eDodgeDir DodgeMove)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector X,Y,Z;<br><br><br>&#9;&#9;if ( bIsCrouching || (Physics != PHYS_Walking) )<br>&#9;&#9;&#9;return;<br><br>&#9;&#9;GetAxes(Rotation,X,Y,Z);<br>&#9;&#9;if (DodgeMove == DODGE_Forward)<br>&#9;&#9;&#9;Velocity = 1.5*GroundSpeed*X + (Velocity Dot Y)*Y;<br>&#9;&#9;else if (DodgeMove == DODGE_Back)<br>&#9;&#9;&#9;Velocity = -1.5*GroundSpeed*X + (Velocity Dot Y)*Y; <br>&#9;&#9;else if (DodgeMove == DODGE_Left)<br>&#9;&#9;&#9;Velocity = 1.5*GroundSpeed*Y + (Velocity Dot X)*X; <br>&#9;&#9;else if (DodgeMove == DODGE_Right)<br>&#9;&#9;&#9;Velocity = -1.5*GroundSpeed*Y + (Velocity Dot X)*X; <br><br>&#9;&#9;Velocity.Z = 160;<br>&#9;&#9;PlayOwnedSound(JumpSound, SLOT_Talk, 1.0, true, 800, 1.0 );<br>&#9;&#9;PlayDodge(DodgeMove);<br>&#9;&#9;DodgeDir = DODGE_Active;<br>&#9;&#9;SetPhysics(PHYS_Falling);<br>&#9;<br></div>
<h3 id="PlayerPawn.EndState"><a class="headerlink" href="#PlayerPawn.EndState" title="Permanent link">EndState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;// clean out saved moves<br>&#9;&#9;while ( SavedMoves != None )<br>&#9;&#9;{<br>&#9;&#9;&#9;SavedMoves.Destroy();<br>&#9;&#9;&#9;SavedMoves = SavedMoves.NextMove;<br>&#9;&#9;}<br>&#9;&#9;if ( PendingMove != None )<br>&#9;&#9;{<br>&#9;&#9;&#9;PendingMove.Destroy();<br>&#9;&#9;&#9;PendingMove = None;<br>&#9;&#9;}<br>&#9;&#9;Velocity = vect(0,0,0);<br>&#9;&#9;Acceleration = vect(0,0,0);<br>&#9;&#9;bBehindView = false;<br>&#9;&#9;bShowScores = false;<br>&#9;&#9;bJustFired = false;<br>&#9;&#9;bJustAltFired = false;<br>&#9;&#9;bPressedJump = false;<br>&#9;&#9;if ( Carcass(ViewTarget) != None )<br>&#9;&#9;&#9;ViewTarget = None;<br>&#9;&#9;//Log(self$" exiting dying with remote role "$RemoteRole$" and role "$Role);<br>&#9;<br></div>
<h3 id="PlayerPawn.EndZoom"><a class="headerlink" href="#PlayerPawn.EndZoom" title="Permanent link">EndZoom</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bZooming = false;<br>&#9;DesiredFOV = DefaultFOV;<br><br></div>
<h3 id="PlayerPawn.FOV"><a class="headerlink" href="#PlayerPawn.FOV" title="Permanent link">FOV</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;SetDesiredFOV(F);<br><br></div>
<h3 id="PlayerPawn.Falling"><a class="headerlink" href="#PlayerPawn.Falling" title="Permanent link">Falling</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;//SetPhysics(PHYS_Falling); //Note - physics changes type to PHYS_Falling by default<br>&#9;&#9;//log(class$" Falling");<br>&#9;&#9;PlayInAir();<br>&#9;<br></div>
<h3 id="PlayerPawn.FeignDeath"><a class="headerlink" href="#PlayerPawn.FeignDeath" title="Permanent link">FeignDeath</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( Physics == PHYS_Walking )<br>&#9;&#9;{<br>&#9;&#9;&#9;ServerFeignDeath();<br>&#9;&#9;&#9;Acceleration = vect(0,0,0);<br>&#9;&#9;&#9;GotoState('FeigningDeath');<br>&#9;&#9;}<br>&#9;<br></div>
<h3 id="PlayerPawn.FindGoodView"><a class="headerlink" href="#PlayerPawn.FindGoodView" title="Permanent link">FindGoodView</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector cameraLoc;<br>&#9;local rotator cameraRot;<br>&#9;local int tries, besttry;<br>&#9;local float bestdist, newdist;<br>&#9;local int startYaw;<br>&#9;local actor ViewActor;<br><br>&#9;&#9;<br>&#9;&#9;ViewRotation.Pitch = 56000;<br>&#9;&#9;tries = 0;<br>&#9;&#9;besttry = 0;<br>&#9;&#9;bestdist = 0.0;<br>&#9;&#9;startYaw = ViewRotation.Yaw;<br>&#9;&#9;<br>&#9;&#9;for (tries=0; tries<16; tries++)<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( ViewTarget != None )<br>&#9;&#9;&#9;&#9;cameraLoc = ViewTarget.Location;<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;cameraLoc = Location;<br>&#9;&#9;&#9;PlayerCalcView(ViewActor, cameraLoc, cameraRot);<br>&#9;&#9;&#9;newdist = VSize(cameraLoc - Location);<br>&#9;&#9;&#9;if (newdist > bestdist)<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;bestdist = newdist;&#9;<br>&#9;&#9;&#9;&#9;besttry = tries;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;ViewRotation.Yaw += 4096;<br>&#9;&#9;}<br>&#9;&#9;&#9;<br>&#9;&#9;ViewRotation.Yaw = startYaw + besttry * 4096;<br>&#9;<br></div>
<h3 id="PlayerPawn.Fire"><a class="headerlink" href="#PlayerPawn.Fire" title="Permanent link">Fire</a> (optional float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( Role < ROLE_Authority)<br>&#9;&#9;&#9;return;<br>&#9;&#9;if ( !bFrozen )<br>&#9;&#9;&#9;ServerReStartGame();<br>&#9;&#9;else if ( TimerRate <= 0 )<br>&#9;&#9;&#9;SetTimer(1.5, false);<br>&#9;<br></div>
<h3 id="PlayerPawn.Fly"><a class="headerlink" href="#PlayerPawn.Fly" title="Permanent link">Fly</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( !bCheatsEnabled )<br>&#9;&#9;return;<br><br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br>&#9;&#9;<br>&#9;UnderWaterTime = Default.UnderWaterTime;&#9;<br>&#9;ClientMessage("You feel much lighter");<br>&#9;SetCollision(true, true , true);<br>&#9;bCollideWorld = true;<br>&#9;GotoState('CheatFlying');<br><br></div>
<h3 id="PlayerPawn.FunctionKey"><a class="headerlink" href="#PlayerPawn.FunctionKey" title="Permanent link">FunctionKey</a> (byte Num)</h3>

<h3 id="PlayerPawn.GetDefaultURL"><a class="headerlink" href="#PlayerPawn.GetDefaultURL" title="Permanent link">GetDefaultURL</a> (string Option) -> string | native</h3>

<h3 id="PlayerPawn.GetEntryLevel"><a class="headerlink" href="#PlayerPawn.GetEntryLevel" title="Permanent link">GetEntryLevel</a> -> LevelInfo | native</h3>

<h3 id="PlayerPawn.GetFreeMove"><a class="headerlink" href="#PlayerPawn.GetFreeMove" title="Permanent link">GetFreeMove</a> -> SavedMove</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local SavedMove s;<br><br><br>&#9;if ( FreeMoves == None )<br>&#9;&#9;return Spawn(class'SavedMove');<br>&#9;else<br>&#9;{<br>&#9;&#9;s = FreeMoves;<br>&#9;&#9;FreeMoves = FreeMoves.NextMove;<br>&#9;&#9;s.NextMove = None;<br>&#9;&#9;return s;<br>&#9;}&#9;<br><br></div>
<h3 id="PlayerPawn.GetPlayerNetworkAddress"><a class="headerlink" href="#PlayerPawn.GetPlayerNetworkAddress" title="Permanent link">GetPlayerNetworkAddress</a> -> string | native</h3>

<h3 id="PlayerPawn.Ghost"><a class="headerlink" href="#PlayerPawn.Ghost" title="Permanent link">Ghost</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( !bCheatsEnabled )<br>&#9;&#9;return;<br><br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br>&#9;<br>&#9;UnderWaterTime = -1.0;&#9;<br>&#9;ClientMessage("You feel ethereal");<br>&#9;SetCollision(false, false, false);<br>&#9;bCollideWorld = false;<br>&#9;GotoState('CheatFlying');<br><br></div>
<h3 id="PlayerPawn.Gibbed"><a class="headerlink" href="#PlayerPawn.Gibbed" title="Permanent link">Gibbed</a> (name damageType) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( (damageType == 'decapitated') || (damageType == 'shot') )<br>&#9;&#9;return false; &#9;<br>&#9;if ( (Health < -80) || ((Health < -40) && (FRand() < 0.6)) )<br>&#9;&#9;return true;<br>&#9;return false;<br><br></div>
<h3 id="PlayerPawn.God"><a class="headerlink" href="#PlayerPawn.God" title="Permanent link">God</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( !bCheatsEnabled )<br>&#9;&#9;return;<br><br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br><br>&#9;if ( ReducedDamageType == 'All' )<br>&#9;{<br>&#9;&#9;ReducedDamageType = '';<br>&#9;&#9;ClientMessage("God mode off");<br>&#9;&#9;return;<br>&#9;}<br><br>&#9;ReducedDamageType = 'All'; <br>&#9;ClientMessage("God Mode on");<br><br></div>
<h3 id="PlayerPawn.Grab"><a class="headerlink" href="#PlayerPawn.Grab" title="Permanent link">Grab</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (CarriedDecoration == None)<br>&#9;&#9;GrabDecoration();<br>&#9;else<br>&#9;&#9;DropDecoration();<br><br></div>
<h3 id="PlayerPawn.HandleWalking"><a class="headerlink" href="#PlayerPawn.HandleWalking" title="Permanent link">HandleWalking</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local rotator carried;<br><br><br>&#9;// this is changed from Unreal -- default is now walk - DEUS_EX CNN<br>&#9;bIsWalking = ((bRun == 0) || (bDuck != 0)) && !Region.Zone.IsA('WarpZoneInfo'); <br><br>&#9;if ( CarriedDecoration != None )<br>&#9;{<br>&#9;&#9;if ( (Role == ROLE_Authority) && (standingcount == 0) ) <br>&#9;&#9;&#9;CarriedDecoration = None;<br>&#9;&#9;if ( CarriedDecoration != None ) //verify its still in front<br>&#9;&#9;{<br>&#9;&#9;&#9;bIsWalking = true;<br>&#9;&#9;&#9;if ( Role == ROLE_Authority )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;carried = Rotator(CarriedDecoration.Location - Location);<br>&#9;&#9;&#9;&#9;carried.Yaw = ((carried.Yaw & 65535) - (Rotation.Yaw & 65535)) & 65535;<br>&#9;&#9;&#9;&#9;if ( (carried.Yaw > 3072) && (carried.Yaw < 62463) )<br>&#9;&#9;&#9;&#9;&#9;DropDecoration();<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.InitPlayerReplicationInfo"><a class="headerlink" href="#PlayerPawn.InitPlayerReplicationInfo" title="Permanent link">InitPlayerReplicationInfo</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.InitPlayerReplicationInfo();<br><br>&#9;PlayerReplicationInfo.bAdmin = bAdmin;<br><br></div>
<h3 id="PlayerPawn.InvertMouse"><a class="headerlink" href="#PlayerPawn.InvertMouse" title="Permanent link">InvertMouse</a> (bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bInvertMouse = B;<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.Invisible"><a class="headerlink" href="#PlayerPawn.Invisible" title="Permanent link">Invisible</a> (bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( !bCheatsEnabled )<br>&#9;&#9;return;<br><br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br><br>&#9;if (B)<br>&#9;{<br>&#9;&#9;bHidden = true;<br>&#9;&#9;Visibility = 0;<br>&#9;&#9;// DEUS_EX STM - added AI invisibility<br>&#9;&#9;bDetectable = false;<br>&#9;&#9;// DEUS_EX CNN - added message<br>&#9;&#9;ClientMessage("Player is now invisible");<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;bHidden = false;<br>&#9;&#9;Visibility = Default.Visibility;<br>&#9;&#9;// DEUS_EX STM - added AI invisibility<br>&#9;&#9;bDetectable = true;<br>&#9;&#9;// DEUS_EX CNN - added message<br>&#9;&#9;ClientMessage("Player is now visible");<br>&#9;}&#9;<br><br></div>
<h3 id="PlayerPawn.Jump"><a class="headerlink" href="#PlayerPawn.Jump" title="Permanent link">Jump</a> (optional float F)</h3>

<h3 id="PlayerPawn.JumpOffPawn"><a class="headerlink" href="#PlayerPawn.JumpOffPawn" title="Permanent link">JumpOffPawn</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Velocity += 60 * VRand();<br>&#9;Velocity.Z = 120;<br>&#9;SetPhysics(PHYS_Falling);<br><br></div>
<h3 id="PlayerPawn.Kick"><a class="headerlink" href="#PlayerPawn.Kick" title="Permanent link">Kick</a> (string KickString)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn aPawn;<br><br>&#9;if( !bAdmin )<br>&#9;&#9;return;<br><br>&#9;for( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )<br>&#9;&#9;if<br>&#9;&#9;(&#9;aPawn.bIsPlayer<br>&#9;&#9;    &&  string(aPawn.PlayerReplicationInfo.PlayerID) ~= KickString<br>&#9;&#9;&#9;&&&#9;(PlayerPawn(aPawn)==None || NetConnection(PlayerPawn(aPawn).Player)!=None ) )<br>&#9;&#9;{<br>&#9;&#9;&#9;aPawn.Destroy();<br>&#9;&#9;&#9;return;<br>&#9;&#9;}<br><br></div>
<h3 id="PlayerPawn.KickBan"><a class="headerlink" href="#PlayerPawn.KickBan" title="Permanent link">KickBan</a> (string KickString)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn aPawn;<br>&#9;local string IP;<br>&#9;local int j;<br><br>&#9;if( !bAdmin )<br>&#9;&#9;return;<br>&#9;for( aPawn=Level.PawnList; aPawn!=None; aPawn=aPawn.NextPawn )<br>&#9;&#9;if<br>&#9;&#9;(&#9;aPawn.bIsPlayer<br>&#9;&#9;    &&  string(aPawn.PlayerReplicationInfo.PlayerID) ~= KickString<br>&#9;&#9;&#9;&&&#9;(PlayerPawn(aPawn)==None || NetConnection(PlayerPawn(aPawn).Player)!=None ) )<br>&#9;&#9;{<br>&#9;&#9;&#9;IP = PlayerPawn(aPawn).GetPlayerNetworkAddress();<br>&#9;&#9;&#9;if(Level.Game.CheckIPPolicy(IP))<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;IP = Left(IP, InStr(IP, ":"));<br>&#9;&#9;&#9;&#9;Log("Adding IP Ban for: "$IP);<br>&#9;&#9;&#9;&#9;for(j=0;j<50;j++)<br>&#9;&#9;&#9;&#9;&#9;if(Level.Game.IPPolicies[j] == "")<br>&#9;&#9;&#9;&#9;&#9;&#9;break;<br>&#9;&#9;&#9;&#9;if(j < 50)<br>&#9;&#9;&#9;&#9;&#9;Level.Game.IPPolicies[j] = "DENY,"$IP;<br>&#9;&#9;&#9;&#9;Level.Game.SaveConfig();<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;aPawn.Destroy();<br>&#9;&#9;&#9;return;<br>&#9;&#9;}<br><br></div>
<h3 id="PlayerPawn.KillAll"><a class="headerlink" href="#PlayerPawn.KillAll" title="Permanent link">KillAll</a> (class<actor> aClass)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Actor A;<br><br><br>&#9;if( !bCheatsEnabled )<br>&#9;&#9;return;<br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br>&#9;ForEach AllActors(class 'Actor', A)<br>&#9;&#9;if ( ClassIsChildOf(A.class, aClass) )<br>&#9;&#9;&#9;A.Destroy();<br><br></div>
<h3 id="PlayerPawn.KillMessage"><a class="headerlink" href="#PlayerPawn.KillMessage" title="Permanent link">KillMessage</a> (name damageType, pawn Other) -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return ( Level.Game.PlayerKillMessage(damageType, Other.PlayerReplicationInfo)$PlayerReplicationInfo.PlayerName );<br><br></div>
<h3 id="PlayerPawn.KillPawns"><a class="headerlink" href="#PlayerPawn.KillPawns" title="Permanent link">KillPawns</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br><br>&#9;<br>&#9;if( !bCheatsEnabled )<br>&#9;&#9;return;<br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br>&#9;ForEach AllActors(class 'Pawn', P)<br>&#9;&#9;if (PlayerPawn(P) == None)<br>&#9;&#9;&#9;P.Destroy();<br><br></div>
<h3 id="PlayerPawn.KilledBy"><a class="headerlink" href="#PlayerPawn.KilledBy" title="Permanent link">KilledBy</a> (pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Health = 0;<br>&#9;Died( EventInstigator, 'Suicided', Location );<br><br></div>
<h3 id="PlayerPawn.Landed"><a class="headerlink" href="#PlayerPawn.Landed" title="Permanent link">Landed</a> (vector HitNormal)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( !bUpdating )<br>&#9;&#9;{<br>&#9;&#9;&#9;//log(class$" Landed while swimming");<br>&#9;&#9;&#9;PlayLanded(Velocity.Z);<br>&#9;&#9;&#9;TakeFallingDamage();<br>&#9;&#9;&#9;bJustLanded = true;<br>&#9;&#9;}<br>&#9;&#9;if ( Region.Zone.bWaterZone )<br>&#9;&#9;&#9;SetPhysics(PHYS_Swimming);<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;GotoState('PlayerWalking');<br>&#9;&#9;&#9;AnimEnd();<br>&#9;&#9;}<br>&#9;<br></div>
<h3 id="PlayerPawn.LocalTravel"><a class="headerlink" href="#PlayerPawn.LocalTravel" title="Permanent link">LocalTravel</a> (string URL)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( bAdmin || Level.Netmode==NM_Standalone )<br>&#9;&#9;ClientTravel( URL, TRAVEL_Relative, true );<br><br></div>
<h3 id="PlayerPawn.MultiplayerTick"><a class="headerlink" href="#PlayerPawn.MultiplayerTick" title="Permanent link">MultiplayerTick</a> (float DeltaTime)</h3>

<h3 id="PlayerPawn.Mutate"><a class="headerlink" href="#PlayerPawn.Mutate" title="Permanent link">Mutate</a> (string MutateString)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( Level.NetMode == NM_Client )<br>&#9;&#9;return;<br>&#9;Level.Game.BaseMutator.Mutate(MutateString, Self);<br><br></div>
<h3 id="PlayerPawn.Name"><a class="headerlink" href="#PlayerPawn.Name" title="Permanent link">Name</a> (coerce string S)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;SetName(S);<br><br></div>
<h3 id="PlayerPawn.NeverSwitchOnPickup"><a class="headerlink" href="#PlayerPawn.NeverSwitchOnPickup" title="Permanent link">NeverSwitchOnPickup</a> (bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bNeverAutoSwitch = B;<br>&#9;bNeverSwitchOnPickup = B;<br>&#9;ServerNeverSwitchOnPickup(B);<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.NextWeapon"><a class="headerlink" href="#PlayerPawn.NextWeapon" title="Permanent link">NextWeapon</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int nextGroup;<br>&#9;local Inventory inv;<br>&#9;local Weapon realWeapon, w, Prev;<br>&#9;local bool bFoundWeapon;<br><br><br>&#9;if( bShowMenu || Level.Pauser!="" )<br>&#9;&#9;return;<br>&#9;if ( Weapon == None )<br>&#9;{<br>&#9;&#9;SwitchToBestWeapon();<br>&#9;&#9;return;<br>&#9;}<br>&#9;nextGroup = 100;<br>&#9;realWeapon = Weapon;<br>&#9;if ( PendingWeapon != None )<br>&#9;&#9;Weapon = PendingWeapon;<br>&#9;PendingWeapon = None;<br><br>&#9;for (inv=Inventory; inv!=None; inv=inv.Inventory)<br>&#9;{<br>&#9;&#9;w = Weapon(inv);<br>&#9;&#9;if ( w != None )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( w.InventoryGroup == Weapon.InventoryGroup )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( w == Weapon )<br>&#9;&#9;&#9;&#9;&#9;bFoundWeapon = true;<br>&#9;&#9;&#9;&#9;else if ( bFoundWeapon && ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;PendingWeapon = W;<br>&#9;&#9;&#9;&#9;&#9;break;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;else if ( (w.InventoryGroup > Weapon.InventoryGroup) <br>&#9;&#9;&#9;&#9;&#9;&& ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) <br>&#9;&#9;&#9;&#9;&#9;&& (w.InventoryGroup < nextGroup) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;nextGroup = w.InventoryGroup;<br>&#9;&#9;&#9;&#9;PendingWeapon = w;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;}<br><br>&#9;bFoundWeapon = false;<br>&#9;nextGroup = Weapon.InventoryGroup;<br>&#9;if ( PendingWeapon == None )<br>&#9;&#9;for (inv=Inventory; inv!=None; inv=inv.Inventory)<br>&#9;&#9;{<br>&#9;&#9;&#9;w = Weapon(Inv);<br>&#9;&#9;&#9;if ( w != None )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( w.InventoryGroup == Weapon.InventoryGroup )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;if ( w == Weapon )<br>&#9;&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;&#9;bFoundWeapon = true;<br>&#9;&#9;&#9;&#9;&#9;&#9;if ( Prev != None )<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;PendingWeapon = Prev;<br>&#9;&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;&#9;else if ( !bFoundWeapon && (PendingWeapon == None) && ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) )<br>&#9;&#9;&#9;&#9;&#9;&#9;Prev = W;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;else if ( (w.InventoryGroup < nextGroup) <br>&#9;&#9;&#9;&#9;&#9;&& ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) ) <br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;nextGroup = w.InventoryGroup;<br>&#9;&#9;&#9;&#9;&#9;PendingWeapon = w;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br><br>&#9;Weapon = realWeapon;<br>&#9;if ( PendingWeapon == None )<br>&#9;&#9;return;<br><br>&#9;Weapon.PutDown();<br><br></div>
<h3 id="PlayerPawn.PasteFromClipboard"><a class="headerlink" href="#PlayerPawn.PasteFromClipboard" title="Permanent link">PasteFromClipboard</a> -> string | native</h3>

<h3 id="PlayerPawn.Pause"><a class="headerlink" href="#PlayerPawn.Pause" title="Permanent link">Pause</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// Don't pause in multiplayer<br>&#9;if ( Level.NetMode == NM_Standalone )<br>&#9;{<br>&#9;&#9;if ( bShowMenu )<br>&#9;&#9;&#9;return;<br>&#9;&#9;if( !SetPause(Level.Pauser=="") )<br>&#9;&#9;&#9;ClientMessage(NoPauseMessage);<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.Ping"><a class="headerlink" href="#PlayerPawn.Ping" title="Permanent link">Ping</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ClientMessage("Current ping is"@PlayerReplicationInfo.Ping);<br><br></div>
<h3 id="PlayerPawn.PlayBeepSound"><a class="headerlink" href="#PlayerPawn.PlayBeepSound" title="Permanent link">PlayBeepSound</a></h3>

<h3 id="PlayerPawn.PlayChatting"><a class="headerlink" href="#PlayerPawn.PlayChatting" title="Permanent link">PlayChatting</a></h3>

<h3 id="PlayerPawn.PlayDodge"><a class="headerlink" href="#PlayerPawn.PlayDodge" title="Permanent link">PlayDodge</a> (eDodgeDir DodgeMove)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlayDuck();<br><br></div>
<h3 id="PlayerPawn.PlayDying"><a class="headerlink" href="#PlayerPawn.PlayDying" title="Permanent link">PlayDying</a> (name DamageType, vector HitLocation)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;BaseEyeHeight = Default.BaseEyeHeight;<br>&#9;<br></div>
<h3 id="PlayerPawn.PlayFeignDeath"><a class="headerlink" href="#PlayerPawn.PlayFeignDeath" title="Permanent link">PlayFeignDeath</a></h3>

<h3 id="PlayerPawn.PlayHit"><a class="headerlink" href="#PlayerPawn.PlayHit" title="Permanent link">PlayHit</a> (float Damage, vector HitLocation, name damageType, vector Momentum)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Level.Game.SpecialDamageString = "";<br><br></div>
<h3 id="PlayerPawn.PlayRising"><a class="headerlink" href="#PlayerPawn.PlayRising" title="Permanent link">PlayRising</a></h3>

<h3 id="PlayerPawn.PlaySwimming"><a class="headerlink" href="#PlayerPawn.PlaySwimming" title="Permanent link">PlaySwimming</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlayRunning();<br><br></div>
<h3 id="PlayerPawn.PlayTakeHit"><a class="headerlink" href="#PlayerPawn.PlayTakeHit" title="Permanent link">PlayTakeHit</a> (float tweentime, vector HitLoc, int Damage)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( IsAnimating() )<br>&#9;&#9;{<br>&#9;&#9;&#9;Enable('AnimEnd');<br>&#9;&#9;&#9;Global.PlayTakeHit(tweentime, HitLoc, Damage);<br>&#9;&#9;}<br>&#9;<br></div>
<h3 id="PlayerPawn.PlayTurning"><a class="headerlink" href="#PlayerPawn.PlayTurning" title="Permanent link">PlayTurning</a></h3>

<h3 id="PlayerPawn.PlayerCalcView"><a class="headerlink" href="#PlayerPawn.PlayerCalcView" title="Permanent link">PlayerCalcView</a> (out actor ViewActor, out vector CameraLocation, out rotator CameraRotation)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector View,HitLocation,HitNormal, FirstHit, spot;<br>&#9;local float DesiredDist, ViewDist, WallOutDist;<br>&#9;local actor HitActor;<br>&#9;local Pawn PTarget;<br><br><br>&#9;&#9;if ( ViewTarget != None )<br>&#9;&#9;{<br>&#9;&#9;&#9;ViewActor = ViewTarget;<br>&#9;&#9;&#9;CameraLocation = ViewTarget.Location;<br>&#9;&#9;&#9;CameraRotation = ViewTarget.Rotation;<br>&#9;&#9;&#9;PTarget = Pawn(ViewTarget);<br>&#9;&#9;&#9;if ( PTarget != None )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( Level.NetMode == NM_Client )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;if ( PTarget.bIsPlayer )<br>&#9;&#9;&#9;&#9;&#9;&#9;PTarget.ViewRotation = TargetViewRotation;<br>&#9;&#9;&#9;&#9;&#9;PTarget.EyeHeight = TargetEyeHeight;<br>&#9;&#9;&#9;&#9;&#9;if ( PTarget.Weapon != None )<br>&#9;&#9;&#9;&#9;&#9;&#9;PTarget.Weapon.PlayerViewOffset = TargetWeaponViewOffset;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;if ( PTarget.bIsPlayer )<br>&#9;&#9;&#9;&#9;&#9;CameraRotation = PTarget.ViewRotation;<br>&#9;&#9;&#9;&#9;CameraLocation.Z += PTarget.EyeHeight;<br>&#9;&#9;&#9;}<br><br>&#9;&#9;&#9;if ( Carcass(ViewTarget) != None )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( bBehindView || (ViewTarget.Physics == PHYS_None) )<br>&#9;&#9;&#9;&#9;&#9;CameraRotation = ViewRotation;<br>&#9;&#9;&#9;&#9;else <br>&#9;&#9;&#9;&#9;&#9;ViewRotation = CameraRotation;<br>&#9;&#9;&#9;&#9;if ( bBehindView )<br>&#9;&#9;&#9;&#9;&#9;CalcBehindView(CameraLocation, CameraRotation, 190);<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;else if ( bBehindView )<br>&#9;&#9;&#9;&#9;CalcBehindView(CameraLocation, CameraRotation, 180);<br><br>&#9;&#9;&#9;return;<br>&#9;&#9;}<br><br>&#9;&#9;// View rotation.<br>&#9;&#9;CameraRotation = ViewRotation;<br>&#9;&#9;DesiredFOV = DefaultFOV;&#9;&#9;<br>&#9;&#9;ViewActor = self;<br>&#9;&#9;if( bBehindView ) //up and behind (for death scene)<br>&#9;&#9;&#9;CalcBehindView(CameraLocation, CameraRotation, 180);<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;// First-person view.<br>&#9;&#9;&#9;CameraLocation = Location;<br>&#9;&#9;&#9;CameraLocation.Z += Default.BaseEyeHeight;<br>&#9;&#9;}<br>&#9;<br></div>
<h3 id="PlayerPawn.PlayerInput"><a class="headerlink" href="#PlayerPawn.PlayerInput" title="Permanent link">PlayerInput</a> (float DeltaTime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float SmoothTime, FOVScale, MouseScale, AbsSmoothX, AbsSmoothY, MouseTime;<br><br><br>&#9;if ( bShowMenu && (myHud != None) ) <br>&#9;{<br>&#9;&#9;if ( myHud.MainMenu != None )<br>&#9;&#9;&#9;myHud.MainMenu.MenuTick( DeltaTime );<br>&#9;&#9;// clear inputs<br>&#9;&#9;bEdgeForward = false;<br>&#9;&#9;bEdgeBack = false;<br>&#9;&#9;bEdgeLeft = false;<br>&#9;&#9;bEdgeRight = false;<br>&#9;&#9;bWasForward = false;<br>&#9;&#9;bWasBack = false;<br>&#9;&#9;bWasLeft = false;<br>&#9;&#9;bWasRight = false;<br>&#9;&#9;aStrafe = 0;<br>&#9;&#9;aTurn = 0;<br>&#9;&#9;aForward = 0;<br>&#9;&#9;aLookUp = 0;<br>&#9;&#9;return;<br>&#9;}<br>&#9;else if ( bDelayedCommand )<br>&#9;{<br>&#9;&#9;bDelayedCommand = false;<br>&#9;&#9;ConsoleCommand(DelayedCommand);<br>&#9;}<br>&#9;&#9;&#9;&#9;<br>&#9;// Check for Dodge move<br>&#9;// flag transitions<br>&#9;bEdgeForward = (bWasForward ^^ (aBaseY > 0));<br>&#9;bEdgeBack = (bWasBack ^^ (aBaseY < 0));<br>&#9;bEdgeLeft = (bWasLeft ^^ (aStrafe > 0));<br>&#9;bEdgeRight = (bWasRight ^^ (aStrafe < 0));<br>&#9;bWasForward = (aBaseY > 0);<br>&#9;bWasBack = (aBaseY < 0);<br>&#9;bWasLeft = (aStrafe > 0);<br>&#9;bWasRight = (aStrafe < 0);<br>&#9;<br>&#9;// Smooth and amplify mouse movement<br>&#9;SmoothTime = FMin(0.2, 3 * DeltaTime * Level.TimeDilation);<br>&#9;FOVScale = DesiredFOV * 0.01111; <br>&#9;MouseScale = MouseSensitivity * FOVScale;<br><br>&#9;aMouseX *= MouseScale;<br>&#9;aMouseY *= MouseScale;<br><br>//************************************************************************<br><br>&#9;//log("X "$aMouseX$" Smooth "$SmoothMouseX$" Borrowed "$BorrowedMouseX$" zero time "$(Level.TimeSeconds - MouseZeroTime)$" vs "$MouseSmoothThreshold);<br>&#9;AbsSmoothX = SmoothMouseX;<br>&#9;AbsSmoothY = SmoothMouseY;<br>&#9;MouseTime = (Level.TimeSeconds - MouseZeroTime)/Level.TimeDilation;<br>&#9;if ( bMaxMouseSmoothing && (aMouseX == 0) && (MouseTime < MouseSmoothThreshold) )<br>&#9;{<br>&#9;&#9;SmoothMouseX = 0.5 * (MouseSmoothThreshold - MouseTime) * AbsSmoothX/MouseSmoothThreshold;<br>&#9;&#9;BorrowedMouseX += SmoothMouseX;<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;if ( (SmoothMouseX == 0) || (aMouseX == 0) <br>&#9;&#9;&#9;&#9;|| ((SmoothMouseX > 0) != (aMouseX > 0)) )<br>&#9;&#9;{<br>&#9;&#9;&#9;SmoothMouseX = aMouseX;<br>&#9;&#9;&#9;BorrowedMouseX = 0;<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;SmoothMouseX = 0.5 * (SmoothMouseX + aMouseX - BorrowedMouseX);<br>&#9;&#9;&#9;if ( (SmoothMouseX > 0) != (aMouseX > 0) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( AMouseX > 0 )<br>&#9;&#9;&#9;&#9;&#9;SmoothMouseX = 1;<br>&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;&#9;SmoothMouseX = -1;<br>&#9;&#9;&#9;} <br>&#9;&#9;&#9;BorrowedMouseX = SmoothMouseX - aMouseX;<br>&#9;&#9;}<br>&#9;&#9;AbsSmoothX = SmoothMouseX;<br>&#9;}<br>&#9;if ( bMaxMouseSmoothing && (aMouseY == 0) && (MouseTime < MouseSmoothThreshold) )<br>&#9;{<br>&#9;&#9;SmoothMouseY = 0.5 * (MouseSmoothThreshold - MouseTime) * AbsSmoothY/MouseSmoothThreshold;<br>&#9;&#9;BorrowedMouseY += SmoothMouseY;<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;if ( (SmoothMouseY == 0) || (aMouseY == 0) <br>&#9;&#9;&#9;&#9;|| ((SmoothMouseY > 0) != (aMouseY > 0)) )<br>&#9;&#9;{<br>&#9;&#9;&#9;SmoothMouseY = aMouseY;<br>&#9;&#9;&#9;BorrowedMouseY = 0;<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;SmoothMouseY = 0.5 * (SmoothMouseY + aMouseY - BorrowedMouseY);<br>&#9;&#9;&#9;if ( (SmoothMouseY > 0) != (aMouseY > 0) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( AMouseY > 0 )<br>&#9;&#9;&#9;&#9;&#9;SmoothMouseY = 1;<br>&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;&#9;SmoothMouseY = -1;<br>&#9;&#9;&#9;} <br>&#9;&#9;&#9;BorrowedMouseY = SmoothMouseY - aMouseY;<br>&#9;&#9;}<br>&#9;&#9;AbsSmoothY = SmoothMouseY;<br>&#9;}<br>&#9;if ( (aMouseX != 0) || (aMouseY != 0) )<br>&#9;&#9;MouseZeroTime = Level.TimeSeconds;<br><br>&#9;// adjust keyboard and joystick movements<br>&#9;aLookUp *= FOVScale;<br>&#9;aTurn   *= FOVScale;<br><br>&#9;// Remap raw x-axis movement.<br>&#9;if( bStrafe!=0 )<br>&#9;{<br>&#9;&#9;// Strafe.<br>&#9;&#9;aStrafe += aBaseX + SmoothMouseX;<br>&#9;&#9;aBaseX   = 0;<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;// Forward.<br>&#9;&#9;aTurn  += aBaseX * FOVScale + SmoothMouseX;<br>&#9;&#9;if ( Level.NetMode != NM_Standalone )<br>&#9;&#9;&#9;aTurn *= TurnRateAdjuster;<br>&#9;&#9;aBaseX  = 0;<br>&#9;}<br><br>&#9;// Remap mouse y-axis movement.<br>&#9;if( (bStrafe == 0) && (bAlwaysMouseLook || (bLook!=0)) )<br>&#9;{<br>&#9;&#9;// Look up/down.<br>&#9;&#9;if ( bInvertMouse )<br>&#9;&#9;&#9;aLookUp -= SmoothMouseY;<br>&#9;&#9;else<br>&#9;&#9;&#9;aLookUp += SmoothMouseY;<br>&#9;&#9;if ( Level.NetMode != NM_Standalone )<br>&#9;&#9;&#9;aLookUp *= TurnRateAdjuster;<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;// Move forward/backward.<br>&#9;&#9;aForward += SmoothMouseY;<br>&#9;}<br>&#9;SmoothMouseX = AbsSmoothX;<br>&#9;SmoothMouseY = AbsSmoothY;<br><br>&#9;if ( bSnapLevel != 0 )<br>&#9;{<br>&#9;&#9;bCenterView = true;<br>&#9;&#9;bKeyboardLook = false;<br>&#9;}<br>&#9;else if (aLookUp != 0)<br>&#9;{<br>&#9;&#9;bCenterView = false;<br>&#9;&#9;bKeyboardLook = true;<br>&#9;}<br>&#9;else if ( bSnapToLevel && !bAlwaysMouseLook )<br>&#9;{<br>&#9;&#9;bCenterView = true;<br>&#9;&#9;bKeyboardLook = false;<br>&#9;}<br><br>&#9;// Remap other y-axis movement.<br>&#9;if ( bFreeLook != 0 )<br>&#9;{<br>&#9;&#9;bKeyboardLook = true;<br>&#9;&#9;aLookUp += 0.5 * aBaseY * FOVScale;<br>&#9;}<br>&#9;else<br>&#9;&#9;aForward += aBaseY;<br><br>&#9;aBaseY = 0;<br><br>&#9;// Handle walking.<br>&#9;HandleWalking();<br><br></div>
<h3 id="PlayerPawn.PlayerList"><a class="headerlink" href="#PlayerPawn.PlayerList" title="Permanent link">PlayerList</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local PlayerReplicationInfo PRI;<br><br><br>&#9;log("Player List:");<br>&#9;ForEach AllActors(class'PlayerReplicationInfo', PRI)<br>&#9;&#9;ClientMessage(PRI.PlayerName$"("$PRI.PlayerID$")");<br><br></div>
<h3 id="PlayerPawn.PlayerMove"><a class="headerlink" href="#PlayerPawn.PlayerMove" title="Permanent link">PlayerMove</a> (float DeltaTime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector X,Y,Z;<br><br>&#9;&#9;<br>&#9;&#9;GetAxes(ViewRotation,X,Y,Z);<br>&#9;&#9;// Update view rotation.<br><br>&#9;&#9;if ( !bFixedCamera )<br>&#9;&#9;{<br>&#9;&#9;&#9;aLookup  *= 0.24;<br>&#9;&#9;&#9;aTurn    *= 0.24;<br>&#9;&#9;&#9;ViewRotation.Yaw += 32.0 * DeltaTime * aTurn;<br>&#9;&#9;&#9;ViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;<br>&#9;&#9;&#9;ViewRotation.Pitch = ViewRotation.Pitch & 65535;<br>&#9;&#9;&#9;If ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;If (aLookUp > 0) <br>&#9;&#9;&#9;&#9;&#9;ViewRotation.Pitch = 18000;<br>&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;&#9;ViewRotation.Pitch = 49152;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;&#9;else if ( ViewTarget != None )<br>&#9;&#9;&#9;ViewRotation = ViewTarget.Rotation;<br><br>&#9;&#9;ViewShake(DeltaTime);<br>&#9;&#9;ViewFlash(DeltaTime);<br><br>&#9;&#9;if ( Role < ROLE_Authority ) // then save this move and replicate it<br>&#9;&#9;&#9;ReplicateMove(DeltaTime, vect(0,0,0), DODGE_None, rot(0,0,0));<br>&#9;&#9;else<br>&#9;&#9;&#9;ProcessMove(DeltaTime, vect(0,0,0), DODGE_None, rot(0,0,0));<br>&#9;&#9;bPressedJump = false;<br>&#9;<br></div>
<h3 id="PlayerPawn.PlayerTick"><a class="headerlink" href="#PlayerPawn.PlayerTick" title="Permanent link">PlayerTick</a> (float DeltaTime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( bUpdatePosition )<br>&#9;&#9;&#9;ClientUpdatePosition();<br><br>&#9;&#9;PlayerMove(DeltaTime);<br>&#9;<br></div>
<h3 id="PlayerPawn.PlayerTimeOut"><a class="headerlink" href="#PlayerPawn.PlayerTimeOut" title="Permanent link">PlayerTimeOut</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Health > 0)<br>&#9;&#9;Died(None, 'Suicided', Location);<br><br></div>
<h3 id="PlayerPawn.PlayersOnly"><a class="headerlink" href="#PlayerPawn.PlayersOnly" title="Permanent link">PlayersOnly</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// DEUS_EX CNN - This needs to be here!<br>&#9;if (!bCheatsEnabled)<br>&#9;&#9;return;<br><br>&#9;if ( Level.Netmode != NM_Standalone )<br>&#9;&#9;return;<br><br>&#9;Level.bPlayersOnly = !Level.bPlayersOnly;<br><br></div>
<h3 id="PlayerPawn.Possess"><a class="headerlink" href="#PlayerPawn.Possess" title="Permanent link">Possess</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Level.Netmode == NM_Client )<br>&#9;{<br>&#9;&#9;// replicate client weapon preferences to server<br>&#9;&#9;ServerNeverSwitchOnPickup(bNeverAutoSwitch);<br>&#9;&#9;ServerSetHandedness(Handedness);<br>&#9;&#9;UpdateWeaponPriorities();<br>&#9;}<br>&#9;ServerUpdateWeapons();<br>&#9;bIsPlayer = true;<br>&#9;DodgeClickTime = FMin(0.3, DodgeClickTime);<br>&#9;EyeHeight = BaseEyeHeight;<br>&#9;NetPriority = 3;<br>&#9;StartWalk();<br><br></div>
<h3 id="PlayerPawn.PostBeginPlay"><a class="headerlink" href="#PlayerPawn.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.PostBeginPlay();<br>&#9;if (Level.LevelEnterText != "" )<br>&#9;&#9;ClientMessage(Level.LevelEnterText);<br>&#9;if ( Level.NetMode != NM_Client )<br>&#9;{<br>&#9;&#9;HUDType = Level.Game.HUDType;<br>&#9;&#9;ScoringType = Level.Game.ScoreboardType;<br>&#9;&#9;MyAutoAim = FMax(MyAutoAim, Level.Game.AutoAim);<br>&#9;}<br>&#9;bIsPlayer = true;<br>&#9;DodgeClickTime = FMin(0.3, DodgeClickTime);<br>&#9;DesiredFOV = DefaultFOV;<br>&#9;EyeHeight = BaseEyeHeight;<br>&#9;if ( Level.Game.IsA('SinglePlayer') && (Level.NetMode == NM_Standalone) )<br>&#9;&#9;FlashScale = vect(0,0,0);<br><br></div>
<h3 id="PlayerPawn.PostRender"><a class="headerlink" href="#PlayerPawn.PostRender" title="Permanent link">PostRender</a> (canvas Canvas)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( myHud != None )&#9;<br>&#9;&#9;myHUD.PostRender(Canvas);<br>&#9;else if ( (Viewport(Player) != None) && (HUDType != None) )<br>&#9;&#9;myHUD = spawn(HUDType, self);<br><br></div>
<h3 id="PlayerPawn.PostRenderFlash"><a class="headerlink" href="#PlayerPawn.PostRenderFlash" title="Permanent link">PostRenderFlash</a> (canvas Canvas)</h3>

<h3 id="PlayerPawn.PreBeginPlay"><a class="headerlink" href="#PlayerPawn.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bIsPlayer = true;<br>&#9;Super.PreBeginPlay();<br><br></div>
<h3 id="PlayerPawn.PreClientTravel"><a class="headerlink" href="#PlayerPawn.PreClientTravel" title="Permanent link">PreClientTravel</a></h3>

<h3 id="PlayerPawn.PreRender"><a class="headerlink" href="#PlayerPawn.PreRender" title="Permanent link">PreRender</a> (canvas Canvas)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( myHud != None )&#9;<br>&#9;&#9;myHUD.PreRender(Canvas);<br>&#9;else if ( (Viewport(Player) != None) && (HUDType != None) )<br>&#9;&#9;myHUD = spawn(HUDType, self);<br><br></div>
<h3 id="PlayerPawn.PrevItem"><a class="headerlink" href="#PlayerPawn.PrevItem" title="Permanent link">PrevItem</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Inventory Inv, LastItem;<br><br><br>&#9;// DEUS_EX CNN - this function is EVIL!<br>&#9;return;<br><br>&#9;if ( bShowMenu || Level.Pauser!="" )<br>&#9;&#9;return;<br>&#9;if (SelectedItem==None) {<br>&#9;&#9;SelectedItem = Inventory.SelectNext();<br>&#9;&#9;Return;<br>&#9;<br></div>
<h3 id="PlayerPawn.PrevWeapon"><a class="headerlink" href="#PlayerPawn.PrevWeapon" title="Permanent link">PrevWeapon</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int prevGroup;<br>&#9;local Inventory inv;<br>&#9;local Weapon realWeapon, w, Prev;<br>&#9;local bool bFoundWeapon;<br><br><br>&#9;if( bShowMenu || Level.Pauser!="" )<br>&#9;&#9;return;<br>&#9;if ( Weapon == None )<br>&#9;{<br>&#9;&#9;SwitchToBestWeapon();<br>&#9;&#9;return;<br>&#9;}<br>&#9;prevGroup = 0;<br>&#9;realWeapon = Weapon;<br>&#9;if ( PendingWeapon != None )<br>&#9;&#9;Weapon = PendingWeapon;<br>&#9;PendingWeapon = None;<br>&#9;<br>&#9;for (inv=Inventory; inv!=None; inv=inv.Inventory)<br>&#9;{<br>&#9;&#9;w = Weapon(inv);<br>&#9;&#9;if ( w != None )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( w.InventoryGroup == Weapon.InventoryGroup )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( w == Weapon )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;bFoundWeapon = true;<br>&#9;&#9;&#9;&#9;&#9;if ( Prev != None )<br>&#9;&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;&#9;PendingWeapon = Prev;<br>&#9;&#9;&#9;&#9;&#9;&#9;break;<br>&#9;&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;else if ( !bFoundWeapon && ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) )<br>&#9;&#9;&#9;&#9;&#9;Prev = W;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;else if ( (w.InventoryGroup < Weapon.InventoryGroup) <br>&#9;&#9;&#9;&#9;&#9;&& ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) <br>&#9;&#9;&#9;&#9;&#9;&& (w.InventoryGroup >= prevGroup) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;prevGroup = w.InventoryGroup;<br>&#9;&#9;&#9;&#9;PendingWeapon = w;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;}<br>&#9;bFoundWeapon = false;<br>&#9;prevGroup = Weapon.InventoryGroup;<br>&#9;if ( PendingWeapon == None )<br>&#9;&#9;for (inv=Inventory; inv!=None; inv=inv.Inventory)<br>&#9;&#9;{<br>&#9;&#9;&#9;w = Weapon(inv);<br>&#9;&#9;&#9;if ( w != None )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( w.InventoryGroup == Weapon.InventoryGroup )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;if ( w == Weapon )<br>&#9;&#9;&#9;&#9;&#9;&#9;bFoundWeapon = true;<br>&#9;&#9;&#9;&#9;&#9;else if ( bFoundWeapon && (PendingWeapon == None) && ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) )<br>&#9;&#9;&#9;&#9;&#9;&#9;PendingWeapon = W;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;else if ( (w.InventoryGroup > PrevGroup) <br>&#9;&#9;&#9;&#9;&#9;&#9;&& ((w.AmmoType == None) || (w.AmmoType.AmmoAmount>0)) ) <br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;prevGroup = w.InventoryGroup;<br>&#9;&#9;&#9;&#9;&#9;PendingWeapon = w;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br><br>&#9;Weapon = realWeapon;<br>&#9;if ( PendingWeapon == None )<br>&#9;&#9;return;<br><br>&#9;Weapon.PutDown();<br><br></div>
<h3 id="PlayerPawn.ProcessMove"><a class="headerlink" href="#PlayerPawn.ProcessMove" title="Permanent link">ProcessMove</a> (float DeltaTime, vector NewAccel, eDodgeDir DodgeMove, rotator DeltaRot)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;Acceleration = NewAccel;<br>&#9;&#9;MoveSmooth(Acceleration * DeltaTime);<br>&#9;<br></div>
<h3 id="PlayerPawn.Profile"><a class="headerlink" href="#PlayerPawn.Profile" title="Permanent link">Profile</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;//TEMP for performance measurement<br><br>&#9;log("Average AI Time"@Level.AvgAITime);<br>&#9;log(" < 5% "$Level.AIProfile[0]);<br>&#9;log(" < 10% "$Level.AIProfile[1]);<br>&#9;log(" < 15% "$Level.AIProfile[2]);<br>&#9;log(" < 20% "$Level.AIProfile[3]);<br>&#9;log(" < 25% "$Level.AIProfile[4]);<br>&#9;log(" < 30% "$Level.AIProfile[5]);<br>&#9;log(" < 35% "$Level.AIProfile[6]);<br>&#9;log(" > 35% "$Level.AIProfile[7]);<br><br></div>
<h3 id="PlayerPawn.QuickLoad"><a class="headerlink" href="#PlayerPawn.QuickLoad" title="Permanent link">QuickLoad</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( (Level.NetMode == NM_Standalone)<br>&#9;&#9;&& !Level.Game.bDeathMatch )<br>&#9;&#9;ClientTravel( "?load=9", TRAVEL_Absolute, false);<br><br></div>
<h3 id="PlayerPawn.QuickSave"><a class="headerlink" href="#PlayerPawn.QuickSave" title="Permanent link">QuickSave</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( (Health > 0) <br>&#9;&#9;&& (Level.NetMode == NM_Standalone)<br>&#9;&#9;&& !Level.Game.bDeathMatch )<br>&#9;{<br>&#9;&#9;ClientMessage(QuickSaveString);<br>&#9;&#9;ConsoleCommand("SaveGame 9");<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.ReceiveLocalizedMessage"><a class="headerlink" href="#PlayerPawn.ReceiveLocalizedMessage" title="Permanent link">ReceiveLocalizedMessage</a> (class<LocalMessage> Message, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Message.Static.ClientReceive( Self, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject );<br><br></div>
<h3 id="PlayerPawn.RememberSpot"><a class="headerlink" href="#PlayerPawn.RememberSpot" title="Permanent link">RememberSpot</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;//remember spot<br>&#9;Destination = Location;<br><br></div>
<h3 id="PlayerPawn.RenderOverlays"><a class="headerlink" href="#PlayerPawn.RenderOverlays" title="Permanent link">RenderOverlays</a> (canvas Canvas)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Weapon != None )<br>&#9;&#9;Weapon.RenderOverlays(Canvas);<br><br>&#9;if ( myHUD != None )<br>&#9;&#9;myHUD.RenderOverlays(Canvas);<br><br></div>
<h3 id="PlayerPawn.ResetKeyboard"><a class="headerlink" href="#PlayerPawn.ResetKeyboard" title="Permanent link">ResetKeyboard</a> | native</h3>

<h3 id="PlayerPawn.RestartLevel"><a class="headerlink" href="#PlayerPawn.RestartLevel" title="Permanent link">RestartLevel</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( bAdmin || Level.Netmode==NM_Standalone )<br>&#9;&#9;ClientTravel( "?restart", TRAVEL_Relative, false );<br><br></div>
<h3 id="PlayerPawn.Rise"><a class="headerlink" href="#PlayerPawn.Rise" title="Permanent link">Rise</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( !bRising )<br>&#9;&#9;{<br>&#9;&#9;&#9;Enable('AnimEnd');<br>&#9;&#9;&#9;BaseEyeHeight = Default.BaseEyeHeight;<br>&#9;&#9;&#9;bRising = true;<br>&#9;&#9;&#9;PlayRising();<br>&#9;&#9;}<br>&#9;<br></div>
<h3 id="PlayerPawn.SShot"><a class="headerlink" href="#PlayerPawn.SShot" title="Permanent link">SShot</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float b;<br><br>&#9;b = float(ConsoleCommand("get ini:Engine.Engine.ViewportManager Brightness"));<br>&#9;ConsoleCommand("set ini:Engine.Engine.ViewportManager Brightness 1");<br>&#9;ConsoleCommand("flush");<br>&#9;ConsoleCommand("shot");<br>&#9;ConsoleCommand("set ini:Engine.Engine.ViewportManager Brightness "$string(B));<br>&#9;ConsoleCommand("flush");<br><br></div>
<h3 id="PlayerPawn.Say"><a class="headerlink" href="#PlayerPawn.Say" title="Permanent link">Say</a> (string Msg)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br>&#9;local String str;<br><br><br>&#9;str = PlayerReplicationInfo.PlayerName $ ": " $ Msg;<br><br>&#9;if ( Role == ROLE_Authority )<br>&#9;&#9;log( "Say>" $ str );<br><br>&#9;for( P = Level.PawnList; P != None; P = P.nextPawn )<br>&#9;{<br>&#9;&#9;if( P.bIsPlayer )<br>&#9;&#9;&#9;P.ClientMessage( str, 'Say', true );<br>&#9;}<br><br>&#9;return;<br><br></div>
<h3 id="PlayerPawn.SendVoiceMessage"><a class="headerlink" href="#PlayerPawn.SendVoiceMessage" title="Permanent link">SendVoiceMessage</a> (PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageID, name broadcasttype)</h3>

<h3 id="PlayerPawn.ServerAddBots"><a class="headerlink" href="#PlayerPawn.ServerAddBots" title="Permanent link">ServerAddBots</a> (int N)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br><br><br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br><br>&#9;if ( !Level.Game.bDeathMatch )<br>&#9;&#9;return;<br><br>&#9;for ( i=0; i<N; i++ )<br>&#9;&#9;Level.Game.ForceAddBot();<br><br></div>
<h3 id="PlayerPawn.ServerChangeSkin"><a class="headerlink" href="#PlayerPawn.ServerChangeSkin" title="Permanent link">ServerChangeSkin</a> (coerce string SkinName, coerce string FaceName, byte TeamNum)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string MeshName;<br><br><br>&#9;MeshName = GetItemName(string(Mesh));<br>&#9;if ( Level.Game.bCanChangeSkin )<br>&#9;{<br>&#9;&#9;Self.static.SetMultiSkin(Self, SkinName, FaceName, TeamNum );<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.ServerFeignDeath"><a class="headerlink" href="#PlayerPawn.ServerFeignDeath" title="Permanent link">ServerFeignDeath</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Weapon W;<br><br><br>&#9;W = Weapon;<br>&#9;PendingWeapon = None;<br>&#9;if ( Weapon != None )<br>&#9;&#9;Weapon.PutDown();<br>&#9;PendingWeapon = W;<br>&#9;GotoState('FeigningDeath');<br><br></div>
<h3 id="PlayerPawn.ServerNeverSwitchOnPickup"><a class="headerlink" href="#PlayerPawn.ServerNeverSwitchOnPickup" title="Permanent link">ServerNeverSwitchOnPickup</a> (bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bNeverSwitchOnPickup = B;<br><br></div>
<h3 id="PlayerPawn.ServerReStartGame"><a class="headerlink" href="#PlayerPawn.ServerReStartGame" title="Permanent link">ServerReStartGame</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Level.Game.RestartGame();<br><br></div>
<h3 id="PlayerPawn.ServerReStartPlayer"><a class="headerlink" href="#PlayerPawn.ServerReStartPlayer" title="Permanent link">ServerReStartPlayer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;//log("calling restartplayer in dying with netmode "$Level.NetMode);<br>&#9;&#9;if ( Level.NetMode == NM_Client )<br>&#9;&#9;&#9;return;<br>&#9;&#9;if( Level.Game.RestartPlayer(self) )<br>&#9;&#9;{<br>&#9;&#9;&#9;ServerTimeStamp = 0;<br>&#9;&#9;&#9;TimeMargin = 0;<br>&#9;&#9;&#9;Enemy = None;<br>&#9;&#9;&#9;Level.Game.StartPlayer(self);<br>&#9;&#9;&#9;if ( Mesh != None )<br>&#9;&#9;&#9;&#9;PlayWaiting();<br>&#9;&#9;&#9;ClientReStart();<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;&#9;log("Restartplayer failed");<br>&#9;<br></div>
<h3 id="PlayerPawn.ServerSetHandedness"><a class="headerlink" href="#PlayerPawn.ServerSetHandedness" title="Permanent link">ServerSetHandedness</a> (float hand)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Handedness = hand;<br>&#9;if ( Weapon != None )<br>&#9;{<br>&#9;&#9;Weapon.SetHand(Handedness);<br>&#9;&#9;if (( Level.NetMode != NM_Standalone ) && ( Role == ROLE_Authority ))<br>&#9;&#9;&#9;Weapon.ClientSetHandedness(Handedness);<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.ServerSetSloMo"><a class="headerlink" href="#PlayerPawn.ServerSetSloMo" title="Permanent link">ServerSetSloMo</a> (float T)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( bAdmin || (Level.Netmode == NM_Standalone) )<br>&#9;{<br>&#9;&#9;Level.Game.SetGameSpeed(T);<br>&#9;&#9;Level.Game.SaveConfig(); <br>&#9;&#9;Level.Game.GameReplicationInfo.SaveConfig();<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.ServerSetWeaponPriority"><a class="headerlink" href="#PlayerPawn.ServerSetWeaponPriority" title="Permanent link">ServerSetWeaponPriority</a> (byte i, name WeaponName)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local inventory inv;<br><br><br>&#9;WeaponPriority[i] = WeaponName;<br><br>&#9;for ( inv=Inventory; inv!=None; inv=inv.inventory )<br>&#9;&#9;if ( inv.class.name == WeaponName )<br>&#9;&#9;&#9;Weapon(inv).SetSwitchPriority(self);<br><br></div>
<h3 id="PlayerPawn.ServerTaunt"><a class="headerlink" href="#PlayerPawn.ServerTaunt" title="Permanent link">ServerTaunt</a> (name Sequence)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlayAnim(Sequence, 0.7, 0.2);<br><br></div>
<h3 id="PlayerPawn.ServerUpdateWeapons"><a class="headerlink" href="#PlayerPawn.ServerUpdateWeapons" title="Permanent link">ServerUpdateWeapons</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local inventory Inv;<br><br><br>&#9;For ( Inv=Inventory; Inv!=None; Inv=Inv.Inventory )<br>&#9;&#9;if ( Inv.IsA('Weapon') )<br>&#9;&#9;&#9;Weapon(Inv).SetSwitchPriority(self); <br><br></div>
<h3 id="PlayerPawn.SetAutoAim"><a class="headerlink" href="#PlayerPawn.SetAutoAim" title="Permanent link">SetAutoAim</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ChangeAutoAim(F);<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.SetBob"><a class="headerlink" href="#PlayerPawn.SetBob" title="Permanent link">SetBob</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;UpdateBob(F);<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.SetDesiredFOV"><a class="headerlink" href="#PlayerPawn.SetDesiredFOV" title="Permanent link">SetDesiredFOV</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( (F >= 80.0) || Level.bAllowFOV || bAdmin || (Level.Netmode==NM_Standalone) )<br>&#9;{<br>&#9;&#9;DefaultFOV = FClamp(F, 1, 170);<br>&#9;&#9;DesiredFOV = DefaultFOV;<br>&#9;&#9;SaveConfig();<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.SetDodgeClickTime"><a class="headerlink" href="#PlayerPawn.SetDodgeClickTime" title="Permanent link">SetDodgeClickTime</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ChangeDodgeClickTime(F);<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.SetFOVAngle"><a class="headerlink" href="#PlayerPawn.SetFOVAngle" title="Permanent link">SetFOVAngle</a> (float newFOV)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;FOVAngle = newFOV;<br><br></div>
<h3 id="PlayerPawn.SetFriction"><a class="headerlink" href="#PlayerPawn.SetFriction" title="Permanent link">SetFriction</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local ZoneInfo Z;<br><br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br>&#9;ForEach AllActors(class'ZoneInfo', Z)<br>&#9;&#9;Z.ZoneGroundFriction = F;<br><br></div>
<h3 id="PlayerPawn.SetHand"><a class="headerlink" href="#PlayerPawn.SetHand" title="Permanent link">SetHand</a> (string S)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ChangeSetHand(S);<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.SetJumpZ"><a class="headerlink" href="#PlayerPawn.SetJumpZ" title="Permanent link">SetJumpZ</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( !bCheatsEnabled )<br>&#9;&#9;return;<br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br>&#9;JumpZ = F;<br><br></div>
<h3 id="PlayerPawn.SetMaxMouseSmoothing"><a class="headerlink" href="#PlayerPawn.SetMaxMouseSmoothing" title="Permanent link">SetMaxMouseSmoothing</a> (bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bMaxMouseSmoothing = B;<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.SetMouseSmoothThreshold"><a class="headerlink" href="#PlayerPawn.SetMouseSmoothThreshold" title="Permanent link">SetMouseSmoothThreshold</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;MouseSmoothThreshold = FClamp(F, 0, 0.1);<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.SetName"><a class="headerlink" href="#PlayerPawn.SetName" title="Permanent link">SetName</a> (coerce string S)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ChangeName(S);<br>&#9;UpdateURL("Name", S, true);<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.SetPause"><a class="headerlink" href="#PlayerPawn.SetPause" title="Permanent link">SetPause</a> (BOOL bPause) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return Level.Game.SetPause(bPause, self);<br><br></div>
<h3 id="PlayerPawn.SetProgressColor"><a class="headerlink" href="#PlayerPawn.SetProgressColor" title="Permanent link">SetProgressColor</a> (color C, int Index)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Index < 8)<br>&#9;&#9;ProgressColor[Index] = C;<br><br></div>
<h3 id="PlayerPawn.SetProgressMessage"><a class="headerlink" href="#PlayerPawn.SetProgressMessage" title="Permanent link">SetProgressMessage</a> (string S, int Index)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Index < 8)<br>&#9;&#9;ProgressMessage[Index] = S;<br><br></div>
<h3 id="PlayerPawn.SetProgressTime"><a class="headerlink" href="#PlayerPawn.SetProgressTime" title="Permanent link">SetProgressTime</a> (float T)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ProgressTimeOut = T + Level.TimeSeconds;<br><br></div>
<h3 id="PlayerPawn.SetSensitivity"><a class="headerlink" href="#PlayerPawn.SetSensitivity" title="Permanent link">SetSensitivity</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;UpdateSensitivity(F);<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.SetSpeed"><a class="headerlink" href="#PlayerPawn.SetSpeed" title="Permanent link">SetSpeed</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( !bCheatsEnabled )<br>&#9;&#9;return;<br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br>&#9;GroundSpeed = Default.GroundSpeed * f;<br>&#9;WaterSpeed = Default.WaterSpeed * f;<br><br></div>
<h3 id="PlayerPawn.SetViewFlash"><a class="headerlink" href="#PlayerPawn.SetViewFlash" title="Permanent link">SetViewFlash</a> (bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bNoFlash = !B;<br><br></div>
<h3 id="PlayerPawn.SetWeaponStay"><a class="headerlink" href="#PlayerPawn.SetWeaponStay" title="Permanent link">SetWeaponStay</a> (bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Weapon W;<br><br><br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br><br>&#9;Level.Game.bCoopWeaponMode = B;<br>&#9;ForEach AllActors(class'Weapon', W)<br>&#9;{<br>&#9;&#9;W.bWeaponStay = false;<br>&#9;&#9;W.SetWeaponStay();<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.ShakeView"><a class="headerlink" href="#PlayerPawn.ShakeView" title="Permanent link">ShakeView</a> (float shaketime, float RollMag, float vertmag)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector shake;<br><br><br>&#9;shake.X = RollMag;<br>&#9;shake.Y = 100 * shaketime;<br>&#9;shake.Z = 100 * vertmag;<br>&#9;ClientShake(shake);<br><br></div>
<h3 id="PlayerPawn.ShowInventory"><a class="headerlink" href="#PlayerPawn.ShowInventory" title="Permanent link">ShowInventory</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Inventory Inv;<br><br>&#9;<br>&#9;if( Weapon!=None )<br>&#9;&#9;log( "   Weapon: " $ Weapon.Class );<br>&#9;for( Inv=Inventory; Inv!=None; Inv=Inv.Inventory ) <br>&#9;&#9;log( "Inv: "$Inv $ " state "$Inv.GetStateName());<br>&#9;if ( SelectedItem != None )<br>&#9;&#9;log( "Selected Item"@SelectedItem@"Charge"@SelectedItem.Charge );<br><br></div>
<h3 id="PlayerPawn.ShowLoadMenu"><a class="headerlink" href="#PlayerPawn.ShowLoadMenu" title="Permanent link">ShowLoadMenu</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ShowMenu();<br><br></div>
<h3 id="PlayerPawn.ShowMenu"><a class="headerlink" href="#PlayerPawn.ShowMenu" title="Permanent link">ShowMenu</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;WalkBob = vect(0,0,0);<br>&#9;bShowMenu = true; // menu is responsible for turning this off<br>&#9;Player.Console.GotoState('Menuing');<br>&#9;&#9;<br>&#9;if( Level.Netmode == NM_Standalone )<br>&#9;&#9;SetPause(true);<br><br></div>
<h3 id="PlayerPawn.ShowPath"><a class="headerlink" href="#PlayerPawn.ShowPath" title="Permanent link">ShowPath</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Actor node;<br><br>&#9;//find next path to remembered spot<br>&#9;node = FindPathTo(Destination);<br>&#9;if (node != None)<br>&#9;{<br>&#9;&#9;log("found path");<br>&#9;&#9;Spawn(class 'WayBeacon', self, '', node.location);<br>&#9;}<br>&#9;else<br>&#9;&#9;log("didn't find path");<br><br></div>
<h3 id="PlayerPawn.ShowProgress"><a class="headerlink" href="#PlayerPawn.ShowProgress" title="Permanent link">ShowProgress</a></h3>

<h3 id="PlayerPawn.ShowSpecialMenu"><a class="headerlink" href="#PlayerPawn.ShowSpecialMenu" title="Permanent link">ShowSpecialMenu</a> (string ClassName)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local class<menu> aMenuClass;<br><br><br>&#9;aMenuClass = class<menu>( DynamicLoadObject( ClassName, class'Class' ) );<br>&#9;if( aMenuClass!=None )<br>&#9;{<br>&#9;&#9;bSpecialMenu = true;<br>&#9;&#9;SpecialMenu = aMenuClass;<br>&#9;&#9;ShowMenu();<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.ShowUpgradeMenu"><a class="headerlink" href="#PlayerPawn.ShowUpgradeMenu" title="Permanent link">ShowUpgradeMenu</a></h3>

<h3 id="PlayerPawn.SloMo"><a class="headerlink" href="#PlayerPawn.SloMo" title="Permanent link">SloMo</a> (float T)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// DEUS_EX CNN - This needs to be here!<br>&#9;if (!bCheatsEnabled)<br>&#9;&#9;return;<br><br>&#9;ServerSetSloMo(T);<br><br></div>
<h3 id="PlayerPawn.SnapView"><a class="headerlink" href="#PlayerPawn.SnapView" title="Permanent link">SnapView</a> (bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ChangeSnapView(B);<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.SpawnCarcass"><a class="headerlink" href="#PlayerPawn.SpawnCarcass" title="Permanent link">SpawnCarcass</a> -> Carcass</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local carcass carc;<br><br><br>&#9;carc = Spawn(CarcassType);<br>&#9;if ( carc == None )<br>&#9;&#9;return None;<br>&#9;carc.Initfor(self);<br>&#9;if (Player != None)<br>&#9;&#9;carc.bPlayerCarcass = true;<br>&#9;if ( !Level.Game.bGameEnded && (Carcass(ViewTarget) == None) )<br>&#9;&#9;ViewTarget = carc; //for Player 3rd person views<br>&#9;return carc;<br><br></div>
<h3 id="PlayerPawn.SpawnGibbedCarcass"><a class="headerlink" href="#PlayerPawn.SpawnGibbedCarcass" title="Permanent link">SpawnGibbedCarcass</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local carcass carc;<br><br><br>&#9;carc = Spawn(CarcassType);<br>&#9;if ( carc != None )<br>&#9;{<br>&#9;&#9;carc.Initfor(self);<br>&#9;&#9;carc.ChunkUp(-1 * Health);<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.Speech"><a class="headerlink" href="#PlayerPawn.Speech" title="Permanent link">Speech</a> (int Type, int Index, int Callsign)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local VoicePack V;<br><br><br>&#9;V = Spawn( PlayerReplicationInfo.VoiceType, Self );<br>&#9;if (V != None)<br>&#9;&#9;V.PlayerSpeech( Type, Index, Callsign );<br><br></div>
<h3 id="PlayerPawn.StairLook"><a class="headerlink" href="#PlayerPawn.StairLook" title="Permanent link">StairLook</a> (bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ChangeStairLook(B);<br>&#9;SaveConfig();<br><br></div>
<h3 id="PlayerPawn.StartWalk"><a class="headerlink" href="#PlayerPawn.StartWalk" title="Permanent link">StartWalk</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;UnderWaterTime = Default.UnderWaterTime;&#9;<br>&#9;SetCollision(true, true , true);<br>&#9;SetPhysics(PHYS_Walking);<br>&#9;bCollideWorld = true;<br>&#9;ClientReStart();&#9;<br><br></div>
<h3 id="PlayerPawn.StartZoom"><a class="headerlink" href="#PlayerPawn.StartZoom" title="Permanent link">StartZoom</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ZoomLevel = 0.0;<br>&#9;bZooming = true;<br><br></div>
<h3 id="PlayerPawn.StopZoom"><a class="headerlink" href="#PlayerPawn.StopZoom" title="Permanent link">StopZoom</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bZooming = false;<br><br></div>
<h3 id="PlayerPawn.Suicide"><a class="headerlink" href="#PlayerPawn.Suicide" title="Permanent link">Suicide</a></h3>

<h3 id="PlayerPawn.Summon"><a class="headerlink" href="#PlayerPawn.Summon" title="Permanent link">Summon</a> (string ClassName)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local class<actor> NewClass;<br><br>&#9;if( !bCheatsEnabled )<br>&#9;&#9;return;<br>&#9;if( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br>&#9;log( "Fabricate " $ ClassName );<br>&#9;NewClass = class<actor>( DynamicLoadObject( ClassName, class'Class' ) );<br>&#9;if( NewClass!=None )<br>&#9;&#9;// DEUS_EX STM<br>&#9;&#9;//Spawn( NewClass,,,Location + 72 * Vector(Rotation) + vect(0,0,1) * 15 );<br>&#9;&#9;Spawn( NewClass,,,Location + (CollisionRadius+NewClass.Default.CollisionRadius+30) * Vector(Rotation) + vect(0,0,1) * 15 );<br><br></div>
<h3 id="PlayerPawn.SwimAnimUpdate"><a class="headerlink" href="#PlayerPawn.SwimAnimUpdate" title="Permanent link">SwimAnimUpdate</a> (bool bNotForward)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( !bAnimTransition && (GetAnimGroup(AnimSequence) != 'Gesture') )<br>&#9;{<br>&#9;&#9;if ( bNotForward )<br>&#9; &#9;{<br>&#9;&#9; &#9; if ( GetAnimGroup(AnimSequence) != 'Waiting' )<br>&#9;&#9;&#9;&#9;TweenToWaiting(0.1);<br>&#9;&#9;}<br>&#9;&#9;else if ( GetAnimGroup(AnimSequence) == 'Waiting' )<br>&#9;&#9;&#9;TweenToSwimming(0.1);<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.SwitchCoopLevel"><a class="headerlink" href="#PlayerPawn.SwitchCoopLevel" title="Permanent link">SwitchCoopLevel</a> (string URL)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( bAdmin || Level.NetMode==NM_Standalone || Level.netMode==NM_ListenServer )<br>&#9;&#9;Level.ServerTravel( URL, true );<br><br></div>
<h3 id="PlayerPawn.SwitchLevel"><a class="headerlink" href="#PlayerPawn.SwitchLevel" title="Permanent link">SwitchLevel</a> (string URL)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( bAdmin || Level.NetMode==NM_Standalone || Level.netMode==NM_ListenServer )<br>&#9;&#9;Level.ServerTravel( URL, false );<br><br></div>
<h3 id="PlayerPawn.SwitchWeapon"><a class="headerlink" href="#PlayerPawn.SwitchWeapon" title="Permanent link">SwitchWeapon</a> (byte F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local weapon newWeapon;<br><br><br>&#9;if ( bShowMenu || Level.Pauser!="" )<br>&#9;{<br>&#9;&#9;if ( myHud != None )<br>&#9;&#9;&#9;myHud.InputNumber(F);<br>&#9;&#9;return;<br>&#9;}<br>&#9;if ( Inventory == None )<br>&#9;&#9;return;<br>&#9;if ( (Weapon != None) && (Weapon.Inventory != None) )<br>&#9;&#9;newWeapon = Weapon.Inventory.WeaponChange(F);<br>&#9;else<br>&#9;&#9;newWeapon = None;&#9;<br>&#9;if ( newWeapon == None )<br>&#9;&#9;newWeapon = Inventory.WeaponChange(F);<br>&#9;if ( newWeapon == None )<br>&#9;&#9;return;<br><br>&#9;if ( Weapon == None )<br>&#9;{<br>&#9;&#9;PendingWeapon = newWeapon;<br>&#9;&#9;ChangedWeapon();<br>&#9;}<br>&#9;else if ( Weapon != newWeapon )<br>&#9;{<br>&#9;&#9;PendingWeapon = newWeapon;<br>&#9;&#9;if ( !Weapon.PutDown() )<br>&#9;&#9;&#9;PendingWeapon = None;<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.Taunt"><a class="headerlink" href="#PlayerPawn.Taunt" title="Permanent link">Taunt</a> (name Sequence)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if ( Health > 0 )<br>&#9;&#9;&#9;Global.Taunt(Sequence);<br>&#9;<br></div>
<h3 id="PlayerPawn.TeamMessage"><a class="headerlink" href="#PlayerPawn.TeamMessage" title="Permanent link">TeamMessage</a> (PlayerReplicationInfo PRI, coerce string S, name Type, optional bool bBeep)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Player.Console != None)<br>&#9;&#9;Player.Console.Message ( PRI, S, Type );<br>&#9;if (bBeep && bMessageBeep)<br>&#9;&#9;PlayBeepSound();<br>&#9;if ( myHUD != None )<br>&#9;&#9;myHUD.Message( PRI, S, Type );<br><br></div>
<h3 id="PlayerPawn.ThrowWeapon"><a class="headerlink" href="#PlayerPawn.ThrowWeapon" title="Permanent link">ThrowWeapon</a></h3>

<h3 id="PlayerPawn.Timer"><a class="headerlink" href="#PlayerPawn.Timer" title="Permanent link">Timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;bFrozen = false;<br>&#9;<br></div>
<h3 id="PlayerPawn.ToggleZoom"><a class="headerlink" href="#PlayerPawn.ToggleZoom" title="Permanent link">ToggleZoom</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( DefaultFOV != DesiredFOV )<br>&#9;&#9;EndZoom();<br>&#9;else<br>&#9;&#9;StartZoom();<br><br></div>
<h3 id="PlayerPawn.TravelPostAccept"><a class="headerlink" href="#PlayerPawn.TravelPostAccept" title="Permanent link">TravelPostAccept</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Health <= 0 )<br>&#9;&#9;Health = Default.Health;<br><br></div>
<h3 id="PlayerPawn.Type"><a class="headerlink" href="#PlayerPawn.Type" title="Permanent link">Type</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (!bCheatsEnabled)<br>&#9;&#9;return;<br><br>&#9;Player.Console.TypedStr="";<br>&#9;Player.Console.GotoState( 'Typing' );<br><br></div>
<h3 id="PlayerPawn.Typing"><a class="headerlink" href="#PlayerPawn.Typing" title="Permanent link">Typing</a> (bool bTyping)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bIsTyping = bTyping;<br>&#9;if (bTyping)<br>&#9;{<br>&#9;&#9;if (Level.Game.WorldLog != None)<br>&#9;&#9;&#9;Level.Game.WorldLog.LogTypingEvent(True, Self);<br>&#9;&#9;if (Level.Game.LocalLog != None)<br>&#9;&#9;&#9;Level.Game.LocalLog.LogTypingEvent(True, Self);<br>&#9;&#9;PlayChatting();<br>&#9;} <br>&#9;else <br>&#9;{<br>&#9;&#9;if (Level.Game.WorldLog != None)<br>&#9;&#9;&#9;Level.Game.WorldLog.LogTypingEvent(False, Self);<br>&#9;&#9;if (Level.Game.LocalLog != None)<br>&#9;&#9;&#9;Level.Game.LocalLog.LogTypingEvent(False, Self);<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.UnPossess"><a class="headerlink" href="#PlayerPawn.UnPossess" title="Permanent link">UnPossess</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;log(Self$" being unpossessed");<br>&#9;if ( myHUD != None )<br>&#9;&#9;myHUD.Destroy();<br>&#9;bIsPlayer = false;<br>&#9;EyeHeight = 0.8 * CollisionHeight;<br><br></div>
<h3 id="PlayerPawn.UpdateBob"><a class="headerlink" href="#PlayerPawn.UpdateBob" title="Permanent link">UpdateBob</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Bob = FClamp(F,0,0.032);<br><br></div>
<h3 id="PlayerPawn.UpdateEyeHeight"><a class="headerlink" href="#PlayerPawn.UpdateEyeHeight" title="Permanent link">UpdateEyeHeight</a> (float DeltaTime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float smooth, bound;<br><br>&#9;&#9;<br>&#9;&#9;// smooth up/down stairs<br>&#9;&#9;if( !bJustLanded )<br>&#9;&#9;{<br>&#9;&#9;&#9;smooth = FMin(1.0, 10.0 * DeltaTime/Level.TimeDilation);<br>&#9;&#9;&#9;EyeHeight = (EyeHeight - Location.Z + OldLocation.Z) * (1 - smooth) + ( ShakeVert + BaseEyeHeight) * smooth;<br>&#9;&#9;&#9;bound = -0.5 * CollisionHeight;<br>&#9;&#9;&#9;if (EyeHeight < bound)<br>&#9;&#9;&#9;&#9;EyeHeight = bound;<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;bound = CollisionHeight + FClamp((OldLocation.Z - Location.Z), 0.0, MaxStepHeight); <br>&#9;&#9;&#9;&#9; if ( EyeHeight > bound )<br>&#9;&#9;&#9;&#9;&#9;EyeHeight = bound;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;smooth = FClamp(10.0 * DeltaTime/Level.TimeDilation, 0.35, 1.0);<br>&#9;&#9;&#9;bJustLanded = false;<br>&#9;&#9;&#9;EyeHeight = EyeHeight * ( 1 - smooth) + (BaseEyeHeight + ShakeVert) * smooth;<br>&#9;&#9;}<br><br>&#9;&#9;// teleporters affect your FOV, so adjust it back down<br>&#9;&#9;if ( FOVAngle != DesiredFOV )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( FOVAngle > DesiredFOV )<br>&#9;&#9;&#9;&#9;FOVAngle = FOVAngle - FMax(7, 0.9 * DeltaTime * (FOVAngle - DesiredFOV)); <br>&#9;&#9;&#9;else <br>&#9;&#9;&#9;&#9;FOVAngle = FOVAngle - FMin(-7, 0.9 * DeltaTime * (FOVAngle - DesiredFOV)); <br>&#9;&#9;&#9;if ( Abs(FOVAngle - DesiredFOV) <= 10 )<br>&#9;&#9;&#9;&#9;FOVAngle = DesiredFOV;<br>&#9;&#9;}<br><br>&#9;&#9;// adjust FOV for weapon zooming<br>&#9;&#9;if ( bZooming )<br>&#9;&#9;{&#9;<br>&#9;&#9;&#9;ZoomLevel += DeltaTime * 1.0;<br>&#9;&#9;&#9;if (ZoomLevel > 0.9)<br>&#9;&#9;&#9;&#9;ZoomLevel = 0.9;<br>&#9;&#9;&#9;DesiredFOV = FClamp(90.0 - (ZoomLevel * 88.0), 1, 170);<br>&#9;&#9;} <br>&#9;<br></div>
<h3 id="PlayerPawn.UpdateRotation"><a class="headerlink" href="#PlayerPawn.UpdateRotation" title="Permanent link">UpdateRotation</a> (float DeltaTime, float maxPitch)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local rotator newRotation;<br><br>&#9;<br>&#9;DesiredRotation = ViewRotation; //save old rotation<br>&#9;ViewRotation.Pitch += 32.0 * DeltaTime * aLookUp;<br>&#9;ViewRotation.Pitch = ViewRotation.Pitch & 65535;<br>&#9;If ((ViewRotation.Pitch > 18000) && (ViewRotation.Pitch < 49152))<br>&#9;{<br>&#9;&#9;If (aLookUp > 0) <br>&#9;&#9;&#9;ViewRotation.Pitch = 18000;<br>&#9;&#9;else<br>&#9;&#9;&#9;ViewRotation.Pitch = 49152;<br>&#9;}<br>&#9;ViewRotation.Yaw += 32.0 * DeltaTime * aTurn;<br>&#9;ViewShake(deltaTime);<br>&#9;ViewFlash(deltaTime);<br>&#9;&#9;<br>&#9;newRotation = Rotation;<br>&#9;newRotation.Yaw = ViewRotation.Yaw;<br>&#9;newRotation.Pitch = ViewRotation.Pitch;<br>&#9;If ( (newRotation.Pitch > maxPitch * RotationRate.Pitch) && (newRotation.Pitch < 65536 - maxPitch * RotationRate.Pitch) )<br>&#9;{<br>&#9;&#9;If (ViewRotation.Pitch < 32768) <br>&#9;&#9;&#9;newRotation.Pitch = maxPitch * RotationRate.Pitch;<br>&#9;&#9;else<br>&#9;&#9;&#9;newRotation.Pitch = 65536 - maxPitch * RotationRate.Pitch;<br>&#9;}<br>    // added to keep the player's model from pitching or rolling - DEUS_EX CNN<br>&#9;newRotation.Pitch = 0;<br>&#9;newRotation.Roll = 0;<br><br>&#9;setRotation(newRotation);<br><br></div>
<h3 id="PlayerPawn.UpdateSensitivity"><a class="headerlink" href="#PlayerPawn.UpdateSensitivity" title="Permanent link">UpdateSensitivity</a> (float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;MouseSensitivity = FMax(0,F);<br><br></div>
<h3 id="PlayerPawn.UpdateURL"><a class="headerlink" href="#PlayerPawn.UpdateURL" title="Permanent link">UpdateURL</a> (string NewOption, string NewValue, bool bSaveDefault) | native</h3>

<h3 id="PlayerPawn.UpdateWeaponPriorities"><a class="headerlink" href="#PlayerPawn.UpdateWeaponPriorities" title="Permanent link">UpdateWeaponPriorities</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local byte i;<br><br><br>&#9;// send new priorities to server<br>&#9;if ( Level.Netmode == NM_Client )<br>&#9;&#9;for ( i=0; i<ArrayCount(WeaponPriority); i++ )<br>&#9;&#9;&#9;ServerSetWeaponPriority(i, WeaponPriority[i]);<br><br></div>
<h3 id="PlayerPawn.VelocityChanged"><a class="headerlink" href="#PlayerPawn.VelocityChanged" title="Permanent link">VelocityChanged</a> (vector OldVel, vector NewVel) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float NormDot, OldSize, NewSize;<br><br><br>   OldSize = VSize(OldVel);<br>   NewSize = VSize(NewVel);<br><br>   // If both are tiny, just return (also handles zero case where the normal is zero).<br>   if ((OldSize < 1) && (NewSize < 1))<br>   {<br>      return false;<br>   }<br><br>   if (OldSize > 1.1 * NewSize)<br>      return true;<br><br>   if (NewSize > 1.1 * OldSize)<br>      return true;<br><br>   NormDot = Normal(OldVel) dot Normal(NewVel);<br><br>   // if they are close to each other, don't bother with the update.<br>   return (NormDot < 0.99);<br><br></div>
<h3 id="PlayerPawn.ViewClass"><a class="headerlink" href="#PlayerPawn.ViewClass" title="Permanent link">ViewClass</a> (class<actor> aClass, optional bool bQuiet)</h3>

<h3 id="PlayerPawn.ViewFlash"><a class="headerlink" href="#PlayerPawn.ViewFlash" title="Permanent link">ViewFlash</a> (float DeltaTime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector goalFog;<br>&#9;local float goalscale, delta;<br><br><br>&#9;if ( bNoFlash )<br>&#9;{<br>&#9;&#9;InstantFlash = 0;<br>&#9;&#9;InstantFog = vect(0,0,0);<br>&#9;}<br><br>&#9;delta = FMin(0.1, DeltaTime);<br>&#9;goalScale = 1 + DesiredFlashScale + ConstantGlowScale + HeadRegion.Zone.ViewFlash.X; <br>&#9;goalFog = DesiredFlashFog + ConstantGlowFog + HeadRegion.Zone.ViewFog;<br>&#9;DesiredFlashScale -= DesiredFlashScale * 2 * delta;  <br>&#9;DesiredFlashFog -= DesiredFlashFog * 2 * delta;<br>&#9;FlashScale.X += (goalScale - FlashScale.X + InstantFlash) * 10 * delta;<br>&#9;FlashFog += (goalFog - FlashFog + InstantFog) * 10 * delta;<br>&#9;InstantFlash = 0;<br>&#9;InstantFog = vect(0,0,0);<br><br>&#9;if ( FlashScale.X > 0.981 )<br>&#9;&#9;FlashScale.X = 1;<br>&#9;FlashScale = FlashScale.X * vect(1,1,1);<br><br>&#9;if ( FlashFog.X < 0.019 )<br>&#9;&#9;FlashFog.X = 0;<br>&#9;if ( FlashFog.Y < 0.019 )<br>&#9;&#9;FlashFog.Y = 0;<br>&#9;if ( FlashFog.Z < 0.019 )<br>&#9;&#9;FlashFog.Z = 0;<br><br></div>
<h3 id="PlayerPawn.ViewPlayer"><a class="headerlink" href="#PlayerPawn.ViewPlayer" title="Permanent link">ViewPlayer</a> (string S)</h3>

<h3 id="PlayerPawn.ViewPlayerNum"><a class="headerlink" href="#PlayerPawn.ViewPlayerNum" title="Permanent link">ViewPlayerNum</a> (optional int num)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br><br><br>&#9;if ( !PlayerReplicationInfo.bIsSpectator && !Level.Game.bTeamGame )<br>&#9;&#9;return;<br>&#9;if ( num >= 0 )<br>&#9;{<br>&#9;&#9;P = Pawn(ViewTarget);<br>&#9;&#9;if ( (P != None) && P.bIsPlayer && (P.PlayerReplicationInfo.TeamID == num) )<br>&#9;&#9;{<br>&#9;&#9;&#9;ViewTarget = None;<br>&#9;&#9;&#9;bBehindView = false;<br>&#9;&#9;&#9;return;<br>&#9;&#9;}<br>&#9;&#9;for ( P=Level.PawnList; P!=None; P=P.NextPawn )<br>&#9;&#9;&#9;if ( P.bIsPlayer && (P.PlayerReplicationInfo.Team == PlayerReplicationInfo.Team)<br>&#9;&#9;&#9;&#9;&& !P.PlayerReplicationInfo.bIsSpectator<br>&#9;&#9;&#9;&#9;&& (P.PlayerReplicationInfo.TeamID == num) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if ( P != self )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;ViewTarget = P;<br>&#9;&#9;&#9;&#9;&#9;bBehindView = true;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;return;<br>&#9;&#9;&#9;}<br>&#9;&#9;return;<br>&#9;}<br>&#9;if ( Role == ROLE_Authority )<br>&#9;{<br>&#9;&#9;ViewClass(class'Pawn', true);<br>&#9;&#9;While ( (ViewTarget != None) <br>&#9;&#9;&#9;&#9;&& (!Pawn(ViewTarget).bIsPlayer || Pawn(ViewTarget).PlayerReplicationInfo.bIsSpectator) )<br>&#9;&#9;&#9;ViewClass(class'Pawn', true);<br><br>&#9;&#9;if ( ViewTarget != None )<br>&#9;&#9;&#9;ClientMessage(ViewingFrom@Pawn(ViewTarget).PlayerReplicationInfo.PlayerName, 'Event', true);<br>&#9;&#9;else<br>&#9;&#9;&#9;ClientMessage(ViewingFrom@OwnCamera, 'Event', true);<br>&#9;}<br><br></div>
<h3 id="PlayerPawn.ViewSelf"><a class="headerlink" href="#PlayerPawn.ViewSelf" title="Permanent link">ViewSelf</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bBehindView = false;<br>&#9;Viewtarget = None;<br>&#9;ClientMessage(ViewingFrom@OwnCamera, 'Event', true);<br><br></div>
<h3 id="PlayerPawn.ViewShake"><a class="headerlink" href="#PlayerPawn.ViewShake" title="Permanent link">ViewShake</a> (float DeltaTime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (shaketimer > 0.0) //shake view<br>&#9;{<br>&#9;&#9;shaketimer -= DeltaTime;<br>&#9;&#9;if ( verttimer == 0 )<br>&#9;&#9;{<br>&#9;&#9;&#9;verttimer = 0.1;<br>&#9;&#9;&#9;ShakeVert = -1.1 * maxshake;<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;verttimer -= DeltaTime;<br>&#9;&#9;&#9;if ( verttimer < 0 )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;verttimer = 0.2 * FRand();<br>&#9;&#9;&#9;&#9;shakeVert = (2 * FRand() - 1) * maxshake;  <br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;&#9;ViewRotation.Roll = ViewRotation.Roll & 65535;<br>&#9;&#9;if (bShakeDir)<br>&#9;&#9;{<br>&#9;&#9;&#9;ViewRotation.Roll += Int( 10 * shakemag * FMin(0.1, DeltaTime));<br>&#9;&#9;&#9;bShakeDir = (ViewRotation.Roll > 32768) || (ViewRotation.Roll < (0.5 + FRand()) * shakemag);<br>&#9;&#9;&#9;if ( (ViewRotation.Roll < 32768) && (ViewRotation.Roll > 1.3 * shakemag) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;ViewRotation.Roll = 1.3 * shakemag;<br>&#9;&#9;&#9;&#9;bShakeDir = false;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;else if (FRand() < 3 * DeltaTime)<br>&#9;&#9;&#9;&#9;bShakeDir = !bShakeDir;<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;ViewRotation.Roll -= Int( 10 * shakemag * FMin(0.1, DeltaTime));<br>&#9;&#9;&#9;bShakeDir = (ViewRotation.Roll > 32768) && (ViewRotation.Roll < 65535 - (0.5 + FRand()) * shakemag);<br>&#9;&#9;&#9;if ( (ViewRotation.Roll > 32768) && (ViewRotation.Roll < 65535 - 1.3 * shakemag) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;ViewRotation.Roll = 65535 - 1.3 * shakemag;<br>&#9;&#9;&#9;&#9;bShakeDir = true;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;else if (FRand() < 3 * DeltaTime)<br>&#9;&#9;&#9;&#9;bShakeDir = !bShakeDir;<br>&#9;&#9;}<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;ShakeVert = 0;<br>&#9;&#9;ViewRotation.Roll = ViewRotation.Roll & 65535;<br>&#9;&#9;if (ViewRotation.Roll < 32768)<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( ViewRotation.Roll > 0 )<br>&#9;&#9;&#9;&#9;ViewRotation.Roll = Max(0, ViewRotation.Roll - (Max(ViewRotation.Roll,500) * 10 * FMin(0.1,DeltaTime)));<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;ViewRotation.Roll += ((65536 - Max(500,ViewRotation.Roll)) * 10 * FMin(0.1,DeltaTime));<br>&#9;&#9;&#9;if ( ViewRotation.Roll > 65534 )<br>&#9;&#9;&#9;&#9;ViewRotation.Roll = 0;<br>&#9;&#9;}<br>&#9;} <br><br></div>
<h3 id="PlayerPawn.Walk"><a class="headerlink" href="#PlayerPawn.Walk" title="Permanent link">Walk</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre">&#9;<br>&#9;if ( !bAdmin && (Level.Netmode != NM_Standalone) )<br>&#9;&#9;return;<br><br>&#9;StartWalk();<br><br></div>
<h3 id="PlayerPawn.ZoneChange"><a class="headerlink" href="#PlayerPawn.ZoneChange" title="Permanent link">ZoneChange</a> (ZoneInfo NewZone)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor HitActor;<br>&#9;local vector HitLocation, HitNormal, checkpoint;<br><br><br>&#9;&#9;if (!NewZone.bWaterZone)<br>&#9;&#9;{<br>&#9;&#9;&#9;SetPhysics(PHYS_Falling);<br>&#9;&#9;&#9;if (bUpAndOut && CheckWaterJump(HitNormal)) //check for waterjump<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;velocity.Z = 330 + 2 * CollisionRadius; //set here so physics uses this for remainder of tick<br>&#9;&#9;&#9;&#9;PlayDuck();<br>&#9;&#9;&#9;&#9;GotoState('PlayerWalking');<br>&#9;&#9;&#9;}&#9;&#9;&#9;&#9;<br>&#9;&#9;&#9;else if (!FootRegion.Zone.bWaterZone || (Velocity.Z > 160) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;GotoState('PlayerWalking');<br>&#9;&#9;&#9;&#9;AnimEnd();<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;else //check if in deep water<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;checkpoint = Location;<br>&#9;&#9;&#9;&#9;checkpoint.Z -= (CollisionHeight + 6.0);<br>&#9;&#9;&#9;&#9;HitActor = Trace(HitLocation, HitNormal, checkpoint, Location, false);<br>&#9;&#9;&#9;&#9;if (HitActor != None)<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;GotoState('PlayerWalking');<br>&#9;&#9;&#9;&#9;&#9;AnimEnd();<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;Enable('Timer');<br>&#9;&#9;&#9;&#9;&#9;SetTimer(0.7,false);<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;//log("Out of water");<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;Disable('Timer');<br>&#9;&#9;&#9;SetPhysics(PHYS_Swimming);<br>&#9;&#9;}<br>&#9;<br></div>
<h3 id="PlayerPawn.damageAttitudeTo"><a class="headerlink" href="#PlayerPawn.damageAttitudeTo" title="Permanent link">damageAttitudeTo</a> (pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Other != Self )<br>&#9;&#9;Enemy = Other;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#PlayerReplicationInfo.uc" title="Permanent link"><h2 id="PlayerReplicationInfo.uc">PlayerReplicationInfo.uc (extends ReplicationInfo)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var string				PlayerName;		// Player name, or blank if none.<br>var string				OldName;		// Temporary value.<br>var int					PlayerID;		// Unique id number.<br>var string				TeamName;		// Team name, or blank if none.<br>var byte				Team;			// Player Team, 255 = None for player.<br>var int					TeamID;			// Player position in team.<br>var float				Score;			// Player's current score.<br>var float				Deaths;			// Number of player's deaths.<br>var class<VoicePack>	VoiceType;<br>var Decoration			HasFlag;<br>var int					Ping;<br>var byte				PacketLoss;<br>var bool				bIsFemale;<br>var bool				bFeigningDeath;<br>var bool				bIsSpectator;<br>var bool				bWaitingPlayer;<br>var bool				bAdmin;<br>var Texture				TalkTexture;<br>var ZoneInfo			PlayerZone;<br>var LocationID			PlayerLocation;<br>var int					StartTime;<br>var int					TimeAcc;<br>var float				Streak;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Team=255<br>NetUpdateFrequency=5.000000</div>
<h3 id="PlayerReplicationInfo.PostBeginPlay"><a class="headerlink" href="#PlayerReplicationInfo.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;StartTime = Level.TimeSeconds;<br>&#9;Timer();<br>&#9;SetTimer(2.0, true);<br>&#9;bIsFemale = Pawn(Owner).bIsFemale;<br><br></div>
<h3 id="PlayerReplicationInfo.Timer"><a class="headerlink" href="#PlayerReplicationInfo.Timer" title="Permanent link">Timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float MinDist, Dist;<br>&#9;local LocationID L;<br><br><br>&#9;MinDist = 1000000;<br>&#9;PlayerLocation = None;<br>&#9;if ( PlayerZone != None )<br>&#9;&#9;for ( L=PlayerZone.LocationID; L!=None; L=L.NextLocation )<br>&#9;&#9;{<br>&#9;&#9;&#9;Dist = VSize(Owner.Location - L.Location);<br>&#9;&#9;&#9;if ( (Dist < L.Radius) && (Dist < MinDist) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;PlayerLocation = L;<br>&#9;&#9;&#9;&#9;MinDist = Dist;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;if ( FRand() < 0.65 )<br>&#9;&#9;return;<br><br>&#9;if (PlayerPawn(Owner) != None)<br>&#9;&#9;Ping = int(PlayerPawn(Owner).ConsoleCommand("GETPING"));<br><br>&#9;if (PlayerPawn(Owner) != None)<br>&#9;&#9;PacketLoss = int(PlayerPawn(Owner).ConsoleCommand("GETLOSS"));<br><br></div>
<br><br><hr>
<a class="headerlink" href="#PlayerStart.uc" title="Permanent link"><h2 id="PlayerStart.uc">PlayerStart.uc (extends NavigationPoint)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() byte TeamNumber;<br>var() bool bSinglePlayerStart;<br>var() bool bTeamOnlyStart;<br>var() bool bNonTeamOnlyStart;<br>var() bool bCoopStart;<br>var() bool bEnabled;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bSinglePlayerStart=True<br>bCoopStart=True<br>bEnabled=True<br>bDirectional=True<br>Texture=Texture'Engine.S_Player'<br>SoundVolume=128<br>CollisionRadius=18.000000<br>CollisionHeight=40.000000</div>
<h3 id="PlayerStart.PlayTeleportEffect"><a class="headerlink" href="#PlayerStart.PlayTeleportEffect" title="Permanent link">PlayTeleportEffect</a> (actor Incoming, bool bOut)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Level.Game.bDeathMatch && Incoming.IsA('PlayerPawn') )<br>&#9;&#9;PlayerPawn(Incoming).SetFOVAngle(135);<br>&#9;Level.Game.PlayTeleportEffect(Incoming, bOut, Level.Game.bDeathMatch );<br><br></div>
<h3 id="PlayerStart.Trigger"><a class="headerlink" href="#PlayerStart.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bEnabled = !bEnabled;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Projectile.uc" title="Permanent link"><h2 id="Projectile.uc">Projectile.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() float    Speed;               // Initial speed of projectile.<br>var() float    MaxSpeed;            // Limit on speed of projectile (0 means no limit)<br>var() float    Damage;<br>var() int	   MomentumTransfer; // Momentum imparted by impacting projectile.<br>var() name	   MyDamageType;<br>var() sound    SpawnSound;		// Sound made when projectile is spawned.<br>var() sound	   ImpactSound;		// Sound made when projectile hits something.<br>var() sound    MiscSound;		// Miscellaneous Sound.<br>var() float		ExploWallOut;	// distance to move explosions out from wall<br>var() class<Decal> ExplosionDecal;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">MaxSpeed=2000.000000<br>bReplicateInstigator=True<br>Physics=PHYS_Projectile<br>LifeSpan=140.000000<br>bDirectional=True<br>DrawType=DT_Mesh<br>Texture=Texture'Engine.S_Camera'<br>bGameRelevant=True<br>SoundVolume=0<br>CollisionRadius=0.000000<br>CollisionHeight=0.000000<br>bCollideActors=True<br>bCollideWorld=True<br>NetPriority=2.500000</div>
<h3 id="Projectile.EncroachingOn"><a class="headerlink" href="#Projectile.EncroachingOn" title="Permanent link">EncroachingOn</a> (actor Other) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( (Other.Brush != None) || (Brush(Other) != None) )<br>&#9;&#9;return true;<br>&#9;&#9;<br>&#9;return false;<br><br></div>
<h3 id="Projectile.Explode"><a class="headerlink" href="#Projectile.Explode" title="Permanent link">Explode</a> (vector HitLocation, vector HitNormal)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Destroy();<br><br></div>
<h3 id="Projectile.HitWall"><a class="headerlink" href="#Projectile.HitWall" title="Permanent link">HitWall</a> (vector HitNormal, actor Wall)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Role == ROLE_Authority )<br>&#9;{<br>&#9;&#9;if ( (Mover(Wall) != None) && Mover(Wall).bDamageTriggered )<br>&#9;&#9;&#9;Wall.TakeDamage( Damage, instigator, Location, MomentumTransfer * Normal(Velocity), '');<br><br>&#9;&#9;MakeNoise(1.0);<br>&#9;}<br>&#9;Explode(Location + ExploWallOut * HitNormal, HitNormal);<br>&#9;if ( ExplosionDecal != None )<br>&#9;&#9;Spawn(ExplosionDecal,self,,Location, rotator(HitNormal));<br><br></div>
<h3 id="Projectile.ProcessTouch"><a class="headerlink" href="#Projectile.ProcessTouch" title="Permanent link">ProcessTouch</a> (Actor Other, Vector HitLocation)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;//should be implemented in subclass<br><br></div>
<h3 id="Projectile.RandSpin"><a class="headerlink" href="#Projectile.RandSpin" title="Permanent link">RandSpin</a> (float spinRate)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;DesiredRotation = RotRand();<br>&#9;RotationRate.Yaw = spinRate * 2 *FRand() - spinRate;<br>&#9;RotationRate.Pitch = spinRate * 2 *FRand() - spinRate;<br>&#9;RotationRate.Roll = spinRate * 2 *FRand() - spinRate;&#9;<br><br></div>
<h3 id="Projectile.Touch"><a class="headerlink" href="#Projectile.Touch" title="Permanent link">Touch</a> (Actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor HitActor;<br>&#9;local vector HitLocation, HitNormal, TestLocation;<br><br>&#9;<br>&#9;if ( Other.IsA('BlockAll') )<br>&#9;{<br>&#9;&#9;HitWall( Normal(Location - Other.Location), Other);<br>&#9;&#9;return;<br>&#9;}<br>&#9;if ( Other.bProjTarget || (Other.bBlockActors && Other.bBlockPlayers) )<br>&#9;{<br>&#9;&#9;//get exact hitlocation<br>&#9; &#9;HitActor = Trace(HitLocation, HitNormal, Location, OldLocation, true);<br>&#9;&#9;if (HitActor == Other)<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( Other.bIsPawn <br>&#9;&#9;&#9;&#9;&& !Pawn(Other).AdjustHitLocation(HitLocation, Velocity) )<br>&#9;&#9;&#9;&#9;&#9;return;<br>&#9;&#9;&#9;ProcessTouch(Other, HitLocation); <br>&#9;&#9;}<br>&#9;&#9;else <br>&#9;&#9;&#9;ProcessTouch(Other, Other.Location + Other.CollisionRadius * Normal(Location - Other.Location));<br>&#9;}<br><br></div>
<br><br><hr>
<a class="headerlink" href="#RenderIterator.uc" title="Permanent link"><h2 id="RenderIterator.uc">RenderIterator.uc (extends Object)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var int			MaxItems;<br>var int			Index;<br>var PlayerPawn	Observer;</div>
<h3 id="RenderIterator.CurrentItem"><a class="headerlink" href="#RenderIterator.CurrentItem" title="Permanent link">CurrentItem</a> -> Actor</h3>

<h3 id="RenderIterator.Init"><a class="headerlink" href="#RenderIterator.Init" title="Permanent link">Init</a> (PlayerPawn Camera)</h3>

<h3 id="RenderIterator.IsDone"><a class="headerlink" href="#RenderIterator.IsDone" title="Permanent link">IsDone</a> -> bool</h3>

<br><br><hr>
<a class="headerlink" href="#ReplicationInfo.uc" title="Permanent link"><h2 id="ReplicationInfo.uc">ReplicationInfo.uc (extends Info)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bAlwaysRelevant=True</div>
<br><br><hr>
<a class="headerlink" href="#RoundRobin.uc" title="Permanent link"><h2 id="RoundRobin.uc">RoundRobin.uc (extends Triggers)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() name OutEvents[16]; // Events to generate.<br>var() bool bLoop;         // Whether to loop when get to end.<br>var int i;                // Internal counter.</div>
<h3 id="RoundRobin.Trigger"><a class="headerlink" href="#RoundRobin.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor A;<br><br>&#9;if( OutEvents[i] != '' )<br>&#9;{<br>&#9;&#9;foreach AllActors( class 'Actor', A, OutEvents[i] )&#9;&#9;<br>&#9;&#9;{<br>&#9;&#9;&#9;A.Trigger( Self, EventInstigator );<br>&#9;&#9;}<br>&#9;&#9;if( ++i>=ArrayCount(OutEvents) || OutEvents[i]=='' )<br>&#9;&#9;{<br>&#9;&#9;&#9;if( bLoop ) i=0;<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;SetCollision(false,false,false);<br>&#9;&#9;}<br>&#9;}<br><br></div>
<br><br><hr>
<a class="headerlink" href="#SavedMove.uc" title="Permanent link"><h2 id="SavedMove.uc">SavedMove.uc (extends Info)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var SavedMove NextMove;		// Next move in linked list.<br>var float TimeStamp;		// Time of this move.<br>var float Delta;			// Distance moved.<br>var bool	bRun;<br>var bool	bDuck;<br>var bool	bPressedJump;<br>var bool	bFire;<br>var bool	bAltFire;<br>var bool	bForceFire;<br>var bool	bForceAltFire;<br>var EDodgeDir DodgeMove;	// Dodge info.</div>
<h3 id="SavedMove.Clear"><a class="headerlink" href="#SavedMove.Clear" title="Permanent link">Clear</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TimeStamp = 0;<br>&#9;Delta = 0;<br>&#9;DodgeMove = DODGE_None;<br>&#9;Acceleration = vect(0,0,0);<br>&#9;bFire = false;<br>&#9;bRun = false;<br>&#9;bDuck = false;<br>&#9;bAltFire = false;<br>&#9;bPressedJump = false;<br>&#9;bForceFire = false;<br>&#9;bForceAltFire = false;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#ScaledSprite.uc" title="Permanent link"><h2 id="ScaledSprite.uc">ScaledSprite.uc (extends Decoration)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Texture=Texture'Engine.S_Pickup'</div>
<br><br><hr>
<a class="headerlink" href="#ScoreBoard.uc" title="Permanent link"><h2 id="ScoreBoard.uc">ScoreBoard.uc (extends Info)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var font RegFont;<br>var HUD OwnerHUD;</div>
<h3 id="ScoreBoard.PreBeginPlay"><a class="headerlink" href="#ScoreBoard.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>

<h3 id="ScoreBoard.ShowMiniScores"><a class="headerlink" href="#ScoreBoard.ShowMiniScores" title="Permanent link">ShowMiniScores</a> (Canvas Canvas)</h3>

<h3 id="ScoreBoard.ShowScores"><a class="headerlink" href="#ScoreBoard.ShowScores" title="Permanent link">ShowScores</a> (canvas Canvas)</h3>

<br><br><hr>
<a class="headerlink" href="#Scout.uc" title="Permanent link"><h2 id="Scout.uc">Scout.uc (extends Pawn)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">AccelRate=1.000000<br>SightRadius=4100.000000<br>CombatStyle=4363467783093056784302080.000000<br>CollisionRadius=52.000000<br>CollisionHeight=50.000000<br>bCollideActors=False<br>bCollideWorld=False<br>bBlockActors=False<br>bBlockPlayers=False<br>bProjTarget=False</div>
<h3 id="Scout.PreBeginPlay"><a class="headerlink" href="#Scout.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Destroy(); //scouts shouldn't exist during play<br><br></div>
<br><br><hr>
<a class="headerlink" href="#ScriptedTexture.uc" title="Permanent link"><h2 id="ScriptedTexture.uc">ScriptedTexture.uc (extends Texture)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var Actor NotifyActor;<br>var() Texture SourceTexture;<br>var transient const int Junk1;	// C++ stuff<br>var transient const int Junk2;	// C++ stuff<br>var transient const int Junk3;	// C++ stuff<br>var transient const float LocalTime;	// C++ stuff</div>
<h3 id="ScriptedTexture.DrawColoredText"><a class="headerlink" href="#ScriptedTexture.DrawColoredText" title="Permanent link">DrawColoredText</a> (float X, float Y, string Text, Font Font, color FontColor) | native</h3>

<h3 id="ScriptedTexture.DrawText"><a class="headerlink" href="#ScriptedTexture.DrawText" title="Permanent link">DrawText</a> (float X, float Y, string Text, Font Font) | native</h3>

<h3 id="ScriptedTexture.DrawTile"><a class="headerlink" href="#ScriptedTexture.DrawTile" title="Permanent link">DrawTile</a> (float X, float Y, float XL, float YL, float U, float V, float UL, float VL, Texture Tex, bool bMasked) | native</h3>

<h3 id="ScriptedTexture.ReplaceTexture"><a class="headerlink" href="#ScriptedTexture.ReplaceTexture" title="Permanent link">ReplaceTexture</a> (Texture Tex) | native</h3>

<h3 id="ScriptedTexture.TextSize"><a class="headerlink" href="#ScriptedTexture.TextSize" title="Permanent link">TextSize</a> (string Text, out float XL, out float YL, Font Font) | native</h3>

<br><br><hr>
<a class="headerlink" href="#SkyZoneInfo.uc" title="Permanent link"><h2 id="SkyZoneInfo.uc">SkyZoneInfo.uc (extends ZoneInfo)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">RemoteRole=ROLE_SimulatedProxy</div>
<br><br><hr>
<a class="headerlink" href="#SmellNode.uc" title="Permanent link"><h2 id="SmellNode.uc">SmellNode.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var(Smell) byte MaxSmellRadius;<br>var(Smell) byte Strength;<br>var(Smell) bool Communicable;<br>var SmellNode   nextNode;<br>var SmellNode   prevNode;<br>var Actor       Owner;</div>
<br><br><hr>
<a class="headerlink" href="#SpawnNotify.uc" title="Permanent link"><h2 id="SpawnNotify.uc">SpawnNotify.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var class<Actor> ActorClass;<br>var SpawnNotify  Next;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">ActorClass=Class'Engine.Actor'<br>bHidden=True<br>bNetTemporary=True<br>bAlwaysRelevant=True</div>
<h3 id="SpawnNotify.Destroyed"><a class="headerlink" href="#SpawnNotify.Destroyed" title="Permanent link">Destroyed</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local SpawnNotify N;<br><br>&#9;<br>&#9;if(Level.SpawnNotify == Self)<br>&#9;{<br>&#9;&#9;Level.SpawnNotify = Next;<br>&#9;&#9;Next = None;&#9;&#9;<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;for(N = Level.SpawnNotify; N != None && N.Next != None; N = N.Next)<br>&#9;&#9;{<br>&#9;&#9;&#9;if(N.Next == Self)<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;N.Next = Next;<br>&#9;&#9;&#9;&#9;Next = None;<br>&#9;&#9;&#9;&#9;return;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="SpawnNotify.PostBeginPlay"><a class="headerlink" href="#SpawnNotify.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local SpawnNotify N;<br><br><br>&#9;for(N = Level.SpawnNotify; N != None; N = N.Next)<br>&#9;&#9;if(N == Self)<br>&#9;&#9;&#9;return;<br><br>&#9;Next = Level.SpawnNotify;<br>&#9;Level.SpawnNotify = Self;<br><br></div>
<h3 id="SpawnNotify.SpawnNotification"><a class="headerlink" href="#SpawnNotify.SpawnNotification" title="Permanent link">SpawnNotification</a> (Actor A) -> Actor</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return A;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#SpecialEvent.uc" title="Permanent link"><h2 id="SpecialEvent.uc">SpecialEvent.uc (extends Triggers)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() int        Damage;         // For DamagePlayer state.<br>var() name		 DamageType;<br>var() localized  string DamageString;<br>var() sound      Sound;          // For PlaySoundEffect state.<br>var() localized  string Message; // For all states.<br>var() bool       bBroadcast;     // To broadcast the message to all players.<br>var() bool       bPlayerViewRot; // Whether player can rotate the view while pathing.</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Texture=Texture'Engine.S_SpecialEvent'</div>
<h3 id="SpecialEvent.Trigger"><a class="headerlink" href="#SpecialEvent.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local InterpolationPoint i;<br><br>&#9;&#9;Global.Trigger( Self, EventInstigator );<br>&#9;&#9;if( EventInstigator!=None && EventInstigator.bIsPlayer && (Level.NetMode == NM_Standalone) )<br>&#9;&#9;{<br>&#9;&#9;&#9;foreach AllActors( class 'InterpolationPoint', i, Event )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if( i.Position == 0 )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;EventInstigator.GotoState('');<br>&#9;&#9;&#9;&#9;&#9;EventInstigator.SetCollision(True,false,false);<br>&#9;&#9;&#9;&#9;&#9;EventInstigator.bCollideWorld = False;<br>&#9;&#9;&#9;&#9;&#9;EventInstigator.Target = i;<br>&#9;&#9;&#9;&#9;&#9;EventInstigator.SetPhysics(PHYS_Interpolating);<br>&#9;&#9;&#9;&#9;&#9;EventInstigator.PhysRate = 1.0;<br>&#9;&#9;&#9;&#9;&#9;EventInstigator.PhysAlpha = 0.0;<br>&#9;&#9;&#9;&#9;&#9;EventInstigator.bInterpolating = true;<br>&#9;&#9;&#9;&#9;&#9;EventInstigator.AmbientSound = AmbientSound;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;<br></div>
<br><br><hr>
<a class="headerlink" href="#Spectator.uc" title="Permanent link"><h2 id="Spectator.uc">Spectator.uc (extends PlayerPawn)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var bool bChaseCam;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bChaseCam=True<br>AirSpeed=400.000000<br>Visibility=0<br>AttitudeToPlayer=ATTITUDE_Friendly<br>MenuName="Spectator"<br>bHidden=True<br>bCollideActors=False<br>bCollideWorld=False<br>bBlockActors=False<br>bBlockPlayers=False<br>bProjTarget=False</div>
<h3 id="Spectator.AltFire"><a class="headerlink" href="#Spectator.AltFire" title="Permanent link">AltFire</a> (optional float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bBehindView = false;<br>&#9;Viewtarget = None;<br>&#9;ClientMessage(ViewingFrom@OwnCamera, 'Event', true);<br><br></div>
<h3 id="Spectator.BehindView"><a class="headerlink" href="#Spectator.BehindView" title="Permanent link">BehindView</a> (Bool B)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bBehindView = B;<br>&#9;bChaseCam = bBehindView;<br>&#9;if ( ViewTarget == None )<br>&#9;&#9;bBehindView = false;<br><br></div>
<h3 id="Spectator.CallForHelp"><a class="headerlink" href="#Spectator.CallForHelp" title="Permanent link">CallForHelp</a></h3>

<h3 id="Spectator.ChangeTeam"><a class="headerlink" href="#Spectator.ChangeTeam" title="Permanent link">ChangeTeam</a> (int N)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Level.Game.ChangeTeam(self, N);<br><br></div>
<h3 id="Spectator.ClientReStart"><a class="headerlink" href="#Spectator.ClientReStart" title="Permanent link">ClientReStart</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;//log("client restart");<br>&#9;Velocity = vect(0,0,0);<br>&#9;Acceleration = vect(0,0,0);<br>&#9;BaseEyeHeight = Default.BaseEyeHeight;<br>&#9;EyeHeight = BaseEyeHeight;<br>&#9;<br>&#9;GotoState('CheatFlying');<br><br></div>
<h3 id="Spectator.Fire"><a class="headerlink" href="#Spectator.Fire" title="Permanent link">Fire</a> (optional float F)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;ViewPlayerNum(-1);<br>&#9;bBehindView = bChaseCam;<br>&#9;if ( ViewTarget == None )<br>&#9;&#9;bBehindView = false;<br><br></div>
<h3 id="Spectator.Fly"><a class="headerlink" href="#Spectator.Fly" title="Permanent link">Fly</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;UnderWaterTime = -1;&#9;<br>&#9;SetCollision(false, false, false);<br>&#9;bCollideWorld = true;<br>&#9;GotoState('CheatFlying');<br><br>&#9;ClientRestart();<br><br></div>
<h3 id="Spectator.FootZoneChange"><a class="headerlink" href="#Spectator.FootZoneChange" title="Permanent link">FootZoneChange</a> (ZoneInfo newFootZone)</h3>

<h3 id="Spectator.Grab"><a class="headerlink" href="#Spectator.Grab" title="Permanent link">Grab</a></h3>

<h3 id="Spectator.HeadZoneChange"><a class="headerlink" href="#Spectator.HeadZoneChange" title="Permanent link">HeadZoneChange</a> (ZoneInfo newHeadZone)</h3>

<h3 id="Spectator.InitPlayerReplicationInfo"><a class="headerlink" href="#Spectator.InitPlayerReplicationInfo" title="Permanent link">InitPlayerReplicationInfo</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.InitPlayerReplicationInfo();<br>&#9;PlayerReplicationInfo.bIsSpectator = true;<br><br></div>
<h3 id="Spectator.NextItem"><a class="headerlink" href="#Spectator.NextItem" title="Permanent link">NextItem</a></h3>

<h3 id="Spectator.PlayerTimeOut"><a class="headerlink" href="#Spectator.PlayerTimeOut" title="Permanent link">PlayerTimeOut</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Health > 0)<br>&#9;&#9;Died(None, 'dropped', Location);<br><br></div>
<h3 id="Spectator.Possess"><a class="headerlink" href="#Spectator.Possess" title="Permanent link">Possess</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bIsPlayer = true;<br>&#9;DodgeClickTime = FMin(0.3, DodgeClickTime);<br>&#9;EyeHeight = BaseEyeHeight;<br>&#9;NetPriority = 2;<br>&#9;Weapon = None;<br>&#9;Inventory = None;<br>&#9;Fly();<br><br></div>
<h3 id="Spectator.PostBeginPlay"><a class="headerlink" href="#Spectator.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Level.LevelEnterText != "" )<br>&#9;&#9;ClientMessage(Level.LevelEnterText);<br>&#9;bIsPlayer = true;<br>&#9;FlashScale = vect(1,1,1);<br>&#9;if ( Level.NetMode != NM_Client )<br>&#9;&#9;ScoringType = Level.Game.ScoreboardType;<br><br></div>
<h3 id="Spectator.PrevItem"><a class="headerlink" href="#Spectator.PrevItem" title="Permanent link">PrevItem</a></h3>

<h3 id="Spectator.RestartLevel"><a class="headerlink" href="#Spectator.RestartLevel" title="Permanent link">RestartLevel</a></h3>

<h3 id="Spectator.Say"><a class="headerlink" href="#Spectator.Say" title="Permanent link">Say</a> (string S)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Len(S) > 63 )<br>&#9;&#9;S = Left(S,63);<br>&#9;if ( !Level.Game.bMuteSpectators )<br>&#9;&#9;BroadcastMessage( PlayerReplicationInfo.PlayerName$":"$S, true );<br><br></div>
<h3 id="Spectator.ServerChangeSkin"><a class="headerlink" href="#Spectator.ServerChangeSkin" title="Permanent link">ServerChangeSkin</a> (coerce string SkinName, coerce string FaceName, byte TeamNum)</h3>

<h3 id="Spectator.Suicide"><a class="headerlink" href="#Spectator.Suicide" title="Permanent link">Suicide</a></h3>

<h3 id="Spectator.SwitchWeapon"><a class="headerlink" href="#Spectator.SwitchWeapon" title="Permanent link">SwitchWeapon</a> (byte F)</h3>

<h3 id="Spectator.Taunt"><a class="headerlink" href="#Spectator.Taunt" title="Permanent link">Taunt</a> (name Sequence)</h3>

<h3 id="Spectator.ThrowWeapon"><a class="headerlink" href="#Spectator.ThrowWeapon" title="Permanent link">ThrowWeapon</a></h3>

<h3 id="Spectator.Walk"><a class="headerlink" href="#Spectator.Walk" title="Permanent link">Walk</a></h3>

<br><br><hr>
<a class="headerlink" href="#Spotlight.uc" title="Permanent link"><h2 id="Spotlight.uc">Spotlight.uc (extends Light)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bDirectional=True<br>LightEffect=LE_Spotlight</div>
<br><br><hr>
<a class="headerlink" href="#StatLog.uc" title="Permanent link"><h2 id="StatLog.uc">StatLog.uc (extends Info)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var int		Context;<br>var bool	bWorld;<br>var() string LocalStandard;		// The standard this log is compliant to.<br>var() string WorldStandard;		// The standard this log is compliant to.<br>var() string LogVersion;		// Version of the log standard.<br>var() string LogInfoURL;		// URL to info on logging standard.<br>var() string GameName;			// Name of this game.<br>var() string GameCreator;		// Name of game creator.<br>var() string GameCreatorURL;	// URL to info on game creator.<br>var() string DecoderRingURL;	// URL to log format decoder ring.<br>var() globalconfig string	    LocalBatcherURL;		// Batcher URL.<br>var() globalconfig string	    LocalBatcherParams;		// Batcher command line parameters.<br>var() globalconfig string	    LocalStatsURL;			// URL to local stats information.<br>var() globalconfig string	    WorldBatcherURL;		// Batcher URL.<br>var() globalconfig string	    WorldBatcherParams;		// Batcher command line parameters.<br>var() globalconfig string	    WorldStatsURL;			// URL to world stats information.<br>var() globalconfig string		LocalLogDir;<br>var() globalconfig string		WorldLogDir;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">LocalStandard="ngLog"<br>WorldStandard="ngLog"<br>LogVersion="1.2"<br>LogInfoURL="http://www.netgamesusa.com/ngLog/"<br>GameName="Unreal"<br>GameCreator="Epic MegaGames, Inc."<br>GameCreatorURL="http://www.epicgames.com/"<br>DecoderRingURL="http://unreal.epicgames.com/Unreal_Log_Decoder_Ring.html"<br>LocalBatcherURL="../NetGamesUSA.com/ngStats/ngStatsUT.exe"<br>LocalStatsURL="../NetGamesUSA.com/ngStats/html/ngStats_Main.html"<br>WorldBatcherURL="../NetGamesUSA.com/ngWorldStats/bin/ngWorldStats.exe"<br>WorldBatcherParams="-d ../NetGamesUSA.com/ngWorldStats/logs -g UT"<br>WorldStatsURL="http://www.netgamesusa.com"<br>LocalLogDir="../Logs"<br>WorldLogDir="../NetGamesUSA.com/ngWorldStats/logs"</div>
<h3 id="StatLog.BatchLocal"><a class="headerlink" href="#StatLog.BatchLocal" title="Permanent link">BatchLocal</a> | native</h3>

<h3 id="StatLog.BeginPlay"><a class="headerlink" href="#StatLog.BeginPlay" title="Permanent link">BeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;SetTimer(30.0, True);<br><br></div>
<h3 id="StatLog.BrowseRelativeLocalURL"><a class="headerlink" href="#StatLog.BrowseRelativeLocalURL" title="Permanent link">BrowseRelativeLocalURL</a> (string URL) | native</h3>

<h3 id="StatLog.ExecuteLocalLogBatcher"><a class="headerlink" href="#StatLog.ExecuteLocalLogBatcher" title="Permanent link">ExecuteLocalLogBatcher</a> | native</h3>

<h3 id="StatLog.ExecuteSilentLogBatcher"><a class="headerlink" href="#StatLog.ExecuteSilentLogBatcher" title="Permanent link">ExecuteSilentLogBatcher</a> | native</h3>

<h3 id="StatLog.ExecuteWorldLogBatcher"><a class="headerlink" href="#StatLog.ExecuteWorldLogBatcher" title="Permanent link">ExecuteWorldLogBatcher</a> | native</h3>

<h3 id="StatLog.FlushLog"><a class="headerlink" href="#StatLog.FlushLog" title="Permanent link">FlushLog</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// Implemented in subclass.<br><br></div>
<h3 id="StatLog.GetAbsoluteTime"><a class="headerlink" href="#StatLog.GetAbsoluteTime" title="Permanent link">GetAbsoluteTime</a> -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string AbsoluteTime;<br>&#9;local string GMTRef;<br><br><br>&#9;AbsoluteTime = string(Level.Year);<br><br>&#9;if (Level.Month < 10)<br>&#9;&#9;AbsoluteTime = AbsoluteTime$".0"$Level.Month;<br>&#9;else<br>&#9;&#9;AbsoluteTime = AbsoluteTime$"."$Level.Month;<br><br>&#9;if (Level.Day < 10)<br>&#9;&#9;AbsoluteTime = AbsoluteTime$".0"$Level.Day;<br>&#9;else<br>&#9;&#9;AbsoluteTime = AbsoluteTime$"."$Level.Day;<br><br>&#9;if (Level.Hour < 10)<br>&#9;&#9;AbsoluteTime = AbsoluteTime$".0"$Level.Hour;<br>&#9;else<br>&#9;&#9;AbsoluteTime = AbsoluteTime$"."$Level.Hour;<br><br>&#9;if (Level.Minute < 10)<br>&#9;&#9;AbsoluteTime = AbsoluteTime$".0"$Level.Minute;<br>&#9;else<br>&#9;&#9;AbsoluteTime = AbsoluteTime$"."$Level.Minute;<br><br>&#9;if (Level.Second < 10)<br>&#9;&#9;AbsoluteTime = AbsoluteTime$".0"$Level.Second;<br>&#9;else<br>&#9;&#9;AbsoluteTime = AbsoluteTime$"."$Level.Second;<br><br>&#9;if (Level.Millisecond < 10)<br>&#9;&#9;AbsoluteTime = AbsoluteTime$".0"$Level.Millisecond;<br>&#9;else<br>&#9;&#9;AbsoluteTime = AbsoluteTime$"."$Level.Millisecond;<br><br>&#9;GMTRef = GetGMTRef();<br><br>&#9;AbsoluteTime = AbsoluteTime$"."$GMTRef;<br><br>&#9;TimeStamp = 0;<br><br>&#9;return AbsoluteTime;<br><br></div>
<h3 id="StatLog.GetGMTRef"><a class="headerlink" href="#StatLog.GetGMTRef" title="Permanent link">GetGMTRef</a> -> string | native</h3>

<h3 id="StatLog.GetLogFileName"><a class="headerlink" href="#StatLog.GetLogFileName" title="Permanent link">GetLogFileName</a> -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return "";<br><br></div>
<h3 id="StatLog.GetMapFileName"><a class="headerlink" href="#StatLog.GetMapFileName" title="Permanent link">GetMapFileName</a> -> string | native</h3>

<h3 id="StatLog.GetPlayerChecksum"><a class="headerlink" href="#StatLog.GetPlayerChecksum" title="Permanent link">GetPlayerChecksum</a> (PlayerPawn P, out string Checksum) | native</h3>

<h3 id="StatLog.GetShortAbsoluteTime"><a class="headerlink" href="#StatLog.GetShortAbsoluteTime" title="Permanent link">GetShortAbsoluteTime</a> -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string AbsoluteTime;<br><br><br>&#9;AbsoluteTime = string(Level.Year);<br><br>&#9;if (Level.Month < 10)<br>&#9;&#9;AbsoluteTime = AbsoluteTime$".0"$Level.Month;<br>&#9;else<br>&#9;&#9;AbsoluteTime = AbsoluteTime$"."$Level.Month;<br><br>&#9;if (Level.Day < 10)<br>&#9;&#9;AbsoluteTime = AbsoluteTime$".0"$Level.Day;<br>&#9;else<br>&#9;&#9;AbsoluteTime = AbsoluteTime$"."$Level.Day;<br><br>&#9;if (Level.Hour < 10)<br>&#9;&#9;AbsoluteTime = AbsoluteTime$".0"$Level.Hour;<br>&#9;else<br>&#9;&#9;AbsoluteTime = AbsoluteTime$"."$Level.Hour;<br><br>&#9;if (Level.Minute < 10)<br>&#9;&#9;AbsoluteTime = AbsoluteTime$".0"$Level.Minute;<br>&#9;else<br>&#9;&#9;AbsoluteTime = AbsoluteTime$"."$Level.Minute;<br><br>&#9;if (Level.Second < 10)<br>&#9;&#9;AbsoluteTime = AbsoluteTime$".0"$Level.Second;<br>&#9;else<br>&#9;&#9;AbsoluteTime = AbsoluteTime$"."$Level.Second;<br><br>&#9;TimeStamp = 0;<br><br>&#9;return AbsoluteTime;<br><br></div>
<h3 id="StatLog.GetTimeStamp"><a class="headerlink" href="#StatLog.GetTimeStamp" title="Permanent link">GetTimeStamp</a> -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string Time;<br>&#9;local int Pos;<br><br><br>&#9;Time = string(TimeStamp);<br>&#9;Time = Left(Time, InStr(Time, ".") + 3);<br>&#9;return Time;<br><br></div>
<h3 id="StatLog.InitialCheck"><a class="headerlink" href="#StatLog.InitialCheck" title="Permanent link">InitialCheck</a> (GameInfo Game) | native</h3>

<h3 id="StatLog.LogEventString"><a class="headerlink" href="#StatLog.LogEventString" title="Permanent link">LogEventString</a> (string EventString)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Log( EventString );<br><br></div>
<h3 id="StatLog.LogGameEnd"><a class="headerlink" href="#StatLog.LogGameEnd" title="Permanent link">LogGameEnd</a> (string Reason)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"game_end"$Chr(9)$Reason);<br><br></div>
<h3 id="StatLog.LogGameSpecial"><a class="headerlink" href="#StatLog.LogGameSpecial" title="Permanent link">LogGameSpecial</a> (String SpecialID, String SpecialParam)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"game"$Chr(9)$SpecialID$Chr(9)$SpecialParam);<br><br></div>
<h3 id="StatLog.LogGameSpecial2"><a class="headerlink" href="#StatLog.LogGameSpecial2" title="Permanent link">LogGameSpecial2</a> (String SpecialID, String SpecialParam, String SpecialParam2)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"game"$Chr(9)$SpecialID$Chr(9)$SpecialParam$Chr(9)$SpecialParam2);<br><br></div>
<h3 id="StatLog.LogGameStart"><a class="headerlink" href="#StatLog.LogGameStart" title="Permanent link">LogGameStart</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"game_start");<br><br></div>
<h3 id="StatLog.LogItemActivate"><a class="headerlink" href="#StatLog.LogItemActivate" title="Permanent link">LogItemActivate</a> (Inventory Item, Pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( (Other == None) || (Other.PlayerReplicationInfo == None) || (Item == None) )<br>&#9;&#9;return;<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"item_activate"$Chr(9)$Item.ItemName$Chr(9)$Other.PlayerReplicationInfo.PlayerID);<br><br></div>
<h3 id="StatLog.LogItemDeactivate"><a class="headerlink" href="#StatLog.LogItemDeactivate" title="Permanent link">LogItemDeactivate</a> (Inventory Item, Pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"item_deactivate"$Chr(9)$Item.ItemName$Chr(9)$Other.PlayerReplicationInfo.PlayerID);<br><br></div>
<h3 id="StatLog.LogKill"><a class="headerlink" href="#StatLog.LogKill" title="Permanent link">LogKill</a> (int KillerID, int VictimID, string KillerWeaponName, string VictimWeaponName, name DamageType)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"kill"$Chr(9)$KillerID$Chr(9)$KillerWeaponName$Chr(9)$VictimID$Chr(9)$VictimWeaponName$Chr(9)$DamageType);<br><br></div>
<h3 id="StatLog.LogMapParameters"><a class="headerlink" href="#StatLog.LogMapParameters" title="Permanent link">LogMapParameters</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string MapName;<br><br><br>&#9;MapName = GetMapFileName();<br><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"map"$Chr(9)$"Name"$Chr(9)$MapName);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"map"$Chr(9)$"Title"$Chr(9)$Level.Title);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"map"$Chr(9)$"Author"$Chr(9)$Level.Author);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"map"$Chr(9)$"IdealPlayerCount"$Chr(9)$Level.IdealPlayerCount);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"map"$Chr(9)$"LevelEnterText"$Chr(9)$Level.LevelEnterText);<br><br></div>
<h3 id="StatLog.LogMutator"><a class="headerlink" href="#StatLog.LogMutator" title="Permanent link">LogMutator</a> (Mutator M) | native</h3>

<h3 id="StatLog.LogNameChange"><a class="headerlink" href="#StatLog.LogNameChange" title="Permanent link">LogNameChange</a> (Pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"player"$Chr(9)$"Rename"$Chr(9)$Other.PlayerReplicationInfo.PlayerName$Chr(9)$Other.PlayerReplicationInfo.PlayerID);<br><br></div>
<h3 id="StatLog.LogPickup"><a class="headerlink" href="#StatLog.LogPickup" title="Permanent link">LogPickup</a> (Inventory Item, Pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Item.ItemName != "")<br>&#9;&#9;LogEventString(GetTimeStamp()$Chr(9)$"item_get"$Chr(9)$Item.ItemName$Chr(9)$Other.PlayerReplicationInfo.PlayerID);<br>&#9;else<br>&#9;&#9;LogEventString(GetTimeStamp()$Chr(9)$"item_get"$Chr(9)$Item.Class$Chr(9)$Other.PlayerReplicationInfo.PlayerID);<br><br></div>
<h3 id="StatLog.LogPings"><a class="headerlink" href="#StatLog.LogPings" title="Permanent link">LogPings</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local PlayerReplicationInfo PRI;<br><br><br>&#9;foreach AllActors(class'PlayerReplicationInfo', PRI)<br>&#9;&#9;LogEventString(GetTimeStamp()$Chr(9)$"player"$Chr(9)$"Ping"$Chr(9)$PRI.PlayerID$Chr(9)$PRI.Ping);<br><br></div>
<h3 id="StatLog.LogPlayerConnect"><a class="headerlink" href="#StatLog.LogPlayerConnect" title="Permanent link">LogPlayerConnect</a> (Pawn Player, optional string Checksum)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Player.IsA('PlayerPawn'))<br>&#9;&#9;LogEventString(GetTimeStamp()$Chr(9)$"player"$Chr(9)$"Connect"$Chr(9)$Player.PlayerReplicationInfo.PlayerName$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$PlayerPawn(Player).bAdmin);<br>&#9;else<br>&#9;&#9;LogEventString(GetTimeStamp()$Chr(9)$"player"$Chr(9)$"Connect"$Chr(9)$Player.PlayerReplicationInfo.PlayerName$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$False);<br>&#9;LogPlayerInfo(Player);<br><br></div>
<h3 id="StatLog.LogPlayerDisconnect"><a class="headerlink" href="#StatLog.LogPlayerDisconnect" title="Permanent link">LogPlayerDisconnect</a> (Pawn Player)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"player"$Chr(9)$"Disconnect"$Chr(9)$Player.PlayerReplicationInfo.PlayerID);<br><br></div>
<h3 id="StatLog.LogPlayerInfo"><a class="headerlink" href="#StatLog.LogPlayerInfo" title="Permanent link">LogPlayerInfo</a> (Pawn Player)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"player"$Chr(9)$"TeamName"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.TeamName);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"player"$Chr(9)$"Team"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.Team);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"player"$Chr(9)$"TeamID"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.TeamID);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"player"$Chr(9)$"Ping"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.Ping);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"player"$Chr(9)$"IsABot"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.PlayerReplicationInfo.bIsABot);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"player"$Chr(9)$"Skill"$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$Player.Skill);<br><br></div>
<h3 id="StatLog.LogServerInfo"><a class="headerlink" href="#StatLog.LogServerInfo" title="Permanent link">LogServerInfo</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string NetworkNumber;<br><br><br>&#9;NetworkNumber = Level.Game.GetNetworkNumber();<br><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Server_ServerName"$Chr(9)$Level.Game.GameReplicationInfo.ServerName);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Server_AdminName"$Chr(9)$Level.Game.GameReplicationInfo.AdminName);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Server_AdminEmail"$Chr(9)$Level.Game.GameReplicationInfo.AdminEmail);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Server_Region"$Chr(9)$Level.Game.GameReplicationInfo.Region);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Server_MOTDLine1"$Chr(9)$Level.Game.GameReplicationInfo.MOTDLine1);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Server_MOTDLine2"$Chr(9)$Level.Game.GameReplicationInfo.MOTDLine2);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Server_MOTDLine3"$Chr(9)$Level.Game.GameReplicationInfo.MOTDLine3);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Server_MOTDLine4"$Chr(9)$Level.Game.GameReplicationInfo.MOTDLine4);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Server_IP"$Chr(9)$NetworkNumber);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Server_Port"$Chr(9)$Level.Game.GetServerPort());<br><br></div>
<h3 id="StatLog.LogSpecialEvent"><a class="headerlink" href="#StatLog.LogSpecialEvent" title="Permanent link">LogSpecialEvent</a> (string EventType, optional coerce string Arg1, optional coerce string Arg2, optional coerce string Arg3, optional coerce string Arg4)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string Event;<br><br><br>&#9;Event = EventType;<br>&#9;if (Arg1 != "")<br>&#9;&#9;Event = Event$Chr(9)$Arg1;<br>&#9;if (Arg2 != "")<br>&#9;&#9;Event = Event$Chr(9)$Arg2;<br>&#9;if (Arg3 != "")<br>&#9;&#9;Event = Event$Chr(9)$Arg3;<br>&#9;if (Arg4 != "")<br>&#9;&#9;Event = Event$Chr(9)$Arg4;<br><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$Event);<br><br></div>
<h3 id="StatLog.LogStandardInfo"><a class="headerlink" href="#StatLog.LogStandardInfo" title="Permanent link">LogStandardInfo</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (bWorld)<br>&#9;&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Log_Standard"$Chr(9)$WorldStandard);<br>&#9;else<br>&#9;&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Log_Standard"$Chr(9)$LocalStandard);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Log_Version"$Chr(9)$LogVersion);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Log_Info_URL"$Chr(9)$LogInfoURL);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Game_Name"$Chr(9)$GameName);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Game_Version"$Chr(9)$Level.EngineVersion);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Game_Creator"$Chr(9)$GameCreator);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Game_Creator_URL"$Chr(9)$GameCreatorURL);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Game_Decoder_Ring_URL"$Chr(9)$DecoderRingURL);<br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"info"$Chr(9)$"Absolute_Time"$Chr(9)$GetAbsoluteTime());&#9;<br><br></div>
<h3 id="StatLog.LogSuicide"><a class="headerlink" href="#StatLog.LogSuicide" title="Permanent link">LogSuicide</a> (Pawn Killed, name DamageType, Pawn Instigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int KilledID;<br>&#9;local string InstigatorString;<br><br><br>&#9;if (Killed == None)<br>&#9;&#9;return;<br><br>&#9;KilledID = Killed.PlayerReplicationInfo.PlayerID;<br>&#9;if (Instigator == None)<br>&#9;&#9;InstigatorString = "None";<br>&#9;else<br>&#9;&#9;InstigatorString = "Self";<br><br>&#9;if (Killed.Weapon != None)<br>&#9;&#9;LogEventString(GetTimeStamp()$Chr(9)$"suicide"$Chr(9)$KilledID$Chr(9)$Killed.Weapon.ItemName$Chr(9)$DamageType$Chr(9)$InstigatorString);<br>&#9;else<br>&#9;&#9;LogEventString(GetTimeStamp()$Chr(9)$"suicide"$Chr(9)$KilledID$Chr(9)$"None"$Chr(9)$DamageType$Chr(9)$InstigatorString);<br><br></div>
<h3 id="StatLog.LogTeamChange"><a class="headerlink" href="#StatLog.LogTeamChange" title="Permanent link">LogTeamChange</a> (Pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"player"$Chr(9)$"Teamchange"$Chr(9)$Other.PlayerReplicationInfo.PlayerID$Chr(9)$Other.PlayerReplicationInfo.Team);<br><br></div>
<h3 id="StatLog.LogTeamKill"><a class="headerlink" href="#StatLog.LogTeamKill" title="Permanent link">LogTeamKill</a> (int KillerID, int VictimID, string KillerWeaponName, string VictimWeaponName, name DamageType)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"teamkill"$Chr(9)$KillerID$Chr(9)$KillerWeaponName$Chr(9)$VictimID$Chr(9)$VictimWeaponName$Chr(9)$DamageType);<br><br></div>
<h3 id="StatLog.LogTypingEvent"><a class="headerlink" href="#StatLog.LogTypingEvent" title="Permanent link">LogTypingEvent</a> (bool bTyping, Pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogEventString(GetTimeStamp()$Chr(9)$"typing"$Chr(9)$bTyping$Chr(9)$Other.PlayerReplicationInfo.PlayerID);<br><br></div>
<h3 id="StatLog.StartLog"><a class="headerlink" href="#StatLog.StartLog" title="Permanent link">StartLog</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// Implemented in subclass.<br><br></div>
<h3 id="StatLog.StopLog"><a class="headerlink" href="#StatLog.StopLog" title="Permanent link">StopLog</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// Implemented in subclass.<br><br></div>
<h3 id="StatLog.Tick"><a class="headerlink" href="#StatLog.Tick" title="Permanent link">Tick</a> (float Delta)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TimeStamp += Delta;<br><br></div>
<h3 id="StatLog.Timer"><a class="headerlink" href="#StatLog.Timer" title="Permanent link">Timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;LogPings();<br><br></div>
<br><br><hr>
<a class="headerlink" href="#StatLogFile.uc" title="Permanent link"><h2 id="StatLogFile.uc">StatLogFile.uc (extends StatLog)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var bool bWatermark;<br>var int LogAr; // C++ FArchive*.<br>var string StatLogFile;<br>var string StatLogFinal;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">StatLogFile="../Logs/unreal.ngStats.Unknown.log"</div>
<h3 id="StatLogFile.CloseLog"><a class="headerlink" href="#StatLogFile.CloseLog" title="Permanent link">CloseLog</a> | native</h3>

<h3 id="StatLogFile.FileFlush"><a class="headerlink" href="#StatLogFile.FileFlush" title="Permanent link">FileFlush</a> | native</h3>

<h3 id="StatLogFile.FileLog"><a class="headerlink" href="#StatLogFile.FileLog" title="Permanent link">FileLog</a> (string EventString) | native</h3>

<h3 id="StatLogFile.FlushLog"><a class="headerlink" href="#StatLogFile.FlushLog" title="Permanent link">FlushLog</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;FileFlush();<br><br></div>
<h3 id="StatLogFile.GetChecksum"><a class="headerlink" href="#StatLogFile.GetChecksum" title="Permanent link">GetChecksum</a> (out string Checksum) | native</h3>

<h3 id="StatLogFile.GetLogFileName"><a class="headerlink" href="#StatLogFile.GetLogFileName" title="Permanent link">GetLogFileName</a> -> string</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return StatLogFinal;<br><br></div>
<h3 id="StatLogFile.LogEventString"><a class="headerlink" href="#StatLogFile.LogEventString" title="Permanent link">LogEventString</a> (string EventString)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( bWatermark )<br>&#9;&#9;Watermark( EventString );<br>&#9;FileLog( EventString );<br>&#9;FlushLog();<br><br></div>
<h3 id="StatLogFile.LogGameEnd"><a class="headerlink" href="#StatLogFile.LogGameEnd" title="Permanent link">LogGameEnd</a> (string Reason)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string Checksum;<br><br><br>&#9;if( bWorld )<br>&#9;{<br>&#9;&#9;bWatermark = False;<br>&#9;&#9;GetChecksum( Checksum );<br>&#9;&#9;LogEventString(GetTimeStamp()$Chr(9)$"game_end"$Chr(9)$Reason$Chr(9)$Checksum$"");<br>&#9;}<br>&#9;else Super.LogGameEnd(Reason);<br><br></div>
<h3 id="StatLogFile.LogPlayerConnect"><a class="headerlink" href="#StatLogFile.LogPlayerConnect" title="Permanent link">LogPlayerConnect</a> (Pawn Player, optional string Checksum)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( bWorld )<br>&#9;{<br>&#9;&#9;if( Player.PlayerReplicationInfo.bIsABot )<br>&#9;&#9;&#9;Checksum = "IsABot";<br>&#9;&#9;if (Player.IsA('PlayerPawn'))<br>&#9;&#9;&#9;LogEventString( GetTimeStamp()$Chr(9)$"player"$Chr(9)$"Connect"$Chr(9)$Player.PlayerReplicationInfo.PlayerName$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$PlayerPawn(Player).bAdmin$Chr(9)$Checksum );<br>&#9;&#9;else<br>&#9;&#9;&#9;LogEventString( GetTimeStamp()$Chr(9)$"player"$Chr(9)$"Connect"$Chr(9)$Player.PlayerReplicationInfo.PlayerName$Chr(9)$Player.PlayerReplicationInfo.PlayerID$Chr(9)$False$Chr(9)$Checksum );<br>&#9;&#9;LogPlayerInfo( Player );<br>&#9;}<br>&#9;else Super.LogPlayerConnect( Player, Checksum );<br><br></div>
<h3 id="StatLogFile.OpenLog"><a class="headerlink" href="#StatLogFile.OpenLog" title="Permanent link">OpenLog</a> | native</h3>

<h3 id="StatLogFile.StartLog"><a class="headerlink" href="#StatLogFile.StartLog" title="Permanent link">StartLog</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string FileName;<br>&#9;local string AbsoluteTime;<br><br><br>&#9;SaveConfig();<br><br>&#9;AbsoluteTime = GetShortAbsoluteTime();<br>&#9;if (!bWorld)<br>&#9;{<br>&#9;&#9;FileName = LocalLogDir$"/"$GameName$"."$LocalStandard$"."$AbsoluteTime$"."$Level.Game.GetServerPort();<br>&#9;&#9;StatLogFile = FileName$".tmp";<br>&#9;&#9;StatLogFinal = FileName$".log";<br>&#9;} else {<br>&#9;&#9;FileName = WorldLogDir$"/"$GameName$"."$WorldStandard$"."$AbsoluteTime$"."$Level.Game.GetServerPort();<br>&#9;&#9;StatLogFile = FileName$".tmp";<br>&#9;&#9;StatLogFinal = FileName$".log";<br>&#9;&#9;bWatermark = True;<br>&#9;<br></div>
<h3 id="StatLogFile.StopLog"><a class="headerlink" href="#StatLogFile.StopLog" title="Permanent link">StopLog</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;FlushLog();<br>&#9;CloseLog();<br><br></div>
<h3 id="StatLogFile.Watermark"><a class="headerlink" href="#StatLogFile.Watermark" title="Permanent link">Watermark</a> (string EventString) | native</h3>

<br><br><hr>
<a class="headerlink" href="#Teleporter.uc" title="Permanent link"><h2 id="Teleporter.uc">Teleporter.uc (extends NavigationPoint)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() string URL;<br>var() name ProductRequired;<br>var() bool    bChangesVelocity; // Set velocity to TargetVelocity.<br>var() bool    bChangesYaw;      // Sets yaw to teleporter's Rotation.Yaw<br>var() bool    bReversesX;       // Reverses X-component of velocity.<br>var() bool    bReversesY;       // Reverses Y-component of velocity.<br>var() bool    bReversesZ;       // Reverses Z-component of velocity.<br>var() bool	  bEnabled;			// Teleporter is turned on;<br>var() vector  TargetVelocity;   // If bChangesVelocity, set target's velocity to this.<br>var Actor TriggerActor;		//used to tell AI how to trigger me<br>var Actor TriggerActor2;<br>var float LastFired;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bChangesYaw=True<br>bEnabled=True<br>RemoteRole=ROLE_SimulatedProxy<br>bDirectional=True<br>Texture=Texture'Engine.S_Teleport'<br>SoundVolume=128<br>CollisionRadius=18.000000<br>CollisionHeight=40.000000<br>bCollideActors=True</div>
<h3 id="Teleporter.Accept"><a class="headerlink" href="#Teleporter.Accept" title="Permanent link">Accept</a> (actor Incoming, Actor Source) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local rotator newRot, oldRot;<br>&#9;local int oldYaw;<br>&#9;local float mag;<br>&#9;local vector oldDir;<br>&#9;local pawn P;<br><br><br>&#9;// Move the actor here.<br>&#9;Disable('Touch');<br>&#9;//log("Move Actor here "$tag);<br>&#9;newRot = Incoming.Rotation;<br>&#9;if (bChangesYaw)<br>&#9;{<br>&#9;&#9;oldRot = Incoming.Rotation;<br>&#9;&#9;newRot.Yaw = Rotation.Yaw;<br>&#9;&#9;if ( Source != None )<br>&#9;&#9;&#9;newRot.Yaw += (32768 + Incoming.Rotation.Yaw - Source.Rotation.Yaw);<br>&#9;}<br><br>&#9;if ( Pawn(Incoming) != None )<br>&#9;{<br>&#9;&#9;//tell enemies about teleport<br>&#9;&#9;if ( Role == ROLE_Authority )<br>&#9;&#9;{<br>&#9;&#9;&#9;P = Level.PawnList;<br>&#9;&#9;&#9;While ( P != None )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;if (P.Enemy == Incoming)<br>&#9;&#9;&#9;&#9;&#9;P.LastSeenPos = Incoming.Location; <br>&#9;&#9;&#9;&#9;P = P.nextPawn;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;&#9;Pawn(Incoming).SetLocation(Location);<br>&#9;&#9;if ( (Role == ROLE_Authority) <br>&#9;&#9;&#9;|| (Level.TimeSeconds - LastFired > 0.5) )<br>&#9;&#9;{<br>&#9;&#9;&#9;Pawn(Incoming).SetRotation(newRot);<br>&#9;&#9;&#9;Pawn(Incoming).ViewRotation = newRot;<br>&#9;&#9;&#9;LastFired = Level.TimeSeconds;<br>&#9;&#9;}<br>&#9;&#9;Pawn(Incoming).MoveTimer = -1.0;<br>&#9;&#9;Pawn(Incoming).MoveTarget = self;<br>&#9;&#9;PlayTeleportEffect( Incoming, false);<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;if ( !Incoming.SetLocation(Location) )<br>&#9;&#9;{<br>&#9;&#9;&#9;Enable('Touch');<br>&#9;&#9;&#9;return false;<br>&#9;&#9;}<br>&#9;&#9;if ( bChangesYaw )<br>&#9;&#9;&#9;Incoming.SetRotation(newRot);<br>&#9;}<br><br>&#9;Enable('Touch');<br><br>&#9;<br>&#9;if (bChangesVelocity)<br>&#9;&#9;Incoming.Velocity = TargetVelocity;<br>&#9;else<br>&#9;{<br>&#9;&#9;if ( bChangesYaw )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( Incoming.Physics == PHYS_Walking )<br>&#9;&#9;&#9;&#9;OldRot.Pitch = 0;<br>&#9;&#9;&#9;oldDir = vector(OldRot);<br>&#9;&#9;&#9;mag = Incoming.Velocity Dot oldDir;&#9;&#9;<br>&#9;&#9;&#9;Incoming.Velocity = Incoming.Velocity - mag * oldDir + mag * vector(Incoming.Rotation);<br>&#9;&#9;} <br>&#9;&#9;if ( bReversesX )<br>&#9;&#9;&#9;Incoming.Velocity.X *= -1.0;<br>&#9;&#9;if ( bReversesY )<br>&#9;&#9;&#9;Incoming.Velocity.Y *= -1.0;<br>&#9;&#9;if ( bReversesZ )<br>&#9;&#9;&#9;Incoming.Velocity.Z *= -1.0;<br>&#9;}&#9;<br><br>&#9;// Play teleport-in effect.<br><br>&#9;return true;<br><br></div>
<h3 id="Teleporter.FindTriggerActor"><a class="headerlink" href="#Teleporter.FindTriggerActor" title="Permanent link">FindTriggerActor</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Actor A;<br><br><br>&#9;TriggerActor = None;<br>&#9;TriggerActor2 = None;<br>&#9;ForEach AllActors(class 'Actor', A)<br>&#9;&#9;if ( A.Event == Tag)<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( Counter(A) != None )<br>&#9;&#9;&#9;&#9;return; //FIXME - handle counters<br>&#9;&#9;&#9;if (TriggerActor == None)<br>&#9;&#9;&#9;&#9;TriggerActor = A;<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;TriggerActor2 = A;<br>&#9;&#9;&#9;&#9;return;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br><br></div>
<h3 id="Teleporter.PlayTeleportEffect"><a class="headerlink" href="#Teleporter.PlayTeleportEffect" title="Permanent link">PlayTeleportEffect</a> (actor Incoming, bool bOut)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Incoming.IsA('Pawn') )<br>&#9;{<br>&#9;&#9;Incoming.MakeNoise(1.0);<br>&#9;&#9;Level.Game.PlayTeleportEffect(Incoming, bOut, true);<br>&#9;}<br><br></div>
<h3 id="Teleporter.PostBeginPlay"><a class="headerlink" href="#Teleporter.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (URL ~= "")<br>&#9;&#9;SetCollision(false, false, false); //destination only<br>&#9;&#9;<br>&#9;if ( !bEnabled )<br>&#9;&#9;FindTriggerActor();<br>&#9;Super.PostBeginPlay();<br><br></div>
<h3 id="Teleporter.SpecialHandling"><a class="headerlink" href="#Teleporter.SpecialHandling" title="Permanent link">SpecialHandling</a> (Pawn Other) -> Actor</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br>&#9;local vector Dist2D;<br><br>&#9;if ( bEnabled && (Other.RouteCache[1] != None)<br>&#9;&#9;&& Other.RouteCache[1].IsA('Teleporter') && (string(Other.RouteCache[1].tag)~=URL) )<br>&#9;{<br>&#9;&#9;if ( Abs(Location.Z - Other.Location.Z) < CollisionHeight + Other.CollisionHeight )<br>&#9;&#9;{<br>&#9;&#9;&#9;Dist2D = Location - Other.Location;<br>&#9;&#9;&#9;Dist2D.Z = 0;<br>&#9;&#9;&#9;if ( VSize(Dist2D) < CollisionRadius + Other.CollisionRadius )<br>&#9;&#9;&#9;&#9;Touch(Other);<br>&#9;&#9;}&#9;<br>&#9;&#9;return self;<br>&#9;}<br><br>&#9;if (TriggerActor == None)<br>&#9;{<br>&#9;&#9;FindTriggerActor();<br>&#9;&#9;if (TriggerActor == None)<br>&#9;&#9;&#9;return None;<br>&#9;}<br><br>&#9;if ( (TriggerActor2 != None) <br>&#9;&#9;&& (VSize(TriggerActor2.Location - Other.Location) < VSize(TriggerActor.Location - Other.Location)) )<br>&#9;&#9;return TriggerActor2;<br>&#9;&#9;&#9;&#9;&#9;<br>&#9;return TriggerActor;&#9;&#9;&#9;<br><br></div>
<h3 id="Teleporter.Touch"><a class="headerlink" href="#Teleporter.Touch" title="Permanent link">Touch</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Teleporter Dest;<br>&#9;local int i;<br>&#9;local Actor A;<br><br>&#9;<br>&#9;if ( !bEnabled )<br>&#9;&#9;return;<br><br>&#9;if( Other.bCanTeleport && Other.PreTeleport(Self)==false )<br>&#9;{<br>&#9;&#9;if( (InStr( URL, "/" ) >= 0) || (InStr( URL, "#" ) >= 0) )<br>&#9;&#9;{<br>&#9;&#9;&#9;// Teleport to a level on the net.<br>&#9;&#9;&#9;if( (Role == ROLE_Authority) && (PlayerPawn(Other) != None) )<br>&#9;&#9;&#9;&#9;Level.Game.SendPlayer(PlayerPawn(Other), URL);<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;{<br>&#9;&#9;&#9;// Teleport to a random teleporter in this local level, if more than one pick random.<br><br>&#9;&#9;&#9;foreach AllActors( class 'Teleporter', Dest )<br>&#9;&#9;&#9;&#9;if( string(Dest.tag)~=URL && Dest!=Self )<br>&#9;&#9;&#9;&#9;&#9;i++;<br>&#9;&#9;&#9;i = rand(i);<br>&#9;&#9;&#9;foreach AllActors( class 'Teleporter', Dest )<br>&#9;&#9;&#9;&#9;if( string(Dest.tag)~=URL && Dest!=Self && i-- == 0 )<br>&#9;&#9;&#9;&#9;&#9;break;<br>&#9;&#9;&#9;if( Dest != None )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;// Teleport the actor into the other teleporter.<br>&#9;&#9;&#9;&#9;if ( Other.IsA('Pawn') )<br>&#9;&#9;&#9;&#9;&#9;PlayTeleportEffect( Pawn(Other), false);<br>&#9;&#9;&#9;&#9;Dest.Accept( Other, self );<br>&#9;&#9;&#9;&#9;if( (Event != '') && (Other.IsA('Pawn')) )<br>&#9;&#9;&#9;&#9;&#9;foreach AllActors( class 'Actor', A, Event )<br>&#9;&#9;&#9;&#9;&#9;&#9;A.Trigger( Other, Other.Instigator );<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;else if ( Role == ROLE_Authority )<br>&#9;&#9;&#9;&#9;Pawn(Other).ClientMessage( "Teleport destination for "$self$" not found!" );<br>&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="Teleporter.Trigger"><a class="headerlink" href="#Teleporter.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br><br><br>&#9;bEnabled = !bEnabled;<br>&#9;if ( bEnabled ) //teleport any pawns already in my radius<br>&#9;&#9;for (i=0;i<4;i++)<br>&#9;&#9;&#9;if ( Touching[i] != None )<br>&#9;&#9;&#9;&#9;Touch(Touching[i]);<br><br></div>
<br><br><hr>
<a class="headerlink" href="#TestInfo.uc" title="Permanent link"><h2 id="TestInfo.uc">TestInfo.uc (extends Info)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() bool bTrue1;<br>var() bool bFalse1;<br>var() bool bTrue2;<br>var() bool bFalse2;<br>var bool bBool1;<br>var bool bBool2;<br>var() int xnum;<br>var float ppp;<br>var string sxx;<br>var int MyArray[2];<br>var vector v1,v2;<br>var string TestRepStr;<br>var struct STest<br>var bool b1;<br>var int i;<br>var bool b2;<br>var bool b3;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bTrue1=True<br>bTrue2=True<br>xnum=777<br>ppp=3.140000<br>sxx="Tim"<br>bHidden=False<br>RemoteRole=ROLE_SimulatedProxy<br>bAlwaysRelevant=True</div>
<h3 id="TestInfo.BeginPlay"><a class="headerlink" href="#TestInfo.BeginPlay" title="Permanent link">BeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local testobj to;<br>&#9;local object oo;<br><br>&#9;to = new class'TestObj';<br>&#9;to = new()class'TestObj';<br>&#9;to = new(self)class'TestObj';<br>&#9;to = new(self,'')class'TestObj';<br>&#9;to = new(self,'',0)class'TestObj';<br>&#9;to.Test();<br>&#9;TestStructBools();<br><br></div>
<h3 id="TestInfo.OtherStatic"><a class="headerlink" href="#TestInfo.OtherStatic" title="Permanent link">OtherStatic</a> (int i) -> int</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;assert(i==246);<br>&#9;assert(default.xnum==777);<br>&#9;return 555;<br><br></div>
<h3 id="TestInfo.PostBeginPlay"><a class="headerlink" href="#TestInfo.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local object o;<br>&#9;local actor TempActor;<br><br>&#9;log("!!BEGIN");<br><br>&#9;default.v1=vect(5,4,3);<br>&#9;assert(default.v1==vect(5,4,3));<br>&#9;test();<br>&#9;assert(default.v1==vect(1,2,3));<br><br>&#9;BroadcastMessage(Tag);<br>&#9;BroadcastMessage(string(Tag));<br>&#9;BroadcastMessage("test "$string(Tag));<br>&#9;assert(IsA('Actor'));<br>&#9;assert(IsA('TestInfo'));<br>&#9;assert(IsA('Info'));<br>&#9;assert(!IsA('LevelInfo'));<br>&#9;assert(!IsA('Texture'));<br>&#9;//o=dynamicloadobject( "UnrealShare.AutoMag.Reload", class'object' );<br>&#9;//assert(o!=None);<br>&#9;//assert(o==None);<br>&#9;log("!!END");<br><br></div>
<h3 id="TestInfo.RecurseTest"><a class="headerlink" href="#TestInfo.RecurseTest" title="Permanent link">RecurseTest</a> -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bBool1=true;<br>&#9;return false;<br><br></div>
<h3 id="TestInfo.SubTestOptionalOut"><a class="headerlink" href="#TestInfo.SubTestOptionalOut" title="Permanent link">SubTestOptionalOut</a> (optional out int a, optional out int b, optional out int c)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;a *= 2;<br>&#9;b = b*2;<br>&#9;c += c;<br><br></div>
<h3 id="TestInfo.TestContinueDoUntil"><a class="headerlink" href="#TestInfo.TestContinueDoUntil" title="Permanent link">TestContinueDoUntil</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br><br>&#9;log("TestContinue");<br>&#9;do<br>&#9;{<br>&#9;&#9;i++;<br>&#9;&#9;log("iteration "$i);<br>&#9;&#9;if(i==7||i==9||i>18)<br>&#9;&#9;&#9;continue;<br>&#9;&#9;log("...");<br>&#9;} until( i>20 );<br>&#9;log("DoneContinue");<br><br></div>
<h3 id="TestInfo.TestContinueFor"><a class="headerlink" href="#TestInfo.TestContinueFor" title="Permanent link">TestContinueFor</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br><br>&#9;log("TestContinue");<br>&#9;for( i=0; i<20; i++ )<br>&#9;{<br>&#9;&#9;log("iteration "$i);<br>&#9;&#9;if(i==7||i==9||i==19)<br>&#9;&#9;&#9;continue;<br>&#9;&#9;log("...");<br>&#9;}<br>&#9;log("DoneContinue");<br><br></div>
<h3 id="TestInfo.TestContinueForEach"><a class="headerlink" href="#TestInfo.TestContinueForEach" title="Permanent link">TestContinueForEach</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor a;<br><br>&#9;log("TestContinue");<br>&#9;foreach AllActors( class'Actor', a )<br>&#9;{<br>&#9;&#9;log("actor "$a);<br>&#9;&#9;if(light(a)==none)<br>&#9;&#9;&#9;continue;<br>&#9;&#9;log("...");<br>&#9;}<br>&#9;log("DoneContinue");<br><br></div>
<h3 id="TestInfo.TestContinueWhile"><a class="headerlink" href="#TestInfo.TestContinueWhile" title="Permanent link">TestContinueWhile</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br><br>&#9;log("TestContinue");<br>&#9;while( ++i <= 20 )<br>&#9;{<br>&#9;&#9;log("iteration "$i);<br>&#9;&#9;if(i==7||i==9)<br>&#9;&#9;&#9;continue;<br>&#9;&#9;log("...");<br>&#9;}<br>&#9;log("DoneContinue");<br><br></div>
<h3 id="TestInfo.TestNullContext"><a class="headerlink" href="#TestInfo.TestNullContext" title="Permanent link">TestNullContext</a> (actor a)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bHidden = a.bHidden;<br>&#9;a.bHidden = bHidden;<br><br></div>
<h3 id="TestInfo.TestOptionalOut"><a class="headerlink" href="#TestInfo.TestOptionalOut" title="Permanent link">TestOptionalOut</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int a,b,c;<br><br>&#9;a=1; b=2; c=3;<br><br>&#9;SubTestOptionalOut(a,b,c);<br>&#9;assert(a==2); assert(b==4); assert(c==6);<br><br>&#9;SubTestOptionalOut(a,b);<br>&#9;assert(a==4); assert(b==8); assert(c==6);<br><br>&#9;SubTestOptionalOut(,b,c);<br>&#9;assert(a==4); assert(b==16); assert(c==12);<br><br>&#9;SubTestOptionalOut();<br>&#9;assert(a==4); assert(b==16); assert(c==12);<br><br>&#9;SubTestOptionalOut(a,b,c);<br>&#9;assert(a==8); assert(b==32); assert(c==24);<br><br>&#9;log("TestOptionalOut ok!");<br><br></div>
<h3 id="TestInfo.TestQ"><a class="headerlink" href="#TestInfo.TestQ" title="Permanent link">TestQ</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector v;<br><br>&#9;v.x = 2;<br>&#9;v.y = 3;<br>&#9;v.z = 4;<br>&#9;assert(v==vect(2,3,4));<br>&#9;assert(v.z==4);<br>&#9;assert(v.y==3);<br>&#9;assert(v.x==2);<br><br></div>
<h3 id="TestInfo.TestStatic"><a class="headerlink" href="#TestInfo.TestStatic" title="Permanent link">TestStatic</a> (int i) -> int</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;assert(i==123);<br>&#9;assert(default.xnum==777);<br>&#9;assert(OtherStatic(i*2)==555);<br><br></div>
<h3 id="TestInfo.TestStructBools"><a class="headerlink" href="#TestInfo.TestStructBools" title="Permanent link">TestStructBools</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;assert(ST.b1==false);<br>&#9;assert(ST.b2==false);<br>&#9;assert(ST.b3==false);<br><br>&#9;ST.b1=true;<br>&#9;assert(ST.b1==true);<br>&#9;assert(ST.b2==false);<br>&#9;assert(ST.b3==false);<br><br>&#9;ST.b2=true;<br>&#9;assert(ST.b1==true);<br>&#9;assert(ST.b2==true);<br>&#9;assert(ST.b3==false);<br><br>&#9;ST.b3=true;<br>&#9;assert(ST.b1==true);<br>&#9;assert(ST.b2==true);<br>&#9;assert(ST.b3==true);<br><br>&#9;ST.b1=false;<br>&#9;ST.b2=false;<br>&#9;ST.b3=false;<br><br></div>
<h3 id="TestInfo.TestSwitch"><a class="headerlink" href="#TestInfo.TestSwitch" title="Permanent link">TestSwitch</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local string s;<br>&#9;local int i;<br>&#9;local bool b;<br><br>&#9;s="Tim";<br>&#9;i=2;<br>&#9;switch( i )<br>&#9;{<br>&#9;&#9;case 0:<br>&#9;&#9;&#9;assert(false);<br>&#9;&#9;&#9;break;<br>&#9;&#9;case 2:<br>&#9;&#9;&#9;b=true;<br>&#9;&#9;&#9;break;<br>&#9;&#9;default:<br>&#9;&#9;&#9;assert(false);<br>&#9;&#9;&#9;break;<br>&#9;}<br>&#9;assert(b);<br>&#9;switch( s )<br>&#9;{<br>&#9;&#9;case "":<br>&#9;&#9;&#9;assert(false);<br>&#9;&#9;&#9;break;<br>&#9;&#9;case "xyzzy":<br>&#9;&#9;&#9;assert(false);<br>&#9;&#9;&#9;break;<br>&#9;&#9;default:<br>&#9;&#9;&#9;b=false;<br>&#9;&#9;&#9;break;<br>&#9;}<br>&#9;assert(!b);<br>&#9;log("testswitch succeeded");<br><br></div>
<h3 id="TestInfo.TestX"><a class="headerlink" href="#TestInfo.TestX" title="Permanent link">TestX</a> (bool bResource)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int n;<br><br>&#9;n = int(bResource);<br>&#9;MyArray[ int(bResource) ] = 0;<br>&#9;MyArray[ int(bResource) ]++;<br><br></div>
<h3 id="TestInfo.Tick"><a class="headerlink" href="#TestInfo.Tick" title="Permanent link">Tick</a> (float DeltaTime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local class C;<br>&#9;local class<testinfo> TC;<br>&#9;local actor a;<br><br><br>&#9;log("time="$Level.TimeSeconds);<br><br>&#9;TestOptionalOut();<br>&#9;TestNullContext( self );<br>&#9;TestNullContext( None );<br>&#9;TestSwitch();<br><br>&#9;v1=vect(1,2,3);<br>&#9;v2=vect(2,4,6);<br>&#9;assert(v1!=v2);<br>&#9;assert(!(v1==v2));<br>&#9;assert(v1==vect(1,2,3));<br>&#9;assert(v2==vect(2,4,6));<br>&#9;assert(vect(1,2,5)!=v1);<br>&#9;assert(v1*2==v2);<br>&#9;assert(v1==v2/2);<br><br>&#9;assert(Pie==3.14);<br>&#9;assert(Pie!=2);<br>&#9;assert(Str=="Tim");<br>&#9;assert(Str!="Bob");<br>&#9;assert(Lotus==vect(1,2,3));<br><br>&#9;assert(GetPropertyText("sxx")=="Tim");<br>&#9;assert(GetPropertyText("ppp")!="123");<br>&#9;assert(GetPropertyText("bogus")=="");<br>&#9;xnum=345;<br>&#9;assert(GetPropertyText("xnum")=="345");<br>&#9;SetPropertyText("xnum","999");<br>&#9;assert(xnum==999);<br>&#9;assert(xnum!=666);<br><br>&#9;assert(bTrue1==true);<br>&#9;assert(bFalse1==false);<br>&#9;assert(bTrue2==true);<br>&#9;assert(bFalse2==false);<br><br>&#9;assert(default.bTrue1==true);<br>&#9;assert(default.bFalse1==false);<br>&#9;assert(default.bTrue2==true);<br>&#9;assert(default.bFalse2==false);<br><br>&#9;assert(class'TestInfo'.default.bTrue1==true);<br>&#9;assert(class'TestInfo'.default.bFalse1==false);<br>&#9;assert(class'TestInfo'.default.bTrue2==true);<br>&#9;assert(class'TestInfo'.default.bFalse2==false);<br><br>&#9;TC=Class;<br>&#9;assert(TC.default.bTrue1==true);<br>&#9;assert(TC.default.bFalse1==false);<br>&#9;assert(TC.default.bTrue2==true);<br>&#9;assert(TC.default.bFalse2==false);<br><br>&#9;C=Class;<br>&#9;assert(class<testinfo>(C).default.bTrue1==true);<br>&#9;assert(class<testinfo>(C).default.bFalse1==false);<br>&#9;assert(class<testinfo>(C).default.bTrue2==true);<br>&#9;assert(class<testinfo>(C).default.bFalse2==false);<br><br>&#9;assert(default.xnum==777);<br>&#9;TestStatic(123);<br>&#9;TC.static.TestStatic(123);<br>&#9;class<testinfo>(C).static.TestStatic(123);<br><br>&#9;bBool2=RecurseTest();<br>&#9;assert(bBool2==false);<br><br>&#9;TestStructBools();<br>&#9;TestQ();<br><br>&#9;log( "All tests passed" );<br><br></div>
<h3 id="TestInfo.f"><a class="headerlink" href="#TestInfo.f" title="Permanent link">f</a></h3>

<h3 id="TestInfo.temp"><a class="headerlink" href="#TestInfo.temp" title="Permanent link">temp</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br>&#9;local playerpawn PlayerOwner;<br>&#9;local name LeftList[20];<br><br>&#9;for( i=0; i<20; i++ )<br>&#9;&#9;PlayerOwner.WeaponPriority[i] = LeftList[i+1];<br>&#9;temp();<br><br></div>
<h3 id="TestInfo.test"><a class="headerlink" href="#TestInfo.test" title="Permanent link">test</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;class'testinfo'.default.v1 = vect(1,2,3);<br><br></div>
<br><br><hr>
<a class="headerlink" href="#TestObj.uc" title="Permanent link"><h2 id="TestObj.uc">TestObj.uc (extends Object)</h2></a>

<h3 id="TestObj.Test"><a class="headerlink" href="#TestObj.Test" title="Permanent link">Test</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;log( "TestObj.Test" );<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Texture.uc" title="Permanent link"><h2 id="Texture.uc">Texture.uc (extends Bitmap)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var(Texture) texture BumpMap;		// Bump map to illuminate this texture with.<br>var(Texture) texture DetailTexture;	// Detail texture to apply.<br>var(Texture) texture MacroTexture;	// Macrotexture to apply, not currently used.<br>var(Texture) float Diffuse;			// Diffuse lighting coefficient.<br>var(Texture) float Specular;		// Specular lighting coefficient.<br>var(Texture) float Alpha;			// Alpha.<br>var(Texture) float DrawScale;       // Scaling relative to parent.<br>var(Texture) float Friction;		// Surface friction coefficient, 1.0=none, 0.95=some.<br>var(Texture) float MipMult;         // Mipmap multiplier.<br>var() sound FootstepSound;			// Footstep sound.<br>var() sound HitSound;				// Sound when the texture is hit with a projectile.<br>var          bool bInvisible;<br>var(Surface) editconst bool bMasked;<br>var(Surface) bool bTransparent;<br>var          bool bNotSolid;<br>var(Surface) bool bEnvironment;<br>var          bool bSemisolid;<br>var(Surface) bool bModulate;<br>var(Surface) bool bFakeBackdrop;<br>var(Surface) bool bTwoSided;<br>var(Surface) bool bAutoUPan;<br>var(Surface) bool bAutoVPan;<br>var(Surface) bool bNoSmooth;<br>var(Surface) bool bBigWavy;<br>var(Surface) bool bSmallWavy;<br>var(Surface) bool bWaterWavy;<br>var          bool bLowShadowDetail;<br>var          bool bNoMerge;<br>var(Surface) bool bCloudWavy;<br>var          bool bDirtyShadows;<br>var          bool bHighLedge;<br>var          bool bSpecialLit;<br>var          bool bGouraud;<br>var(Surface) bool bUnlit;<br>var          bool bHighShadowDetail;<br>var          bool bPortal;<br>var          const bool bMirrored, bX2, bX3;<br>var          const bool bX4, bX5, bX6, bX7;<br>var(Quality) private  bool bHighColorQuality;   // High color quality hint.<br>var(Quality) private  bool bHighTextureQuality; // High color quality hint.<br>var private           bool bRealtime;           // Texture changes in realtime.<br>var private           bool bParametric;         // Texture data need not be stored.<br>var private transient bool bRealtimeChanged;    // Changed since last render.<br>var private           bool bHasComp;			// Whether a compressed version exists.<br>var(Quality) enum ELODSet<br>var(Animation) texture AnimNext;<br>var transient  texture AnimCurrent;<br>var(Animation) byte    PrimeCount;<br>var transient  byte    PrimeCurrent;<br>var(Animation) float   MinFrameRate, MaxFrameRate;<br>var transient  float   Accumulator;<br>var private native const array<int> Mips, CompMips;<br>var const ETextureFormat CompFormat;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">Diffuse=1.000000<br>Specular=1.000000<br>DrawScale=1.000000<br>Friction=1.000000<br>MipMult=1.000000<br>LODSet=LODSET_World</div>
<br><br><hr>
<a class="headerlink" href="#Trigger.uc" title="Permanent link"><h2 id="Trigger.uc">Trigger.uc (extends Triggers)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() enum ETriggerType<br>var() localized string Message;<br>var() bool bTriggerOnceOnly;<br>var() bool bInitiallyActive;<br>var() class<actor> ClassProximityType;<br>var() float	RepeatTriggerTime; //if > 0, repeat trigger message at this interval is still touching other<br>var() float ReTriggerDelay; //minimum time before trigger can be triggered again<br>var() float DamageThreshold; //minimum damage to trigger if TT_Shoot<br>var actor TriggerActor2;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bInitiallyActive=True<br>InitialState=NormalTrigger<br>Texture=Texture'Engine.S_Trigger'</div>
<h3 id="Trigger.CheckTouchList"><a class="headerlink" href="#Trigger.CheckTouchList" title="Permanent link">CheckTouchList</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br><br><br>&#9;for (i=0;i<4;i++)<br>&#9;&#9;if ( Touching[i] != None )<br>&#9;&#9;&#9;Touch(Touching[i]);<br><br></div>
<h3 id="Trigger.FindTriggerActor"><a class="headerlink" href="#Trigger.FindTriggerActor" title="Permanent link">FindTriggerActor</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Actor A;<br><br><br>&#9;TriggerActor = None;<br>&#9;TriggerActor2 = None;<br>&#9;ForEach AllActors(class 'Actor', A)<br>&#9;&#9;if ( A.Event == Tag)<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( Counter(A) != None )<br>&#9;&#9;&#9;&#9;return; //FIXME - handle counters<br>&#9;&#9;&#9;if (TriggerActor == None)<br>&#9;&#9;&#9;&#9;TriggerActor = A;<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;TriggerActor2 = A;<br>&#9;&#9;&#9;&#9;return;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br><br></div>
<h3 id="Trigger.IsRelevant"><a class="headerlink" href="#Trigger.IsRelevant" title="Permanent link">IsRelevant</a> (actor Other) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( !bInitiallyActive )<br>&#9;&#9;return false;<br><br>&#9;// DEUS_EX STM -- added cheat<br>&#9;if( (Other != None) && (!Other.bDetectable) )<br>&#9;&#9;return false;<br><br>&#9;switch( TriggerType )<br>&#9;{<br>&#9;&#9;case TT_PlayerProximity:<br>&#9;&#9;&#9;return Pawn(Other)!=None && Pawn(Other).bIsPlayer;<br>&#9;&#9;case TT_PawnProximity:<br>&#9;&#9;&#9;return Pawn(Other)!=None && ( Pawn(Other).Intelligence > BRAINS_None );<br>&#9;&#9;case TT_ClassProximity:<br>&#9;&#9;&#9;return ClassIsChildOf(Other.Class, ClassProximityType);<br>&#9;&#9;case TT_AnyProximity:<br>&#9;&#9;&#9;return true;<br>&#9;&#9;case TT_Shoot:<br>&#9;&#9;&#9;return ( (Projectile(Other) != None) && (Projectile(Other).Damage >= DamageThreshold) );<br>&#9;}<br><br></div>
<h3 id="Trigger.PostBeginPlay"><a class="headerlink" href="#Trigger.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( !bInitiallyActive )<br>&#9;&#9;FindTriggerActor();<br>&#9;if ( TriggerType == TT_Shoot )<br>&#9;{<br>&#9;&#9;bHidden = false;<br>&#9;&#9;bProjTarget = true;<br>&#9;&#9;DrawType = DT_None;<br>&#9;}<br>&#9;&#9;<br>&#9;Super.PostBeginPlay();<br><br></div>
<h3 id="Trigger.SpecialHandling"><a class="headerlink" href="#Trigger.SpecialHandling" title="Permanent link">SpecialHandling</a> (Pawn Other) -> Actor</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br><br><br>&#9;if ( bTriggerOnceOnly && !bCollideActors )<br>&#9;&#9;return None;<br><br>&#9;if ( (TriggerType == TT_PlayerProximity) && !Other.bIsPlayer )<br>&#9;&#9;return None;<br><br>&#9;if ( !bInitiallyActive )<br>&#9;{<br>&#9;&#9;if ( TriggerActor == None )<br>&#9;&#9;&#9;FindTriggerActor();<br>&#9;&#9;if ( TriggerActor == None )<br>&#9;&#9;&#9;return None;<br>&#9;&#9;if ( (TriggerActor2 != None) <br>&#9;&#9;&#9;&& (VSize(TriggerActor2.Location - Other.Location) < VSize(TriggerActor.Location - Other.Location)) )<br>&#9;&#9;&#9;return TriggerActor2;<br>&#9;&#9;else<br>&#9;&#9;&#9;return TriggerActor;<br>&#9;}<br><br>&#9;// is this a shootable trigger?<br>&#9;if ( TriggerType == TT_Shoot )<br>&#9;{<br>&#9;&#9;if ( !Other.bCanDoSpecial || (Other.Weapon == None) )<br>&#9;&#9;&#9;return None;<br><br>&#9;&#9;Other.Target = self;<br>&#9;&#9;Other.bShootSpecial = true;<br>&#9;&#9;Other.FireWeapon();<br>&#9;&#9;Other.bFire = 0;<br>&#9;&#9;Other.bAltFire = 0;<br>&#9;&#9;return Other;<br>&#9;}<br><br>&#9;// can other trigger it right away?<br>&#9;if ( IsRelevant(Other) )<br>&#9;{<br>&#9;&#9;for (i=0;i<4;i++)<br>&#9;&#9;&#9;if (Touching[i] == Other)<br>&#9;&#9;&#9;&#9;Touch(Other);<br>&#9;&#9;return self;<br>&#9;}<br><br>&#9;return self;<br><br></div>
<h3 id="Trigger.Timer"><a class="headerlink" href="#Trigger.Timer" title="Permanent link">Timer</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local bool bKeepTiming;<br>&#9;local int i;<br><br><br>&#9;bKeepTiming = false;<br><br>&#9;for (i=0;i<4;i++)<br>&#9;&#9;if ( (Touching[i] != None) && IsRelevant(Touching[i]) )<br>&#9;&#9;{<br>&#9;&#9;&#9;bKeepTiming = true;<br>&#9;&#9;&#9;Touch(Touching[i]);<br>&#9;&#9;}<br><br>&#9;if ( bKeepTiming )<br>&#9;&#9;SetTimer(RepeatTriggerTime, false);<br><br></div>
<h3 id="Trigger.Touch"><a class="headerlink" href="#Trigger.Touch" title="Permanent link">Touch</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor A;<br>&#9;local bool  restoreGroup;  // DEUS_EX CNN<br><br><br>&#9;if( IsRelevant( Other ) )<br>&#9;{<br>&#9;&#9;if ( ReTriggerDelay > 0 )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( Level.TimeSeconds - TriggerTime < ReTriggerDelay )<br>&#9;&#9;&#9;&#9;return;<br>&#9;&#9;&#9;TriggerTime = Level.TimeSeconds;<br>&#9;&#9;}<br>&#9;&#9;// Broadcast the Trigger message to all matching actors.<br>&#9;&#9;if( Event != '' )<br>&#9;&#9;&#9;foreach AllActors( class 'Actor', A, Event )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;// DEUS_EX CNN<br>&#9;&#9;&#9;&#9;// If the triggering actor doesn't have a group, then<br>&#9;&#9;&#9;&#9;// we copy the trigger's group into the group of the triggerer<br>&#9;&#9;&#9;&#9;// This will make LogicTriggers work correctly and won't<br>&#9;&#9;&#9;&#9;// affect anything else<br>&#9;&#9;&#9;&#9;if (Other.Group == '')<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;Other.Group = Group;<br>&#9;&#9;&#9;&#9;&#9;restoreGroup = True;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;&#9;restoreGroup = False;<br><br>&#9;&#9;&#9;&#9;A.Trigger( Other, Other.Instigator );<br><br>&#9;&#9;&#9;&#9;// DEUS_EX CNN<br>&#9;&#9;&#9;&#9;if (restoreGroup)<br>&#9;&#9;&#9;&#9;&#9;Other.Group = '';<br>&#9;&#9;&#9;}<br><br>&#9;&#9;if ( Other.IsA('Pawn') && (Pawn(Other).SpecialGoal == self) )<br>&#9;&#9;&#9;Pawn(Other).SpecialGoal = None;<br>&#9;&#9;&#9;&#9;<br>&#9;&#9;if( Message != "" )<br>&#9;&#9;&#9;// Send a string message to the toucher.<br>&#9;&#9;&#9;Other.Instigator.ClientMessage( Message );<br><br>&#9;&#9;if( bTriggerOnceOnly )<br>&#9;&#9;&#9;// Ignore future touches.<br>&#9;&#9;&#9;SetCollision(False);<br>&#9;&#9;else if ( RepeatTriggerTime > 0 )<br>&#9;&#9;&#9;SetTimer(RepeatTriggerTime, false);<br>&#9;}<br><br></div>
<h3 id="Trigger.Trigger"><a class="headerlink" href="#Trigger.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;bInitiallyActive = false;<br>&#9;<br></div>
<h3 id="Trigger.UnTouch"><a class="headerlink" href="#Trigger.UnTouch" title="Permanent link">UnTouch</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor A;<br><br>&#9;if( IsRelevant( Other ) )<br>&#9;{<br>&#9;&#9;// Untrigger all matching actors.<br>&#9;&#9;if( Event != '' )<br>&#9;&#9;&#9;foreach AllActors( class 'Actor', A, Event )<br>&#9;&#9;&#9;&#9;A.UnTrigger( Other, Other.Instigator );<br>&#9;}<br><br></div>
<br><br><hr>
<a class="headerlink" href="#TriggerLight.uc" title="Permanent link"><h2 id="TriggerLight.uc">TriggerLight.uc (extends Light)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() float ChangeTime;        // Time light takes to change from on to off.<br>var() bool  bInitiallyOn;      // Whether it's initially on.<br>var() bool  bDelayFullOn;      // Delay then go full-on.<br>var() float RemainOnTime;      // How long the TriggerPound effect lasts<br>var   float InitialBrightness; // Initial brightness.<br>var   float Alpha, Direction;<br>var   actor SavedTrigger;<br>var   float poundTime;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bStatic=False<br>bHidden=False<br>bMovable=True<br>RemoteRole=ROLE_SimulatedProxy</div>
<h3 id="TriggerLight.BeginPlay"><a class="headerlink" href="#TriggerLight.BeginPlay" title="Permanent link">BeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;// Remember initial light type and set new one.<br>&#9;Disable( 'Tick' );<br>&#9;InitialBrightness = LightBrightness;<br>&#9;if( bInitiallyOn )<br>&#9;{<br>&#9;&#9;Alpha     = 1.0;<br>&#9;&#9;Direction = 1.0;<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;Alpha     = 0.0;<br>&#9;&#9;Direction = -1.0;<br>&#9;}<br>&#9;DrawType = DT_None;<br><br></div>
<h3 id="TriggerLight.Tick"><a class="headerlink" href="#TriggerLight.Tick" title="Permanent link">Tick</a> (float DeltaTime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Alpha += Direction * DeltaTime / ChangeTime;<br>&#9;if( Alpha > 1.0 )<br>&#9;{<br>&#9;&#9;Alpha = 1.0;<br>&#9;&#9;Disable( 'Tick' );<br>&#9;&#9;if( SavedTrigger != None )<br>&#9;&#9;&#9;SavedTrigger.EndEvent();<br>&#9;}<br>&#9;else if( Alpha < 0.0 )<br>&#9;{<br>&#9;&#9;Alpha = 0.0;<br>&#9;&#9;Disable( 'Tick' );<br>&#9;&#9;if( SavedTrigger != None )<br>&#9;&#9;&#9;SavedTrigger.EndEvent();<br>&#9;}<br>&#9;if( !bDelayFullOn )<br>&#9;&#9;LightBrightness = Alpha * InitialBrightness;<br>&#9;else if( (Direction>0 && Alpha!=1) || Alpha==0 )<br>&#9;&#9;LightBrightness = 0;<br>&#9;else<br>&#9;&#9;LightBrightness = InitialBrightness;<br><br>&#9;// DEUS_EX CNN - Hide the corona when turned off<br>&#9;if (LightBrightness == 0)<br>&#9;{<br>&#9;&#9;MultiSkins[1] = Skin;<br>&#9;&#9;Skin = None;<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;Skin = MultiSkins[1];<br>&#9;&#9;MultiSkins[1] = None;<br>&#9;}<br><br></div>
<h3 id="TriggerLight.Timer"><a class="headerlink" href="#TriggerLight.Timer" title="Permanent link">Timer</a></h3>

<h3 id="TriggerLight.Trigger"><a class="headerlink" href="#TriggerLight.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br><br>&#9;&#9;if( SavedTrigger!=None )<br>&#9;&#9;&#9;SavedTrigger.EndEvent();<br>&#9;&#9;SavedTrigger = Other;<br>&#9;&#9;SavedTrigger.BeginEvent();<br>&#9;&#9;Direction = 1;<br>&#9;&#9;poundTime = ChangeTime;&#9;&#9;&#9;// how much time will pass till reversal<br>&#9;&#9;SetTimer (ChangeTime, false);&#9;&#9;// wake up when it's time to reverse<br>&#9;&#9;Enable   ('Timer');<br>&#9;&#9;Enable   ('Tick');<br>&#9;<br></div>
<h3 id="TriggerLight.UnTrigger"><a class="headerlink" href="#TriggerLight.UnTrigger" title="Permanent link">UnTrigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;if( SavedTrigger!=None )<br>&#9;&#9;&#9;SavedTrigger.EndEvent();<br>&#9;&#9;SavedTrigger = Other;<br>&#9;&#9;SavedTrigger.BeginEvent();<br>&#9;&#9;if( bInitiallyOn ) Direction = 1.0;<br>&#9;&#9;else               Direction = -1.0;<br>&#9;&#9;Enable( 'Tick' );<br>&#9;<br></div>
<br><br><hr>
<a class="headerlink" href="#TriggerMarker.uc" title="Permanent link"><h2 id="TriggerMarker.uc">TriggerMarker.uc (extends NavigationPoint)</h2></a>

<br><br><hr>
<a class="headerlink" href="#Triggers.uc" title="Permanent link"><h2 id="Triggers.uc">Triggers.uc (extends Actor)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bHidden=True<br>CollisionRadius=40.000000<br>CollisionHeight=40.000000<br>bCollideActors=True</div>
<br><br><hr>
<a class="headerlink" href="#VoicePack.uc" title="Permanent link"><h2 id="VoicePack.uc">VoicePack.uc (extends Info)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">RemoteRole=ROLE_None<br>LifeSpan=10.000000</div>
<h3 id="VoicePack."><a class="headerlink" href="#VoicePack." title="Permanent link"></a> (exec function to do ServerVoiceMessage, and use in OrdersMenu)</h3>

<h3 id="VoicePack.ClientInitialize"><a class="headerlink" href="#VoicePack.ClientInitialize" title="Permanent link">ClientInitialize</a> (PlayerReplicationInfo Sender, PlayerReplicationInfo Recipient, name messagetype, byte messageIndex)</h3>

<h3 id="VoicePack.PlayerSpeech"><a class="headerlink" href="#VoicePack.PlayerSpeech" title="Permanent link">PlayerSpeech</a> (int Type, int Index, int Callsign)</h3>

<br><br><hr>
<a class="headerlink" href="#WarpZoneInfo.uc" title="Permanent link"><h2 id="WarpZoneInfo.uc">WarpZoneInfo.uc (extends ZoneInfo)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() string     OtherSideURL;<br>var() name       ThisTag;<br>var() bool		 bNoTeleFrag;<br>var const int              iWarpZone;<br>var const coords           WarpCoords;<br>var transient WarpZoneInfo OtherSideActor;<br>var transient object       OtherSideLevel;<br>var() string		       Destinations[8];<br>var int					   numDestinations;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">MaxCarcasses=0</div>
<h3 id="WarpZoneInfo.ActorEntered"><a class="headerlink" href="#WarpZoneInfo.ActorEntered" title="Permanent link">ActorEntered</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector L;<br>&#9;local rotator R;<br>&#9;local Pawn P;<br><br><br>&#9;//if ( Other.Role == ROLE_AutonomousProxy )<br>&#9;//&#9;return; // don't simulate for client players<br>&#9;Super.ActorEntered( Other );<br>&#9;if( !Other.bJustTeleported )<br>&#9;{<br>&#9;&#9;Generate();<br>&#9;&#9;if( OtherSideActor != None )<br>&#9;&#9;{<br>&#9;&#9;&#9;// This needs to also perform a coordinate system transformation,<br>&#9;&#9;&#9;// in case the portals aren't directionally aligned. This is easy to<br>&#9;&#9;&#9;// do but UnrealScript doesn't provide coordinate system operators yet.<br>&#9;&#9;&#9;Other.Disable('Touch');<br>&#9;&#9;&#9;Other.Disable('UnTouch');<br><br>&#9;&#9;&#9;L = Other.Location;<br>&#9;&#9;&#9;if( Other.IsA('PlayerPawn') )<br>&#9;&#9;&#9;&#9;R = PlayerPawn(Other).ViewRotation;<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;R = Other.Rotation;<br><br>&#9;&#9;&#9;UnWarp( L, Other.Velocity, R );<br>&#9;&#9;&#9;OtherSideActor.Warp( L, Other.Velocity, R );<br><br>&#9;&#9;&#9;if( Other.IsA('Pawn') )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;Pawn(Other).bWarping = bNoTelefrag;<br>&#9;&#9;&#9;&#9;if ( Other.SetLocation(L) )<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;//tell enemies about teleport<br>&#9;&#9;&#9;&#9;&#9;if ( Role == ROLE_Authority )<br>&#9;&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;&#9;P = Level.PawnList;<br>&#9;&#9;&#9;&#9;&#9;&#9;While ( P != None )<br>&#9;&#9;&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (P.Enemy == Other)<br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;P.LastSeenPos = Other.Location; <br>&#9;&#9;&#9;&#9;&#9;&#9;&#9;P = P.nextPawn;<br>&#9;&#9;&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;&#9;R.Roll = 0;<br>&#9;&#9;&#9;&#9;&#9;Pawn(Other).ViewRotation = R;<br>&#9;&#9;&#9;&#9;&#9;Pawn(Other).ClientSetLocation(L, R );<br>&#9;&#9;&#9;&#9;&#9;Pawn(Other).MoveTimer = -1.0;<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;&#9;// set up to keep trying to teleport<br>&#9;&#9;&#9;&#9;&#9;GotoState('DelayedWarp');<br>&#9;&#9;&#9;&#9;}<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;Other.SetLocation(L);<br>&#9;&#9;&#9;&#9;Other.SetRotation( R );<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;Other.Enable('Touch');<br>&#9;&#9;&#9;Other.Enable('UnTouch');<br>&#9;&#9;&#9;// Change rotation according to portal's rotational change.<br>&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="WarpZoneInfo.ActorLeaving"><a class="headerlink" href="#WarpZoneInfo.ActorLeaving" title="Permanent link">ActorLeaving</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.ActorLeaving(Other);<br>&#9;If ( Other.IsA('Pawn') )<br>&#9;&#9;Pawn(Other).bWarping = false;<br><br></div>
<h3 id="WarpZoneInfo.ForceGenerate"><a class="headerlink" href="#WarpZoneInfo.ForceGenerate" title="Permanent link">ForceGenerate</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( InStr(OtherSideURL,"/") >= 0 )<br>&#9;{<br>&#9;&#9;// Remote level.<br>&#9;&#9;//log( "Warpzone " $ Self $ " remote" );<br>&#9;&#9;OtherSideLevel = None;<br>&#9;&#9;OtherSideActor = None;<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;// Local level.<br>&#9;&#9;OtherSideLevel = XLevel;<br>&#9;&#9;foreach AllActors( class 'WarpZoneInfo', OtherSideActor )<br>&#9;&#9;&#9;if( string(OtherSideActor.ThisTag)~=OtherSideURL && OtherSideActor!=Self )<br>&#9;&#9;&#9;&#9;break;<br>&#9;&#9;//log( "Warpzone " $ Self $ " local, connected to " $ OtherSideActor );<br>&#9;}<br><br></div>
<h3 id="WarpZoneInfo.Generate"><a class="headerlink" href="#WarpZoneInfo.Generate" title="Permanent link">Generate</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if( OtherSideLevel != None )<br>&#9;&#9;return;<br>&#9;ForceGenerate();<br><br></div>
<h3 id="WarpZoneInfo.PreBeginPlay"><a class="headerlink" href="#WarpZoneInfo.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.PreBeginPlay();<br><br>&#9;// Generate the local connection.<br>&#9;Generate();<br><br>&#9;// Setup destination list.<br>&#9;numDestinations = 0;<br>&#9;While( numDestinations < 8 )<br>&#9;&#9;if (Destinations[numDestinations] != "")<br>&#9;&#9;&#9;numDestinations++;<br>&#9;&#9;else<br>&#9;&#9;&#9;numDestinations = 8;<br><br>&#9;// Generate URL if necessary.<br>&#9;if( numDestinations>0 && (OtherSideURL == "") )<br>&#9;&#9;OtherSideURL = Destinations[0];<br><br></div>
<h3 id="WarpZoneInfo.Tick"><a class="headerlink" href="#WarpZoneInfo.Tick" title="Permanent link">Tick</a> (float DeltaTime)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn P;<br>&#9;local bool bFound;<br><br><br>&#9;&#9;For ( P=Level.PawnList; P!=None; P=P.NextPawn )<br>&#9;&#9;&#9;if ( P.bWarping && (P.Region.Zone == Self) )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;bFound = true;<br>&#9;&#9;&#9;&#9;ActorEntered(P);<br>&#9;&#9;&#9;}<br><br>&#9;&#9;If ( !bFound )<br>&#9;&#9;&#9;GotoState('');<br>&#9;<br></div>
<h3 id="WarpZoneInfo.Trigger"><a class="headerlink" href="#WarpZoneInfo.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int nextPick;<br><br>&#9;if (numDestinations == 0)<br>&#9;&#9;return;<br>&#9;<br>&#9;nextPick = 0;<br>&#9;While( (nextPick < 8) && (Destinations[nextPick] != OtherSideURL )  )<br>&#9;&#9;nextPick++;<br><br>&#9;nextPick++;<br>&#9;if ( (nextPick > 7) || (Destinations[nextPick] == "") )<br>&#9;&#9;nextPick = 0;<br>&#9;<br>&#9;OtherSideURL = Destinations[nextPick];<br>&#9;ForceGenerate();<br><br></div>
<h3 id="WarpZoneInfo.UnWarp"><a class="headerlink" href="#WarpZoneInfo.UnWarp" title="Permanent link">UnWarp</a> (out vector Loc, out vector Vel, out rotator R) | native</h3>

<h3 id="WarpZoneInfo.Warp"><a class="headerlink" href="#WarpZoneInfo.Warp" title="Permanent link">Warp</a> (out vector Loc, out vector Vel, out rotator R) | native</h3>

<br><br><hr>
<a class="headerlink" href="#WarpZoneMarker.uc" title="Permanent link"><h2 id="WarpZoneMarker.uc">WarpZoneMarker.uc (extends NavigationPoint)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var WarpZoneInfo markedWarpZone;<br>var Actor TriggerActor;		//used to tell AI how to trigger me<br>var Actor TriggerActor2;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bCollideWhenPlacing=False<br>bHiddenEd=True<br>CollisionRadius=20.000000<br>CollisionHeight=40.000000</div>
<h3 id="WarpZoneMarker.FindTriggerActor"><a class="headerlink" href="#WarpZoneMarker.FindTriggerActor" title="Permanent link">FindTriggerActor</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local ZoneTrigger Z;<br><br>&#9;ForEach AllActors(class 'ZoneTrigger', Z)<br>&#9;&#9;if ( Z.Event == markedWarpZone.ZoneTag)<br>&#9;&#9;{<br>&#9;&#9;&#9;TriggerActor = Z;<br>&#9;&#9;&#9;return;<br>&#9;&#9;} <br><br></div>
<h3 id="WarpZoneMarker.PostBeginPlay"><a class="headerlink" href="#WarpZoneMarker.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( markedWarpZone.numDestinations > 1 )<br>&#9;&#9;FindTriggerActor();<br>&#9;Super.PostBeginPlay();<br><br></div>
<h3 id="WarpZoneMarker.SpecialHandling"><a class="headerlink" href="#WarpZoneMarker.SpecialHandling" title="Permanent link">SpecialHandling</a> (Pawn Other) -> Actor</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (Other.Region.Zone == markedWarpZone)<br>&#9;&#9;markedWarpZone.ActorEntered(Other);<br>&#9;return self;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#WayBeacon.uc" title="Permanent link"><h2 id="WayBeacon.uc">WayBeacon.uc (extends Keypoint)</h2></a>

<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">bStatic=False<br>bHidden=False<br>RemoteRole=ROLE_None<br>LifeSpan=6.000000<br>DrawType=DT_Mesh<br>DrawScale=0.500000<br>AmbientGlow=40<br>bOnlyOwnerSee=True<br>bCollideActors=True<br>LightType=LT_Steady<br>LightBrightness=125<br>LightSaturation=125</div>
<h3 id="WayBeacon.PostBeginPlay"><a class="headerlink" href="#WayBeacon.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local class<actor> NewClass;<br><br><br>&#9;Super.PostBeginPlay();<br>&#9;NewClass = class<actor>( DynamicLoadObject( "Unreali.Lamp4", class'Class' ) );<br>&#9;if( NewClass!=None )<br>&#9;&#9;Mesh = NewClass.Default.Mesh;<br><br></div>
<h3 id="WayBeacon.touch"><a class="headerlink" href="#WayBeacon.touch" title="Permanent link">touch</a> (actor other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if (other == owner)<br>&#9;{<br>&#9;&#9;if ( Owner.IsA('PlayerPawn') )<br>&#9;&#9;&#9;PlayerPawn(owner).ShowPath();<br>&#9;&#9;Destroy();<br>&#9;}<br><br></div>
<br><br><hr>
<a class="headerlink" href="#Weapon.uc" title="Permanent link"><h2 id="Weapon.uc">Weapon.uc (extends Inventory)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() float   MaxTargetRange;    // Maximum distance to target.<br>var() class<ammo> AmmoName;          // Type of ammo used.<br>var() travel byte    ReloadCount;       // Amount of ammo depletion before reloading. 0 if no reloading is done.<br>var() int     PickupAmmoCount;   // Amount of ammo initially in pick-up item.<br>var travel ammo	AmmoType;		 // Inventory Ammo being used.<br>var() travel bool	  bInstantHit;		 // If true, instant hit rather than projectile firing weapon<br>var() bool	  bAltInstantHit;	 // If true, instant hit rather than projectile firing weapon for AltFire<br>var(WeaponAI) bool	  bWarnTarget;		 // When firing projectile, warn the target<br>var(WeaponAI) bool	  bAltWarnTarget;	 // When firing alternate projectile, warn the target<br>var   bool	  bWeaponUp;		 // Used in Active State<br>var   bool	  bChangeWeapon;	 // Used in Active State<br>var   bool 	  bLockedOn;<br>var(WeaponAI) bool	  bSplashDamage;	 // used by bot AI<br>var()		  bool	  bCanThrow;	//if true, player can toss this weapon out<br>var(WeaponAI) bool	  bRecommendSplashDamage; //if true, bot preferentially tries to use splash damage<br>var(WeaponAI) bool	  bRecommendAltSplashDamage; //if true, bot preferentially tries to use splash damage<br>var() bool	  bWeaponStay;<br>var() bool	  bOwnsCrosshair;	// this weapon is responsible for drawing its own crosshair (in its postrender function)<br>var(WeaponAI) bool	  bMeleeWeapon; //Weapon is only a melee weapon<br>var() bool	  bRapidFire;		// used by human animations in determining firing animation (for still firing)<br>var() float	  FiringSpeed;		// used by human animations in determining firing speed<br>var()   vector	FireOffset;		 // Offset from drawing location for projectile/trace start<br>var()   class<projectile> ProjectileClass;<br>var()   class<projectile> AltProjectileClass;<br>var()	name MyDamageType;<br>var()	name AltDamageType;<br>var()	float	ShakeMag;<br>var()	float	ShakeTime;<br>var()	float   ShakeVert;<br>var(WeaponAI)	float	AIRating;<br>var(WeaponAI)	float	RefireRate;<br>var(WeaponAI)	float	AltRefireRate;<br>var() sound 	FireSound;<br>var() sound 	AltFireSound;<br>var() sound 	CockingSound;<br>var() sound 	SelectSound;<br>var() sound 	Misc1Sound;<br>var() sound 	Misc2Sound;<br>var() sound 	Misc3Sound;<br>var() Localized string MessageNoAmmo;<br>var() Localized string DeathMessage;<br>var() Color NameColor;	// used when drawing name on HUD<br>var Rotator AdjustedAim;<br>var bool bSetFlashTime;<br>var(MuzzleFlash) bool bDrawMuzzleFlash;<br>var byte bMuzzleFlash;<br>var float FlashTime;<br>var(MuzzleFlash) float MuzzleScale, FlashY, FlashO, FlashC, FlashLength;<br>var(MuzzleFlash) int FlashS;	// size of (square) texture/2<br>var(MuzzleFlash) texture MFTexture;<br>var(MuzzleFlash) texture MuzzleFlare;<br>var(MuzzleFlash) float FlareOffset;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">MaxTargetRange=4096.000000<br>bCanThrow=True<br>ProjectileSpeed=1000.000000<br>AltProjectileSpeed=1000.000000<br>aimerror=550.000000<br>shakemag=300.000000<br>shaketime=0.100000<br>shakevert=5.000000<br>AIRating=0.100000<br>RefireRate=0.500000<br>AltRefireRate=0.500000<br>MessageNoAmmo=" has no ammo."<br>DeathMessage="%o was killed by %k's %w."<br>NameColor=(R=255,G=255,B=255)<br>MuzzleScale=4.000000<br>FlashLength=0.100000<br>AutoSwitchPriority=1<br>InventoryGroup=1<br>PickupMessage="You got a weapon"<br>ItemName="Weapon"<br>RespawnTime=30.000000<br>PlayerViewOffset=(X=30.000000,Z=-5.000000)<br>MaxDesireability=0.500000<br>Icon=Texture'Engine.S_Weapon'<br>Texture=Texture'Engine.S_Weapon'<br>bNoSmooth=True</div>
<h3 id="Weapon.AltFire"><a class="headerlink" href="#Weapon.AltFire" title="Permanent link">AltFire</a> (float F)</h3>

<h3 id="Weapon.AnimEnd"><a class="headerlink" href="#Weapon.AnimEnd" title="Permanent link">AnimEnd</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;PlayIdleAnim();<br>&#9;<br></div>
<h3 id="Weapon.BecomeItem"><a class="headerlink" href="#Weapon.BecomeItem" title="Permanent link">BecomeItem</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>   Super.BecomeItem();<br>   Lifespan = 0;<br><br></div>
<h3 id="Weapon.BecomePickup"><a class="headerlink" href="#Weapon.BecomePickup" title="Permanent link">BecomePickup</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.BecomePickup();<br>&#9;SetDisplayProperties(Default.Style, Default.Texture, Default.bUnlit, Default.bMeshEnviromap );<br>   if (Level.NetMode != NM_Standalone)<br>      if (bTossedOut)<br>         Lifespan = 5.0;<br><br></div>
<h3 id="Weapon.BeginState"><a class="headerlink" href="#Weapon.BeginState" title="Permanent link">BeginState</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;&#9;bChangeWeapon = false;<br>&#9;&#9;bMuzzleFlash = 0;<br>&#9;&#9;Pawn(Owner).ClientPutDown(self, Pawn(Owner).PendingWeapon);<br>&#9;<br></div>
<h3 id="Weapon.BotDesireability"><a class="headerlink" href="#Weapon.BotDesireability" title="Permanent link">BotDesireability</a> (Pawn Bot) -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Weapon AlreadyHas;<br>&#9;local float desire;<br><br><br>&#9;desire = MaxDesireability + Bot.AdjustDesireFor(self);<br>&#9;AlreadyHas = Weapon(Bot.FindInventoryType(class)); <br>&#9;if ( AlreadyHas != None )<br>&#9;{<br>&#9;&#9;if ( (RespawnTime < 10) <br>&#9;&#9;&#9;&& ( bHidden || (AlreadyHas.AmmoType == None) <br>&#9;&#9;&#9;&#9;|| (AlreadyHas.AmmoType.AmmoAmount < AlreadyHas.AmmoType.MaxAmmo)) )<br>&#9;&#9;&#9;return 0;<br>&#9;&#9;if ( (!bHeldItem || bTossedOut) && bWeaponStay )<br>&#9;&#9;&#9;return 0;<br>&#9;&#9;if ( AlreadyHas.AmmoType == None )<br>&#9;&#9;&#9;return 0.25 * desire;<br><br>&#9;&#9;if ( AlreadyHas.AmmoType.AmmoAmount > 0 )<br>&#9;&#9;&#9;return FMax( 0.25 * desire, <br>&#9;&#9;&#9;&#9;&#9;AlreadyHas.AmmoType.MaxDesireability<br>&#9;&#9;&#9;&#9;&#9; * FMin(1, 0.15 * AlreadyHas.AmmoType.MaxAmmo/AlreadyHas.AmmoType.AmmoAmount) ); <br>&#9;&#9;else<br>&#9;&#9;&#9;return 0.05;<br>&#9;}<br>&#9;if ( (Bot.Weapon == None) || (Bot.Weapon.AIRating <= 0.4) )<br>&#9;&#9;return 2*desire;<br><br>&#9;return desire;<br><br></div>
<h3 id="Weapon.BringUp"><a class="headerlink" href="#Weapon.BringUp" title="Permanent link">BringUp</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Owner.IsA('PlayerPawn') )<br>&#9;{<br>&#9;&#9;SetHand(PlayerPawn(Owner).Handedness);<br>&#9;&#9;if (( Level.NetMode != NM_Standalone ) && (Role == ROLE_Authority))<br>&#9;&#9;&#9;ClientSetHandedness( PlayerPawn(Owner).Handedness );<br>&#9;&#9;PlayerPawn(Owner).EndZoom();<br>&#9;}&#9;<br>&#9;bWeaponUp = false;<br>&#9;PlaySelect();<br>&#9;GotoState('Active');<br><br></div>
<h3 id="Weapon.CheckVisibility"><a class="headerlink" href="#Weapon.CheckVisibility" title="Permanent link">CheckVisibility</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn PawnOwner;<br><br><br>&#9;PawnOwner = Pawn(Owner);<br>&#9;if( Owner.bHidden && (PawnOwner.Health > 0) && (PawnOwner.Visibility < PawnOwner.Default.Visibility) )<br>&#9;{<br>&#9;&#9;Owner.bHidden = false;<br>&#9;&#9;PawnOwner.Visibility = PawnOwner.Default.Visibility;<br>&#9;}<br><br></div>
<h3 id="Weapon.ClientAltFire"><a class="headerlink" href="#Weapon.ClientAltFire" title="Permanent link">ClientAltFire</a> (float Value) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return true;<br><br></div>
<h3 id="Weapon.ClientFire"><a class="headerlink" href="#Weapon.ClientFire" title="Permanent link">ClientFire</a> (float Value) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return true;<br><br></div>
<h3 id="Weapon.ClientPutDown"><a class="headerlink" href="#Weapon.ClientPutDown" title="Permanent link">ClientPutDown</a> (Weapon NextWeapon)</h3>

<h3 id="Weapon.ClientSetHandedness"><a class="headerlink" href="#Weapon.ClientSetHandedness" title="Permanent link">ClientSetHandedness</a> (float Hand)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;setHand( Hand );<br><br></div>
<h3 id="Weapon.ClientWeaponEvent"><a class="headerlink" href="#Weapon.ClientWeaponEvent" title="Permanent link">ClientWeaponEvent</a> (name EventType)</h3>

<h3 id="Weapon.Destroyed"><a class="headerlink" href="#Weapon.Destroyed" title="Permanent link">Destroyed</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.Destroyed();<br>&#9;if( (Pawn(Owner)!=None) && (Pawn(Owner).Weapon == self) )<br>&#9;&#9;Pawn(Owner).Weapon = None;<br><br></div>
<h3 id="Weapon.DropFrom"><a class="headerlink" href="#Weapon.DropFrom" title="Permanent link">DropFrom</a> (vector StartLocation)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( !SetLocation(StartLocation) )<br>&#9;&#9;return; <br>&#9;AIRating = Default.AIRating;<br>&#9;bMuzzleFlash = 0;<br>&#9;//<br>&#9;// DEUS_EX CNN - ALERT!  HUGE HACK ALERT!!!<br>&#9;//<br>&#9;// Basically, you don't want to drop all of your ammo unless you are dropping<br>&#9;// a grenade of some sort.  The only way to check for a grenade is to check the<br>&#9;// PickupViewMesh for the illegal mesh TestBox.  But since TestBox is in the DeusExItems<br>&#9;// package, we can't directly access the mesh, so we have to cast the mesh to a string<br>&#9;// and check it that way.<br>&#9;//<br>&#9;// Hate Hate Hate.<br>&#9;//<br>&#9;if (AmmoType != None)<br>&#9;{<br>&#9;&#9;if (String(AmmoType.PickupViewMesh) == "DeusExItems.TestBox")<br>&#9;&#9;{<br>&#9;&#9;&#9;PickupAmmoCount = AmmoType.AmmoAmount;<br>&#9;&#9;&#9;AmmoType.AmmoAmount = 0;<br>&#9;&#9;}<br>&#9;&#9;else<br>&#9;&#9;&#9;PickupAmmoCount = 0;<br>&#9;}<br>   if (Level.Netmode != NM_Standalone)<br>      bTossedOut = true;<br>&#9;Super.DropFrom(StartLocation);<br><br></div>
<h3 id="Weapon.Finish"><a class="headerlink" href="#Weapon.Finish" title="Permanent link">Finish</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Pawn PawnOwner;<br><br><br>&#9;if ( bChangeWeapon )<br>&#9;{<br>&#9;&#9;GotoState('DownWeapon');<br>&#9;&#9;return;<br>&#9;}<br><br>&#9;PawnOwner = Pawn(Owner);<br>&#9;if ( PlayerPawn(Owner) == None )<br>&#9;{<br>&#9;&#9;if ( (AmmoType != None) && (AmmoType.AmmoAmount<=0) )<br>&#9;&#9;{<br>&#9;&#9;&#9;PawnOwner.StopFiring();<br>&#9;&#9;&#9;PawnOwner.SwitchToBestWeapon();<br>&#9;&#9;&#9;if ( bChangeWeapon )<br>&#9;&#9;&#9;&#9;GotoState('DownWeapon');<br>&#9;&#9;}<br>&#9;&#9;else if ( (PawnOwner.bFire != 0) && (FRand() < RefireRate) )<br>&#9;&#9;&#9;Global.Fire(0);<br>&#9;&#9;else if ( (PawnOwner.bAltFire != 0) && (FRand() < AltRefireRate) )<br>&#9;&#9;&#9;Global.AltFire(0);&#9;<br>&#9;&#9;else <br>&#9;&#9;{<br>&#9;&#9;&#9;PawnOwner.StopFiring();<br>&#9;&#9;&#9;GotoState('Idle');<br>&#9;&#9;}<br>&#9;&#9;return;<br>&#9;}<br>&#9;if ( ((AmmoType != None) && (AmmoType.AmmoAmount<=0)) || (PawnOwner.Weapon != self) )<br>&#9;&#9;GotoState('Idle');<br>&#9;else if ( PawnOwner.bFire!=0 )<br>&#9;&#9;Global.Fire(0);<br>&#9;else if ( PawnOwner.bAltFire!=0 )<br>&#9;&#9;Global.AltFire(0);<br>&#9;else <br>&#9;&#9;GotoState('Idle');<br><br></div>
<h3 id="Weapon.Fire"><a class="headerlink" href="#Weapon.Fire" title="Permanent link">Fire</a> (float F)</h3>

<h3 id="Weapon.ForceAltFire"><a class="headerlink" href="#Weapon.ForceAltFire" title="Permanent link">ForceAltFire</a></h3>

<h3 id="Weapon.ForceFire"><a class="headerlink" href="#Weapon.ForceFire" title="Permanent link">ForceFire</a></h3>

<h3 id="Weapon.GiveAmmo"><a class="headerlink" href="#Weapon.GiveAmmo" title="Permanent link">GiveAmmo</a> (Pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( AmmoName == None )<br>&#9;&#9;return;<br>&#9;AmmoType = Ammo(Other.FindInventoryType(AmmoName));<br>&#9;if ( AmmoType != None )<br>&#9;&#9;AmmoType.AddAmmo(PickUpAmmoCount);<br>&#9;else<br>&#9;{<br>&#9;&#9;AmmoType = Spawn(AmmoName);&#9;// Create ammo type required&#9;&#9;<br>&#9;&#9;Other.AddInventory(AmmoType);&#9;&#9;// and add to player's inventory<br>&#9;&#9;AmmoType.BecomeItem();<br>&#9;&#9;AmmoType.AmmoAmount = PickUpAmmoCount; <br>&#9;&#9;AmmoType.GotoState('Idle2');<br>&#9;}<br><br></div>
<h3 id="Weapon.HandlePickupQuery"><a class="headerlink" href="#Weapon.HandlePickupQuery" title="Permanent link">HandlePickupQuery</a> (inventory Item) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int OldAmmo;<br>&#9;local Pawn P;<br><br><br>&#9;if (Item.Class == Class)<br>&#9;{<br>&#9;&#9;if ( Weapon(item).bWeaponStay && (!Weapon(item).bHeldItem || Weapon(item).bTossedOut) )<br>&#9;&#9;&#9;return true;<br>&#9;&#9;P = Pawn(Owner);<br>//&#9;&#9;if ( AmmoType != None )<br>//&#9;&#9;{<br>//&#9;&#9;&#9;OldAmmo = AmmoType.AmmoAmount;<br>//<br>//&#9;&#9;&#9;// DEUS_EX CNN - never switch weapons automatically, but do add the ammo<br>//&#9;&#9;&#9;AmmoType.AddAmmo(Weapon(Item).PickupAmmoCount);<br>//&#9;&#9;&#9;if ( AmmoType.AddAmmo(Weapon(Item).PickupAmmoCount) && (OldAmmo == 0) <br>//&#9;&#9;&#9;&#9;&& (P.Weapon.class != item.class) && !P.bNeverSwitchOnPickup )<br>//&#9;&#9;&#9;&#9;&#9;WeaponSet(P);<br>//&#9;&#9;}<br>&#9;&#9;if (Level.Game.LocalLog != None)<br>&#9;&#9;&#9;Level.Game.LocalLog.LogPickup(Item, Pawn(Owner));<br>&#9;&#9;if (Level.Game.WorldLog != None)<br>&#9;&#9;&#9;Level.Game.WorldLog.LogPickup(Item, Pawn(Owner));<br>&#9;&#9;if (Item.PickupMessageClass == None)<br>&#9;&#9;&#9;// DEUS_EX CNN - use the itemArticle and itemName<br>//&#9;&#9;&#9;P.ClientMessage(Item.PickupMessage, 'Pickup');<br>&#9;&#9;&#9;P.ClientMessage(Item.PickupMessage @ Item.itemArticle @ Item.itemName, 'Pickup');<br>&#9;&#9;else<br>&#9;&#9;&#9;P.ReceiveLocalizedMessage( Item.PickupMessageClass, 0, None, None, item.Class );<br>&#9;&#9;Item.PlaySound(Item.PickupSound);<br>&#9;&#9;Item.SetRespawn();   <br>&#9;&#9;return true;<br>&#9;<br></div>
<h3 id="Weapon.PlayAltFiring"><a class="headerlink" href="#Weapon.PlayAltFiring" title="Permanent link">PlayAltFiring</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;//Play alt firing animation and sound<br><br></div>
<h3 id="Weapon.PlayFiring"><a class="headerlink" href="#Weapon.PlayFiring" title="Permanent link">PlayFiring</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;//Play firing animation and sound<br><br></div>
<h3 id="Weapon.PlayIdleAnim"><a class="headerlink" href="#Weapon.PlayIdleAnim" title="Permanent link">PlayIdleAnim</a></h3>

<h3 id="Weapon.PlayPostSelect"><a class="headerlink" href="#Weapon.PlayPostSelect" title="Permanent link">PlayPostSelect</a></h3>

<h3 id="Weapon.PlaySelect"><a class="headerlink" href="#Weapon.PlaySelect" title="Permanent link">PlaySelect</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;PlayAnim('Select',1.0,0.0);<br>&#9;Owner.PlaySound(SelectSound, SLOT_Misc, Pawn(Owner).SoundDampening);&#9;<br><br></div>
<h3 id="Weapon.PostBeginPlay"><a class="headerlink" href="#Weapon.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.PostBeginPlay();<br>&#9;SetWeaponStay();<br>&#9;MaxDesireability = 1.2 * AIRating;<br>&#9;if ( ProjectileClass != None )<br>&#9;{<br>&#9;&#9;ProjectileSpeed = ProjectileClass.Default.Speed;<br>&#9;&#9;MyDamageType = ProjectileClass.Default.MyDamageType;<br>&#9;}<br>&#9;if ( AltProjectileClass != None )<br>&#9;{<br>&#9;&#9;AltProjectileSpeed = AltProjectileClass.Default.Speed;<br>&#9;&#9;AltDamageType = AltProjectileClass.Default.MyDamageType;<br>&#9;}<br><br></div>
<h3 id="Weapon.PostRender"><a class="headerlink" href="#Weapon.PostRender" title="Permanent link">PostRender</a> (canvas Canvas)</h3>

<h3 id="Weapon.PreRender"><a class="headerlink" href="#Weapon.PreRender" title="Permanent link">PreRender</a> (canvas Canvas)</h3>

<h3 id="Weapon.ProcessTraceHit"><a class="headerlink" href="#Weapon.ProcessTraceHit" title="Permanent link">ProcessTraceHit</a> (Actor Other, Vector HitLocation, Vector HitNormal, Vector X, Vector Y, Vector Z)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;//Spawn appropriate effects at hit location, any weapon lights, and damage hit actor<br><br></div>
<h3 id="Weapon.ProjectileFire"><a class="headerlink" href="#Weapon.ProjectileFire" title="Permanent link">ProjectileFire</a> (class<projectile> ProjClass, float ProjSpeed, bool bWarn) -> Projectile</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Vector Start, X,Y,Z;<br>&#9;local Pawn PawnOwner;<br><br><br>&#9;PawnOwner = Pawn(Owner);<br>&#9;Owner.MakeNoise(PawnOwner.SoundDampening);<br>&#9;GetAxes(PawnOwner.ViewRotation,X,Y,Z);<br>&#9;Start = Owner.Location + CalcDrawOffset() + FireOffset.X * X + FireOffset.Y * Y + FireOffset.Z * Z; <br>&#9;AdjustedAim = PawnOwner.AdjustAim(ProjSpeed, Start, AimError, True, bWarn);&#9;<br>&#9;return Spawn(ProjClass,,, Start,AdjustedAim);&#9;<br><br></div>
<h3 id="Weapon.PutDown"><a class="headerlink" href="#Weapon.PutDown" title="Permanent link">PutDown</a> -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bChangeWeapon = true;<br>&#9;GotoState('DownWeapon');&#9;&#9;// DEUS_EX CNN - added to force the weapon down<br>&#9;return true; <br><br></div>
<h3 id="Weapon.RaiseUp"><a class="headerlink" href="#Weapon.RaiseUp" title="Permanent link">RaiseUp</a> (Weapon OldWeapon)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;BringUp();<br><br></div>
<h3 id="Weapon.RateSelf"><a class="headerlink" href="#Weapon.RateSelf" title="Permanent link">RateSelf</a> (out int bUseAltMode) -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( (AmmoType != None) && (AmmoType.AmmoAmount <=0) )<br>&#9;&#9;return -2;<br>&#9;bUseAltMode = int(FRand() < 0.4);<br>&#9;return (AIRating + FRand() * 0.05);<br><br></div>
<h3 id="Weapon.RecommendWeapon"><a class="headerlink" href="#Weapon.RecommendWeapon" title="Permanent link">RecommendWeapon</a> (out float rating, out int bUseAltMode) -> Weapon</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Weapon Recommended;<br>&#9;local float oldRating, oldFiring;<br>&#9;local int oldMode;<br><br><br>&#9;if ( Owner.IsA('PlayerPawn') )<br>&#9;&#9;rating = SwitchPriority();<br>&#9;else<br>&#9;{<br>&#9;&#9;rating = RateSelf(bUseAltMode);<br>&#9;&#9;if ( (self == Pawn(Owner).Weapon) && (Pawn(Owner).Enemy != None) <br>&#9;&#9;&#9;&& ((AmmoType == None) || (AmmoType.AmmoAmount > 0)) )<br>&#9;&#9;&#9;rating += 0.21; // tend to stick with same weapon<br>&#9;}<br>&#9;if ( inventory != None )<br>&#9;{<br>&#9;&#9;Recommended = inventory.RecommendWeapon(oldRating, oldMode);<br>&#9;&#9;if ( (Recommended != None) && (oldRating > rating) )<br>&#9;&#9;{<br>&#9;&#9;&#9;rating = oldRating;<br>&#9;&#9;&#9;bUseAltMode = oldMode;<br>&#9;&#9;&#9;return Recommended;<br>&#9;&#9;}<br>&#9;}<br>&#9;return self;<br><br></div>
<h3 id="Weapon.RenderOverlays"><a class="headerlink" href="#Weapon.RenderOverlays" title="Permanent link">RenderOverlays</a> (canvas Canvas)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local rotator NewRot;<br>&#9;local bool bPlayerOwner;<br>&#9;local int Hand;<br>&#9;local PlayerPawn PlayerOwner;<br><br><br>&#9;if ( bHideWeapon || (Owner == None) )<br>&#9;&#9;return;<br><br>&#9;PlayerOwner = PlayerPawn(Owner);<br><br>&#9;if ( PlayerOwner != None )<br>&#9;{<br>&#9;&#9;if ( PlayerOwner.DesiredFOV != PlayerOwner.DefaultFOV )<br>&#9;&#9;&#9;return;<br>&#9;&#9;bPlayerOwner = true;<br>&#9;&#9;Hand = PlayerOwner.Handedness;<br><br>&#9;&#9;if (  (Level.NetMode == NM_Client) && (Hand == 2) )<br>&#9;&#9;{<br>&#9;&#9;&#9;bHideWeapon = true;<br>&#9;&#9;&#9;return;<br>&#9;&#9;}<br>&#9;}<br><br>&#9;if ( !bPlayerOwner || (PlayerOwner.Player == None) )<br>&#9;&#9;Pawn(Owner).WalkBob = vect(0,0,0);<br><br>&#9;if ( (bMuzzleFlash > 0) && bDrawMuzzleFlash && Level.bHighDetailMode && (MFTexture != None) )<br>&#9;{<br>&#9;&#9;MuzzleScale = Default.MuzzleScale * Canvas.ClipX/640.0;<br>&#9;&#9;if ( !bSetFlashTime )<br>&#9;&#9;{<br>&#9;&#9;&#9;bSetFlashTime = true;<br>&#9;&#9;&#9;FlashTime = Level.TimeSeconds + FlashLength;<br>&#9;&#9;}<br>&#9;&#9;else if ( FlashTime < Level.TimeSeconds )<br>&#9;&#9;&#9;bMuzzleFlash = 0;<br>&#9;&#9;if ( bMuzzleFlash > 0 )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( Hand == 0 )<br>&#9;&#9;&#9;&#9;Canvas.SetPos(Canvas.ClipX/2 - 0.5 * MuzzleScale * FlashS + Canvas.ClipX * (-0.2 * Default.FireOffset.Y * FlashO), Canvas.ClipY/2 - 0.5 * MuzzleScale * FlashS + Canvas.ClipY * (FlashY + FlashC));<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;Canvas.SetPos(Canvas.ClipX/2 - 0.5 * MuzzleScale * FlashS + Canvas.ClipX * (Hand * Default.FireOffset.Y * FlashO), Canvas.ClipY/2 - 0.5 * MuzzleScale * FlashS + Canvas.ClipY * FlashY);<br><br>&#9;&#9;&#9;Canvas.Style = 3;<br>&#9;&#9;&#9;Canvas.DrawIcon(MFTexture, MuzzleScale);<br>&#9;&#9;&#9;Canvas.Style = 1;<br>&#9;&#9;}<br>&#9;}<br>&#9;else<br>&#9;&#9;bSetFlashTime = false;<br><br>&#9;SetLocation( Owner.Location + CalcDrawOffset() );<br>&#9;NewRot = Pawn(Owner).ViewRotation;<br><br>&#9;if ( Hand == 0 )<br>&#9;&#9;newRot.Roll = -2 * Default.Rotation.Roll;<br>&#9;else<br>&#9;&#9;newRot.Roll = Default.Rotation.Roll * Hand;<br><br>&#9;setRotation(newRot);<br>&#9;Canvas.DrawActor(self, false);<br><br></div>
<h3 id="Weapon.SetSwitchPriority"><a class="headerlink" href="#Weapon.SetSwitchPriority" title="Permanent link">SetSwitchPriority</a> (pawn Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local int i;<br>&#9;local name temp, carried;<br><br><br>&#9;if ( PlayerPawn(Other) != None )<br>&#9;{<br>&#9;&#9;for ( i=0; i<20; i++)<br>&#9;&#9;&#9;if ( PlayerPawn(Other).WeaponPriority[i] == class.name )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;AutoSwitchPriority = i;<br>&#9;&#9;&#9;&#9;return;<br>&#9;&#9;&#9;}<br>&#9;&#9;// else, register this weapon<br>&#9;&#9;carried = class.name;<br>&#9;&#9;for ( i=AutoSwitchPriority; i<20; i++ )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( PlayerPawn(Other).WeaponPriority[i] == '' )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;PlayerPawn(Other).WeaponPriority[i] = carried;<br>&#9;&#9;&#9;&#9;return;<br>&#9;&#9;&#9;}<br>&#9;&#9;&#9;else if ( i<19 )<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;temp = PlayerPawn(Other).WeaponPriority[i];<br>&#9;&#9;&#9;&#9;PlayerPawn(Other).WeaponPriority[i] = carried;<br>&#9;&#9;&#9;&#9;carried = temp;<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;}&#9;&#9;<br><br></div>
<h3 id="Weapon.SetWeaponStay"><a class="headerlink" href="#Weapon.SetWeaponStay" title="Permanent link">SetWeaponStay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;bWeaponStay = bWeaponStay || Level.Game.bCoopWeaponMode;<br><br></div>
<h3 id="Weapon.SpawnCopy"><a class="headerlink" href="#Weapon.SpawnCopy" title="Permanent link">SpawnCopy</a> (pawn Other) -> inventory</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local inventory Copy;<br>&#9;local Weapon newWeapon;<br><br><br>&#9;if( Level.Game.ShouldRespawn(self) )<br>&#9;{<br>&#9;&#9;Copy = spawn(Class,Other,,,rot(0,0,0));<br>&#9;&#9;Copy.Tag           = Tag;<br>&#9;&#9;Copy.Event         = Event;<br>&#9;&#9;if ( !bWeaponStay )<br>&#9;&#9;&#9;GotoState('Sleeping');<br>&#9;}<br>&#9;else<br>&#9;&#9;Copy = self;<br><br>&#9;Copy.RespawnTime = 0.0;<br>&#9;Copy.bHeldItem = true;<br>&#9;Copy.bTossedOut = false;<br><br>&#9;// DEUS_EX AJY<br>&#9;// Give weapon ammo before giving to player&#9;<br>&#9;Weapon(Copy).GiveAmmo(Other);<br>&#9;Copy.GiveTo( Other );<br>&#9;<br>&#9;newWeapon = Weapon(Copy);<br>&#9;newWeapon.Instigator = Other;<br>&#9;newWeapon.SetSwitchPriority(Other);<br>&#9;// DEUS_EX CNN - Don't autoswitch weapons<br>//&#9;if ( !Other.bNeverSwitchOnPickup )<br>//&#9;&#9;newWeapon.WeaponSet(Other);<br>&#9;newWeapon.AmbientGlow = 0;<br>&#9;return newWeapon;<br><br></div>
<h3 id="Weapon.SplashJump"><a class="headerlink" href="#Weapon.SplashJump" title="Permanent link">SplashJump</a> -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return false;<br><br></div>
<h3 id="Weapon.SuggestAttackStyle"><a class="headerlink" href="#Weapon.SuggestAttackStyle" title="Permanent link">SuggestAttackStyle</a> -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return 0.0;<br><br></div>
<h3 id="Weapon.SuggestDefenseStyle"><a class="headerlink" href="#Weapon.SuggestDefenseStyle" title="Permanent link">SuggestDefenseStyle</a> -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;return 0.0;<br><br></div>
<h3 id="Weapon.SwitchPriority"><a class="headerlink" href="#Weapon.SwitchPriority" title="Permanent link">SwitchPriority</a> -> float</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local float temp;<br>&#9;local int bTemp;<br><br><br>&#9;if ( !Owner.IsA('PlayerPawn') )<br>&#9;&#9;return RateSelf(bTemp);<br>&#9;else if ( (AmmoType != None) && (AmmoType.AmmoAmount<=0) )<br>&#9;{<br>&#9;&#9;if ( Pawn(Owner).Weapon == self )<br>&#9;&#9;&#9;return -0.5;<br>&#9;&#9;else<br>&#9;&#9;&#9;return -1;<br>&#9;}<br>&#9;else <br>&#9;&#9;return AutoSwitchPriority;<br><br></div>
<h3 id="Weapon.TraceFire"><a class="headerlink" href="#Weapon.TraceFire" title="Permanent link">TraceFire</a> (float Accuracy)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local vector HitLocation, HitNormal, StartTrace, EndTrace, X,Y,Z;<br>&#9;local actor Other;<br>&#9;local Pawn PawnOwner;<br><br><br>&#9;PawnOwner = Pawn(Owner);<br><br>&#9;Owner.MakeNoise(PawnOwner.SoundDampening);<br>&#9;GetAxes(PawnOwner.ViewRotation,X,Y,Z);<br>&#9;StartTrace = Owner.Location + CalcDrawOffset() + FireOffset.X * X + FireOffset.Y * Y + FireOffset.Z * Z; <br>&#9;AdjustedAim = PawnOwner.AdjustAim(1000000, StartTrace, 2*AimError, False, False);&#9;<br>&#9;EndTrace = StartTrace + Accuracy * (FRand() - 0.5 )* Y * 1000<br>&#9;&#9;+ Accuracy * (FRand() - 0.5 ) * Z * 1000;<br>&#9;X = vector(AdjustedAim);<br>&#9;EndTrace += (10000 * X); <br>&#9;Other = PawnOwner.TraceShot(HitLocation,HitNormal,EndTrace,StartTrace);<br>&#9;ProcessTraceHit(Other, HitLocation, HitNormal, X,Y,Z);<br><br></div>
<h3 id="Weapon.TravelPostAccept"><a class="headerlink" href="#Weapon.TravelPostAccept" title="Permanent link">TravelPostAccept</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.TravelPostAccept();<br>&#9;if ( Pawn(Owner) == None )<br>&#9;&#9;return;<br>&#9;if ( AmmoName != None )<br>&#9;{<br>&#9;&#9;// DEUS_EX CNN - if AmmoType isn't already set (through a travel),<br>&#9;&#9;// find the default in the inventory list<br>&#9;&#9;if ( AmmoType == None )<br>&#9;&#9;{&#9;&#9;<br>&#9;&#9;&#9;AmmoType = Ammo(Pawn(Owner).FindInventoryType(AmmoName));<br>&#9;&#9;&#9;if (AmmoType == None)<br>&#9;&#9;&#9;{<br>&#9;&#9;&#9;&#9;AmmoType = Spawn(AmmoName);&#9;// Create ammo type required&#9;&#9;<br>&#9;&#9;&#9;&#9;Pawn(Owner).AddInventory(AmmoType);&#9;&#9;// and add to player's inventory<br>&#9;&#9;&#9;&#9;AmmoType.BecomeItem();<br>&#9;&#9;&#9;&#9;AmmoType.AmmoAmount = PickUpAmmoCount; <br>&#9;&#9;&#9;&#9;AmmoType.GotoState('Idle2');<br>&#9;&#9;&#9;}<br>&#9;&#9;}<br>&#9;}<br>&#9;if ( self == Pawn(Owner).Weapon )<br>&#9;&#9;BringUp();<br>&#9;else GoToState('Idle2');<br><br></div>
<h3 id="Weapon.TweenDown"><a class="headerlink" href="#Weapon.TweenDown" title="Permanent link">TweenDown</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( (AnimSequence != '') && (GetAnimGroup(AnimSequence) == 'Select') )<br>&#9;&#9;TweenAnim( AnimSequence, AnimFrame * 0.4 );<br>&#9;else<br>&#9;{<br>&#9;&#9;// Have the put away animation play twice as fast in multiplayer<br>&#9;&#9;if ( Level.NetMode != NM_Standalone )<br>&#9;&#9;&#9;PlayAnim('Down', 2.0, 0.05);<br>&#9;&#9;else<br>&#9;&#9;&#9;PlayAnim('Down', 1.0, 0.05);<br>&#9;}<br><br></div>
<h3 id="Weapon.TweenSelect"><a class="headerlink" href="#Weapon.TweenSelect" title="Permanent link">TweenSelect</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;TweenAnim('Select',0.001);<br><br></div>
<h3 id="Weapon.TweenToStill"><a class="headerlink" href="#Weapon.TweenToStill" title="Permanent link">TweenToStill</a></h3>

<h3 id="Weapon.WeaponChange"><a class="headerlink" href="#Weapon.WeaponChange" title="Permanent link">WeaponChange</a> (byte F) -> Weapon</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local Weapon newWeapon;<br>&#9;<br>&#9; <br>&#9;if ( InventoryGroup == F )<br>&#9;{<br>&#9;&#9;/* we want you to change weapons even if you're out of ammo - DEUS_EX CNN<br>&#9;&#9;if ( (AmmoType != None) && (AmmoType.AmmoAmount <= 0) )<br>&#9;&#9;{<br>&#9;&#9;&#9;if ( Inventory == None )<br>&#9;&#9;&#9;&#9;newWeapon = None;<br>&#9;&#9;&#9;else<br>&#9;&#9;&#9;&#9;newWeapon = Inventory.WeaponChange(F);<br>&#9;&#9;&#9;if ( newWeapon == None )<br>&#9;&#9;&#9;&#9;Pawn(Owner).ClientMessage( ItemName$MessageNoAmmo );&#9;&#9;<br>&#9;&#9;&#9;return newWeapon;<br>&#9;&#9;}&#9;&#9;<br>&#9;&#9;else <br>&#9;&#9;*/<br>&#9;&#9;&#9;return self;<br>&#9;}<br>&#9;else if ( Inventory == None )<br>&#9;&#9;return None;<br>&#9;else<br>&#9;&#9;return Inventory.WeaponChange(F);<br><br></div>
<h3 id="Weapon.WeaponSet"><a class="headerlink" href="#Weapon.WeaponSet" title="Permanent link">WeaponSet</a> (Pawn Other) -> bool</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local bool bSwitch,bHaveAmmo;<br>&#9;local Inventory Inv;<br>&#9;local weapon W;<br><br>&#9;<br>&#9;if ( Other.Weapon == self)<br>&#9;&#9;return false;<br><br>&#9;if ( Other.Weapon == None )<br>&#9;{<br>&#9;&#9;Other.PendingWeapon = self;<br>&#9;&#9;Other.ChangedWeapon();<br>&#9;&#9;return true;&#9;<br>&#9;}<br>&#9;else if ( Other.Weapon.SwitchPriority() < SwitchPriority() ) <br>&#9;{<br>&#9;&#9;W = Other.PendingWeapon;<br>&#9;&#9;Other.PendingWeapon = self;<br>&#9;&#9;GotoState('');<br><br>&#9;&#9;if ( Other.Weapon.PutDown() )<br>&#9;&#9;&#9;return true;<br>&#9;&#9;Other.PendingWeapon = W;<br>&#9;&#9;return false;<br>&#9;}<br>&#9;else <br>&#9;{<br>&#9;&#9;GoToState('');<br>&#9;&#9;return false;<br>&#9;}<br><br></div>
<h3 id="Weapon.setHand"><a class="headerlink" href="#Weapon.setHand" title="Permanent link">setHand</a> (float Hand)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;if ( Hand == 2 )<br>&#9;{<br>&#9;&#9;PlayerViewOffset.Y = 0;<br>&#9;&#9;FireOffset.Y = 0;<br>&#9;&#9;bHideWeapon = true;<br>&#9;&#9;return;<br>&#9;}<br>&#9;else<br>&#9;&#9;bHideWeapon = false;<br><br>&#9;if ( Hand == 0 )<br>&#9;{<br>&#9;&#9;PlayerViewOffset.X = Default.PlayerViewOffset.X * 0.88;<br>&#9;&#9;PlayerViewOffset.Y = -0.2 * Default.PlayerViewOffset.Y;<br>&#9;&#9;PlayerViewOffset.Z = Default.PlayerViewOffset.Z * 1.12;<br>&#9;}<br>&#9;else<br>&#9;{<br>&#9;&#9;PlayerViewOffset.X = Default.PlayerViewOffset.X;<br>&#9;&#9;PlayerViewOffset.Y = Default.PlayerViewOffset.Y * Hand;<br>&#9;&#9;PlayerViewOffset.Z = Default.PlayerViewOffset.Z;<br>&#9;}<br>&#9;PlayerViewOffset *= 100; //scale since network passes vector components as ints<br>&#9;FireOffset.Y = Default.FireOffset.Y * Hand;<br><br></div>
<br><br><hr>
<a class="headerlink" href="#ZoneInfo.uc" title="Permanent link"><h2 id="ZoneInfo.uc">ZoneInfo.uc (extends Info)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() name   ZoneTag;<br>var() vector ZoneGravity;<br>var() vector ZoneVelocity;<br>var() float  ZoneGroundFriction;<br>var() float  ZoneFluidFriction;<br>var() float	 ZoneTerminalVelocity;<br>var() name   ZonePlayerEvent;<br>var   int    ZonePlayerCount;<br>var   int	 NumCarcasses;<br>var() int	 DamagePerSec;<br>var() name	 DamageType;<br>var() localized string DamageString;<br>var(LocationStrings) localized string ZoneName;<br>var LocationID LocationID;<br>var() int	 MaxCarcasses;<br>var() sound  EntrySound;	//only if waterzone<br>var() sound  ExitSound;		// only if waterzone<br>var() class<actor> EntryActor;	// e.g. a splash (only if water zone)<br>var() class<actor> ExitActor;	// e.g. a splash (only if water zone)<br>var skyzoneinfo SkyZone; // Optional sky zone containing this zone's sky.<br>var()		bool   bWaterZone;   // Zone is water-filled.<br>var() const bool   bFogZone;     // Zone is fog-filled.<br>var() const bool   bKillZone;    // Zone instantly kills those who enter.<br>var()		bool   bNeutralZone; // Players can't take damage in this zone.<br>var()		bool   bGravityZone; // Use ZoneGravity.<br>var()		bool   bPainZone;	 // Zone causes pain.<br>var()		bool   bDestructive; // Destroys carcasses.<br>var()		bool   bNoInventory;<br>var()		bool   bMoveProjectiles;	// this velocity zone should impart velocity to projectiles and effects<br>var()		bool   bBounceVelocity;		// this velocity zone should bounce actors that land in it<br>var(ZoneLight) byte AmbientBrightness, AmbientHue, AmbientSaturation;<br>var(ZoneLight) color FogColor;<br>var(ZoneLight) float FogDistance;<br>var(ZoneLight) const texture EnvironmentMap;<br>var(ZoneLight) float TexUPanSpeed, TexVPanSpeed;<br>var(ZoneLight) vector ViewFlash, ViewFog;<br>var(Reverb) bool bReverbZone;<br>var(Reverb) bool bRaytraceReverb;<br>var(Reverb) float SpeedOfSound;<br>var(Reverb) byte MasterGain;<br>var(Reverb) int  CutoffHz;<br>var(Reverb) byte Delay[6];<br>var(Reverb) byte Gain[6];<br>var(LensFlare) texture LensFlare[12];<br>var(LensFlare) float LensFlareOffset[12];<br>var(LensFlare) float LensFlareScale[12];<br>var() byte MinLightCount; // minimum number of lights to use (when MaxLightingPolyCount is exceeded)<br>var() byte MaxLightCount; // maximum number of lights to use (when MeshPolyCount drops below MinLightingPolyCount)<br>var() int MinLightingPolyCount;<br>var() int MaxLightingPolyCount;</div>
<button type="button" class="collapsible">Show Default Properties</button><div class="content" style="white-space:pre">ZoneGravity=(Z=-950.000000)<br>ZoneGroundFriction=8.000000<br>ZoneFluidFriction=1.200000<br>ZoneTerminalVelocity=2500.000000<br>MaxCarcasses=3<br>bMoveProjectiles=True<br>AmbientSaturation=255<br>TexUPanSpeed=1.000000<br>TexVPanSpeed=1.000000<br>SpeedOfSound=8000.000000<br>MasterGain=100<br>CutoffHz=6000<br>Delay(0)=20<br>Delay(1)=34<br>Gain(0)=150<br>Gain(1)=70<br>MinLightCount=6<br>MaxLightCount=6<br>MinLightingPolyCount=1000<br>MaxLightingPolyCount=5000<br>bStatic=True<br>bNoDelete=True<br>Texture=Texture'Engine.S_ZoneInfo'<br>bAlwaysRelevant=True<br>NetUpdateFrequency=4.000000</div>
<h3 id="ZoneInfo.ActorEntered"><a class="headerlink" href="#ZoneInfo.ActorEntered" title="Permanent link">ActorEntered</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor A;<br>&#9;local vector AddVelocity;<br><br><br>&#9;if ( bNoInventory && Other.IsA('Inventory') && (Other.Owner == None) )<br>&#9;{<br>&#9;&#9;Other.LifeSpan = 1.5;<br>&#9;&#9;return;<br>&#9;}<br><br>&#9;if( Pawn(Other)!=None && Pawn(Other).bIsPlayer )<br>&#9;&#9;if( ++ZonePlayerCount==1 && ZonePlayerEvent!='' )<br>&#9;&#9;&#9;foreach AllActors( class 'Actor', A, ZonePlayerEvent )<br>&#9;&#9;&#9;&#9;A.Trigger( Self, Pawn(Other) );<br><br>&#9;if ( bMoveProjectiles && (ZoneVelocity != vect(0,0,0)) )<br>&#9;{<br>&#9;&#9;if ( Other.Physics == PHYS_Projectile )<br>&#9;&#9;&#9;Other.Velocity += ZoneVelocity;<br>&#9;&#9;else if ( Other.IsA('Effects') && (Other.Physics == PHYS_None) )<br>&#9;&#9;{<br>&#9;&#9;&#9;Other.SetPhysics(PHYS_Projectile);<br>&#9;&#9;&#9;Other.Velocity += ZoneVelocity;<br>&#9;&#9;}<br>&#9;}<br><br></div>
<h3 id="ZoneInfo.ActorLeaving"><a class="headerlink" href="#ZoneInfo.ActorLeaving" title="Permanent link">ActorLeaving</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local actor A;<br><br>&#9;if( Pawn(Other)!=None && Pawn(Other).bIsPlayer )<br>&#9;&#9;if( --ZonePlayerCount==0 && ZonePlayerEvent!='' )<br>&#9;&#9;&#9;foreach AllActors( class 'Actor', A, ZonePlayerEvent )<br>&#9;&#9;&#9;&#9;A.UnTrigger( Self, Pawn(Other) );<br><br></div>
<h3 id="ZoneInfo.LinkToSkybox"><a class="headerlink" href="#ZoneInfo.LinkToSkybox" title="Permanent link">LinkToSkybox</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local skyzoneinfo TempSkyZone;<br><br><br>&#9;// SkyZone.<br>&#9;foreach AllActors( class 'SkyZoneInfo', TempSkyZone, '' )<br>&#9;&#9;SkyZone = TempSkyZone;<br>&#9;foreach AllActors( class 'SkyZoneInfo', TempSkyZone, '' )<br>&#9;&#9;if( TempSkyZone.bHighDetail == Level.bHighDetailMode )<br>&#9;&#9;&#9;SkyZone = TempSkyZone;<br><br></div>
<h3 id="ZoneInfo.PreBeginPlay"><a class="headerlink" href="#ZoneInfo.PreBeginPlay" title="Permanent link">PreBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;Super.PreBeginPlay();<br><br>&#9;// DEUS_EX CNN - set the SoundRadius to ZERO to fix the zone AmbientSound problem<br>&#9;SoundRadius = 0;<br><br>&#9;// call overridable function to link this ZoneInfo actor to a skybox<br>&#9;LinkToSkybox();<br><br></div>
<h3 id="ZoneInfo.Trigger"><a class="headerlink" href="#ZoneInfo.Trigger" title="Permanent link">Trigger</a> (actor Other, pawn EventInstigator)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>// modified to toggle instead of just set to true - DEUS_EX CNN<br>// modified to start the pain timer if you are alread in the zone - DEUS_EX CNN<br>&#9;if (DamagePerSec != 0)<br>&#9;{<br>//&#9;&#9;bPainZone = true;<br>&#9;&#9;bPainZone = !bPainZone;<br>&#9;&#9;if (bPainZone)<br>&#9;&#9;&#9;EventInstigator.PainTimer();<br>&#9;}<br><br><br></div>
<h3 id="ZoneInfo.ZoneActors"><a class="headerlink" href="#ZoneInfo.ZoneActors" title="Permanent link">ZoneActors</a> (class<actor> BaseClass, out actor Actor) | native</h3>

<br><br><hr>
<a class="headerlink" href="#ZoneTrigger.uc" title="Permanent link"><h2 id="ZoneTrigger.uc">ZoneTrigger.uc (extends Trigger)</h2></a>

<h3 id="ZoneTrigger.Touch"><a class="headerlink" href="#ZoneTrigger.Touch" title="Permanent link">Touch</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local ZoneInfo Z;<br><br>&#9;if( IsRelevant( Other ) )<br>&#9;{<br>&#9;&#9;// Broadcast the Trigger message to all matching actors.<br>&#9;&#9;if( Event != '' )<br>&#9;&#9;&#9;foreach AllActors( class 'ZoneInfo', Z )<br>&#9;&#9;&#9;&#9;if ( Z.ZoneTag == Event )<br>&#9;&#9;&#9;&#9;&#9;Z.Trigger( Other, Other.Instigator );<br><br>&#9;&#9;if( Message != "" )<br>&#9;&#9;&#9;// Send a string message to the toucher.<br>&#9;&#9;&#9;Other.Instigator.ClientMessage( Message );<br><br>&#9;&#9;if( bTriggerOnceOnly )<br>&#9;&#9;&#9;// Ignore future touches.<br>&#9;&#9;&#9;SetCollision(False);<br>&#9;}<br><br></div>
<h3 id="ZoneTrigger.UnTouch"><a class="headerlink" href="#ZoneTrigger.UnTouch" title="Permanent link">UnTouch</a> (actor Other)</h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local ZoneInfo Z;<br><br>&#9;if( IsRelevant( Other ) )<br>&#9;{<br>&#9;&#9;// Untrigger all matching actors.<br>&#9;&#9;if( Event != '' )<br>&#9;&#9;&#9;foreach AllActors( class 'ZoneInfo', Z )<br>&#9;&#9;&#9;&#9;if ( Z.ZoneTag == Event )<br>&#9;&#9;&#9;&#9;&#9;Z.UnTrigger( Other, Other.Instigator );<br>&#9;}<br><br></div>
<br><br><hr>
<a class="headerlink" href="#locationid.uc" title="Permanent link"><h2 id="locationid.uc">locationid.uc (extends KeyPoint)</h2></a>

<button type="button" class="collapsible">Show Variables</button><div class="content" style="white-space:pre">var() localized string LocationName;<br>var() float Radius;<br>var LocationID NextLocation;</div>
<h3 id="locationid.PostBeginPlay"><a class="headerlink" href="#locationid.PostBeginPlay" title="Permanent link">PostBeginPlay</a></h3>
<button type="button" class="collapsible">Code</button><div class="content" style="white-space:pre"><br>&#9;local LocationID L;<br><br>&#9;Super.PostBeginPlay();<br><br>&#9;// add self to zone list<br>&#9;if ( Region.Zone.LocationID == None )<br>&#9;{<br>&#9;&#9;Region.Zone.LocationID = self;<br>&#9;&#9;return;<br>&#9;}<br><br>&#9;for ( L=Region.Zone.LocationID; L!=None; L=L.NextLocation )<br>&#9;&#9;if ( L.NextLocation == None )<br>&#9;&#9;{<br>&#9;&#9;&#9;L.NextLocation = self;<br>&#9;&#9;&#9;return;<br>&#9;&#9;}<br><br></div>
<br><br><hr>
	</article>
    </section>
    <footer> By Kaiser, The Coded Mind (C) 2021</footer>
  </body>
</html>
